# 场景题型和应对策略



### 零钱找零问题-最好使用动态规划

| Item     | Value                                                | Comments |
| -------- | ---------------------------------------------------- | -------- |
| 场景描述 | 用最少的硬币组成目标金额                             |          |
| 排序逻辑 | 按照面额排序                                         |          |
| 选择逻辑 | 优先使用面额较大的硬币                               |          |
| 实现原理 | 尝试使用大面额，优先贪心，但只对**特定面额组合有效** |          |
| Leetcode | 860,322(适合动态规划)                                |          |

##### 注意事项

并不能总是得出最优解，应该使用动态规划

### 背包近似问题

| Item     | Value                                          | Comments |
| -------- | ---------------------------------------------- | -------- |
| 场景描述 | 物品可分割，装最大总价值                       |          |
| 排序逻辑 | 按单位价值降序                                 |          |
| 选择逻辑 | 优先选单位价值高的，按比例取用                 |          |
| 实现原理 | 每个单位容量都装入“性价比最高”的物品，直至装满 |          |
| Leetcode |                                                |          |

#### 注意事项-可分割物品才适用贪心

可分割物品前提下，贪心才适用。



#### 套路模板

```java
//1. 按照单位价值进行排序
Arrays.sort(items,(a,b)->Double.compare((double)b.value/b.weight,(double)a.value/a.weight));

for (Item item :items){
  //如果能将物品整个装下，就拿走整个物品
  if (capacity >= item.weight){
    capacity -= item.weight;
    res += item.value;
  }else{
    //如果不能装下整个物品，拿走部分物品
    res += double(item.value)*capacity/item.wight;
    break;
  }
}
```



##Leetcode 316 去除重复字母

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。

需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

 

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

##### 问题解析

###### 什么是字典排序最小？

字典序和字典一样，按从小到大排列，比如：

- `"abc"` < `"acb"` < `"bac"` < `"bca"`

所以我们要找的是**所有可能的去重子序列中**，**最小的那一个字典序**。

###### 什么是`不能打乱其他字符的相对位置`？

> ✅ 你可以从原字符串中挑字符（删掉一些），但不能**重新排列**字符。挑出来的字符之间**在原字符串中必须保持顺序**。

也就是说，我们只能从字符串中选出一个**子序列**，不能做排序。

###### 举个例子更清楚

输入字符串：`"cbacdcbc"`

我们要从中选出不重复的字符，构成结果字符串。所有字符都要：

- 出现一次（去重）
- 保留原字符串的相对顺序（子序列）
- 构成的结果字典序最小

###### ❌错误的理解

你可能会想：“是不是把所有字母取出来，然后按字典序排序？”

比如：`"cbacdcbc"` 去重是 `a, b, c, d`，排序得 `"abcd"`？

**错！** 原因是 `abcd` 并不是原字符串的子序列。

###### 正确的方式

我们在 `"cbacdcbc"` 中找去重的、相对顺序不变的、字典序最小的结果。

最后的正确答案是：`"acdb"`

解释：

- `a` 在 `c` 后面没关系，因为 `a` 是最小的，先出现。
- 后面再选 `c`，然后 `d`，最后 `b`，形成字典序最小的合法子序列。

###### 总结

| 条件               | 含义                                               |
| ------------------ | -------------------------------------------------- |
| 每个字母只出现一次 | 不能重复出现字符                                   |
| 字典序最小         | 选择的子序列在字典顺序上尽可能靠前                 |
| 不打乱相对位置     | 挑出的字符顺序必须是原字符串中的顺序，不能乱序重排 |

##### 基本原理（去重+保序+字典序最小）

我们想从`s` 中挑出若干个字符，要求：

- 每个字符只出现一次
- 字符顺序不能打乱
- 结果字典序最小

##### 排序逻辑-用`栈`维护字典序

我们想要结果字符字典序最小，那么必须在构建过程中做出`排序上的决策`。

- 如果当前字符比栈顶小，且栈顶字符后面还会出现，就可以弹出栈顶字符(因为我们子后还可以加回来)

##### 贪心逻辑

在保证结果合法的前提下，每一步都选当前字典序最小的字符，并把后续更大的字符延后处理。

##### 实现代码

```java
public String removeDuplicateLetters(String s){
  int[] count = new int[26];
  boolean[] visited = new boolean[26];
  
  Stack<Character> stack = new Stack<>();
  for(char c:s.toCharArray()){
    count[c-'a']++;
  }
  
  for(char c: s.toCharArray()){
    int idx = c-'a';
    count[idx]--;
    if (visited[idx]){//已经入栈的跳过
      continue;
    }
    
    while(!stack.isEmpty() 
          && c<stack.peek() //栈顶字符大于当前字符
          && count[stack.peek()-'a']>0 //后面还会出现栈顶元素
         ){
      char removed = stack.pop();
      visited[removed-'a'] = false;//标记为未访问
    }
    stack.push(c);
    visited[idx]=true;
  }
  
  // 构造结果
        StringBuilder sb = new StringBuilder();
        for (char ch : stack) {
            sb.append(ch);
        }

        return sb.toString();
}
```

##
