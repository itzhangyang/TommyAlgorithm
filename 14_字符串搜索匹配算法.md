# 问题的定义 - 在主串$T$中寻找模式$P$

**场景 (Scene):** 我们有两个字符串。一个是**主串 $T$ (Text)**，即待搜索的文本；另一个是**模式串 $P$ (Pattern)**，即我们想要查找的字符串。

**目标 (Goal):** 在主串 $T$ 中找出模式串 $P$ **首次**出现的位置（索引）。如果 $P$ 不存在于 $T$ 中，则返回一个特殊值（通常是 -1）。

**例如：**

- 主串 $T$ = "HELLO, WORLD"
- 模式串 $P$ = "WORLD"
- **目标：** 返回 7（"W" 在 $T$ 中的索引）。

# 问题的本质和分析 - 滑动窗口与比较

想象一下，你有一个长度为 $m$（模式串 $P$ 的长度）的“窗口”，你在一个长度为 $n$（主串 $T$ 的长度）的“轨道”上移动这个窗口。

## 朴素的暴力想法 - 比较窗口内的$m$个字符是否与$P$完全一致

1. 将窗口对齐 $T$ 的第 0 位，比较窗口内的 $m$ 个字符是否与 $P$ 完全一致。
2. 如果不一致，将窗口向右**移动 1 位**，对齐 $T$ 的第 1 位，再次比较。
3. 重复此过程，直到窗口滑到 $T$ 的末尾。

## 暴力算法的关键问题 - 窗口只能向右移动1位

这个“朴素想法”的效率瓶颈在于：**当发生不匹配时，它（窗口）总是只向右移动 1 位**。

例如：$T$ = "<u>ABCABC</u>ABC"，$P$ = "<u>ABCABD</u>"

1. 我们比较 $T[0...5]$ 和 $P[0...5]$。
2. `T[0...4]` ("ABCAB") 与 `P[0...4]` ("ABCAB") 完美匹配。
3. 在第 6 个字符发生不匹配：`T[5]` ('C') $\neq$ `P[5]` ('D')。

此时，朴素算法会**丢弃所有已知信息**，将 $P$ 向右移动 1 位，去比较 `T[1...6]` ("BCABCA") 和 `P[0...5]` ("ABCABD")。

这显然是徒劳的，因为我们从刚才的比较中**已经知道** `T[1...4]` ("BCAB") 根本不等于 `P[0...3]` ("ABCA")。

**高级算法的本质**就在于：**当不匹配发生时，如何利用已经匹配过的信息，来决定下一次“窗口”应该滑动多少位，从而跳过那些注定失败的比较。**

# 算法一：朴素匹配

## 核心思想和套路

如上所述，就是最直观的“窗口滑动”。逐个位置对齐，逐个字符比较。

## 实现原理和步骤

1. 使用一个外层循环 `i` 遍历主串 $T$ 的所有可能的起始点（从 0 到 $n-m$）。`i` 代表窗口的左边界。
2. 使用一个内层循环 `j` 遍历模式串 $P$（从 0 到 $m-1$）。
3. 在内层循环中，比较 `T[i+j]` 和 `P[j]`。
4. 如果 `T[i+j] != P[j]`，说明当前窗口（始于 `i`）匹配失败。立刻 `break` 内层循环，外层循环 `i` 增加 1，进入下一个窗口。
5. 如果内层循环**正常完成**（即 `j` 达到了 $m$），说明所有字符都匹配成功。返回 `i`。
6. 如果外层循环结束仍未找到，返回 -1。

## 对应的Leetcode题目

- **LeetCode 28. 实现 strStr()**: 此题的“简单”解法就是 BF 算法。

# 算法二： KMP算法

## 继续看暴力匹配方法存在的问题

###为什么“暴力匹配”很慢？

让我们先用一个生活中的例子来说明“暴力匹配”（Brute Force）的低效。

- **主串 $T$ (Text):** `"你好，我是张三，我是李四"`
- **模式串 $P$ (Pattern):** `"我是李四"`

####**暴力匹配的逻辑：**每次都重新匹配所有的字符

1. **第1次尝试 (从 $T$ 的第0位开始):**

   - `"你"` vs `"我"` -> 失败。

2. **第2次尝试 (从 $T$ 的第1位开始):**

   - "好" vs "我" -> 失败。

     ...

3. **第6次尝试 (从 $T$ 的第6位开始):**

   - $T$: `"我 是 张 三 ..."`
   - $P$: `"我 是 李 四 ..."`
   - 比较 `"我"` vs `"我"` -> 成功。
   - 比较 `"是"` vs `"是"` -> 成功。
   - 比较 `"张"` vs `"李"` -> **失败！**

暴力匹配的“愚蠢”之处：

当 "张" vs "李" 失败时，你知道在它之前已经成功匹配了 "我是" 这两个字。

但暴力匹配会**完全丢弃**这个已知信息。

它的下一步是：**将模式串 $P$ 向右只移动一位**，从 $T$ 的第7位（"是"）开始**重新比较**。

- **第7次尝试 (从 $T$ 的第7位开始):**
  - `"是"` vs `"我"` -> 失败。

这显然是浪费时间。

我们刚才明明已经匹配了 `"我是"`，我们**已经知道** $T$ 的第7位是 `"是"`，它不可能是 `"我"`。

**怎么去利用已经匹配了的内容呢？**

KMP 的核心思想就是：不再“愚蠢”地只移动一位，而是利用**已知信息**，智能地决定下一次应该从哪里开始比较。

## 核心思想和套路：$T[i]$和$P[j]$不匹配怎么办？

KMP 的智能体现在两个方面：

1. **主串指针永不回退：** 在上面的例子中，当 $T$ 的 `"张"` 和 $P$ 的 `"李"` 匹配失败时，主串 $T$ 的指针（指向"张"）**永远不会向左退回**到"是"。它只会前进或保持不动。
2. **模式串 $P$ 智能“滑动”：** KMP 知道 $P$ 应该“滑动”多少。

这依赖于一个“作弊表”—— **`next` 数组**（也常被称为 LPS 数组）。

### $LPS$数组的作用和定义：最长公共前后缀

#### $LPS$的作用：从$P$的哪个位置继续和主串的当前位置比较？

当模式串 $P$ 的第$j$个字符发生不匹配时，$LPS$ 数组告诉我，下一次应该用 $P$ 的**哪个位置**的字符去和主串的**当前位置**（就是那个不匹配的位置）继续比较。

#### LPS到底是什么东西？- 最长公共前后缀的长度

$LPS$ 数组是 KMP 的精髓。

它只在**模式串 $P$ 内部**计算，**与主串 $T$ 无关**。

$LPS[j]$的含义：在模式串 $P$ 的子串 $P[0...j]$ 中，“**最长的、且相等的‘前缀’和‘后缀’”的长度**。

- **前缀 (Prefix):** 指不包含**最后一个字符**的所有头部子串。

- **后缀 (Suffix):** 指不包含**第一个字符**的所有尾部子串



再说明白一点，就是将$P[0...j]$的所有前缀和所有的后缀列出来，找到**最长的相同的前缀和后缀**。

$LPS[j]$就是**最长的相同前缀和后缀的长度**。

举个例子: $P$ = "abab"

$LPS$数组的计算过程如下：

- 列出所有$P[0...j]$不包含$P[j]$的**前缀子串**集合
- 列出所有$P[0...j]$不包含$P[0]$的**后缀子串**集合
- 找出同时出现在前缀集合和后缀集合的**公共前后缀**集合
- 找出**公共前后缀集合**中最长的子串

| 子串                | LPS          | Comments                                                     |
| ------------------- | ------------ | ------------------------------------------------------------ |
| $P[0...0]$  = `a`   | $LPS[0] = 0$ | 默认$LPS[0] = 0$                                             |
| $P[0...1]$ = `ab`   | $LPS[1] = 0$ | 前缀 'a'，<br>后缀 'b'。<br>不相等。0                        |
| $P[0...2]$ = `aba`  | $LPS[2] = 1$ | 前缀 'a', 'ab'；<br>后缀 'a', 'ba'。<br>最长相等的是 'a'。<br>长度为 1。 |
| $P[0...3]$ = `abab` | $LPS[3] = 2$ | 前缀 'a', 'ab', 'aba'；<br>后缀 'b', 'ab', 'bab'。<br>最长相等的是 'ab'。<br>长度为 2。 |



### KMP如何使用LPS数组？

#### 两个指针的定义：$T[i]$和$P[j]$分别代表$T$中的字符和$P$中的字符

- `i`：指向**文本串 (Text)** 的当前字符，**永不回退**。
- `j`：指向**模式串 (Pattern)** 的当前字符，**会根据LPS数组回退**。

匹配过程的核心思想在于处理 **“失配” (Mismatch)** 的情况。

假设我们有：

- Text: `T = "ABC ABCDAB ABCDABCDABDE"`
- Pattern: `P = "ABCDABD"`

我们根据$P$计算出来的LPS数组是： `lps = [0, 0, 0, 0, 1, 2, 0]`

#### 场景一：$T[i]$和$P[j]$匹配 - 两个指针均前移即可

如果 `text[i]` == `pattern[j]`，说明当前字符匹配成功。

很简单，两个指针都向后移动，继续比较下一个字符。 `i++` `j++`

#### 场景二： $T[i]$和$P[j]$不匹配

如果 `text[i]` != `pattern[j]`，KMP的魔法开始了。

####**传统（朴素）算法： 回退$T$的指针并且重置$P$的指针** 

它会放弃本次匹配，将 `i` 回退到**本次匹配开始的下一个位置**，并将 `j` 重置为 `0`。

这浪费了大量已匹配的信息。

####KMP：将$P$指针移动到$LPS(j-1)$

##### 我们已经知道$T[i-j...j-1]$和$P[0...j-1]$是匹配的

当 `text[i]` 与 `pattern[j]` 失配时，我们知道在失配位置**之前**的 `j` 个字符（即 `text[i-j ... i-1]`）已经与 `pattern[0 ... j-1]` 成功匹配了。



##### 可以推导出来$P[0...LPS[j-1]-1]$ 和 $T[i-LPS[j-1]...i-1]$是匹配的

我们不需要完全重来。

我们查看 `p[0 ... j-1]` 这个子串，它的LPS值是 `lps[j-1]`。

`lps[j-1]` 告诉我们：`pattern[0 ... j-1]` 的 **后缀**（长度为 `lps[j-1]`） 与它的 **前缀**（长度也为 `lps[j-1]`）是相等的。

我们假设`lps[j-1]`的值是$x$。

也就是说，`p[0...x-1]`和`p[n-x...n-1]` 应该是相等的，长度都是$x$：

1. 因为$T[i-j...i-1]$ 和 $P[0...j-1]$匹配，因此对于$x = LPS[j-1]$而言

   $suffix(T[i-j...i-1], x) = suffix(P[0...j-1],x)$

2. 另外根据$LPS$的定义:

   $suffix(P[0...j-1], x) = prefix(P[0...j-1],x)$

3. $\rightarrow prefix(P[0...j-1],x) = suffix(T[i-j...i-1],x)$

因此我们可以得到结论$P[0...x-1]$ = $T[i-x...i-1]$

根据上面的推论，$p[0...x-1]$和$T[i-x,i-1]$是匹配的。

##### 我们只需要移动$P$上的指针到$LPS[j-1]$即可

因此，我们**不需要移动 `i`**，我们只需要将模式串“滑动”到**其前缀 `p[0 ... x-1]` 与 文本串的后缀 `t[i-x ... i-1]` 对齐**的位置。

**因此我们下一步需要比较的，就是 `text[i]` 和 `pattern[lps[j-1]]`。**

**所以，我们将 `j` 更新为：`j = lps[j-1]`**

####场景三：整个模式串匹配成功 - 还是将$P$的指针转移到$LPS[j-1]$

如果 `j` 移动到了模式串的末尾（即 `j == pattern.length()`），说明我们找到了一个完整的匹配。

- 我们记录下这个匹配的起始位置（通常是 `i - j`）。

- **寻找下一个匹配：** 此时不能停止。我们假设文本串在刚匹配上的位置后面，又立即开始了下一次匹配。

  例如，在 "AAAAA" 中寻找 "AAA"。

- 我们采取与“失配”类似的操作：`j = lps[j-1]`，然后继续比较 `text[i]` 和 `pattern[j]`。

#### LPS数组使用总结

KMP算法利用LPS数组实现了以下两个关键目的：

1. **在文本串`T`上永不回溯 (`i` 指针永不左移)**。
2. **利用LPS数组实现模式串`P`的智能“滑动”**。

当 `text[i]` 和 `pattern[j]` 失配时，LPS数组（具体来说是 `lps[j-1]`）告诉我们：`pattern[0...j-1]` 这个已匹配的子串中，有多长的前缀和后缀是相同的。我们可以把模式串 `P` 向右滑动，让这个前缀（长度为 `lps[j-1]`）移动到刚才后缀的位置，然后从 `pattern[lps[j-1]]` 继续与 `text[i]` 进行比较。

这个机制保证了我们**跳过了所有已知的、必定会失败的比较**，从而将匹配的时间复杂度从 O(m*n) 优化到了 O(m+n)（其中 m 是文本串长度，n 是模式串长度）。

## KMP的实现原理和步骤

### 构建$P$的LPS数组 - 动态规划问题

这一步是 KMP 最精妙的地方：**用 $P$ 自己去匹配 $P$**。

#### LPS 数组的定义和我们的目标

- **字符串 $P$**：`"a", "b", "a", "c", "a", "b", "a"`

- **LPS 数组**：`LPS[i]` 的值等于子串 `P[0...i]` 的“最长公共前后缀”的**长度**。

  - “前缀”：**不能**包含 `P[i]`。
  - “后缀”：**不能**包含 `P[0]`。
  - `LPS[0]` 永远是 0。

- 我们的目标：利用$LPS[0...i-1] $计算出$LPS[i]$

  这是一个**动态规划**问题。

  我们想求 `LPS[i]`，并且我们假设 `LPS[0]` 到 `LPS[i-1]` 已经全部算出来了。

#### 怎样利用$LPS[i-1]$推导计算出$LPS[i]$?

假设$len = LPS[i-1]$

##### $LPS[0...i-1] $可以推导出$P[0...len-1] = P[i-len ... i-1]$

我们手上最有用的信息是 `LPS[i-1]`

我们要算 `LPS[i]`。

按照$LPS$的定义，$LPS[i-1]$是$P[0...i-1]$中的最长公共前后缀的长度。

 假设 $len = LPS[i-1]$。

根据定义，$len$高速我们，长度为$len$的前缀等于长度为$len$的后缀：

$P[0 ... len-1] = P[(i-1)-len+1 ... i-1]$



整理一下(看着似曾相识燕归来？)：

大约可能是这是KMP中最重要的公式：

$P[0...len-1] = P[i-len ... i-1]$



**以 `P = "ababa"` 为例：** 

我们要算 `LPS[4]` ("ababa")。($i=4$) 

我们已知 `LPS[3]` ("abab") = 2($i-1=3$)，所以 $len=2$。

将具体值带入上面的公式可以得到：$P[0...len-1] = P[i-len ... i-1]$

 这告诉我们： `P[0...1]` ("ab") == `P[2...3]` ("ab")





#####如果$P[i] = P[len]\implies LPS[i] = len + 1$

现在我们已经根据$LPS[i-1]$得到了前面的公式：$P[0...LPS[i-1]-1] = P[i-LPS[i-1]....i-1]$。

现在我们要开始计算$LPS[i]$， 也就是字符串$P[0...i]$的最大公共前后缀长度。



**最理想的情况**：我们能不能在 `len` 的基础上**扩展**？

根据定义，我们可以得到：

- 旧的匹配前缀是 `P[0...len-1]`。
- 旧的匹配后缀是 `P[i-len...i-1]`。

如果我们能证明它们各自的**下一个字符**也相等，我们就能把这个 LPS 延长 1。

我们继续假设$LPS[i-1] = len$

- 前缀的下一个字符是：`P[len]`
- 后缀的下一个字符是：`P[i]`

所以我们的任务就是检查`P[len] == P[i]`。

```Java
// (在代码中 'len' 被命名为 'j')
if (pattern.charAt(i) == pattern.charAt(j)) {
    j++; // 长度 +1
}
lps[i] = j; // 记录答案
```



##### 如果 $P[i] \neq P[len]$: 尝试寻找一个更短的LPS

现在看一个更复杂的例子：`P = "aabaaab"` 。

我们已经算到`P[0...4]`

 我们可以看到，$LPS[4] = 2$ ， 因为`aabaa`的最长公共前后缀是`aa`， 其长度为2.



现在我们要求$LPS[5]$

首先我们根据之前的推导的结论， 首先判断$P[i]$和$P[len]$是否相同

- $LPS[i-1] = LPS[4] = 2$
- `p[i] = P[5] = 'a'`
- `P[len] = P[2] = 'b'`

很明显： $P[5] \neq P[2]$。



这说明长度为**2的LPS是无法继续扩展了**。

我们需要寻找一个**更短的LPS**，看看那个LPS能不能扩展。

那就应该找 `P[0...i-1]` ("aabaa") 的**次长**公共前后缀。



###### 怎样找一个更短的LPS: 次长的LPS是其最长LPS的LPS

`P[0...i-1]` ("aabaa") 的**最长LPS**是 "aa" (即 `P[0...len-1]`)。

**KMP 的天才洞察：** "aabaa" 的**次长LPS**，必定是它**最长LPS ("aa")** 的 **LPS**。



**"aa" (即 `P[0...len-1]`) 的LPS是啥？**

“这我早就已经算过了！它就存在 `LPS[len - 1]` 里！”

**查找表格：** `len = 2`。

我们去查 `LPS[len - 1] = LPS[1]`。

`LPS[1]` ("aa") 的值是 1。



**Plan B 启动：**

现在我们的新希望 (新的 `len`) 是 $LPS[1]=1$，即 `len = 1`。

现在$len$ 从 2 回溯到了 1。



这就是 `while` 循环的含义：`len = lps[len - 1]`

如果 `len` 长度的LPS无法扩展(即$P[i]\neq P[len]$)， 我就去 `len` 对应的那个前缀 (`P[0...len-1]`) 里， 找到**它的LPS** (`lps[len-1]`)， 把它作为我的新希望 (新的 `len`)， 然后**重新尝试**。”

```Java
 while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
            
            // 我们的期望 'j' 太长了，必须缩短。
            // 缩短到“次长LPS”：即 j (最长LPS) 的 LPS。
            // 这个值我们已经算过了，就存在 lps[j-1] 中。
            j = lps[j - 1]; // j 回溯
        }
```



**继续执行 Plan B：**

- `i = 5` (不变)。`len` 现在是 1。
- **重新 Plan A：检查 `P[i]` 是否等于 `P[len]`？**
  - `P[i] = P[5] = 'a'`
  - `P[len] = P[1] = 'a'`
  - **它们相等！**
- **结论：** 我们可以成功扩展！
- 新的LPS长度就是 `len + 1`。
- `LPS[5] = 1 + 1 = 2`。
- (这是正确的，"aabaaa" 的LPS是 "aa"，长度为2)。

```Java
 // 统一检查：
        if (pattern.charAt(i) == pattern.charAt(j)) {
            // 无论是 Plan A 直接成功，还是 Plan B 最终成功，
            // 还是 j=0 时 P[i]==P[0] 成功，
            // 我们的LPS长度都可以 +1。
            j++;
        }
```

最后我们更新$LPS[i]$为$len$即可：

```Java
 lps[i] = j;
```



#### 总结代码实现

```Java
/**
 * 根据 LPS[i] 的定义：
 * P[0...i] 的最长公共前后缀的长度
 *
 * 采用动态规划思想：
 * 利用 lps[0...i-1] 来推导 lps[i]
 */
private int[] computeLPS(String pattern) {
    int m = pattern.length();
    int[] lps = new int[m];
    
    // lps[0] 永远是 0，这是我们的DP基础
    lps[0] = 0; 
    
    // 'j' (即 'len' 在我们推导中的角色)
    // j 代表 P[0...i-1] 的LPS长度，
    // 它也是我们为 P[i] 准备的“Plan A”候选长度
    int j = 0; 
    
    // 'i' 是主循环，从 1 开始，计算 lps[1], lps[2], ...
    for (int i = 1; i < m; i++) {
        
        // ---- 这是推导中的 Plan B (当 Plan A 失败时) ----
        // 含义：当 j > 0 (说明LPS长度不为0)
        // 并且 Plan A 失败 (P[i] != P[j])
        while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
            
            // 我们的期望 'j' 太长了，必须缩短。
            // 缩短到“次长LPS”：即 j (最长LPS) 的 LPS。
            // 这个值我们已经算过了，就存在 lps[j-1] 中。
            j = lps[j - 1]; // j 回溯
        }
        
        // ---- 这是推导中的 Plan A (尝试扩展) ----
        // 跳出 while 循环时，只有两种可能：
        // 1. (j > 0) 并且 pattern.charAt(i) == pattern.charAt(j) (Plan B 找到了一个可扩展的 j)
        // 2. j == 0 (所有LPS都失败了，回溯到头了)
        
        // 统一检查：
        if (pattern.charAt(i) == pattern.charAt(j)) {
            // 无论是 Plan A 直接成功，还是 Plan B 最终成功，
            // 还是 j=0 时 P[i]==P[0] 成功，
            // 我们的LPS长度都可以 +1。
            j++;
        }
        
        // ---- 记录 DP 结果 ----
        // 1. 如果if成功了，j 被 +1，我们记录这个新长度
        // 2. 如果if失败了 (意味着 j=0 且 P[i]!=P[0])，
        //    j 仍然是 0，我们记录 0。
        lps[i] = j;
    }
    
    return lps;
}
```

### 利用LPS实现KMP算法：匹配$P$和$T$

这一步就是应用“核心套路”的过程。

我们使用两个指针：

- `i`：主串 $T$ 的指针。
- `j`：模式串 $P$ 的指针。

**搜索过程：**（$n$ 为 $T$ 的长度，$m$ 为 $P$ 的长度）

1. 初始化 `i = 0`, `j = 0`。
2. `while (i < n)` 循环：
3. **当 `T[i] == P[j]` 时（匹配）：**
   - `i++`
   - `j++`
4. **当 `T[i] != P[j]` 时（不匹配）：**
   - **如果 `j > 0`：**
     - `j = next[j-1]` (核心：`i` 不动，`j` 回溯)
   - **如果 `j == 0`：**
     - `i++` (回溯到头了，`T[i]` 连 `P[0]` 都不匹配，`i` 只能前进)
5. **检查是否匹配完成：**
   - 当 `j == m` 时，说明 $P$ 已经全部匹配。
   - 匹配的起始索引为 `i - m`。
   - 返回 `i - m`。
6. 循环结束（`i` 遍历完 $T$）仍未找到：
   - 返回 -1。

## 代码套路模板

```Java
class Solution {

    /**
     * KMP 主函数：在主串 (haystack) 中查找模式串 (needle)
     */
    public int strStr(String haystack, String needle) {
        int n = haystack.length();
        int m = needle.length();

        // 1. 处理边界情况
        if (m == 0) {
            return 0; // 模式串为空，返回 0
        }
        
        // 2. 步骤一：构建 next 数组
        int[] next = computeNext(needle);

        // 3. 步骤二：执行 KMP 搜索
        int i = 0; // 主串 T 的指针
        int j = 0; // 模式串 P 的指针

        while (i < n) {
            // Case 1: 匹配成功 (T[i] == P[j])
            if (haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } 
            // Case 2: 匹配失败 (T[i] != P[j])
            else {
                if (j > 0) {
                    // 核心套路：主串 i 不动，模式串 j 回溯
                    j = next[j - 1]; 
                } else {
                    // j 已经回退到 0，说明 T[i] 连 P[0] 都不匹配
                    // 此时只能让 i 前进
                    i++;
                }
            }

            // Case 3: 匹配完成 (j 走到了 P 的末尾)
            if (j == m) {
                // P[0...m-1] 全部匹配
                // 返回 P 在 T 中的起始索引
                return i - m; 
            }
        }

        // 循环结束，未找到
        return -1;
    }


    /**
     * 辅助函数：构建 next 数组 (LPS 数组)
     * @param pattern 模式串 P
     * @return next 数组
     */
    private int[] computeNext(String pattern) {
        int m = pattern.length();
        int[] next = new int[m];
        
        // next[0] 总是 0
        next[0] = 0; 
        
        // j: 指向前缀末尾 (也代表当前 LPS 长度)
        // i: 指向后缀末尾 (遍历 P)
        int j = 0; 
        
        for (int i = 1; i < m; i++) {
            
            // 核心回溯逻辑：当 P[i] != P[j] 时，j 需要回溯
            // j > 0 是为了防止 j=0 时 next[j-1] (next[-1]) 越界
            while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
                // j 回溯到上一个“最长公共前后缀”的位置
                j = next[j - 1];
            }

            // 匹配成功逻辑：当 P[i] == P[j] 时
            if (pattern.charAt(i) == pattern.charAt(j)) {
                // 当前 LPS 长度 +1
                j++;
            }

            // 记录 P[0...i] 的 LPS 长度
            next[i] = j;
        }
        
        return next;
    }
}
```



