# 整理和总结

| 问题类型          | 场景描述            | 目标                   | 顺序限制 | 解空间结构         | 遍历逻辑                       | 终止条件                            | 剪枝条件                     | 状态记录方式                   | 结果存储方式             |
| ----------------- | ------------------- | ---------------------- | -------- | ------------------ | ------------------------------ | ----------------------------------- | ---------------------------- | ------------------------------ | ------------------------ |
| 子集 Subsets      | 给定集合求所有子集  | 所有子集               | 无       | 树（选/不选）      | 从 index 起递归                | 遍历完所有元素                      | 可选：跳过重复元素           | path                           | 每一层都加入 path        |
| 组合 Combinations | 选 k 个不重复元素   | 所有大小为 k 的组合    | 无       | 树（index 控制）   | for (i = start...)             | path.size == k                      | 剩余元素不足 k               | path + start                   | 满足大小为 k 时加入      |
| 排列 Permutations | 所有排列方式        | 所有长度为 n 的排列    | 有       | 树（每层选择一个） | 枚举所有未使用元素             | path.size == n                      | used[i] == true 或跳重       | boolean[] used                 | 满足条件加入 path        |
| 分割 Partition    | 字符串合法切割      | 所有满足条件的切割方式 | 有       | 树（substring）    | 尝试所有 substring(start, i+1) | start == s.length()                 | 子串不满足条件（如不是回文） | start + path                   | 完成切割加入 path        |
| 棋盘 N皇后/数独   | 棋盘放置棋子/填数   | 所有合法放置方案       | 有       | 网格（二维）       | 每一行/空格递归                | 所有行/格子处理完                   | 位置冲突/数独不合法          | col/diag/row/九宫格            | 构造棋盘或原地填充       |
| 路径 Path         | 迷宫/图中找路径     | 判断路径存在/列出路径  | 有       | 网格/图            | DFS四方向或邻接点              | 达到目标位置/路径长度够             | 越界、重复访问               | visited 或原地标记             | 满足路径后加入 res       |
| 数字填充 Sudoku   | 数独等填数字        | 找到一个合法填法       | 有       | 网格               | 从左上到右下填数字             | 全部格子填完                        | 数字冲突                     | 行列宫的合法性                 | 修改 grid 原地填         |
| 构造表达式        | 表达式求值为 target | 所有结果为目标的表达式 | 有       | 树（字符串组合）   | 每次切出子串+符号              | index == num.length 且 calc==target | 前导 0、溢出等非法情况       | 递归参数中记录 calc 和 prevNum | 满足目标加入表达式字符串 |





# 分割与划分类

# 矩阵类

## N皇后类问题

## 数独问题

# 路径类

# 表达式构造类问题



# 图类问题

## [DFS回溯]LeetCode 784. 字母大小写全排列 (Letter Case Permutation)

 给定一个字符串 `s`，你可以将其中的每个字母单独转换为小写或大写，以生成一个新字符串。返回所有可能生成的字符串集合。

### 问题要点

- **输入：** 一个字符串 `s`。
- **输出：** 一个列表 (`List<String>`)，包含所有可能的字符串。
- **转换规则：**
  - 字符串中的每个**字母**都可以被转换为小写或大写。
  - 字符串中的**数字**（或其他非字母字符）保持不变。
- **目标：** 生成所有这些规则下可能的字符串组合。

**示例：**

- 输入: `s = "a1b2"`
- 输出: `["a1b2", "a1B2", "A1b2", "A1B2"]`

### 问题本质和分析

这个问题的本质是一个**组合搜索问题**。给定一个输入字符串，我们需要遍历其中每个字符。

- 如果字符是**数字**，我们没有选择，只能保留它。
- 如果字符是**字母**，我们有两个选择：保持小写或转换为大写（或者反过来）。

如果字符串中有 $L$ 个字母，那么总共的可能性就是 $2^L$ 种。

例如，`"a1b2"` 有两个字母（a, b），所以总共有 $2^2 = 4$ 种组合。

我们需要一个算法来系统地探索所有这些组合，确保不重不漏。

### 模式套路匹配

#### 回溯 (Backtracking) / 深度优先搜索 (DFS):

这是最自然、最匹配的模式。

我们尝试一个选择（例如 'a'），然后递归地深入下去解决子问题（处理 `"1b"`）。

当子问题解决后，我们“回溯”到当前节点，尝试另一个选择（例如 'A'），然后再次递归。

#### 广度优先搜索 (BFS):

- 如“规律观察”中所示，我们可以使用一个队列来维护所有中间结果。

- 每一轮，我们处理原字符串的一个字符，取出队列中所有当前的部分结果，根据新字符生成新的、更长的部分结果，再放回队列。

### 核心思想和套路 - DFS回溯

#### DFS回溯的过程

这个过程是**标准回溯 (Standard Backtracking) / 深度优先搜索 (DFS)** 的完美体现。

它严格遵循了回溯算法的三个步骤：

1. **选择 (Choose):** 将一个字符（小写、大写或数字）添加到 `path` 中。
2. **探索 (Explore):** 带着*新的* `path` 递归进入下一层（处理下一个 `index`）。
3. **撤销 (Unchoose):** 当下一层的递归返回时，将之前添加的字符从 `path` 中移除，以便尝试*同一层*的下一个选择。

##### DFS回溯 - 基于当前节点

- 检查当前节点是否合法
- 将当前节点加入path
- 检查path是否是合法解，
  - 如果是，则加入解集合
- 如果当前path不可能继续，返回(`return`)
- 递归调用后继节点的回溯过程
- 将当前节点从path中删除

##### DFS回溯 - 基于后继节点

- 检查当前path是否是合法解，如果是，则加入解集合
- 如果当前path不可能继续追加，返回`return`
- 遍历所有后继节点，对于每一个后继节点
  - 检查后继节点是否合法，不合法则剪枝（`continue`）
  - 将当前后继节点加入path
  - 递归回溯当前节点
  - 将当前节点从path中删除

#### 回溯过程的主要思路

我们使用一个递归函数 `backtrack(s, index, path)`，其含义是： “我们正在为原字符串 `s` 的第 `index` 个字符做决策，到目前为止构建的路径是 `path`。”

#####**状态（参数）：**

- `String s`：原始输入，保持不变。
- `int index`：**当前需要处理的字符**在 `s` 中的索引。
- `List<Character> path`（或 `StringBuilder path`）：从 `s[0]` 到 `s[index-1]` 累计做出的选择所构成的路径。

#####**基本情况 (Base Case)：**

- 当 `index == s.length()` 时，意味着我们已经处理完了所有字符（从 0 到 `s.length() - 1`）。
- 此时的 `path` 包含了一个完整的排列。
- 我们将 `path` 转换为字符串，添加到最终结果 `res` 中。
- 返回 (return)，结束当前分支的探索。

#####**递归步骤 (Recursive Step)：**

获取当前要处理的字符 `char c = s.charAt(index)`。

######**情况一：`c` 是字母 ( `Character.isLetter(c)` )**

- **选择 1 (小写):**
  - `path.add(Character.toLowerCase(c))` (选择)
  - `backtrack(s, index + 1, path)` (探索)
  - `path.remove(path.size() - 1)` (撤销)
- **选择 2 (大写):**
  - `path.add(Character.toUpperCase(c))` (选择)
  - `backtrack(s, index + 1, path)` (探索)
  - `path.remove(path.size() - 1)` (撤销)

######**情况二：`c` 是数字 (或非字母)**

- **唯一的选择:**
  - `path.add(c)` (选择)
  - `backtrack(s, index + 1, path)` (探索)
  - `path.remove(path.size() - 1)` (撤销)

### 实现原理和步骤

初始化一个全局（或成员）列表 `List<String> res = new ArrayList<>()`。

初始化一个空路径 `List<Character> path = new ArrayList<>()`。

调用 `backtrack(s, 0, path)` 开始递归。

在 `backtrack` 函数中：

- 检查 Base Case：`if (index == s.length())`。
- 如果是，将 `path` 转换为 `String`（例如通过 `StringBuilder` 或 `char[]` 中转），`res.add(...)`，然后 `return`。
- 如果不是 Base Case，获取 `char c = s.charAt(index)`。
- 根据 `c` 是字母还是数字，执行上述“递归步骤”中的选择、探索、撤销逻辑。

### 实现代码

```Java
import java.util.ArrayList;
import java.util.List;

class Solution {
    List<String> res = new ArrayList<>();

    public List<String> letterCasePermutation(String s) {
        // 路径，用于存放当前构建的字符组合
        List<Character> path = new ArrayList<>();
        
        // 从索引 0 (第一个字符) 开始处理
        backtrack(s, 0, path);
        return res;
    }

    /**
     * @param s     原始字符串
     * @param index 当前正要处理的字符索引 (s[index])
     * @param path  到目前为止构建的路径 (s[0]...s[index-1] 的选择结果)
     */
    private void backtrack(String s, int index, List<Character> path) {
        
        // 基本情况 (Base Case):
        // 当 index 等于 s.length() 时，说明 s[0] 到 s[s.length()-1] 都已经处理完毕
        // 此时 path 的长度也等于 s.length()
        if (index == s.length()) {
            // 将 path 列表转换为字符串
            char[] chars = new char[s.length()];
            for (int i = 0; i < s.length(); i++) {
                chars[i] = path.get(i);
            }
            res.add(new String(chars));
            return; // 结束当前分支
        }

        // --- 递归步骤 ---
        // 获取当前索引 index 对应的字符
        char c = s.charAt(index);

        // 情况 1: 如果是字母
        if (Character.isLetter(c)) {
            // 选择 1: 小写
            path.add(Character.toLowerCase(c));      // 选择
            backtrack(s, index + 1, path);           // 探索
            path.remove(path.size() - 1);            // 撤销

            // 选择 2: 大写
            path.add(Character.toUpperCase(c));      // 选择
            backtrack(s, index + 1, path);           // 探索
            path.remove(path.size() - 1);            // 撤销
        } 
        // 情况 2: 如果是数字
        else {
            // 唯一的选择
            path.add(c);                             // 选择
            backtrack(s, index + 1, path);           // 探索
            path.remove(path.size() - 1);            // 撤销
        }
    }
}
```

### 注意事项

**Base Case 的选择：** 你的原始代码中 Base Case 是 `path.size() == s.length()`。在这个问题中，它和 `index == s.length()` 是等价的。但我更推荐使用 `index == s.length()`，因为它清晰地表示“所有*索引*都已处理完毕”，逻辑上更健壮。

**撤销操作 (Unchoose)：** `path.remove(path.size() - 1)` 是这种回溯方案的核心。它保证了当你从一个递归调用返回时（例如，处理完 `"a1b"` 返回到 `"a1"` 的状态），`path` 会被正确地重置，以便进行*同一层*的下一个选择（例如，选择 `"B"`）。

**索引处理：** 这种方案的核心是 `backtrack(s, index, ...)` 函数**只负责** `s[index]` 这一个字符的决策，然后调用 `backtrack(s, index + 1, ...)` 把后续的任务交给下一个递归。

### 经验总结

**“路径构建”法 (Path Building)：** 这是回溯算法最标准、最通用的范式。

**适用性：** 这种 `(index, path)` 的模式几乎适用于所有组合、排列、子集问题。

**清晰度：** “选择 - 探索 - 撤销” 的三段论逻辑非常清晰，`path` 变量明确地保存了当前的状态。

**性能考量：** 相比 `char[]` 原地修改，使用 `List<Character>` 或 `StringBuilder` 会有轻微的性能开销（`add` 和 `remove` 操作），但在大多数情况下，这种清晰性是值得的。`StringBuilder` 又通常比 `List<Character>` 更快。

#二叉树类问题

