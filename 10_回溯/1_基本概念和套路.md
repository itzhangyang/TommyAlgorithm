# 核心思想： 试错 + 回撤

回溯的本质是`尝试走一条路，如果走不通就回退（撤销）并尝试下一条路`，就像迷宫求解或者排列组合。

## 类比过程

1. 从一个起点开始尝试做决策；
2. 如果某个决策**不满足条件**，就**撤销**这个决策（回溯）；
3. 然后尝试下一个可能的决策，继续向下深入搜索；
4. 直到找到一个解，或者所有选择都尝试过后回退到上一个决策点；

## 基本原理和过程

```Java
def backtrack(路径，选择列表)：
	if (满足条件):
    记录结果；
    return；
  
  for 选择 in 选择列表：
  
  	if 不合法：
    	continue;
      
    做选择;
    backtrack(路径，选择列表)
    撤销选择
```

## 回溯的基本要素

### 已经选中的选项 - 路径（path）

当前**已经做出的选择的集合**

### 待选择的选选项列表 - 待选择列表

当前**还可以做的选择**

### 路径满足要求的条件

当路径满足具体场景中的具体条件之后，我们的路径就可以作为一个答案加入到**答案列表**中。

### 剪枝的条件

在某些条件下提前跳过无效分支，提升效率

## 回溯的常见应用场景

| 场景     | 示例题目                       |
| -------- | ------------------------------ |
| 组合问题 | 从 1~9 中选出和为 7 的所有组合 |
| 排列问题 | 给定数组求所有可能排列         |
| 子集问题 | 给定数组求所有子集             |
| 分割问题 | 回文字符串分割                 |
| 棋盘问题 | N皇后、数独                    |
| 迷宫路径 | 是否能走到终点                 |
| 恢复解码 | IP地址恢复                     |

## 回溯算法的技巧总结

1. **路径用 `List<>` 管理**，递归中使用 `new ArrayList<>(path)` 保存`当前状态`。
2. **状态标记用 `boolean[]`**，如排列中是否使用过该元素。
3. **剪枝条件尽早判断**，比如排序后跳过重复元素 `if (i > start && nums[i] == nums[i - 1]) continue;`
4. **回溯 + 排序** 常用于避免重复解（如组合总和）。

## 回溯算法的本质 - 树上的DFS过程

### 回溯树上的节点是什么？- 已经做出的选择的集合

在回溯算法的“决策树”中，一个**“状态节点”**，就是**“在当前这个递归层级上，我们已经做出的选择的集合”**。

更具体地说，这个“状态”在代码中通常由两个核心部分来定义：

#### 已经做出的选择 - Path

这就是我们一直在维护的 `path` 列表（或栈）。

它代表了从根节点走到当前节点所**“累积”**的决策结果。

**例如：** 在 `subsets([1, 2, 3])` 的问题中，一个状态节点可能就是 `[1, 2]`。

#### 可做的选择 (The Remaining Options / The Choices Left)

- 这决定了从**当前**这个节点出发，**“下一步”**可以走向哪些子节点。

- 在我们的子集/组合问题模板中，这个“可做的选择”就是通过 `startIndex` 这个参数来**隐式**定义的。
  - 如果当前 `startIndex` 是 `2` (对应数组元素 `3`)，那么“可做的选择”就是 `{ 3 }`。
  - 如果 `startIndex` 越界了，那么“可做的选择”就是空集 `{}`，此时到达了叶子节点。
- 在其他问题中（比如全排列），这可能由一个 `boolean[] used` 数组来定义。

### 距离说明：`subsets([1, 2, 3])` 的决策树

![image-20251020165618575](/Users/tommy/Library/Application Support/typora-user-images/image-20251020165618575.png)

从上面的图中，我们可以看到，树中的状态节点是当前**已经选择的元素的集合**。

#### 一个重要的问题：怎么计算当前节点的子节点有哪些？

### 总结： 状态节点与DFS的关系

####**状态节点 (Node)：** 

就是我们上面画的每一个方框。它由 `(Path, startIndex)` 唯一确定。

#### 深度优先搜索

1. `path.add(nums[i])` **(做出选择)**：这是DFS在**“访问”**一个子节点。`Path` 改变了，我们从父节点状态**“推进”**到了子节点状态。

2. `backtrack(..., i + 1)` **(递归)**：这是DFS在**“深入”**，继续沿着这条路径往下走。`startIndex` 改变了，“可做的选择”范围缩小了。

3. `path.remove(path.size() - 1)` **(撤销选择)**：这就是**“回溯”**的本意。

   当一个节点（例如 `Node A1`）的所有子节点（`Node A1-1`）都访问完毕后，DFS需要**“退回”**到父节点（`Node A`），以便去访问它的其他子节点（`Node A2`）。