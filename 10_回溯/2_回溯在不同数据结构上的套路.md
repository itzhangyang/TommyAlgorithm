## 回溯算法的通用模板

在深入具体题型之前，我们先统一回溯算法的“骨架”。

所有的回溯问题，都可以抽象为在一个**解空间树**上进行DFS。

###**核心三要素（用户提问）：**

1. **路径 (Path):** 已经做出的选择，构成的（部分）解。
2. **选项 (Options):** 在当前路径下，可以做的所有选择。
3. **结束条件 (Termination):** 满足题目要求的一个完整解（e.g., 路径长度够了，找到目标了）或者路径无法再继续（e.g., 没选项了）。

### 两种不同的范式套路

我们在使用回溯的时候，有两种常见的流程，简单来说主要围绕如下核心：

- 当前节点什么时候加入路径？
- 什么时候检查路径是否满足合法解的条件？

#### 以当前节点为中心 - 图或者二叉树的场景中主要使用

1. 检查当前节点是否合法，不合法直接返回(`return`)

2. 将当前节点加入到路径

3. 检查路径是否构成一个合法解

   如果是，将路径加入到解集合，返回(`return`)

4. 对于当前节点的每一个后继节点，运行回溯过程

5. 将当前节点从路径中删除



```Java
private void backtrack(Node curr){
	if(current == null){
    return;
  }
  
  path.add(curr);
  if(/**path是合法解**/){
    res.add(path);
    return;
  }
  
  for(Node : next : curr.getNexts()){
    backtrack(next);
  }
  
  path.remove(curr);
}
```

#### 以后继节点为中心 - 数组或者字符串中使用

1. 检查路径是否满足合法解的条件，若满足则加入解集合并返回；
2. 遍历每一个后继节点：
   1. 若后继节点不合法，剪枝(`continue`)
   2. 将后继节点加入路径；
   3. 调用backtrack(`successor`)
   4. 将后继节点从路径中删除

```Java
private void backtrack(Node curr){
  if(/**path是合法解**/){
    res.add(path);
    return;
  }
  for(Node next : current.getNexts()){
    if(/**next不合法**/){
      continue;
    }
    
    path.add(next);
    backtrack(next);
    path.remove(next);
  }
}
```

###是不是每次遇到合法解之后就要返回？

不一定。

当一个“合法解”**同时**也是“另一个更长合法解的前缀”时，或者当“撤销选择”的步骤必须在递归之后执行时，我们就不能在找到解后立刻 `return`。

####情况一：“路径即解” (所有节点都是解)

在这种模式下，**解空间树上的“每一个节点”都是一个合法的解**，而不仅仅是“叶子节点”。

#####**典型问题：** **LeetCode 78. 子集 (Subsets)**

**问题目标：** 找出 `[1, 2, 3]` 的*所有*子集。

**分析：**

- `[]` (空集) 是一个合法解。
- `[1]` 是一个合法解。
- `[1, 2]` 是一个合法解。
- `[1, 2, 3]` 是一个合法解。

**回溯逻辑**：

- 当 `backtrack` 函数一被调用，`path` 是 `[]`。它是一个解吗？是。**立刻加入 `result`**。

- 能 `return` 吗？**不能！** 因为 `[]` 必须作为 `[1]`、`[2]`、`[3]` 的前缀，继续搜索。

- `for` 循环中，选择了 `1`，`path` 变为 `[1]`。递归调用 `backtrack`。

- 在下一层，`path` 是 `[1]`。它是一个解吗？是。**立刻加入 `result`**。

- 能 `return` 吗？**不能！** 因为 `[1]` 必须作为 `[1, 2]`、`[1, 3]` 的前缀，继续搜索。

**实现代码**

```Java
List<List<Integer>> result = new ArrayList<>();
LinkedList<Integer> path = new LinkedList<>();

void backtrack(int[] nums, int startIndex) {
    // 1. 路径即解：
    // 无论何时，当前的 "path" 都是一个合法的子集，先加进去
    result.add(new ArrayList<>(path)); 

    // 2. 检查 "结束条件" (可选)
    // (如果 path.size() == k，可以 return，但子集问题没有 k)

    // 3. 遍历选项，继续构建 "更长的解"
    for (int i = startIndex; i < nums.length; i++) {
        path.add(nums[i]);
        // 递归，继续寻找以 "path" 为前缀的解
        backtrack(nums, i + 1); 
        path.removeLast();
    }

    // 当 for 循环结束，函数自然返回，实现回溯
}
```

**对比 (需要 return 的情况)：**

- **LeetCode 77. 组合 (Combinations)**：目标是找到所有*大小为 k*的组合。
- `if (path.size() == k)` 时，`[1, 2]` (假设 k=2) 是一个解。
- `[1, 2]` 是 `[1, 2, 3]` 的前缀吗？是。
- 但 `[1, 2, 3]` 是我们*想要*的解吗？不是 (因为 `size == 3`)。
- 所以，一旦 `path.size() == k`，我们就找到了一个“终结解”(Leaf Node)，我们**必须 `return`**，因为**再往下搜索没有意义**。

####情况二：“结构性需要” (保证撤销选择)

这种情况在**图、矩阵、二叉树**的“位置中心”模型中非常普遍。

`return` 会破坏回溯的“撤销”步骤。

#####**典型问题：** **LeetCode 113. 路径总和 II (Path Sum II)**

**问题目标：** 找出所有从根到*叶子节点*和为 `targetSum` 的路径。

**分析：**

以下列二叉树为例子：(targetSum = 22):

![image-20251020120423275](/Users/tommy/Library/Application Support/typora-user-images/image-20251020120423275.png)

- 我们使用 DFS (前序遍历) 来探索。
- `path.add(node.val)` （做出选择）
- `backtrack(node.left)` （递归）
- `backtrack(node.right)` （递归）
- `path.removeLast()` （撤销选择）
- 这是雷打不动的“DFS + 回溯”结构。

**回溯逻辑：**

假设我们走到了一个叶子节点，并且 `targetSum == 0`。

`path` 是 `[5, 4, 11, 2]`。

这是一个合法解。

**将其加入 `result`**。

**此时能 `return` 吗？**

**绝对不能！**

如果你在这里 `return`，会发生什么？

- `backtrack(node.left)` (此时是 `null`) 会被跳过。
- `backtrack(node.right)` (此时是 `null`) 会被跳过。
- **`path.removeLast()` 也会被跳过！**

函数返回到上一层（节点 `11`）。此时 `path` *仍然*是 `[5, 4, 11, 2]`。

`11` 的左子树 (`2`) 刚探索完，它开始探索右子树 (假设是 `7`)。

`path` 变成了 `[5, 4, 11, 2, 7]`，这**完全是错误**的！它本应是 `[5, 4, 11, 7]`。

## 范式一：数组 / 集合 (Arrays / Collections)

好的，这是一个非常好的提议。在深入研究“数据结构 + 目标”的详细组合之前，我们先提炼出回溯算法应用在不同数据结构上的**通用范式（Paradigm）**。

这能帮你建立一个更高阶的认知：无论问题怎么变，回溯在这类结构上的“探索”方式是固定的。

------



### 1. 通用回溯范式（万能公式）



所有回溯问题都是在“解空间树”上进行深度优先搜索（DFS）。这个范式的核心是“三段论”：

Java

```
void backtrack(路径, 选项列表) {
    if (满足结束条件) {
        保存路径;
        return;
    }

    for (选项 : 选项列表) {
        // 1. 做出选择
        将 "选项" 添加到 "路径";
        
        // 2. 递归
        // 基于当前选项，更新 "下一轮的选项列表"
        backtrack(路径, 下一轮的选项列表); 
        
        // 3. 撤销选择
        从 "路径" 中移除 "选项"; 
    }
}
```

现在，我们来看这个范式在不同数据结构上是如何“具体化”的。

------



### 范式一：数组 / 集合 (Arrays / Collections)

这是最经典的回溯范式，核心是**“组合”**与**“排列”**。

**路径 (Path):** 通常是一个 `List` 或 `LinkedList`，用来存放“已选择”的元素。

**选项 (Options):** 数组/集合中的元素。

**范式特点 (关键)：** 如何定义“下一轮的选项列表”？这导致了两种主要的控制范式：

 如何定义“下一轮的选项列表”？这导致了两种主要的控制范式：

### A. `startIndex` 控制范式 (用于子集、组合问题)

**含义：** 为了避免产生重复的组合（如 `[1, 2]` 和 `[2, 1]`），我们只允许“向后看”。

**实现：** 递归时，`startIndex` 作为参数传递。`for` 循环从 `startIndex` 开始。

套路：

```Java
void backtrack(int[] nums, int startIndex) {
    // ...
    for (int i = startIndex; i < nums.length; i++) {
        path.add(nums[i]);
        // 递归时传入 i + 1 (或 i, 如果元素可重复使用)
        backtrack(nums, i + 1); 
        path.removeLast();
    }
}
```

### B. `used` 数组控制范式 (用于排列问题)

**含义：** 为了确保每个元素在*一条路径*中只被使用一次，但*不同路径*可以从任意元素开始（顺序相关）。

**实现：** 需要一个额外的 `boolean[] used` 数组。`for` 循环*总是*从 `0` 开始。

套路：

```Java
void backtrack(int[] nums, boolean[] used) {
    // ...
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) {
            continue; // 此元素已在当前 "路径" 中
        }

        path.add(nums[i]);
        used[i] = true;

        backtrack(nums, used); // 下一轮还是从 0 开始

        used[i] = false;
        path.removeLast();
    }
}
```

## 范式二：字符串 (Strings) - 分割或者映射

字符串问题通常是**“分割”**或**“映射”**范式。

**路径 (Path):** 通常是 `List<String>` (存放分割出的子串) 或 `StringBuilder` (存放映射组合的字符)。

**选项 (Options):** 不再是单个元素，而是**“切割点”**（`index`）或**“映射的字符”**。

**范式特点 (关键)：** 探索的不再是“选哪个元素”，而是“在哪里切割”或“选哪个映射”。

### A. 分割范式 (e.g., 分割回文串)

尝试在 `startIndex` 后的每一个位置 `i` 切一刀，看 `s[startIndex...i]` 是否合法。

```Java
void backtrack(String s, int startIndex) {
    if (startIndex == s.length()) { // 切到头了
        result.add(new ArrayList<>(path));
        return;
    }

    // 遍历所有可能的 "切割点"
    for (int i = startIndex; i < s.length(); i++) {
      //获取子串s[start...i]
        String sub = s.substring(startIndex, i + 1);
				//检查子串是否合法
        if (isValid(sub)) { // 剪枝
            path.add(sub);//将子串加入path
            backtrack(s, i + 1); // 下一次从 i+1 开始切
            path.removeLast();//将子串从path中移除
        }
    }
}
```

### B. 映射/组合范式 (e.g., 电话号码)

字符串的第 `index` 个字符，对应一个“选项列表”（如 '2' 对应 "abc"）。



```Java
void backtrack(String digits, int index) {
    if (index == digits.length()) {
        result.add(path.toString());
        return;
    }

    String letters = map[digits.charAt(index)]; // 获取 "选项列表"

    for (char c : letters.toCharArray()) {
        path.append(c);
        backtrack(digits, index + 1); // 处理下一个数字
        path.deleteCharAt(path.length() - 1);
    }
}
```

## 4. 范式三：矩阵 / 图 (Matrix / Graph)

这是纯粹的**“深度优先搜索 (DFS)”**范式，核心是**“方向”**。

**路径 (Path):** 通常是 `boolean[][] visited` 数组，标记“当前路径”访问过的格子，以防在*同一次搜索*中走回头路。

**选项 (Options):** 当前格子 `(r, c)` 的**上、下、左、右**四个（或八个）相邻的、未访问过的格子。

**范式特点 (关键)：** “选择”就是移动到下一个格子，“撤销选择”就是将该格子从 `visited` 中移除，以便*其他*搜索路径可以使用它。

```Java
void backtrack(char[][] board, int r, int c, ...) {
    // 1. 剪枝 (越界, 不满足条件, 已访问)
    if (r < 0 || r >= R || c < 0 || c >= C || visited[r][c] || ...) {
        return;
    }

    // (检查是否满足结束条件 ...)

    // 1. 做出选择 (标记)
    visited[r][c] = true;
    // (path.add(...) 如果需要记录路径)

    // 2. 递归 (遍历 "选项"：四个方向)
    backtrack(board, r + 1, c, ...);
    backtrack(board, r - 1, c, ...);
    backtrack(board, r, c + 1, ...);
    backtrack(board, r, c - 1, ...);

    // 3. 撤销选择 (取消标记)
    visited[r][c] = false;
    // (path.removeLast(...) 如果需要记录路径)
}
```

## 范式四：二叉树 (Binary Trees)

二叉树的回溯范式是**“路径搜索”**，它是图/矩阵范式的一个简化版（因为没有“环”，也无需 `visited` 数组）。

**路径 (Path):** 通常是 `List<Integer>`，记录从根到当前节点的路径。

**选项 (Options):** `node.left` 和 `node.right`。

**范式特点 (关键)：** 递归调用本身就是“选择”，回溯（撤销选择）发生在**左右子树都探索完毕**之后。这天然地契合了“前序遍历”和“后序遍历”的组合。

套路 (经典：路径总和):

```Java
void backtrack(TreeNode node, List<Integer> path, ...) {
    // 剪枝 (Base Case)
    if (node == null) {
        return;
    }

    // 1. 做出选择 (前序遍历位置)
    path.add(node.val);
    // (currentSum += node.val)

    // 检查结束条件 (e.g., 叶子节点 + 满足 sum)
    if (node.left == null && node.right == null && ...) {
        result.add(new ArrayList<>(path));
        // 注意：这里不能 return，必须执行 "撤销"
    }

    // 2. 递归 (探索 "选项")
    backtrack(node.left, path, ...);
    backtrack(node.right, path, ...);

    // 3. 撤销选择 (后序遍历位置)
    path.removeLast();
    // (currentSum -= node.val)
}
```

好的，这是一个非常好的提议。在深入研究“数据结构 + 目标”的详细组合之前，我们先提炼出回溯算法应用在不同数据结构上的**通用范式（Paradigm）**。

这能帮你建立一个更高阶的认知：无论问题怎么变，回溯在这类结构上的“探索”方式是固定的。

------



### 1. 通用回溯范式（万能公式）



所有回溯问题都是在“解空间树”上进行深度优先搜索（DFS）。这个范式的核心是“三段论”：

Java

```
void backtrack(路径, 选项列表) {
    if (满足结束条件) {
        保存路径;
        return;
    }

    for (选项 : 选项列表) {
        // 1. 做出选择
        将 "选项" 添加到 "路径";
        
        // 2. 递归
        // 基于当前选项，更新 "下一轮的选项列表"
        backtrack(路径, 下一轮的选项列表); 
        
        // 3. 撤销选择
        从 "路径" 中移除 "选项"; 
    }
}
```

现在，我们来看这个范式在不同数据结构上是如何“具体化”的。

------



### 2. 范式一：数组 / 集合 (Arrays / Collections)



这是最经典的回溯范式，核心是**“组合”**与**“排列”**。

- **路径 (Path):** 通常是一个 `List` 或 `LinkedList`，用来存放“已选择”的元素。

- **选项 (Options):** 数组/集合中的元素。

- **范式特点 (关键)：** 如何定义“下一轮的选项列表”？这导致了两种主要的控制范式：

  - **A. `startIndex` 控制范式 (用于子集、组合问题)**

    - **含义：** 为了避免产生重复的组合（如 `[1, 2]` 和 `[2, 1]`），我们只允许“向后看”。

    - **实现：** 递归时，`startIndex` 作为参数传递。`for` 循环从 `startIndex` 开始。

    - **套路：**

      Java

      ```
      void backtrack(int[] nums, int startIndex) {
          // ...
          for (int i = startIndex; i < nums.length; i++) {
              path.add(nums[i]);
              // 递归时传入 i + 1 (或 i, 如果元素可重复使用)
              backtrack(nums, i + 1); 
              path.removeLast();
          }
      }
      ```

  - **B. `used` 数组控制范式 (用于排列问题)**

    - **含义：** 为了确保每个元素在*一条路径*中只被使用一次，但*不同路径*可以从任意元素开始（顺序相关）。

    - **实现：** 需要一个额外的 `boolean[] used` 数组。`for` 循环*总是*从 `0` 开始。

    - **套路：**

      Java

      ```
      void backtrack(int[] nums, boolean[] used) {
          // ...
          for (int i = 0; i < nums.length; i++) {
              if (used[i]) {
                  continue; // 此元素已在当前 "路径" 中
              }
      
              path.add(nums[i]);
              used[i] = true;
      
              backtrack(nums, used); // 下一轮还是从 0 开始
      
              used[i] = false;
              path.removeLast();
          }
      }
      ```

------



### 3. 范式二：字符串 (Strings)



字符串问题通常是**“分割”**或**“映射”**范式。

- **路径 (Path):** 通常是 `List<String>` (存放分割出的子串) 或 `StringBuilder` (存放映射组合的字符)。

- **选项 (Options):** 不再是单个元素，而是**“切割点”**（`index`）或**“映射的字符”**。

- **范式特点 (关键)：** 探索的不再是“选哪个元素”，而是“在哪里切割”或“选哪个映射”。

  - **A. 分割范式 (e.g., 分割回文串)**

    - **含义：** 尝试在 `startIndex` 后的每一个位置 `i` 切一刀，看 `s[startIndex...i]` 是否合法。

    - **套路：**

      Java

      ```
      void backtrack(String s, int startIndex) {
          if (startIndex == s.length()) { // 切到头了
              result.add(new ArrayList<>(path));
              return;
          }
      
          // 遍历所有可能的 "切割点"
          for (int i = startIndex; i < s.length(); i++) {
              String sub = s.substring(startIndex, i + 1);
      
              if (isValid(sub)) { // 剪枝
                  path.add(sub);
                  backtrack(s, i + 1); // 下一次从 i+1 开始切
                  path.removeLast();
              }
          }
      }
      ```

  - **B. 映射/组合范式 (e.g., 电话号码)**

    - **含义：** 字符串的第 `index` 个字符，对应一个“选项列表”（如 '2' 对应 "abc"）。

    - **套路：**

      Java

      ```
      void backtrack(String digits, int index) {
          if (index == digits.length()) {
              result.add(path.toString());
              return;
          }
      
          String letters = map[digits.charAt(index)]; // 获取 "选项列表"
      
          for (char c : letters.toCharArray()) {
              path.append(c);
              backtrack(digits, index + 1); // 处理下一个数字
              path.deleteCharAt(path.length() - 1);
          }
      }
      ```

------



### 4. 范式三：矩阵 / 图 (Matrix / Graph)



这是纯粹的**“深度优先搜索 (DFS)”**范式，核心是**“方向”**。

- **路径 (Path):** 通常是 `boolean[][] visited` 数组，标记“当前路径”访问过的格子，以防在*同一次搜索*中走回头路。

- **选项 (Options):** 当前格子 `(r, c)` 的**上、下、左、右**四个（或八个）相邻的、未访问过的格子。

- **范式特点 (关键)：** “选择”就是移动到下一个格子，“撤销选择”就是将该格子从 `visited` 中移除，以便*其他*搜索路径可以使用它。

- **套路：**

  Java

  ```
  void backtrack(char[][] board, int r, int c, ...) {
      // 1. 剪枝 (越界, 不满足条件, 已访问)
      if (r < 0 || r >= R || c < 0 || c >= C || visited[r][c] || ...) {
          return;
      }
  
      // (检查是否满足结束条件 ...)
  
      // 1. 做出选择 (标记)
      visited[r][c] = true;
      // (path.add(...) 如果需要记录路径)
  
      // 2. 递归 (遍历 "选项"：四个方向)
      backtrack(board, r + 1, c, ...);
      backtrack(board, r - 1, c, ...);
      backtrack(board, r, c + 1, ...);
      backtrack(board, r, c - 1, ...);
  
      // 3. 撤销选择 (取消标记)
      visited[r][c] = false;
      // (path.removeLast(...) 如果需要记录路径)
  }
  ```

------



### 5. 范式四：二叉树 (Binary Trees)



二叉树的回溯范式是**“路径搜索”**，它是图/矩阵范式的一个简化版（因为没有“环”，也无需 `visited` 数组）。

- **路径 (Path):** 通常是 `List<Integer>`，记录从根到当前节点的路径。

- **选项 (Options):** `node.left` 和 `node.right`。

- **范式特点 (关键)：** 递归调用本身就是“选择”，回溯（撤销选择）发生在**左右子树都探索完毕**之后。这天然地契合了“前序遍历”和“后序遍历”的组合。

- **套路 (经典：路径总和)**

  Java

  ```
  void backtrack(TreeNode node, List<Integer> path, ...) {
      // 剪枝 (Base Case)
      if (node == null) {
          return;
      }
  
      // 1. 做出选择 (前序遍历位置)
      path.add(node.val);
      // (currentSum += node.val)
  
      // 检查结束条件 (e.g., 叶子节点 + 满足 sum)
      if (node.left == null && node.right == null && ...) {
          result.add(new ArrayList<>(path));
          // 注意：这里不能 return，必须执行 "撤销"
      }
  
      // 2. 递归 (探索 "选项")
      backtrack(node.left, path, ...);
      backtrack(node.right, path, ...);
  
      // 3. 撤销选择 (后序遍历位置)
      path.removeLast();
      // (currentSum -= node.val)
  }
  ```

##总结

| **数据结构**  | **核心范式**   | **"选项" 是什么？**                     | **"路径" 是什么？**              | **"撤销" 如何实现？**                       |
| ------------- | -------------- | --------------------------------------- | -------------------------------- | ------------------------------------------- |
| **数组/集合** | 组合 / 排列    | 元素 (通过 `startIndex` 或 `used` 筛选) | `List` (已选元素)                | `path.removeLast()` (和 `used[i]=false`)    |
| **字符串**    | 分割 / 映射    | "切割点" (`i`) / "映射字符" (`c`)       | `List<String>` / `StringBuilder` | `path.removeLast()` / `path.deleteCharAt()` |
| **矩阵/图**   | DFS / 路径搜索 | 四个方向的邻居 `(r', c')`               | `boolean[][] visited` (标记路径) | `visited[r][c] = false`                     |
| **二叉树**    | DFS / 路径搜索 | `node.left` 和 `node.right`             | `List` (节点值)                  | `path.removeLast()` (递归返回后)            |
