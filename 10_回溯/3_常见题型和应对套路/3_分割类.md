# 分割类问题

"分割"类问题，顾名思义，就是将一个**连续**的整体（如字符串、数组）切割成若干个**连续**的部分，并要求每个部分都满足特定条件。

## 问题要点

### 输入和输出

**输入 (Input):** 通常是一个线性的、有序的数据结构，最常见的是**字符串 (String)**。

**输出 (Output):** 要求返回：

- 所有可能的分割方案（`List<List<String>>`);
- 或者方案的个数（`int`);
- 或者是“最优”方案（如最小分割次数）;

### 核心限制

**连续性 (Contiguity):** 分割出的每个部分（子串）必须是**原结构中的连续片段**。

**完整性 (Completeness):** 所有分割出的部分拼接起来，必须**等于**原始输入，不多不少。

**合法性 (Validity):** 每一个被分割出的部分，都必须满足一个`isValid()`的条件（例如：是回文串、是合法的 IP 段、在字典中等）。

##  问题本质和分析 (Essence & Analysis) - 组合的变体

### 问题的本质就是寻找所有可能的切割点组合

问题的本质是**“组合”**的变体。

假设一个长度为 $N$ 的字符串，它有 $N-1$ 个“可能的切割点”（即字符与字符之间的空隙）。

比如"abcde"， 有4个可能的切割点。

你的任务是，在这 $N-1$ 个切割点中，选择**一个子集**（可以为空，也可以为全部）来进行切割。

例如，对于 "abcde"，如果你选择在第1和第3个空隙切割，方案就是 `["ab", "c", "de"]`。

因此，解决这个问题的过程，就是在**搜索所有可能的“切割点组合”**。

### 如何转化为回溯问题？

这天然地构成了一棵**决策树**。

#### 回溯决策树的状态节点是什么？

状态节点

在树的每一个节点，你都需要做一个决策：**“下一个合法的分割点在哪里？”**

- **根节点：** 原始字符串 "abcde"，从索引 0 开始。
- 第一层决策（从 0 开始）：
  - **选择 1:** 切割 "a"，子问题是分割 "bcde" (从索引 1 开始)。
  - **选择 2:** 切割 "ab"，子问题是分割 "cde" (从索引 2 开始)。
  - **选择 3:** 切割 "abc"，子问题是分割 "de" (从索引 3 开始)。
  - ....
- **第二层决策（以“选择 1”为例）：** 子问题是 "bcde"，从索引 1 开始。
  - **选择 1.1:** 切割 "b"，子问题是分割 "cde" (从索引 2 开始)。
  - **选择 1.2:** 切割 "bc"，子问题是分割 "de" (从索引 3 开始)。
  - ...

回溯法（Backtracking）就是用于遍历这棵决策树的完美工具，它通过深度优先搜索（DFS）来找到所有满足条件的路径（从根节点到叶子节点）。

## 模式套路匹配 (Pattern Matching)

此问题匹配回溯法中的**“切割/组合”**模式。

- **状态变量：** 整个回溯过程中，唯一需要追踪的核心状态是 `startIndex`。

- **`startIndex` 的含义：** 当前正准备处理的、**剩余子串的起始索引**。

- **`backtrack(startIndex)` 的职责：** 找到并处理从 `startIndex` 开始到字符串末尾的所有可能的分割方案。

## 核心思想和套路 (Core Idea and "Taolu")

核心思想是：**“循环尝试所有可能的‘第一段’，然后递归处理‘剩余部分’”**。

### 回溯函数的定义

定义回溯函数 `backtrack(String s, int startIndex)`。

### 终止条件的定义

如果 `startIndex` 等于（或越过）字符串的长度 `s.length()`，说明我们已经成功地分割完了整个字符串。

此时，我们找到了一个完整的解，将当前`path`（路径）的**副本**存入最终结果`results`中。

### 设置循环（遍历当前层的所有选择）- 检查`s[start...i]`是否符合条件

- 使用一个 `for` 循环，`i` 从 `startIndex` 遍历到 `s.length() - 1`。
- 这个 `i` 的含义是：**当前尝试分割的子串的“结束索引”**, 说白了每一次循环我们都是在：
  - 检查`s[start...i]`到底他妈的是不是一个**符合条件的字符串**？
  - 如果是的话，他妈的就继续回溯`s[i+1...[i+2...n-1]]`
- 因此，`for` 循环中的“一个选择”就是子串 `s.substring(startIndex, i + 1)`。

### 剪枝条件 - 如果`[start...i]`不是符合条件的子串

- 在 `for` 循环内部，检查这个“选择”是否合法：`if (isValid(s.substring(startIndex, i + 1)))`。

- 例如，在“分割回文串”中，`isValid` 就是 `isPalindrome`。

- 如果**不合法**，`continue`，跳过这个选择，尝试更长的子串（即 `i + 1`）。

### 选择 - 探索 - 回溯

如果他妈的`s[start...i]`是一个合法的。

则进行回溯三部曲：

1. - 做出选择 (Choose):** `path.add(s.substring(startIndex, i + 1))`。
   - **探索 (Explore):** 递归调用 `backtrack(s, i + 1)`。**注意：** 下一个子问题的起始索引是 `i + 1`，因为 `[startIndex, i]` 已经被用掉了。
   - **撤销选择 (Unchoose):** `path.remove(path.size() - 1)`。这是回溯的精髓，为了返回上一层时，能尝试其他的 `i`（即其他的分割点）。

## 实现原理和步骤

我们使用一个`path`（通常是 `List<String>`）来记录当前已经分割好的子串，`results`（`List<List<String>>`）来保存所有成功的 `path`。

###**步骤 1 (启动): 初始化result和path** 

初始化 `results = new ArrayList<>()` 和 `path = new ArrayList<>()`。 调用 `backtrack(s, 0)`，从索引 0 开始分割。

###**步骤 2 (递归与终止): `backtrack(s, startIndex)`**

- **`if (startIndex == s.length())`:**
  - `results.add(new ArrayList<>(path));` (必须加副本)
  - `return;` (终止)

###**步骤 3 (循环与选择):**

- **`for (int i = startIndex; i < s.length(); i++)`:**
  - `String currentSegment = s.substring(startIndex, i + 1);` (获取当前选择)

###**步骤 4 (剪枝与递归):**

- **`if (isValid(currentSegment))`:** (检查合法性)
  - `path.add(currentSegment);` (选择)
  - `backtrack(s, i + 1);` (递归处理 `s[i+1...]`)
  - `path.remove(path.size() - 1);` (撤销)
- **`else`:**
  - `continue;` (剪枝，`i` 会自增，尝试 `s.substring(startIndex, i + 2)`)

## 代码套路模板

```Java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> partition(String s) {
        List<String> path = new ArrayList<>();
        backtrack(s,0,path);
        return res;
    }

    private void backtrack(String s, int start, List<String> path){
        if(start == s.length()){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = start; i < s.length(); i++){
            String substr = s.substring(start, i+1);
            if(isPalindrome(substr)){
                path.add(substr);
                backtrack(s, i+1, path);
                path.remove(path.size()-1);
            }
        }
    }

    private boolean isPalindrome(String s){
        int left = 0;
        int right = s.length() - 1;
        while(left < right){
            if(s.charAt(left) != s.charAt(right)){
                return false;
            }
            left++;
            right--;
        }

        return true;
    }
}
```

## Leetcode 131: 分割回文串

//见上述解析

## Leetcode 93: 复原IP地址

基本的原理和标准套路是一样的。

### 按照标准套路的解决方法

####检查Path是否符合条件

- Path的长度为4
- Start的位置越界

如果如何上述条件，将path转化为一个IP地址，并加入结果。

####从`start`开始，遍历每一个子串`[start...i]`是否是一个**IP数字**：

- 两位以上数字不能以0开头
- 长度不能超过3
- 大小不能超过255

#### 对符合条件的子串开启回溯三部曲

##### 将子串加入path

`path.add(substr)`

##### 递归调用回溯`backtrack(s,i+1,path)`

##### 将子串从path中删除

#### 代码实现

```Java
//分割类型的问题

class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        List<String> path = new ArrayList<>();
        backtrack(s, 0, path);
        return res;
    }

    private void backtrack(String s, int start, List<String> path){
        if(start == s.length() && path.size() == 4){
            String ip = String.join(".", path);
            res.add(ip);
            return;
        }

        for(int i = start; i < s.length(); i++){
            String substr = s.substring(start,i+1);
            if(isValidIpNum(substr)){
                path.add(substr);
                backtrack(s, i+1, path);
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isValidIpNum(String s){
        if(s.length() >= 2 && s.startsWith("0")){
            return false;
        }
        if(s.length() > 3){
            return false;
        }
        int num = Integer.parseInt(s);
        if(num > 255) return false;
        return true;
    }
}
```



### 可以根据场景优化的地方有哪些？

#### 优化点一 (核心)：修正终止条件与剪枝逻辑

你当前的终止条件 `if(start == s.length() && path.size() == 4)` 有一个问题：

- **问题：** 当 `path.size() == 4` 但 `start != s.length()` 时（例如，"1.1.1.1" 匹配了，但字符串还有剩余 "234"），你的 `if` 条件不满足，代码会**继续**执行 `for` 循环，尝试向一个已经有 4 段的 `path` 中添加第 5 段！
- **修正：** 应该将“段数”作为更高优先级的检查。一旦 `path` 中已经有 4 段，就必须立刻停止递归，无论 `start` 在哪里。

```Java
private void backtrack(String s, int start, List<String> path){
    // 优化1：终止条件和剪枝的优先级调整
    
    // 1. 如果段数已经到 4，我们必须做出最终判断
    if(path.size() == 4){
        // 1.1 此时如果 start 也刚好用完字符串，才是有效解
        if(start == s.length()){
            String ip = String.join(".", path);
            res.add(ip);
        }
        // 1.2 无论是否有效，都必须返回。不能再继续添加第 5 段。
        // (这就是你原代码中缺失的剪枝)
        return;
    }

    // 2. 如果字符串用完了，但段数还不到 4，说明此路不通
    if(start == s.length()){
        return;
    }
    
    // 3. 继续搜索（for 循环...）
    // ...
}
```

**小结：** 将 `path.size() == 4` 作为“必须返回”的信号，是这个问题的关键剪枝之一。



#### 优化点二 (性能)：大幅剪枝 `for` 循环的范围

你当前的 `for` 循环会遍历 `start` 之后的所有可能性：`for(int i = start; i < s.length(); i++)`。

- **问题：** 如果 `s = "123456789"` 且 `start = 0`，你的循环会尝试 `substr = "1234"`、`"12345"`... 等等。但我们知道 IP 地址的一段**最多只有 3 位**。
- **优化：** `for` 循环的结束点 `i` 最多只需要遍历到 `start + 2` 即可。

```Java
// 3. 继续搜索
    // 优化2：i 最多到 start + 2 (即子串长度最多为 3)
    // 并且 i 不能越过字符串边界
    int end = Math.min(s.length(), start + 3);
    for(int i = start; i < end; i++){
        String substr = s.substring(start,i+1);
        if(isValidIpNum(substr)){
            path.add(substr);
            backtrack(s, i+1, path);
            path.remove(path.size() - 1);
        }
    }
}
```

**小结：** 这个优化将 `for` 循环的次数从 $O(N)$ 降到了 $O(1)$（最多 3 次），是本题**最重要**的性能剪枝。

#### 优化点三 (性能)："剩余长度"剪枝

这是一个更高级的剪枝，可以避免许多无效的深层递归。

- **思路：** 在`backtrack`函数的开头，我们可以检查**剩余的字符**是否足够（或过多）用来组成“剩余的段”。
- **例如：** `s = "1234567890123"` (13个字符)，`start = 0`, `path.size() = 0`。
  - 我们需要 4 段。
  - 最少需要 `4 * 1 = 4` 个字符。
  - 最多需要 `4 * 3 = 12` 个字符。
  - 而我们有 13 个字符，超过了最大值 12，所以这个 `s` 根本不可能组成 IP，可以直接 `return`。

```Java
private void backtrack(String s, int start, List<String> path){
    // 优化1：修正终止逻辑
    if(path.size() == 4){
        if(start == s.length()){
            res.add(String.join(".", path));
        }
        return;
    }

    // 优化3：剩余长度剪枝
    int remainingLen = s.length() - start;
    int remainingSegments = 4 - path.size();
    
    // 如果剩余的字符太少（连每段 1 个都不够）
    if (remainingLen < remainingSegments * 1) {
        return;
    }
    // 如果剩余的字符太多（连每段 3 个都用不完）
    if (remainingLen > remainingSegments * 3) {
        return;
    }

    // 优化2：在 for 循环中体现
    int end = Math.min(s.length(), start + 3);
    for(int i = start; i < end; i++){
        // ... (循环体不变)
    }
}
```

#### (可选) 优化点四：`isValidIpNum` 的简化

如果你采用了**优化点二**（限制 `for` 循环范围），那么 `isValidIpNum` 就不再需要检查 `s.length() > 3` 了，因为传给它的子串长度**绝对不会**大于 3。

```Java
private boolean isValidIpNum(String s){
    // 优化4：因为调用方保证了 s.length() <= 3，所以可以移除这个检查
    // if(s.length() > 3){
    //     return false;
    // }

    // 检查 "0" 开头的多位数，例如 "01", "001"
    if(s.length() > 1 && s.startsWith("0")){
        return false;
    }

    // 此时 s 长度为 1, 2, 或 3，且不以 0 开头（除非 s 本身就是 "0"）
    int num = Integer.parseInt(s);
    
    // 简化：直接 return 比较结果
    return num <= 255;
}
```

#### 优化后的代码

```Java
//分割类型的问题

class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        List<String> path = new ArrayList<>();
        backtrack(s, 0, path);
        return res;
    }

    private void backtrack(String s, int start, List<String> path){
        if(path.size() == 4){
            if(start == s.length()){
                String ip = String.join(".", path);
                res.add(ip);
            }
            //path.size == 4时，不管start是否在结尾，都是要return的
            return;
        }
        //若不满足，我们看看start往后（从start开始），还有多少字符？
        //计算剩余字符的长度
        int remainingLen = s.length() - start;
        //计算还有几个IP段需要计算
        int remainingSegments = 4 - path.size();

        //最小的剩余长度检查，假设segment长度为1，最少需要的剩余长度应该为remainingSegments * 1;
        //如果剩余长度不足，则返回
        if(remainingLen < remainingSegments * 1){
            return;
        }

        //最大剩余长度检查，如果超过最大剩余长度，也应该返回
        if(remainingLen > remainingSegments * 3){
            return;
        }

        //因为IP数字最长只有三位，因此我们每次只需要最多遍历长度为1到3的子串即可
        int end = Math.min(s.length(), start + 3);
        for(int i = start; i < end; i++){
            String substr = s.substring(start,i+1);
            if(isValidIpNum(substr)){
                path.add(substr);
                backtrack(s, i+1, path);
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isValidIpNum(String s){
        if(s.length() >= 2 && s.startsWith("0")){
            return false;
        }
        int num = Integer.parseInt(s);
        if(num > 255) return false;
        return true;
    }
}
```

#### 优化前后对比

| Metric  | 优化前               | 优化后                |
| ------- | -------------------- | --------------------- |
| Runtime | 6ms (Beats 27.72%)   | 2ms (Beats 88.88%)    |
| Memory  | 44.78MB(Beats 7.66%) | 42.12MB(Beats 96.45%) |
|         |                      |                       |

