# 划分类 

## 场景 + 目标

### 输入和输出

**输入 (Input):** 通常是一个**离散元素的集合**，最常见的是**数组 (Array)**，例如 `int[] nums`。

这个题目的标准范本是Leetcode 698。

**输出 (Output):**

- `boolean`：是否**存在**一种满足条件的划分方案（如 LeetCode 698, 416）。
- `List<List<Integer>>`：返回**所有**满足条件的划分方案（这不常见，但“子集”问题是其变体）。

### 核心约束 (Core Constraint):

1. **完整性 (Completeness):** 数组中的**每一个**元素都**必须**被分配。
2. **唯一性 (Exclusivity):** 每一个元素都**只能**被分配到 $k$ 个桶中的**一个**。
3. **合法性 (Validity):** 最终，**每一个**桶（或所有桶的组合）都必须满足某个全局条件（例如：$k$ 个桶的元素和都相等）。

### 典型例子

- LeetCode 698. 划分为K个相等的子集
- LeetCode 416. 分割等和子集 (本质是 $k=2$ 的 698)
- LeetCode 473. 火柴拼正方形 (本质是 $k=4$ 的 698)

## 问题的分析和本质：分配或者映射

### 问题的本质 - 为元素找个桶作为归宿

问题的本质是**“分配”**或**“映射”**。

你有 $N$ 个元素（`nums` 数组）和 $k$ 个桶（`buckets`）。

你的任务是为 $N$ 个元素中的**每一个**元素，从 $k$ 个桶中选择一个“归宿”。

###**决策视角：** 以**元素**为视角，进行 $N$ 次决策。

我们需要遍历每一个元素，并且尝试将某个元素找个桶来放。

然后我们继续为后续元素找桶，

- 如果后面每个元素都找到桶放了，说明这个方案可行，return true。
- 否则说明这个方案不行，我们得将当前元素从桶里拿出来（回溯），继续尝试其他桶。

####**决策树的节点状态**

- 树的**深度**（层级）对应**元素的索引 `itemIndex`**（从 0 到 $N-1$）。
- 树的**宽度**（分支）对应**桶的索引 `j`**（从 0 到 $k-1$）。

####**决策过程：**

1. **Level 0 (根节点):** 决定 `nums[0]` 放入哪个桶？（有 $k$ 个选择：桶 0, 桶 1, ..., 桶 $k-1$）。
2. **Level 1:** 决定 `nums[1]` 放入哪个桶？（同样有 $k$ 个选择）。
3. ...
4. **Level N (叶子节点):** 所有 $N$ 个元素都已分配完毕。此时检查 $k$ 个桶的状态是否满足最终条件。

这是一个搜索空间为 $O(k^N)$ 的问题，必须使用回溯法，并配合强力的剪枝。

## 模式套路匹配

此问题匹配回溯法中的**“元素分配给桶” (Items to Bins)** 模式。

- **状态变量：** 核心状态变量是 `itemIndex`。
- **`itemIndex` 的含义：** “我们正在为 `nums[itemIndex]` 这个元素寻找一个桶”。
- **`backtrack(itemIndex, ...)` 的职责：** 将 `nums[itemIndex]` 以及它之后的所有元素（从 `itemIndex+1` 到 `N-1`）成功分配到 $k$ 个桶中。
- **辅助状态：** 你需要一个数据结构来**追踪 $k$ 个桶的当前状态**，最常见的是一个数组 `int[] buckets`，其中 `buckets[j]` 记录第 `j` 个桶当前的元素总和。

## 核心思想和套路 - 尝试给每个元素找个桶

核心思想：**“以‘元素’为主角，遍历每个‘元素’；在处理每个元素时，遍历所有‘桶’，尝试将其放入。”**

需要注意的是，我们每一轮循环遍历的是每一个桶，而不是元素。

也就是说，我们每次递归过程就是为当前的元素找个桶：

- 找不着合适的桶，就说明这事办不下去了，直接返回`false`
- 找到了，说明这事还能继续办，将当前元素放入找到的桶里，继续递归调用`backtrack(nums,next,buckets)` 给下一个元素找桶
- 如果所有元素都找到桶了，返回`true`

### **定义回溯函数：** `backtrack(int[] nums, int itemIndex, int[] buckets)`。

- ItemIndex表示当前元素的索引
- buckets表示每个桶里面的数字总和

###**设置终止条件 (Base Case):**`itemIndex == nums.length`

- `if (itemIndex == nums.length)`：所有元素都已成功分配。
- 此时，检查 $k$ 个桶的状态是否都满足条件（例如 `buckets[0] == buckets[1] == ... == target`）。
- 如果都满足，说明找到了一条完整解，返回 `true`。

###**设置循环（遍历当前 itemIndex 的所有选择）：**

- `for (int j = 0; j < k; j++)`：遍历 $k$ 个桶。
- 这个 `j` 的含义是：**“尝试将 `nums[itemIndex]` 放入第 `j` 个桶”**。

###**剪枝（约束检查）：**看看桶能放得下不？

- 在 `for` 循环内部，检查这个“选择”是否合法：
- **(重要剪枝1 - 容量剪枝):** `if (buckets[j] + nums[itemIndex] > targetSum)`。如果放入后会导致第 `j` 个桶溢出，则 `continue`，尝试下一个桶 `j+1`。
- **(重要剪枝2 - 等效剪枝):** `if (j > 0 && buckets[j] == buckets[j-1])`。如果第 $j$ 个桶和第 $j-1$ 个桶**在放入`nums[itemIndex]`之前**的状态（总和）完全一样，那么“放入 $j-1$ 桶”和“放入 $j$ 桶”是等效的。如果尝试 `j-1` 桶失败了（即 `backtrack` 返回 `false`），那么尝试 `j` 桶也必然失败，应直接 `continue`。

###**处理（做出选择 -> 探索 -> 撤销）：**

#### **做出选择 (Choose):**

 `buckets[j] += nums[itemIndex]`。

#### **探索 (Explore):** 继续尝试放后面的元素

递归调用 `backtrack(nums, itemIndex + 1, buckets)`。

**注意：** 下一个子问题是处理**下一个元素 `itemIndex + 1`**。

#### **(处理返回值):** 

`if (backtrack(...) == true)`，说明找到了一个解，立刻 `return true`，终止当前层的 `for` 循环（“喜报”层层传递）。

#### **撤销选择 (Unchoose):** `buckets[j] -= nums[itemIndex]`。

这是回溯的精髓。

如果上一步返回 `false`（说明把 `nums[itemIndex]` 放在桶 `j` 的这条路走不通），我们就必须把它“拿出来”，以便在 `for` 循环的下一次迭代中，尝试把它放入桶 `j+1`。

#### **返回 `false`：所有桶都放不下**

如果 `for` 循环（尝试了所有 $k$ 个桶）都走不通，说明 `nums[itemIndex]` 元素“无家可归”，返回 `false`。



## 实现原理和步骤

###**步骤 1 (预处理):**检查总和并初始化桶

- 计算 `sum`，检查 `sum % k != 0`，若不满足则 `return false`。
- 计算 `targetSum = sum / k`。
- 初始化 $k$ 个桶 `int[] buckets = new int[k]`。
- **(关键优化)**：对 `nums` **降序排序**。

###**步骤 2 (启动):** 开启回溯过程

- 调用 `backtrack(nums, 0, buckets, targetSum)`，从第 0 个元素开始分配。

###**步骤 3 (递归与终止): `backtrack(nums, itemIndex, ...)`**

####**`if (itemIndex == nums.length)`:**

- *（此时，由于剪枝，我们可以确保所有 bucket 都 <= targetSum。又因为所有元素都已放入，且总和为 `k*targetSum`，所以此时必然所有 bucket 都 == targetSum）*
- `return true;`

###**步骤 4 (循环与选择):**

- **`for (int j = 0; j < k; j++)`:** (尝试 $k$ 个桶)

###**步骤 5 (剪枝):**

- **容量剪枝:** `if (buckets[j] + nums[itemIndex] > targetSum) { continue; }`
- **等效剪枝:** `if (j > 0 && buckets[j] == buckets[j-1]) { continue; }`

###**步骤 6 (递归与回溯):**

- **选择:** `buckets[j] += nums[itemIndex];`
- **探索:** `if (backtrack(nums, itemIndex + 1, buckets, targetSum)) { return true; }`
- **撤销:** `buckets[j] -= nums[itemIndex];`

###**步骤 7 (失败):**

- (循环结束) `return false;`

## 实现代码

//详细见Leetcode 698

## Leetcode 698: 划分为k个相等的子集

这是一个从“组合问题”升级而来的“搜索问题”，难度较高 (Medium/Hard)，是面试常客。它询问的不是“找到所有”，而是“是否可能”。

### 问题描述

**输入**: 一个整数数组 `nums` 和一个正整数 `k`。

**输出**: 一个布尔值 (`true` / `false`)。

**目标**: 判断是否可能将 `nums` 数组中的所有数字，不重不漏地划分成 `k` 个非空子集。

**约束**: 这 `k` 个子集的元素之和必须完全相等。

### 问题本质和分析 - 集合划分问题

这个问题的本质是**集合划分问题**，具体来说，是"多路数字划分"（Multiway Number Partitioning），它是经典的**子集和问题**（Subset Sum Problem）和**装箱问题**（Bin Packing Problem）的变体。

我们要将 `n` 个数字（`nums` 里的元素）放入 `k` 个桶（`k` 个子集）中，并且满足以下条件：

1. 所有数字都必须被放入桶中。
2. 每个桶的"容量"（元素总和）必须严格相等。

这天然就导出了几个**强剪枝**（Pruning）条件：

#### **总和必须整除 k**:

 如果 `nums` 的总和 `totalSum` 不能被 `k` 整除（`totalSum % k != 0`），那么就不可能分出 `k` 个和相等的子集。可以直接返回 `false`。

#### **目标和 (Target Sum)**:

 如果可以划分，那么每个子集（每个桶）的和必须等于 `targetSum = totalSum / k`。

#### **最大元素限制**: 

如果 `nums` 数组中存在任何一个元素 `num`，它的大小 `num > targetSum`，那么这个元素不可能被放入任何一个子集中。可以直接返回 `false`。

### 规律观察

1. 这是一个"是/否"的决策问题。
2. 我们必须尝试所有可能的组合，没有明显的贪心策略。例如，先把最大的放进去，不一定能得到最优解。
3. 这是一个指数级的搜索空间。如果我们有 `n` 个数字和 `k` 个桶，每个数字都有 `k` 种选择（放入第 `0` 到 `k-1` 个桶），粗略的复杂度是 $O(k^n)$。
4. **优化观察**: 如果我们先处理**较大**的数字，搜索树会更快地"撞墙"（即某个桶的和 `> targetSum`），从而更早地剪枝。因此，对 `nums` **降序排序**（或升序排序后从后往前处理）是一个至关重要的优化。
5. **对称性观察**: 假设我们有 `k` 个空桶。我们尝试把第一个数字 `nums[0]` 放入桶 1，如果这条路走不通；那么我们再尝试把 `nums[0]` 放入桶 2，这和放入桶 1 的情况是完全等价的（因为所有桶开始时都是一样的）。这就是**等价性剪枝**（或对称性剪枝）。

### 模式套路匹配 (Pattern/Template Matching) - 组合型回溯

具体来说，这是“**组合型回溯**”。我们有两种回溯的思考角度：

1. **角度一：以“桶”为中心**。尝试填满第一个桶（使其和为 `targetSum`），然后再在剩下的数字中填满第二个桶，以此类推。
2. **角度二：以“数字”为中心**。遍历 `nums` 数组中的每一个数字，为每个数字决定它应该进入 `k` 个桶中的哪一个。

角度二（以“数字”为中心）通常更直观且更容易实现剪枝。

### 核心思想和套路 (Core Idea and Template)

我们采用“以数字为中心”的回溯思路。

#### 状态定义

- `buckets`: 一个大小为 `k` 的数组，`buckets[i]` 记录第 `i` 个桶（子集）当前的元素总和。
- `index`: 当前我们正准备处理 `nums` 数组中索引为 `index` 的数字。

#### 回溯函数定义

`boolean backtrack(int index)` 这个函数的含义是：“在 `buckets` 数组的当前状态下，我们能否成功地将 `nums[index]` 及其之后的所有数字（`nums[index...n-1]`）放入这 `k` 个桶中，且保证每个桶的总和最终不超过 `targetSum`。”

#### 核心实现套路

##### Base Case

如果我们已经处理完了所有数字（例如，我们从后往前处理，`index < 0`），说明所有数字都已成功放入桶中。

此时返回 `true`。

##### **Recursive Step (递归与回溯)**:

- 获取当前要处理的数字 `currentNum = nums[index]`。

- 遍历 `k` 个桶（`for i = 0 to k-1`）：

  - **尝试**: 尝试将 `currentNum` 放入第 `i` 个桶。

  - **剪枝 (Pruning)**: 检查是否可行？

    - 如果 `buckets[i] + currentNum <= targetSum`，说明可以放。

  - **选择 (Choose)**:

    - `buckets[i] += currentNum` （放入桶中）

      **递归 (Explore)**: 转向下一个数字 `if (backtrack(index - 1))`，如果这条路能走通，立刻返回 `true`。

  - **撤销 (Unchoose / Backtrack)**:

    - `buckets[i] -= currentNum` （拿出来）

  - **关键剪枝 (Symmetry Pruning)**:

    - 如果 `buckets[i] == 0`，说明我们刚刚尝试了把 `currentNum` 放入一个**空桶**，并且失败了（否则上一步的 `if` 已经 `return true` 了）。
    - 既然放入这个空桶失败了，那么尝试放入**其他任何一个空桶**也必然会失败（对称性）。
    - 因此，我们可以直接 `break` 这个 `for` 循环，停止尝试其他桶。

### 实现原理和步骤

####**预处理**: 检查总和并排序

- 计算 `nums` 的总和 `totalSum`。
- **剪枝 1**: 如果 `k <= 0` 或者 `totalSum % k != 0`，返回 `false`。
- 计算目标和 `targetSum = totalSum / k`。
- **优化 1**: 对 `nums` 数组**生序排序**。
- **剪枝 2**: 检查最大元素。如果 `nums[n-1] > targetSum`，返回 `false`。

####**初始化Buckets数组**:

- 创建一个大小为 `k` 的桶数组 `int[] buckets = new int[k]`，全部初始化为 0。

####**启动回溯**:

- 调用回溯函数 `backtrack(0, nums, buckets, targetSum)`。

####**回溯函数 `backtrack(index, ...)`**:

- **Base Case**: `if (index < 0)`，返回 `true`。
- 获取 `currentNum = nums[index]`。
- 遍历 `k` 个桶（`for i = 0 to k-1`）：
  - **可行性判断 (剪枝)**: `if (buckets[i] + currentNum <= targetSum)`:
    - **选择**: `buckets[i] += currentNum`
    - **递归**: `if (backtrack(index-1, ...))`，返回 `true`。
    - **撤销**: `buckets[i] -= currentNum`
    - **对称性剪枝**: `if (buckets[i] == 0)`，`break`。 (如果往空桶放失败了，就没必要试别的空桶了)
- 如果 `for` 循环结束都没能返回 `true`，说明 `currentNum` 无法放入任何一个桶中，返回 `false`。

### 实现代码

```Java
import java.util.Arrays;

class Solution {
    
    /**
     * 主函数
     * @param nums 原始数组
     * @param k    目标子集数量
     * @return 是否可以划分
     */
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // 1. 计算总和
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }

        // 2. 强剪枝：如果k<=0 或 总和无法被k整除
        if (k <= 0 || totalSum % k != 0) {
            return false;
        }

        int targetSum = totalSum / k;
        
        // 3. 优化与剪枝：排序
        Arrays.sort(nums); // 升序排序
        
        // 4. 强剪枝：最大元素大于目标和
        if (nums[nums.length - 1] > targetSum) {
            return false;
        }

        // 5. 初始化k个桶
        int[] buckets = new int[k];
        
        // 6. 开始回溯
        // 我们从数组的末尾（最大元素）开始处理，这是关键优化
        return backtrack(nums.length - 1, nums, buckets, targetSum);
    }

    /**
     * 回溯函数 (DFS)
     * @param index     当前要处理的 nums 数组的索引（从后往前）
     * @param nums      原始数组
     * @param buckets   k个桶的当前和
     * @param targetSum 每个桶的目标和
     * @return
     */
    private boolean backtrack(int index, int[] nums, int[] buckets, int targetSum) {
        
        // Base Case: 所有数字都已成功放入桶中
        if (index < 0) {
            return true;
        }

        int currentNum = nums[index];

        // 尝试将 currentNum 放入 k 个桶中的一个
        for (int i = 0; i < buckets.length; i++) {
            
            // 剪枝：如果放入该桶后，总和会超过 targetSum，则跳过
            if (buckets[i] + currentNum <= targetSum) {
                
                // 选择：将数字放入桶 i
                buckets[i] += currentNum;

                // 递归：处理下一个数字 (index - 1)
                if (backtrack(index - 1, nums, buckets, targetSum)) {
                    return true; // 找到一个可行解，立刻返回
                }

                // 撤销选择 (Backtrack)，说明放这个桶里可能不合适
                buckets[i] -= currentNum;

                // 关键优化（对称性剪枝）：
                // 如果 buckets[i] == 0，说明我们尝试了将 currentNum 放入一个空桶，
                // 并且这条路（递归）失败了。
                // 既然放入这个空桶失败了，那么尝试放入其他任何空桶
                // （例如 buckets[j] 也是 0）也必然会失败。
                // 因此，我们直接跳出循环，不再尝试其他桶。
                if (buckets[i] == 0) {
                    break;
                }
            }
        }

        // 如果尝试了所有 k 个桶都无法放入 currentNum，则此路不通
        return false;
    }
}
```

### 注意事项

**排序 (Sorting)**: **必须排序**，并且**从大到小**处理（即升序排序后，从 `index = n-1` 开始回溯）。这是最重要的性能优化。它使得 `buckets[i] + currentNum <= targetSum` 这个剪枝条件能更早地触发，大幅减少搜索空间。

**对称性剪枝 (Symmetry Pruning)**: `if (buckets[i] == 0) break;` 是第二个关键优化。它解决了因为桶的顺序导致的大量重复计算。没有这个优化，代码很可能会超时（TLE）。

### 经验总结 (Experience Summary)

LeetCode 698 是回溯法（DFS + 剪枝）的集大成者。当你遇到“**将一个集合划分为 K 份，每份都满足特定约束**”这类问题时，应立即想到回溯法。

解决这类问题的核心套路是：

1. **寻找剪枝条件**: 分析问题的约束（例如本题的 `totalSum % k` 和 `max(num) > targetSum`）。
2. **定义回溯状态**: 决定是“以桶为中心”还是“以元素为中心”。（后者通常更优）
3. **应用排序优化**: 优先处理“最受限制”或“最大/最小”的元素，以便尽早剪枝。
4. **应用对称性剪枝**: 识别并消除等价的搜索路径（例如本题的“空桶等价”）。

## Leetcode 416: 分割等和子集

从回溯的角度上来说，本题和Leetcode 698属于同一个问题，只是K固定为2.

### 回溯法实现

```Java
class Solution {
    public boolean canPartition(int[] nums) {
        return canPartition(nums,2);
    }

    private boolean canPartition(int[] nums, int k){
        int totalSum = 0;
        for(int i = 0; i < nums.length; i++){
            totalSum += nums[i];
        }
        
        if(totalSum % k != 0) return false;

        int targetSum = totalSum / k;
        int[] buckets = new int[k];
        return backtrack(nums, 0, buckets, targetSum);
    }

    private boolean backtrack(int[] nums, int index, int[] buckets, int targetSum){
        if(index == nums.length){
            return true;
        }

        int currentNum = nums[index];
      //尝试找个桶放进球
            for(int j = 0; j < buckets.length; j++){
                if(buckets[j] + currentNum > targetSum){
                    continue;
                }

                buckets[j] += currentNum;
                if(backtrack(nums, index+1, buckets, targetSum)){
                    return true;
                }
                buckets[j] -= currentNum;

                if(buckets[j] == 0){
                    return false;
                }
            }
        return false;
    }
}
```

### [复习]动态规划实现 - 背包问题

从动态规划的角度上说，本题属于典型的背包问题：

即是在`nums[0...n-1]`中，是否能够找出一组数字，使他们的和为$\frac {totalSum} 2 $。

#### 检查总和是否合法

既然要平均分为两个和相同的子集，那么数组的总和必须是偶数，否则就返回`false`

```Java
      int totalSum = 0; 
        for(int num : nums){
            totalSum += num;
        }

        if(totalSum % 2 != 0){
            return false;
        }
```

#### 计算背包容量

正如上文所说，我们的问题是:是否能够找出一组数字，使他们的和为$\frac {totalSum} 2 $。

这算是一种典型的背包问题，背包的容量就是`totalSum/2`。

#### 遍历过程：外层物品内层容量

```Java
        for(int i = 1; i <= n; i++){
            int num = nums[i-1];
            for(int j = 0; j <= targetSum; j++){
                dp[i][j] = dp[i-1][j];
                if(j >= num){
                    dp[i][j] = dp[i][j] || dp[i-1][j-num];
                }
            }
        }
```

#### 最终的返回值就是`dp[n][targetSum]`

## LeetCode 473. 火柴拼正方形 (本质是 $k=4$ 的 698)

这个问题可以认为是k=4版本的Leetcode 698:

```Java
class Solution {
    public boolean makesquare(int[] matchsticks) {
        int totalSum = 0;
        for(int matchstick : matchsticks){
            totalSum += matchstick;
        }

        if(totalSum % 4 != 0) return false;
        int targetSum = totalSum / 4;
        int[] buckets = new int[4];
        return backtrack(matchsticks,0,targetSum,buckets);
    }

    private boolean backtrack(int[] nums, int index, int targetSum,int[] buckets){
        //如果走到最后一步，说明全部都匹配成功了
        if(index == nums.length){
            return true;
        }

        int currentNum = nums[index];
        for(int j = 0; j < buckets.length; j++){
            if(currentNum + buckets[j] > targetSum) continue;

            buckets[j] += currentNum;
            if(backtrack(nums,index+1,targetSum,buckets)){
                return true;
            }
            buckets[j] -= currentNum;

            if(buckets[j] == 0) return false;
        }

        return false;

    }
}
```

