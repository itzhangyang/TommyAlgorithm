# 排列类

**景 (Scene):** 给定一个集合（通常是数组或字符串），这个集合可能包含重复元素，也可能不包含。

**目标 (Goal):** 找出这个集合中所有元素（或指定 $k$ 个元素）的**所有可能的排列顺序**。

- 例如：`[1, 2, 3]` 的全排列 (Full Permutation) 是 6 种。
- 例如：`[1, 1, 2]` 的全排列是 3 种（需要去重）。

排列问题的**核心在于“顺序”**。`[1, 2]` 和 `[2, 1]` 是两种不同的排列。

### 核心思想与套路

全排列中的元素内容是一样的，但是元素的顺序不一样。

因此如果两个排列中的元素顺序不一样，他们应该被视为两个不同的解。

#### 解决有顺序限制的情况？- 遍历从0开始

#####遍历逻辑： 从`nums[0]`开始！不需要记录start

遍历逻辑： 从`nums[0]`开始！不需要记录start

##### 状态记录方式 - 必须使用visited来防止重复访问！

`boolean[] used`

#####解空间：每一层可以选择任意还未使用的元素

##### 剪枝条件：元素已经被使用过

元素已经被使用过`used[i]==true` 跳过（`continue`）

##### 去重方法

如果有元素重复，通常加入去重条件：

`i>0 and nums[i]==nums[i-1] and !used[i-1]`

##### 终止条件：path size == length

#####结果存储

满足条件加入`res`

### 回溯要素在排列问题中的对应

我们以经典的回溯模板（`路径`, `选择列表`, `终止条件`）为例，看看它们在排列问题中具体对应什么：

1. **路径 (Path):**
   - **对应：** 当前正在构建的排列。
   - **示例：** `[1, 3, ...]`。
   - **实现：** 通常是一个 `List` 或 `StringBuilder`。
2. **选择列表 (Choice List):**
   - **对应：** **所有**原始元素中，**尚未被使用**（`used[i] == false`）的那些元素。
   - **注意：** 这和组合问题有本质区别。组合问题中，你的“选择列表”是“当前元素*之后*的元素”；而在排列问题中，你的“选择列表”**永远是“全体元素中尚未被使用的元素”**。
3. **终止条件 (End Condition):**
   - **对应：** 当构建的排列 `path` 的长度达到了 $n$（即原始数组的长度）。
   - **动作：** 此时，你找到了一个完整的排列，将其（的拷贝）存入最终结果集 `results`。
4. **状态变量 (State Variable):**
   - **对应：** `boolean[] used` 数组。
   - **职责：** 动态维护“选择列表”，确保回溯的每一层都能正确地知道哪些元素是可用的。



### 代码套路模板

```Java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> permute(int[] nums){
  boolean[] used = new boolean[nums.length];
  backtrack(nums, new ArrayList<>(), used);
  return res;
}

private void backtrack(int[] nums,List<Integer> path, boolean[] used){
  if (path.size == nums.length){
    res.add(new ArrayList<path>);
    return;
  }
  //排列的情况下每一次都从元素0开始遍历
  for (int i=0; i<nums.length; i++){
    //如果元素i已经使用过了，剪枝
    if (used[i]) continue;
    
    //回溯过程
    //加入当前元素
    used[i] = true;
    path.add(nums[i]);
    //递归调用回溯
    backtrack(nums[], pathm used);
    //删除当前元素
    used[i] = false;
    path.remove(path.size()-1);
  }
}
```

## Leetcode 46: 全排列 

//见上述分析

## Leetcode 47: 全排列 II (Permutations II)

### 问题要点

给定一个**可能包含重复数字**的数组 `nums`，返回所有**不重复**的全排列。

#### 代码实现

```Java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        backtrack(nums, used, path);
        return res;
    }

    private void backtrack(int[] nums, boolean[] used, List<Integer> path){
        if(path.size() == nums.length){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length;i++){
            if(used[i]) continue;
            if(i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;

            path.add(nums[i]);
            used[i] = true;
            backtrack(nums, used, path);
            path.remove(path.size()-1);
            used[i] = false;
        }
    }
}
```

##值得注意的伪排列问题

### Leetcode 31.计算当前排列的下一个排列 - 没什么鸟套路

#### 问题要点

**输入**: 一个整数数组 `nums`。

**输出**: `nums` 的下一个字典序更大的排列。

**原地修改**: 必须在原数组上进行修改，**不能分配额外的数组空间**（除了常数级别的额外空间）。

**特殊情况**: 如果数组已经是最大的排列（即降序排列），则需要将其重新排列为最小的排列（即升序排列）。

#### 实例

- `[1, 2, 3]` → `[1, 3, 2]`
- `[3, 2, 1]` → `[1, 2, 3]`
- `[1, 1, 5]` → `[1, 5, 1]`
- `[1, 5, 8, 4, 7, 6, 5, 3, 1]` -> `[1, 5, 8, 5, 1, 3, 4, 6, 7]`

#### 问题的本质和分析 - 寻找比当前数字大的下一个数字

#####问题的本质 - 降序排列是最大的数字

这个问题的本质是寻找给定数字序列在所有可能的全排列中的“下一个”序列，这里的“下一个”是按照**字典序 (Lexicographical Order)** 来定义的。

想象一下查字典的过程：`apple` 的下一个是 `apply`。我们希望做出**尽可能小的改变**，来得到一个比当前“单词”更大的“单词”。

为了让改变尽可能小，我们应该从**右向左**看。

以 `[1, 5, 8, 4, 7, 6, 5, 3, 1]` 为例：

- 我们希望找到一个比它大的数。

- 如果只改变最右边的 `1`，无法变得更大。

- 如果只改变 `3, 1`，`[1, 3]`已经是最大排列，无法变得更大。

- 同样，`[5, 3, 1]`, `[6, 5, 3, 1]`, `[7, 6, 5, 3, 1]` 它们各自都已经是**降序排列**，是其元素能组成的**最大排列**。

- 当我们看到 `4` 时，情况发生了变化。后缀 `[7, 6, 5, 3, 1]` 是降序的，但 `4` 小于 `7`。

  这意味着，我们可以通过改变 `4` 以及它右边的数字，来得到一个更大的排列。

##### 问题分析 - 通过交换获得一个更大的数字

###### **如何得到一个更大的数？** 

我们需要将一个“小数”和一个“大数”交换。

###### 如何让增幅近可能的小？

选择最靠右的那个“小数”来进行交换。

**找到最右侧的较小数**

这个“小数”的特征是，它**右边的数字序列是降序**的。

例如，在 `...4, 7, 6, 5...` 中，`4` 就是我们要找的那个“小数”。

**交换过程**

将这个“小数”与它右边序列中，**比它大的数中“最小”的那个“大数”进行交换**。

- 数字应当比当前数字大
- 应该是最小的比当前数字大的数

在 `4` 右边的 `[7, 6, 5, 3, 1]` 中，比 `4` 大的数有 `7, 6, 5`，其中最小的是 `5`。

###### 交换后如何保证是“下一个”排列？

- 当我们把 `4` 和 `5` 交换后，序列变为 `[1, 5, 8, 5, 7, 6, 4, 3, 1]`。
- 此时，前缀 `[1, 5, 8, 5]` 已经确定了。为了得到字典序中紧邻的下一个排列，我们需要让后缀 `[7, 6, 4, 3, 1]` 尽可能小。
- 如何让一个序列最小？将其变为升序排列。
- 一个重要的观察是：在我们找到“小数” `4` 之前，它右边的序列 `[7, 6, 5, 3, 1]` 本身就是**降序**的。当我们用 `5` 替换了 `4`，并将 `4` 放入后缀后，新的后缀 `[7, 6, 4, 3, 1]` 仍然是**降序**的。
- 将一个降序的序列变为升序，只需要将其**翻转 (Reverse)** 即可。

#### 模式匹配 - 没什么鸟模式可以匹配

这一类观察类的题目是挺讨厌的，临场发挥能观察到这种规律是很难的

这个问题属于**数组操作**和**构造性算法 (Constructive Algorithm)**。

它不遵循典型的 DP、BFS、DFS 等模式，而是基于对字典序排列规律的观察和逻辑推导。

其核心模式是：**从右向左寻找第一个破坏降序的拐点，然后与右侧序列中合适的元素交换，最后将右侧序列整理成最小的排列。**

这个模式在处理与排列、组合相关的“下一个”或“上一个”问题时非常有用，例如 LeetCode 60. Permutation Sequence。

#### 核心思想和套路

##### **找拐点 (Find Pivot)** -找到第一个破坏递减的元素

从右向左遍历数组，找到第一个 `nums[i] < nums[i+1]` 的元素。这个 `nums[i]` 就是我们要操作的“小数”，我们称之为 `pivot`。`i` 就是它的索引。如果找不到这样的 `i`（即整个数组是降序的），说明这已是最大排列。

#####**找交换点并交换 (Find Swap Target and Swap)**

再次从右向左遍历数组（从末尾到 `i+1`），找到第一个 `nums[j] > nums[i]` 的元素。

这个 `nums[j]` 就是我们要用来和 `pivot` 交换的“大数”。

找到后，交换 `nums[i]` 和 `nums[j]`。

##### **翻转后缀 (Reverse Suffix)** - 为啥？

将索引 `i+1` 到数组末尾的这部分子数组进行翻转。

这能保证交换后的后缀是最小的排列。

#### 实现原理和步骤

我们用 `nums = [1, 5, 8, 4, 7, 6, 5, 3, 1]` 来完整走一遍流程。

**数组**: `[1, 5, 8, 4, 7, 6, 5, 3, 1]` **长度 n**: 9

**步骤 1: 找拐点 `i`**

- 从 `i = n-2 = 7` 开始向前找。
- `i=7`: `nums[7]=3`, `nums[8]=1`。`3 > 1`，不满足 `nums[i] < nums[i+1]`。继续。
- `i=6`: `nums[6]=5`, `nums[7]=3`。`5 > 3`，不满足。继续。
- `i=5`: `nums[5]=6`, `nums[6]=5`。`6 > 5`，不满足。继续。
- `i=4`: `nums[4]=7`, `nums[5]=6`。`7 > 6`，不满足。继续。
- `i=3`: `nums[3]=4`, `nums[4]=7`。`4 < 7`，满足条件！
- 我们找到了**拐点 `i = 3`**，对应的值是 `4`。

**步骤 2: 找交换点 `j` 并交换**

- 从 `j = n-1 = 8` 开始向前找，直到 `i+1`。
- `j=8`: `nums[8]=1`。`1 > nums[i]=4` 不成立。继续。
- `j=7`: `nums[7]=3`。`3 > 4` 不成立。继续。
- `j=6`: `nums[6]=5`。`5 > 4` 成立！
- 我们找到了**交换点 `j = 6`**，对应的值是 `5`。
- **交换** `nums[i]` 和 `nums[j]` (即 `nums[3]` 和 `nums[6]`)。
- 交换前: `[1, 5, 8, **4**, 7, 6, **5**, 3, 1]`
- 交换后: `[1, 5, 8, **5**, 7, 6, **4**, 3, 1]`

**步骤 3: 翻转后缀**

- 翻转从索引 `i+1 = 4` 到结尾的子数组。
- 需要翻转的子数组是 `[7, 6, 4, 3, 1]`。
- 翻转后变为 `[1, 3, 4, 6, 7]`。
- 将这部分放回原数组，得到最终结果:
- `[1, 5, 8, 5, 1, 3, 4, 6, 7]`

**特殊情况处理**: 如果 `nums = [3, 2, 1]`，在步骤1中，`i` 会一直递减到 `-1` 都找不到拐点。这时，我们直接进入步骤3（可以认为 `i=-1`），翻转整个数组（从 `i+1=0` 到结尾），得到 `[1, 2, 3]`。

#### 代码实现

```java
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length <= 1){
            return;
        }
        //寻找拐点元素
        //nums[i] < nums[i+1]
        int n = nums.length;
        int i = n-2;
        
        while(i >= 0 && nums[i] >= nums[i+1]){
            i--;
        }
        // 如果找到了这样的 i (即 i 不是 -1)
        if(i >= 0){
            int j = n - 1;
            while(j > i && nums[j] <= nums[i]){
                j--;
            }
            swap(nums, i, j);
        }
        // 步骤 3: 翻转从 i+1 到末尾的子数组
        // 如果 i 是 -1 (整个数组降序)，这将翻转整个数组
        reverse(nums, i+1, n-1);
    }

    private void swap(int[] nums, int i , int j ){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    private void reverse(int[] nums, int start, int end){
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }
```

#### 注意事项

**边界条件**: `i` 的循环条件是 `i >= 0`，`j` 的循环条件是 `j > i`。这些边界要非常小心，避免数组越界。

**原地操作**: `swap` 和 `reverse` 辅助函数都是原地操作，满足题目要求。

**处理降序数组**: 算法能自然地处理完全降序的数组。此时，`while` 循环结束后 `i` 会是 `-1`。`if (i >= 0)` 条件不满足，直接执行 `reverse(nums, 0, n - 1)`，将整个数组翻转，得到正确结果。

**重复数字**: 这个算法对含有重复数字的数组同样有效。因为比较用的是 `>=` 和 `<=`，这保证了我们找到的是正确的“拐点”和“交换点”，不会因为重复数字而出错。

#### 经验总结

1. **直观理解是关键**: 不要死记硬背代码。理解“从右边开始，做最小的改动以形成一个更大的数”这个核心思想，算法步骤就会自然而然地推导出来。
2. **化繁为简**: 这个问题可以分解为三个清晰的子问题：找拐点、找交换点、翻转后缀。将复杂问题分解是解决算法题的有效策略。
3. **辅助函数**: 将 `swap` 和 `reverse` 提取为辅助函数，能让主逻辑 `nextPermutation` 更加清晰、易读，也更容易调试。
4. **举例推演**: 对于这类构造性算法，拿一个稍微复杂一点的例子（比如 `[1, 5, 8, 4, 7, 6, 5, 3, 1]`）在纸上完整地走一遍流程，是检验自己思路是否正确的最佳方法。同时也要考虑 `[3, 2, 1]` 和 `[1, 2, 3]` 这样的边缘情况。
5. **代码的健壮性**: 代码中的 `while` 循环条件 (`>=`, `<=`) 的选择非常精妙，确保了即使有重复元素也能正确工作。这是高质量代码的体现。





### Leetcode 60: 排列序列 - 第K个排列

#### 问题要点

给定两个整数 `n` 和 `k`。 你需要返回集合 `[1, 2, 3, ..., n]` 的所有排列中，按字典序排列后的第 `k` 个排列。

例如：`n = 3`, `k = 3` 所有排列如下：

1. "123"
2. "132"
3. "213"
4. "231"
5. "312"
6. "321"

第 3 个是 "213"，所以返回 "213"。

#### 问题的本质和分析 - 构造问题而非回溯问题

##### 直观的方法：回溯并返回第K个排列

最直观的想法是使用回溯法（DFS）来生成所有 $n!$ 个排列，存入一个列表，然后返回第 `k-1` 个（0-indexed）元素。

##### 为什么回溯方法不行？

题目的约束是 $1 \le n \le 9$。当 $n=9$ 时，$n! = 9! = 362,880$。

生成这么多字符串，然后排序（或者按顺序生成），在时间和空间上都是一个巨大的开销，很容易导致 TLE (Time Limit Exceeded) 或 MLE (Memory Limit Exceeded)。

##### 问题的本质 - 构造而非搜索问题

这不是一个“搜索”问题，而是一个“构造”问题。我们不需要生成 $k$ 之前的所有排列，我们应该能够通过数学计算，*直接定位*并*构造*出第 $k$ 个排列的每一位数字。

#### 规律观察

##### 以第一个数字开头的排列数有多少？

我们以 n = 4, k = 17 为例来寻找规律。

集合为 [1, 2, 3, 4]。总排列数为 $4! = 24$。

我们来观察这些排列的**首位数字**：

- 以 '1' 开头的排列：
  - `1, [2, 3, 4 的排列]`
  - 总共有多少个？有 $(4-1)! = 3! = 6$ 个。
  - (这是第 1 到第 6 个排列)
- 以 '2' 开头的排列：
  - `2, [1, 3, 4 的排列]`
  - 总共有多少个？有 $(4-1)! = 3! = 6$ 个。
  - (这是第 7 到第 12 个排列)
- 以 '3' 开头的排列：
  - `3, [1, 2, 4 的排列]`
  - 总共有多少个？有 $(4-1)! = 3! = 6$ 个。
  - (这是第 13 到第 18 个排列)
- 以 '4' 开头的排列：
  - `4, [1, 2, 3 的排列]`
  - 总共有多少个？有 $(4-1)! = 3! = 6$ 个。
  - (这是第 19 到第 24 个排列)

推导第一位：

我们要找第 $k=17$ 个。

$k=17$ 落在了 "以 '3' 开头" 的区间（即第 13 到 18 个）中。

##### 如何推导第一位数字？

###### 如何使用数学公式定位？

为了方便计算，我们先将 $k$ 转换为 0-based 索引：$k = k - 1 = 16$。 

我们称每个块的大小为 `blockSize = (n-1)! = 6`。 

我们用 $k$ 去除以 `blockSize`： `index = k / blockSize = 16 / 6 = 2`



这个 `index = 2` 是什么意思？ 

它告诉我们，应该在**当前可用**的数字列表 `[1, 2, 3, 4]` 中，选择**索引**为 2 的那个数字。

 `numbers = [1, 2, 3, 4]` `numbers[2]` 就是 '3'。 

**所以，我们确定了第一位是 '3'。**

##### 如何推导第二位数字？

我们已经使用了 '3'。 现在的问题变成了：在剩下的 `[1, 2, 4]` 这 3 个数字中，找出 "第 $k'$ 个" 排列。

 $k'$ 是多少？ $k=16$ 告诉我们，在所有 $4!$ 个排列中，我们找的是第 16 个（0-indexed）。

 我们跳过了 `index = 2` 个完整的块，也就是 $2 \times 6 = 12$ 个排列（以 '1' 开头的 6 个和以 '2' 开头的 6 个）。 

所以，我们要在 "以 '3' 开头" 的子问题中，寻找第 $k' = k \% \text{blockSize} = 16 \% 6 = 4$ 个排列（0-indexed）。

**子问题：** `n = 3`, `k = 4` (0-indexed), 可用数字 `[1, 2, 4]`。

- 新的 `blockSize = (3-1)! = 2! = 2`。
- `index = k / blockSize = 4 / 2 = 2`。
- 在**当前可用**的数字列表 `[1, 2, 4]` 中，选择索引为 2 的那个数字。
- `numbers[2]` 就是 '4'。
- **所以，我们确定了第二位是 '4'。**

##### 如何推导第三位数字？

我们已经使用了 '3' 和 '4'。

可用数字 [1, 2]。

更新 $k$：$k' = k \% \text{blockSize} = 4 \% 2 = 0$。

**子问题：** `n = 2`, `k = 0` (0-indexed), 可用数字 `[1, 2]`。

- 新的 `blockSize = (2-1)! = 1! = 1`。
- `index = k / blockSize = 0 / 1 = 0`。
- 在**当前可用**的数字列表 `[1, 2]` 中，选择索引为 0 的那个数字。
- `numbers[0]` 就是 '1'。
- **所以，我们确定了第三位是 '1'。**

##### 如何推导第4位数字？

我们已经使用了 '3', '4', '1'。

可用数字 [2]。

更新 $k$：$k' = k \% \text{blockSize} = 0 \% 1 = 0$。

**子问题：** `n = 1`, `k = 0` (0-indexed), 可用数字 `[2]`。

- 新的 `blockSize = (1-1)! = 0! = 1`。
- `index = k / blockSize = 0 / 1 = 0`。
- 在**当前可用**的数字列表 `[2]` 中，选择索引为 0 的那个数字。
- `numbers[0]` 就是 '2'。
- **所以，我们确定了第四位是 '2'。**

**最终结果：** "3412"。

我们验证一下： 第 13: "3124" 第 14: "3142" 第 15: "3214" 第 16: "3241" 第 17: "3412" 完全正确。



#### 模式和套路匹配 - 阶乘进制

这个模式叫做 **"阶乘进制" (Factorial Number System)**，或者说是 **"康托展开" (Cantor Expansion) 的逆运算**。

- **康托展开：** 给定一个排列（如 "3412"），计算它是第几个排列。
- **逆康托展开（本题）：** 给定一个 $k$，构造出第 $k$ 个排列。

这个模式的套路是：

1. 预处理阶乘。
2. 维护一个 "当前可用数字" 列表。
3. 通过 $k$ 和 $(n-1)!$ 来确定第一个位置应该选哪个数字。
4. 从 $k$ 中减去跳过的块，更新 $k$。
5. 从可用列表中移除已选数字。
6. 在子问题中重复此过程。

#### 核心思想和套路 (Core Idea and Approach)

我们从左到右，一位一位地确定排列中的数字。

1. **确定第 1 位：**
   - 有 $n$ 个数字可选。
   - 以每个数字开头的排列都有 $(n-1)!$ 个。
   - 我们计算 $k$ 处于第几个 "块"（块大小为 $(n-1)!$）。
   - `index = (k-1) / (n-1)!` (这里 $k$ 是 1-based)
   - 我们就从 `[1, 2, ..., n]` 中选择第 `index` 个数字作为首位。
2. **确定第 2 位（子问题）：**
   - 更新 $k$：$k = (k-1) \% (n-1)! + 1$ (转换回 1-based)。
   - 现在有 $n-1$ 个数字可选。
   - 以每个可用数字开头的排列都有 $(n-2)!$ 个。
   - `index = (k-1) / (n-2)!`
   - 我们从**剩余的**数字中选择第 `index` 个数字作为第二位。
3. **重复此过程：**
   - 直到所有 $n$ 位数字都被确定。

为了编程方便，我们统一使用 0-based 的 $k$ (在开头 `k--`)，这样计算 `index` 和更新 $k$ 会更简洁：

- `index = k / (n-1)!`
- `k = k % (n-1)!`

#### 实现原理和步骤

**预处理阶乘：** 创建一个数组 `factorial`，`factorial[i]` 存储 $i!$。我们只需要到 $(n-1)!$。

**初始化候选列表：** 创建一个 `List` (如 `ArrayList` 或 `LinkedList`)，`numbers`，按顺序存入 `1, 2, ..., n`。

**k 转换：** $k = k - 1$，将其转换为 0-based 索引。

**初始化结果：** `StringBuilder sb = new StringBuilder()`。

**循环构造：** 从 $i = n-1$ 循环到 $0$ (代表剩余 $n$ 位, $n-1$ 位, ..., 1 位)。

- $i = n-1$ (确定第 1 位，块大小 `factorial[n-1] = (n-1)!`)
- $i = n-2$ (确定第 2 位，块大小 `factorial[n-2] = (n-2)!`)
- ...
- $i = 0$ (确定最后 1 位，块大小 `factorial[0] = 0! = 1`)
- 在循环 $i$ 中：
  - `blockSize = factorial[i]`
  - `index = k / blockSize`  (计算当前 $k$ 落在第几个块)
  - `sb.append(numbers.get(index))` (从候选列表中取出该数字)
  - `numbers.remove(index)` (从候选列表中移除，确保不再使用)
  - `k = k % blockSize` (更新 $k$，准备进入子问题)

**返回结果：** `return sb.toString()`。

#### 实现代码

```Java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public String getPermutation(int n, int k) {
        
        // 1. 预处理阶乘数组
        // factorial[i] = i!
        // 只需要 0! 到 (n-1)!
        int[] factorial = new int[n];
        factorial[0] = 1; // 0! = 1
        for (int i = 1; i < n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        // 2. 初始化候选数字列表
        // 使用 ArrayList 足够高效，因为 n <= 9
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            numbers.add(i);
        }

        // 3. 将 k 转换为 0-based 索引
        // 这是本算法最关键的步骤之一
        k--;

        StringBuilder sb = new StringBuilder();

        // 4. 循环构造每一位
        // i 从 n-1 递减到 0, 代表 n 个位置
        // 当 i = n-1 时，我们确定第 1 位，此时块大小是 (n-1)!
        // 当 i = n-2 时，我们确定第 2 位，此时块大小是 (n-2)!
        // ...
        // 当 i = 0 时，我们确定最后 1 位，此时块大小是 0! = 1
        for (int i = n - 1; i >= 0; i--) {
            // 5. 计算当前位的块大小 (i!)
            int blockSize = factorial[i];
            
            // 6. 计算 k 落在第几个块
            int index = k / blockSize;
            
            // 7. 将该块对应的数字追加到结果
            sb.append(numbers.get(index));
            
            // 8. 从候选列表中移除已使用的数字
            numbers.remove(index);
            
            // 9. 更新 k，准备子问题的计算
            k = k % blockSize;
        }

        return sb.toString();
    }
}
```

#### 注意事项

**k的 0-based 转换：** 这是最容易出错的地方。题目给的 $k$ 是 1-based，而我们的数学计算（整除取 index，取模更新 k）是基于 0-based 的。必须在所有计算开始前执行 `k--`。

**阶乘数组的对应：** 确定第 1 位时，有 $n-1$ 个元素待排列，块大小是 $(n-1)!$，对应 `factorial[n-1]`。在我的代码实现中，我使用了 `i` 从 `n-1` 降到 `0`，`factorial[i]` 恰好对应 $i!$，也就是当前剩余元素（`i+1` 个）的全排列的子块大小（`i!`）。

**`numbers.remove(index)` 的效率：** `ArrayList` 的 `remove(index)` 是 $O(N)$ 操作（因为它需要移动后续元素）。由于 $N \le 9$，这个 $O(N)$ 操作非常快。总时间复杂度是 $O(N \times N) = O(N^2)$。这远远优于 $O(N!)$ 的回溯法。

**$0! = 1$：** 在最后一步，当 `i=0` 时，`blockSize = factorial[0] = 1`。此时 $k$ 必然为 $0$。`index = 0 / 1 = 0`。这会正确地取出 `numbers` 列表中仅剩的最后一个元素。

#### 经验总结

**"第 $k$ 个" 问题：** 遇到 "求第 $k$ 个..." 这类问题，通常都不是要你生成所有 $N$ 个元素。解法往往是 $O(k)$、$O(\log N)$ 或是 $O(\text{解的长度})$ 的构造法。

**排列组合的数学本质：** 涉及排列组合的问题，如果 $N$ 稍大（$N > 10$），$O(N!)$ 的回溯法就不可行。此时必须深入思考其数学结构。

**阶乘进制：** "阶乘进制" 是解决排列与排名对应关系的标准工具。本题就是 "排名 $\to$ 排列"（逆康托展开），反过来 "排列 $\to$ 排名"（康托展开）也是一个经典问题，值得一并掌握。

**降维思想：** 我们通过确定一位数，将 $N$ 个数的排列问题，降维成了 $N-1$ 个数的排列问题。这是一种分治思想，但我们通过数学计算，避免了搜索，而是*唯一确定*了每一步的解。