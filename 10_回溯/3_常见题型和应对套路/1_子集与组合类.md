# 子集与组合类

## 问题的概要

其核心是**从一组元素中挑选出若干个元素（0个到N个）**，形成一个新的集合。

回溯法是解决此类问题的“万金油”方法。

**组合类问题可以被认为是子集类问题的一种特列。**

对于子集问题，这个过程被抽象为构建一棵**“决策树”**。

- **问题：** 给定一个集合 `nums`（例如 `[1, 2, 3]`）。
- **决策树：** 对于 `nums` 中的**每一个元素**，你都有两个选择：
  1. **“要”** (include) 这个元素，将其加入当前子集。
  2. **“不要”** (exclude) 这个元素。

回溯法就是遍历这棵决策树的**所有路径**，每一条从根节点到任意节点的路径，都代表一个子集。

## 子集类问题与组合类问题的比较

### 目标和特点比较

| 问题       | 目标                                                         | 特点                                                 |
| ---------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| 子集类问题 | 找出给定集合的**所有**可能的子集（包括空集和集合本身）       | 你需要收集**所有大小** (size 0, 1, 2, 3...) 的子集。 |
| 组合类问题 | 从给定集合（通常是 $1$ 到 $n$）中，找出所有大小为**固定值 $k$** 的子集。 | 你**只**需要收集大小为 $k$ 的子集。                  |

### 在回溯法中的体现

#### 子集类问题 - 解在决策树的每一个节点上

解（即一个合法的子集）在决策树的**每一个节点**上。

所以，我们在 `backtrack` 函数的**最开始**就 `result.add(new ArrayList<>(path));`，

因为每一步递归（无论 `path` 多长）都是一个合法的答案。

#### 组合类问题 - 在特定深度上

解只在决策树的**特定深度（即叶子节点）**上，这个深度就是 $k$。

所以，我们必须在 `backtrack` 函数的开头加上一个**终止条件**：`if (path.size() == k)`，并且**只有在这个条件满足时**才 `result.add(...)`。

### 比较总结

#### 相同点 - 从n个元素中挑选若干个且不关心顺序

两个问题都是在 $n$ 个元素中“挑选”若干个，且**不关心元素的顺序**（`[1, 2]` 和 `[2, 1]` 是一样的）。

它们都使用回溯法，并通过 `startIndex` 来避免重复。

####**不同点：** 对于子集大小的特定要求

- **「子集」**要的是所有 $C(n, 0) + C(n, 1) + ... + C(n, n)$ 的结果；

- 而**「组合」**只要 $C(n, k)$ 这一特定大小的结果。

### 回溯过程 - 决策树的DFS过程

我们之前已经总结过，回溯过程本质上就是对决策树的DFS过程。

#### 状态节点是当前的路径（path）

#### 怎样收集当前状态节点的后继节点列表？

对于子集类或者组合类的过程，我们假设完整的列表是`[1,2,3,4,5]`

那么对于节点`[1,2,3]`来说：

- 它的子节点应该大小为4
- 它的子节点就是`[1,2,3,[4...5中的一个]]`

## 常见的限制与解决方法

### 怎样排除重复的集合？

#### 对元素进行从小到大的排序

```Java
Arrays.sort(nums);
```

#### 跳过重复的元素

```Java
// 5. 核心去重剪枝：
            //    (i > start) 保证了我们是在同一递归层级进行比较。
            //    如果 i == start，说明 nums[i] 是本层第一个被考虑的元素，
            //    即使它和 nums[i-1] 相同（比如 [2, 2] 中的第一个 2），
            //    我们也必须选择它（因为它要和它前面的元素组合）。
            //    
            //    如果 i > start 且 nums[i] == nums[i-1]，
            //    说明 nums[i-1] 刚刚在 "本层" 被跳过了 (即 i-1 对应的分支已回溯完毕)，
            //    为了避免重复（例如 [1, 2a] 和 [1, 2b]），我们必须跳过 nums[i]。
if(i > start && nums[i] == nums[i-1]) continue;
```

- `(i > start)` 保证了我们是在同一递归层级进行比较， 在本层级我们需要遍历的元素是`[start....n-1]`, 本层元素的组成状态应该是`[{当前path},{start...n-1中的一个}]`
- 如果 `i == start`，说明 `nums[i]` 是本层第一个被考虑的元素，即使它和 `nums[i-1]` 相同（比如 [2, 2] 中的第一个 2），我们也必须选择它（因为它要和它前面的元素组合）。
- 如果 `i > start` 且 `nums[i] == nums[i-1]`，说明 `nums[i-1]` 刚刚在 "本层" 被跳过了 (即 i-1 对应的分支已回溯完毕)，

- 为了避免重复（例如 [1, 2a] 和 [1, 2b]），我们必须跳过 `nums[i]`。

### 怎样实现非递减子序列？



### 怎样查找固定大小的子集？

#### 修改递归参数 - 下一层继续从i开始

 最大的区别在于，因为元素可以重复使用，下一层递归**不需要**从 `i + 1` 开始，而是可以**继续从 `i` 开始**。

#### 修改终止条件

解：当 `currentSum == target` 时，收集结果并返回。

剪枝：当 `currentSum > target` 时，此路不通，直接返回 (剪枝)。

##Leetcode 39: 和为target的子集 - 元素可以重复使用

### 实现代码

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> path = new ArrayList<>();
        backtrack(candidates,0,target,path);
        return res;
    }

    private void backtrack(int[] candidates, int start, int target, List<Integer> path){
        if(target == 0){
            res.add(new ArrayList<>(path));
            return;
        }
        if(target < 0){
            return;
        }

        for(int i = start; i < candidates.length; i++){
            path.add(candidates[i]);

            backtrack(candidates,i,target - candidates[i], path);

            path.remove(path.size()-1);
        }
    }
}
```



### 元素可以重复使用

### 元素不可重复使用



## 代码套路模板

```Java
List<List<Integer>> res = new ArrayList<>();

private backtrack(int start, int nums,List<Integer> path){
  //将当前path加入结果，无需终止
  res.add(new ArrayList<>(path));
  
  for (int i= start; i< nums.length; i++){
    path.add(nums[i]);
    
    backtrack(i+1,nums,path);
    
    path.remove(path.size()-1);
  }
}
```

## Leetcode 78: 子集问题

## Leetcode 90: 不重复的子集

### 问题要点

- **输入：** 一个整数数组 `nums`，**可能包含重复元素**。
- **输出：** 该数组所有可能的**不重复**子集（幂集）。
- **约束：** 解集不能包含重复的子集。返回的子集顺序可以是任意的。

**示例：** 输入: `nums = [1, 2, 2]` 输出: `[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]`

### 问题本质和分析

#### 问题本质：不能够产生重复的子集

**问题本质：** 这是一个求幂集（Powerset）的问题。

**核心挑战：** 与 LeetCode 78 (Subsets) 不同，本题的输入 `nums` 包含重复元素。

这导致如果使用常规方法（如标准回溯或迭代），会产生重复的子集。

**示例分析：** 对于 `[1, 2a, 2b]` (我们姑且标记两个2为2a和2b)：

- 常规方法会产生 `[1, 2a]` 和 `[1, 2b]`。
- 在最终结果中，这两个子集都是 `[1, 2]`，属于重复子集，必须去重。

#### 去重策略：排序

 解决这类去重问题的标准起手式是 **排序**。

将 `nums` 排序后，相同的元素会聚集在一起（例如 `[1, 2, 2]`）。

这使得我们可以在迭代或递归时，通过比较 "当前元素" 和 "前一个元素" 是否相等，来实施去重策略。

 将 `nums` 排序后（例如 `[1, 2, 2]`），所有相同的元素都会聚集在一起。

这使得我们可以在递归（回溯）的过程中，通过一个简单的逻辑来 "剪枝"，跳过那些会导致重复结果的分支。

```Java
for(int i = start; i < candidates.length;i++){
  //去重剪枝逻辑
  if(i > start && candidates[i] == candidates[i-1]) continue;
  //其他逻辑
  ...
}
```

### 规律观察

我们通过构建一个 "决策树" 来看待这个问题。 对于排序后的数组 `[1, 2a, 2b]` (标记两个2以便区分)：

####**不排序 `[2a, 1, 2b]`**：

- `[]`
- `[2a]`
- `[2a, 1]`
- `[2a, 1, 2b]` -> `[1, 2, 2]`
- `[2a, 2b]` -> `[2, 2]`
- `[1]`
- `[1, 2b]` -> `[1, 2]`
- `[2b]` -> `[2]`
- `[2a, 1]` 和 `[1, 2b]` 产生了 `[1, 2]`
- `[2a]` 和 `[2b]` 产生了 `[2]`
- **结论：** 不排序，去重逻辑会非常复杂。

####排序 `[1, 2a, 2b]`

```
           [ ]
       /    |    \
 选择1    选择2a    选择2b (X) <--- 关键剪枝点
 / \        |
[1] [1,2a] [2a] | | | [1,2a] [1,2,2] [2a, 2b] | [1,2,2] 
```

#####**观察：**

- 在根节点 `[]` 这一层，我们有三个选择：选 `1` (索引0)，选 `2a` (索引1)，选 `2b` (索引2)。

- 如果我们选择了 `2a` (索引1)，我们会得到 `[2a]` 以及后续的 `[2a, 2b]`。

- 如果我们跳过了 `2a` (索引1)，然后去选择 `2b` (索引2)，我们会得到 `[2b]`。

- **问题：** `[2a]` 和 `[2b]` 是重复的子集 (都是 `[2]`)。

#### 规律 - 去重剪枝

为了防止这种重复，我们规定：当我们即将做 $nums[i]$ 这个选择时，我们已经完成了 $nums[i-1]$ 的分支并且回溯了（即 $nums[i-1]$ 已经不在当前的 `path` 里了）。我们跳过`nums[i]`。

#### 如何实现去重？- 在同一层的选择中实现

在回溯的 `for` 循环中 (**代表同一层的选择**)，我们用 `if (i > start && nums[i] == nums[i-1]) continue;` 来实现。

- `i > start`：这个条件至关重要。它保证了我们是在 "同一层" 做选择。`start` 是上一层递归传下来的起始索引。`i > start` 意味着 `i-1` (即 $nums[i-1]$) 是本轮循环中刚刚被 *跳过* 的元素。
- `nums[i] == nums[i-1]`：当前元素和上一个元素相同。
- **合起来：** 如果我们发现当前元素 $nums[i]$ 和它前一个元素 $nums[i-1]$ 相同，并且我们 *没有* 在路径中包含 $nums[i-1]$ (因为 $i > start$，说明 $i-1$ 那个分支已经回溯结束了)，那么我们必须跳过 $nums[i]$，否则就会产生重复。

### 核心思想和套路

回溯法本质上是深度优先搜索 (DFS)。我们使用一个递归函数 `backtrack`，它维护了 "当前已经构建的路径 `path`" 和 "下一步可以开始选择的索引 `start`"。

1. **排序 (Sort)：** `Arrays.sort(nums)`。这是去重的前提。
2. **回溯函数签名：** `void backtrack(List<List<Integer>> res, List<Integer> path, int[] nums, int start)`
3. **收集结果 (Base Case)：** 在递归函数的 *入口*，立刻将当前路径 `path` 的一个 *拷贝* (snapshot) 加入结果集 `res`。这保证了所有中间路径（即所有子集）都被收集。
   - `res.add(new ArrayList<>(path));`
4. **遍历选择 (Iteration / Choices)：** 从 `start` 索引开始，遍历 `nums` 数组。
   - `for (int i = start; i < nums.length; i++)`
5. **剪枝 (Pruning / De-duplication)：**
   - 这是本题的核心。
   - `if (i > start && nums[i] == nums[i-1]) { continue; }`
   - 这个 `if` 语句保证了在同一递归层级，不会选择重复的元素作为分支的开头。
6. **做选择 (Choose)：**
   - `path.add(nums[i]);`
7. **进入下一层递归 (Explore)：**
   - `backtrack(res, path, nums, i + 1);`
   - **注意：** 传入的是 `i + 1`，不是 `start + 1`。这表示下一层递归可以从 `i` 之后的任意元素开始选择。
8. **撤销选择 (Unchoose / Backtrack)：**
   - `path.remove(path.size() - 1);`
   - 这是回溯的精髓：当 $i$ 循环要进入下一次迭代时（例如从 $i=1$ 到 $i=2$），我们必须将 $i=1$ 时添加的元素移除，恢复到进入 $i=1$ 之前的状态。

### 实现原理和步骤

1. 初始化结果列表 `res`。

2. 对 `nums` 数组进行 **排序**。

3. 调用 `backtrack(res, new ArrayList<>(), nums, 0)` 启动回溯。

4. `backtrack` 函数内部： 

   a.  `res.add(new ArrayList<>(path))`：将当前路径的快照存入结果。 

   b.  `for` 循环从 `start` 开始遍历。 

   c.  `if (i > start && nums[i] == nums[i-1]) continue;`：执行去重剪枝。

   d.  `path.add(nums[i])`：选择 `nums[i]`。 

   e.  `backtrack(res, path, nums, i + 1)`：递归调用，起始索引更新为 `i + 1`。 

   f.  `path.remove(path.size() - 1)`：撤销选择。

5. `for` 循环结束后，递归返回。

6. 主函数返回 `res`。

### 实现代码

```Java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // 1. 排序是回溯去重的关键前提
        Arrays.sort(nums);
        
        // 2. 调用回溯函数
        //    result: 最终结果集
        //    new ArrayList<>(): 当前路径 (path)
        //    nums: 输入数组
        //    0: 起始索引 (start)
        backtrack(result, new ArrayList<>(), nums, 0);
        
        return result;
    }
    
    /**
     * 回溯辅助函数
     * @param res   最终结果集
     * @param path  当前路径（一个子集）
     * @param nums  输入数组
     * @param start 当前递归层级可以开始选择的索引
     */
    private void backtrack(List<List<Integer>> res, List<Integer> path, int[] nums, int start) {
        
        // 3. 收集结果：
        //    在递归的入口处，将当前 path 的快照（深拷贝）加入结果集
        //    这代表了决策树上的每一个节点
        res.add(new ArrayList<>(path));
        
        // 4. 遍历选择列表（从 start 开始）
        for (int i = start; i < nums.length; i++) {
            
            // 5. 核心去重剪枝：
            //    (i > start) 保证了我们是在同一递归层级进行比较。
            //    如果 i == start，说明 nums[i] 是本层第一个被考虑的元素，
            //    即使它和 nums[i-1] 相同（比如 [2, 2] 中的第一个 2），
            //    我们也必须选择它（因为它要和它前面的元素组合）。
            //    
            //    如果 i > start 且 nums[i] == nums[i-1]，
            //    说明 nums[i-1] 刚刚在 "本层" 被跳过了 (即 i-1 对应的分支已回溯完毕)，
            //    为了避免重复（例如 [1, 2a] 和 [1, 2b]），我们必须跳过 nums[i]。
            if (i > start && nums[i] == nums[i-1]) {
                continue; 
            }
            
            // 6. 做出选择
            path.add(nums[i]);
            
            // 7. 进入下一层递归（探索）
            //    注意：传入的是 i + 1，不是 start + 1
            //    因为子集中的下一个元素必须在 i 之后
            backtrack(res, path, nums, i + 1);
            
            // 8. 撤销选择（回溯）
            path.remove(path.size() - 1);
        }
    }
}
```

### 注意事项

**必须排序：** `Arrays.sort(nums)` 是算法正确的前提。

**剪枝条件 `i > start`：** 这是最容易出错的地方。必须是 `i > start` 而不是 `i > 0`。

- `i > 0`：用于 "排列" 问题的去重（如 LeetCode 47. Permutations II），因为它需要检查 `used[i-1]` 状态。
- `i > start`：用于 "组合/子集" 问题的去重（如 LeetCode 40, 90）。它利用了 `start` 索引来定义 "递归层级"。

**递归调用 `i + 1`：** 必须传入 `i + 1`，确保每个元素在子集中只使用一次，并且是按顺序的。

**`res.add(new ArrayList<>(path))`：** 必须添加 `path` 的深拷贝。如果直接 `res.add(path)`，`res` 中所有的引用都会指向同一个 `path` 对象，最终 `res` 中全是空列表。

### 经验总结

- LeetCode 90 是解决 "有重复元素的组合/子集" 问题的标准模板题。

- 解决这类问题的通用范式是：**"先排序 + 回溯 + `i > start` 剪枝"**。

- 回溯法通过 "选择-探索-撤销" 的机制，系统性地遍历了所有可能的解，并通过剪枝排除了无效或重复的解。

## Leetcode 491: 非递减子序列

Given an integer array `nums`, return *all the different possible non-decreasing subsequences of the given array with at least two elements*. You may return the answer in **any order**.

### 核心难点 - 不能够改变原来的顺序

问题的目的是求不同的非递减子序列。

因此我们必须在结果中保持每一个元素的**相对位置**。

在普通的子集或者组合题目中，并无让我们保留原来的元素的相对位置，因此我们可以对数组进行**重排序**。

但是现在我们需要保持每一个元素在结果中的相对位置，因此我们不能够对数组进行重排序。

### 核心套路 - 使用Set去重

我们需要一个结构用于在回溯树的同一个层里面进行去重。

现在我们可以选择的是Set结构定义一个`used`来保存本层**已经选择过**的元素。

同时注意，我们在将元素加入路径的同时将元素加入`used`，但是在从路径中删除元素的时候，不能够也从used中删除元素。

#### 回溯函数的定义：`backtrack(nums,start,path)`

##### 回溯函数的输入参数

- `nums`：即输入的数组
- `start`:表示本层的起始元素
- `path`:当前选中的元素列表，也就是决策树中上一层的状态节点

#### 检查path是否是一个合法结果

这属于标准套路的第一步，判断Path是否是一个合法解。

题目中对于合法的非递减子序列的规定就是大小不能小于2.

因此我们只需要判断path大小是否超过2，如果超过则加入结果集。

#### 定义set保存本层选择过的元素

为什么是本层选择过的元素？

因为只有同一层选择了两个相同元素，才会产生相同的序列。



#### 遍历`[start .. n-1]`

- 检查当前元素是否已经使用过了，如果使用过了，则直接剪枝(`continue`)

- 如果path为空，或者当前元素大于等于path元素的最后一个元素:

  - 将元素加入`path`

  - 将元素标记为`used`

  - 调用该基于该元素的回溯过程

    `backtrack(nums,i+1,path)`

  - 将元素从path中移除

  - **注意不要从used中移除该元素**

### 实现代码

```Java
//列举所有的非递减子序列
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> path = new ArrayList<>();
        backtrack(nums,0,path);
        return res;
    }

    private void backtrack(int[] nums, int start, List<Integer> path){
        if(path.size() >= 2){
            res.add(new ArrayList<>(path));
        }
        Set<Integer> used = new HashSet<>();
        for(int i = start; i < nums.length; i++){
            //这个用法只适用于有序的情况下，无序的情况下应该使用Set
            // if(i > start && nums[i] == nums[i-1]) continue;
            //无序的情况下应该使用used
            if(used.contains(nums[i])) continue;
            if(path.isEmpty() || path.get(path.size() - 1) <= nums[i]){
                path.add(nums[i]);
                used.add(nums[i]);
                backtrack(nums, i+1, path);

                path.remove(path.size() - 1);
            }
        }
    }
}
```

## Leetcode 40: 和为target的不同子集 - 数字不能够重复使用


Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:** The solution set must not contain duplicate combinations.

### 核心注意点 - 需要先排序

我们之前分析过Leetcode 491: 列举所有的非递减子序列。

在这个题目中我们**不能对数组进行重排序**。因此我们采用**Set**来对结果进行去重。

#### 为什么需要先排序？重要的原因是需要方式`[a,b]`和`[b,a]`同时出现

在一个组合中，元素的顺序是无关紧要的。

`[1, 2, 5]` 和 `[1, 5, 2]` 是同一个组合。

 因为我们只关心“选哪些数”，而不关心它们“原来的位置”。

排序后，`[1, 1, 2, 5, 6, 7]` 和 `[7, 1, 5, 2, 6, 1]` 包含的元素是完全一样的，排序不影响我们找出所有可能的组合。

#### 为什么不用 Set？

因为我们排序了！排序后，所有重复的元素都会挨在一起。

我们使用 `if (i > startIndex && nums[i] == nums[i-1])` 这种“剪枝”操作，效率极高（O(1)的判断）。

这个`if`语句的含义是：在当前这一轮选择中（`for`循环），如果你发现当前元素`nums[i]`和它*紧挨着的前一个元素*`nums[i-1]`相同，那说明`nums[i-1]`已经被（或将被）在*同一个`for`循环*中处理过了。

为了避免产生重复的组合分支，我们跳过`nums[i]`。

####如果不排序的情况下使用Set会怎样？

在这种情况下，会产生`[a,b]`和`[b,a]`这种元素相同但是顺序不同的子集。

所以换句话说，排序 + 去重，可以保证**不讲顺序**的情况下，子集的**唯一性**。

#### 非递减子序列问题中为什么可以？- `[a,b]`和`[b,a]`是不同的子序列！

在这个题目中我们**不能对数组进行重排序**。

同时我们需要注意，`[a,b]`和`[b,a]`属于不同的两个结果，所以说它对顺序是有要求的。

因此我们采用**Set**来对结果进行去重。

不排序 + Set去重，可以保证`[a,b]`和`[b,a]`这种结果可以同时出现。

### 实现代码

```Java
//返回和为target的唯一子集列表
//元素不能重复使用
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        //必须排序
        Arrays.sort(candidates);
        List<Integer> path = new ArrayList<>();
        backtrack(candidates,0,target,path);
        return res;
    }

    private void backtrack(int[] candidates, int start, int target, List<Integer> path){
        if(target == 0){
            res.add(new ArrayList<>(path));
            return;
        }

        if(target < 0){
            return;
        }

        // Set<Integer> used = new HashSet<>();

        for(int i = start; i < candidates.length; i++){
            if(i > start && candidates[i] == candidates[i-1]) continue;
            // if(used.contains(candidates[i])) continue;

            path.add(candidates[i]);
            //不能够在没有排序的情况下去重
            //否则会产生[a,b]和[b,a]这种重复的情况
            // used.add(candidates[i]);

            backtrack(candidates,i+1,target - candidates[i], path);

            path.remove(path.size() - 1);
        }
    }
}
```

## Leetcode 216: [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)

Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:

- Only numbers `1` through `9` are used.
- Each number is used **at most once**.

Return *a list of all possible valid combinations*. The list must not contain the same combination twice, and the combinations may be returned in any order.

### 实现代码

```Java
//找出和为n并且大小为k的组合数量
//每一个元素只能使用一次
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        int[] nums = new int[9];
        for(int i = 0; i < 9; i++){
            nums[i] = i+1;
        }
        List<Integer> path = new ArrayList<>();
        backtrack(nums,0,n,k,path);
        return res;
    }

    private void backtrack(int[] nums, int start, int target, int k, List<Integer> path){
        if(target == 0 && path.size() == k){
            res.add(new ArrayList<>(path));
        }
        if(target < 0 || path.size() > k){
            return;
        }

        for(int i = start; i < nums.length; i++){
            path.add(nums[i]);
            backtrack(nums,i+1, target - nums[i], k,path);
            path.remove(path.size() - 1);
        }
    }
}
```

4. 

