# 图类回溯问题

## 核心场景 - 图

问题通常以**邻接表 (Adjacency List)**（如 `List<List<Integer>>` 或 `Map<Integer, List<Integer>>`）或**邻接矩阵 (Adjacency Matrix)**（`int[][]`）的形式给出。图可以是有向的 (Directed) 或无向的 (Undirected)。

## 常见的目标类型

### **寻找所有路径 (Find All Paths)**：

- *目标：* 找出从 `source` 节点到 `target` 节点的所有唯一路径。
- *例子：* LeetCode 797. 所有可能的路径（这是一个有向无环图 DAG，是图回溯的简化版）。

### **寻找存在性/可达性 (Find Existence / Reachability)**：

*目标：* 判断是否**存在**从 `source` 到 `target` 的路径。

*例子：* 这是标准 DFS 的基础应用，回溯是 DFS 的一种。

### **环检测 (Cycle Detection)**：

*目标：* 判断一个图中是否存在环。

*例子：* LeetCode 207. 课程表（判断有向图是否存在环）。

### **图的特定遍历 (Specific Traversal)**：

*目标：* 寻找满足特定约束条件的路径，例如“欧拉路径”（访问所有边）或“哈密顿路径”（访问所有点）。

*例子：* LeetCode 332. 重新安排行程（寻找欧拉路径）。

### **图着色问题 (Graph Coloring)**：

- *目标：* 尝试用 K 种颜色为图的节点着色，使得相邻节点颜色不同。
- *例子：* LeetCode 785. 判断二分图（即 2-着色问题）。

## 核心思想和套路 - DFS回溯过程

### 核心思想： 选择 - 标记 - 探索 - 撤销标记

#### 选择：访问节点并加入路径

- 访问一个节点`node`
- 将其加入当前路径`path`

#### 标记：将节点标记为已访问

- **这是图回溯的核心！**
- 为了防止在环中（例如 A -> B -> A -> B ...）无限循环，必须在“选择”一个节点后，立刻将其**标记为“已访问”**。
- `visited.add(node)` 或 `visited[node] = true`。

#### 探索： 遍历所有邻居节点

遍历当前节点 `node` 的所有**邻居 (Neighbors)**。

```Java
for (int neighbor : adj.get(node))
```

**在探索前剪枝：** `if (!visited.contains(neighbor))`

递归调用：`backtrack(neighbor, ...)`

#### 撤销标记： 撤销已访问标记

- **这是图回溯最精妙的地方！**

- 当 `backtrack(neighbor, ...)` 的递归调用返回后，意味着从 `neighbor` 出发的所有可能性都探索完了。
- 此时，**必须撤销“标记”**：`visited.remove(node)` 或 `visited[node] = false`。
- 同时，也要撤销“选择”：`path.remove(path.size() - 1)`。

### 为什么必须撤销 `visited` 标记？

**场景：** 寻找从 A 到 D 的**所有**路径。

**图：** A -> B -> D, A -> C -> B -> D

**过程：**

1. 你探索了路径 `A -> B -> D`。此时 `visited` 包含 {A, B, D}。
2. 你回溯到 A。
3. 你尝试探索 A 的下一个邻居 C，即 `A -> C`。
4. 你从 C 探索邻居 B，即 `A -> C -> B`。
5. 此时，如果你**没有**在探索完 `A -> B` 路径后**撤销 B 的 `visited` 标记**，`visited` 仍然包含 {A, B, D}。
6. `if (!visited.contains(B))` 这个判断会失败，导致你无法探索 `A -> C -> B` 这条路，从而丢失 `A -> C -> B -> D` 这个解。

**结论：** 在寻找**所有路径**时，必须撤销 `visited` 标记，以允许其他分支的路径“重复使用”该节点。

## 回溯的要素

| **通用回溯要素**         | **图 (Graph) 的具体映射**                                    |
| ------------------------ | ------------------------------------------------------------ |
| **参数 (Parameters)**    | `(int node, List<Integer> path, Set<Integer> visited)`  `node` 是当前节点，`path` 是从 `source` 到 `node` 的路径，`visited` 是 `path` 中所有节点的集合。 |
| **终止条件 (Base Case)** | **1. 成功：** `if (node == target)`  此时找到一条路径，`results.add(new ArrayList<>(path))`。 |
|                          | **2. 失败（隐式）：**  `for` 循环结束，所有邻居都无法通向 `target`。 |
| **选择列表 (Choices)**   | `adj.get(node)` （当前节点的所有邻居）                       |
| **剪枝 (Pruning)**       | `if (visited.contains(neighbor))`  这是图回溯的**防环/防重**剪枝。 |
| **做出选择 (Choose)**    | `path.add(node);`  `visited.add(node);` （**选择**与**标记**） |
| **撤销选择 (Unchoose)**  | `path.remove(path.size() - 1);`  `visited.remove(node);` （**撤销**与**撤销标记**） |

## 实现原理和步骤（以“寻找所有路径”为例）

**目标：** 找到从 `source` 到 `target` 的所有路径。

###**定义主函数 `allPaths(adj, source, target)`**：

- 初始化 `results = new ArrayList<>()`。
- 初始化 `currentPath = new ArrayList<>()`。
- 初始化 `visited = new HashSet<>()` (或 `boolean[]`)。
- 调用 `backtrack(adj, source, target, currentPath, visited)`。

###**定义递归函数 `backtrack(adj, node, target, path, visited)`**：

####**步骤 1：做出选择并标记 (Choose & Mark)**

- `path.add(node);`
- `visited.add(node);`

####**步骤 2：检查是否满足成功条件**

- `if (node == target)`：
  - `results.add(new ArrayList<>(path));`
  - **（重要）** 找到了解，但不能立即 `return`，因为 `node` 可能还有其他邻居（虽然在 `target` 节点这不太可能，但如果目标是“路径和”，则可能）。我们必须让函数走到最后的“撤销”步骤，以便回溯。
  - **（优化）** 在此 `if` 块中执行“撤销”并 `return` 是一个常见且正确的写法，可以避免多余的 `for` 循环。
  - *我们先按标准模板走：*

####**步骤 3：探索（遍历选择列表） (Explore)**

- `for (int neighbor : adj.get(node))`：

####**步骤 4：剪枝 (Pruning)**

  - `if (!visited.contains(neighbor))`：

####**步骤 5：递归 (Recurse)**

    - `backtrack(adj, neighbor, target, path, visited);`

####**步骤 6：撤销选择和标记 (Unchoose / Backtrack)**

- （当 `for` 循环结束，`node` 的所有邻居都探索完毕后）
- `path.remove(path.size() - 1);`
- `visited.remove(node);`

## 代码套路模板

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<Integer> path = new ArrayList<>();
        int n = graph.length;
        boolean[] visited = new boolean[n];
        backtrack(graph, 0, path, visited);
        return res;
    }

    private void backtrack(int[][] graph, int curr, List<Integer> path, boolean[] visited){
        int n = graph.length;
        if(curr >= n){
            return;
        }

        path.add(curr);
        visited[curr] = true;
        if(curr == n - 1){
            res.add(new ArrayList<>(path));
          //注意同样不可以返回
          //即使是最后一个节点，也需要后面的回溯机制确保恢复现场
        }

        int[] nexts = graph[curr];
        for(int next : nexts){
            if(visited[next]) continue;

            backtrack(graph, next, path, visited);
        }

        path.remove(path.size() - 1);
        visited[curr] = false;
    }


}
```

## LeetCode 797. 所有可能的路径 (All Paths From Source to Target)

//见上述解析

## LeetCode 785. 判断二分图 (Is Graph Bipartite?)

### 问题要点

1. **输入**: 一个无向图，以邻接表的形式 `int[][] graph` 给出。`graph[i]` 是一个数组，包含了所有与节点 `i` 相邻的节点。
2. **输出**: `boolean` 值。判断这个图是否为「二分图」。
3. **二分图定义**: 一个图是二分图，当且仅当我们可以将图中的所有顶点划分到两个**不相交**且**独立**的集合 $U$ 和 $V$ 中，使得图中的每条边 `(u, v)` 都连接一个 $U$ 中的顶点和 $V$ 中的顶点。
4. **图的特性**:
   - 图是无向的。
   - 图可能是不连通的（即包含多个独立的连通分量）。

### 问题的本质和分析 - 是否是一个二分图？

「二分图」有一个等价的定义：**一个图是二分图，当且仅当它不包含任何奇数长度的环（Odd-length cycles）**。

但更直观、更适合算法实现的是「**二分图着色**」定义： **一个图是二分图，当且仅当我们可以用两种颜色（例如，颜色 1 和 颜色 -1）来为图中的所有顶点着色，使得任意一条边的两个端点都具有不同的颜色。**

如果我们在着色过程中，发现一个节点（例如节点 $X$）既需要被染成颜色 1（因为它与一个颜色 -1 的节点相邻），又需要被染成颜色 -1（因为它与一个颜色 1 的节点相邻），那么就产生了**冲突**。这种冲突的发生，等价于我们找到了一个奇数环。

因此，问题的本质转变为了：**尝试对图进行二着色，看是否会发生冲突。**

### 规律观察

####**颜色的传播性**:

 如果我们给图中的任意一个节点 $u$ 染上“颜色 1”，那么这个决策会**强制**它所有的邻居节点 $v_1, v_2, ...$ 都必须被染上“颜色 -1”。

#### **强制的连锁反应**: 

接着，这些“颜色 -1”的邻居节点，又会**强制**它们各自的邻居（$u$ 的“邻居的邻居”）必须被染上“颜色 1”。

#### **冲突的产生**: 

这种颜色的强制传播会持续下去。如果在传播过程中，我们遇到了一个已经被染色的节点，我们就必须检查它的颜色是否符合我们的“强制”要求。

- 如果要求给节点 $X$ 染“颜色 1”，但它已经被染成了“颜色 -1”，这是没问题的（它可能是从另一条路径被染色的）。
- 如果要求给节点 $X$ 染“颜色 1”，但它已经被染成了“颜色 1”，这就**产生了冲突**。

#### **不连通图**: 

如果图有多个连通分量，一个分量的着色决策不会影响另一个分量。因此，我们必须对每个尚未访问（着色）的连通分量都独立地进行一次二着色尝试。

### 模式套路匹配 - 图的着色问题

这个“着色”并“检查冲突”的过程，完美地匹配了**图的遍历算法**。

- 我们可以从一个节点出发，探索它的邻居，再探索邻居的邻居……
- 这个“探索”的过程，就是**深度优先搜索 (DFS)** 或**广度优先搜索 (BFS)**。

题目要求使用「回溯算法」，而 **DFS 本身就是回溯算法的一种典型应用**。

在 DFS 中，我们沿着一条路径深入，这个过程就是“做选择”（给节点染色）；

当遇到冲突时，我们返回 `false`（即“回溯”并报告失败）；

如果一条路径走到底没有冲突，我们就退回上一层（这也是“回溯”）去探索其他路径。

因此，我们匹配的模式是：**图的 DFS 遍历 + 状态记录（染色）**。



### 核心思想和套路：DFS

####**状态**:  `colors` 数组来记录每个节点的状态

- `colors[i] = 0`: 节点 $i$ 尚未被访问（未染色）。
- `colors[i] = 1`: 节点 $i$ 被染成“颜色 1”。
- `colors[i] = -1`: 节点 $i$ 被染成“颜色 -1”。（使用 1 和 -1 的好处是，相反的颜色就是 ` -color`）。

#### **回溯函数 (DFS)**: 定义一个 `dfs(int node, int color, ...)` 函数

**含义**: 尝试将 `node` 节点染成 `color` 颜色，并递归地对其所有邻居进行染色。

如果成功（无冲突），返回 `true`；如果发现冲突，返回 `false`。

####**选择 (Choice)**: 给当前节点染色

当 `dfs` 访问 `node` 时，它首先“做出选择”：`colors[node] = color`。

####**探索 (Explore)**: 遍历 `node` 的所有邻居 `neighbor`：

##### 情况 A: `neighbor` 未被染色 (`colors[neighbor] == 0`)

我们必须将其染成相反的颜色 `-color`。

递归调用 `dfs(neighbor, -color, ...)`。

**回溯点**: 如果这个递归调用返回 `false`（表示在更深的探索中发现了冲突），说明当前的着色方案行不通。我们立刻停止探索，并向上一层也返回 `false`。

##### 情况 B: `neighbor` 已被染色 (`colors[neighbor] != 0`)

这是**约束检查**。

我们必须检查 `neighbor` 现在的颜色是否与 `node` 的颜色 *相同*。

如果 `colors[neighbor] == color`，说明两个相邻的节点被染成了同一种颜色，**发生冲突**。立即返回 `false`。

如果 `colors[neighbor] == -color`，说明颜色正确，无冲突，继续检查下一个邻居。

#### 成功：所有邻居都检查通过

 如果所有邻居都检查完毕且没有返回 `false`，说明从 `node` 出发的这个分支是成功的。返回 `true`。

#### **驱动程序**: 

因为图可能**不连通**，我们需要一个主循环来遍历所有节点。

如果节点 $i$ 尚未被染色 (`colors[i] == 0`)，我们就从它开始发起一次新的 DFS（回溯）过程，任意给它一个起始颜色（比如 1）。

如果这次 DFS 返回 `false`，说明这个连通分量无法被二着色，整个图就不是二分图，立即返回 `false`。

### 实现原理和步骤

1. 获取图的节点数 $n$（即 `graph.length`）。

2. 创建一个状态数组 `int[] colors = new int[n]`，Java 中默认初始化为 0（表示未访问）。

3. 遍历所有节点 $i$ (从 0 到 $n-1$)：

   a.  检查 colors[i]。

   b.  如果 colors[i] == 0（表示 $i$ 属于一个新的、尚未访问的连通分量）：

   i.  调用回溯函数 dfs(i, 1, colors, graph)（尝试将 $i$ 染成颜色 1）。

   ii. 如果 dfs 函数返回 false，说明在 $i$ 所属的连通分量中发现了冲突。立即返回 false。

4. 如果循环正常结束（所有连通分量都被成功染色），返回 `true`。

**`dfs(int node, int color, int[] colors, int[][] graph)` 函数的步骤：**

1. **做出选择（染色）**: `colors[node] = color`。

2. **探索邻居**: 遍历 `graph[node]` 中的每一个 `neighbor`。

3. 检查邻居状态:

   a.  未访问 (colors[neighbor] == 0):

   i.  递归调用 dfs(neighbor, -color, colors, graph)。

   ii. 如果递归返回 false，则立即 return false（传播失败信号）。

   b.  已访问 (colors[neighbor] != 0):

   i.  检查是否冲突：if (colors[neighbor] == color)。

   ii. 如果冲突，立即 return false。

   iii. (如果不冲突，即 colors[neighbor] == -color，则什么也不做，继续循环)。

4. **返回结果**: 循环结束后，说明 `node` 节点的所有邻居都已处理且无冲突。`return true`。

### 实现代码

```Java
class Solution {
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        int[] colors = new int[n];
        for(int i = 0; i < n; i++){
            if(colors[i] == 0){
                if(!dfs(graph,i,colors,1)){
                    return false;
                }
            }
        }
        return true;
    }

    private boolean dfs(int[][] graph, int curr, int[] colors, int color){
        colors[curr] = color;
        
        int[] neighbors = graph[curr];
        for(int neighbor : neighbors){
            if(colors[neighbor] == 0){
                // colors[neighbor] = -1 * color;
                if(!dfs(graph, neighbor, colors, -1 * color)){
                    return false;
                }
            }else{
                if(colors[neighbor] == color){
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 注意事项

1. **处理不连通图**: 最重要的一点。必须在主函数 `isBipartite` 中使用 `for` 循环遍历所有节点，并对未访问的节点（`colors[i] == 0`）发起新的 DFS。只从 `node 0` 开始是错误的。
2. **状态设计**: 使用 `0` (未访问), `1` (颜色A), `-1` (颜色B) 是最简洁的。`0` 作为未访问状态非常自然，而 `1` 和 `-1` 互为相反数，方便通过 `-color` 来切换。
3. **回溯的体现**: 在这个特定问题中，“回溯”主要体现在：
   - 通过 `return false` 来传播失败信号，从而“撤销”整个分支的探索。
   - 与N皇后等问题不同，我们**不需要**在 `backtrack` 函数返回 `true` 之前“撤销”我们的选择（即 `colors[node] = 0`）。因为在一个连通分量中，一旦起始颜色确定，所有节点的颜色都是唯一确定的。如果一个方案可行，它就是这个分量唯一的二分图划分方案，无需撤销。

### 经验总结

- **二分图判定 = 2-着色问题**。
- 2-着色问题是**图遍历（DFS/BFS）**的经典应用。
- 使用 DFS（即回溯算法）时，`colors` 数组充当了 `visited` 数组和状态记录的双重角色。
- DFS 检查冲突的核心在于：当遇到一个**已访问**的邻居时，检查它的颜色是否与当前节点的颜色**相同**。
- BFS 也可以解决此问题（使用队列），其思想是逐层染色，检查同一层的节点是否不应该相连。
- 始终牢记处理**不连通图**。

## LeetCode 399. 除法求值 (Evaluate Division)

详细解析见图章节中的DFS套路解析部分。

现在我们在分析使用回溯方法解决问题，这个问题本质上是在使用DFS回溯解决的。

但是我们在之前的实现过程中，并没有看到**回溯三部曲中的撤销部分**。

其实在之前的实现中，它是相当于实现了回溯三部曲的。因为每一个步骤它其实都传入了一个新的`currentSum`变量。

所以`currentSum`变量在这里并没有起到标准回溯中`path`的作用。

### DFS中的回溯三部曲

#### 添加路径和visited

#### 递归调用DFS

#### 撤销路径和visited

### 基于标准回溯的实现代码

现在我们提供一下基于标准的回溯三部曲的实现:

```Java
class Edge{
    String from;
    String to;
    double weight;

    public Edge(String from, String to, double weight){
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
}

class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String,List<Edge>> graph = getGraph(equations, values);
        double[] ans = new double[queries.size()];
      
        for(int i = 0; i < queries.size(); i++){
            List<String> query = queries.get(i);
            String from = query.get(0);
            String to = query.get(1);
            Set<String> visited = new HashSet<>();
            visited.add(from);
            double res = backtrack(graph, from, to, 1d,visited);
            ans[i] = res;
        }

        return ans;
    }

    private double backtrack(Map<String,List<Edge>> graph, String curr, String target, double currentSum, Set<String> visited){
        //如果当前节点不存在，返回-1
        if(!graph.containsKey(curr) || !graph.containsKey(target)){
            return -1.0d;
        }
        //如果已经到达目标节点，返回currentSum
        if(Objects.equals(curr,target)){
            return currentSum;
        }
        //DFS 遍历其邻居节点
        List<Edge> edges = graph.getOrDefault(curr, new ArrayList<>());
        for(Edge edge : edges){
            if(visited.contains(edge.to)) continue;

            double weight = edge.weight;
            String next = edge.to;
            //回溯三部曲
            //回溯，路径添加操作
            currentSum = currentSum * weight;
            visited.add(next);
            //递归调用回溯
            double res = backtrack(graph, next, target, currentSum, visited);
            if(res != -1d){
                return res;
            }

            //回溯路径撤销操作
            visited.remove(next);
            currentSum = currentSum / weight;
        }

        return -1d;

    }

    private Map<String, List<Edge>> getGraph(List<List<String>> equations, double[] values){
        Map<String,List<Edge>> graph = new HashMap<>();
        for(int i = 0; i < equations.size(); i++){
            List<String> list = equations.get(i);
            double val = values[i];
            String from = list.get(0);
            String to = list.get(1);
            Edge edge1 = new Edge(from, to, val);
            graph.computeIfAbsent(from, x -> new ArrayList<>()).add(edge1);

            Edge edge2 = new Edge(to, from, 1.0d/val);
            graph.computeIfAbsent(to, x -> new ArrayList<>()).add(edge2);
            
        }
        return graph;
    }
}
```

## LeetCode 332. 重新安排行程 (Reconstruct Itinerary)

### 问题要点

**输入:** 一张机票列表 `List<List<String>> tickets`，每张机票形如 `[from, to]`。

**输出:** 一个字符串列表 `List<String>`，表示一个完整的行程。

**起点:** 行程必须从 "JFK" 开始。

**核心约束 1:** 必须使用掉*每一张*机票，且*每张*只能使用一次。

**核心约束 2:** 如果存在多种可能的行程，必须返回*字典序最小*的那一个。

**保证:** 至少存在一个有效的行程。

### 问题本质分析 - 欧拉路径

这是一个图论问题。

我们可以将每个机场视为图中的一个**顶点(Vertex)**，每张机票视为一条**有向边(Directed Edge)**。

#### 约束1: 用完所有机票 - 欧拉路径

这个问题要求我们找到一条遍历图中所有*边*一次且仅一次的路径。

这就是图论中的**欧拉路径 (Eulerian Path)**。

#### 约束 2: 字典序最小

这给我们增加了约束。

当我们站在一个机场（顶点），有多个下一站（多条出边）可选择时，我们必须*优先*选择字典序最小的那个机场。

#### 约束3: 必须从指定的顶点出发

路径必须从 "JFK" 顶点开始。

综上，本题的本质是：**在一个有向图中，从 "JFK" 顶点出发，寻找一条经过所有边的、且在选择路径时遵循字典序最小原则的欧拉路径。**

### 规律观察

#### 为什么贪心算法是错误的？

最直观的想法是：在 "JFK"，我有很多选择，比如 "ATL", "SFO"。因为 "ATL" 字典序更小，我就先飞 "ATL"。

这是一种贪心策略。

举个例子，假设有如下机票:

- `JFK -> A`
- `JFK -> B`
- `A -> C`
- `B -> A`

如果我们采用贪心策略：

1. 从 "JFK" 出发。`A` 和 `B` 之间，选 `A` (因为A的字典序小)。

2. 行程：`JFK -> A`。

3. 从 "A" 出发。只有一个选择 `C`。

4. 行程：`JFK -> A -> C`。

5. 我们卡在 `C` 了，但还有一张机票 `B -> A` 和 `JFK -> B` 没用。

   行程失败。

正确的行程应该是：`JFK -> B -> A -> C`。

因此我们进入**死胡同**了。

我们最好的策略是**先找到那个在死胡同尽头的节点**`C`。

**反向构建:** 这启发我们，如果我们能先找到那个 "死胡同" (终点)，然后找到倒数第二个点，以此类推，就能反向构建出整个路径。

### 模式套路匹配

1. **图 (Graph):** 机场和机票是典型的图结构。
2. **深度优先搜索 (DFS):** 寻找一条路径，自然想到 DFS。
3. **欧拉路径 (Eulerian Path):** "遍历所有边" 是欧拉路径的定义。
4. **Hierholzer 算法:** 这是寻找欧拉路径的标准算法。它的核心思想与我们解决 "贪心陷阱" 的需求一致：**深入探索，直到卡住，然后反向构建路径。**
5. **贪心 (Greedy):** "字典序最小" 的要求，可以通过在图的数据结构中（例如使用优先队列）来保证邻居的访问顺序。

### 核心思想和套路 - Hierholzer 算法

我们将使用**后序遍历 (Post-order) 的 DFS** 来实现 Hierholzer 算法的思想。

#### 数据结构的定义

我们需要一个图的邻接表。为了同时满足 "字典序最小" 和 "用完即删" 的需求，`Map<String, PriorityQueue<String>>` 是完美的数据结构。

- `Key (String)`: 出发机场。
- `Value (PriorityQueue<String>)`: 目的地机场。`PriorityQueue` (最小堆) 可以自动保证我们每次取出的都是字典序最小的邻居。

#### 核心DFS遍历逻辑 - 后序遍历

##### 核心思路 - 找到死胡同尽头的节点

我们的核心思想是使用 **后序遍历 (Post-order) 的 DFS** 来实现 Hierholzer 算法。

######**为什么是后序遍历？**

 回想 "贪心陷阱" 例子：`[JFK, B, A, C]`。

 `C` 是路径的终点，`A` 是倒数第二个，`B` 是倒数第三个，`JFK` 是起点。

 Hierholzer 算法的精髓在于：**一个节点（机场）什么时候会被"卡住"（没有更多可用出边）？**

**当它成为路径的终点时。**

算法通过 DFS 不断深入，直到找到一个 "死胡同"（比如 `C`）。

`C` 没有任何出边，所以 `dfs("C")` 会立即返回。

在返回前，我们把它加入*结果*。

然后 `dfs("A")` 返回，我们加入 `A`。然后 `dfs("B")` 返回...

等等，这样路径是 `[C, A, B, JFK]`，是反的。

 我们需要定义一个 **`result` 列表 (使用 `LinkedList`)**。

当我们从 `dfs` 调用中返回，将当前机场**加入到 `result` 列表的\*头部\* (`addFirst()`)**。

##### 详细的演示过程

现在我们有机票： `[["JFK", "MUC"], ["MUC", "LHR"], ["LHR", "SFO"], ["SFO", "SJC"]]`

###### 构建有向图

我们通过上述机票（有向边）构建出如下的图：

**图:** `JFK:[MUC]`, `MUC:[LHR]`, `LHR:[SFO]`, `SFO:[SJC]`, `SJC:[]`

###### 初始化一个结果列表

**`result`:** `[]` (一个 `LinkedList`)

###### 递归和结果加入过程

```
dfs("JFK")
```

1. `JFK` 有邻居 `MUC`。**使用机票 `JFK->MUC`** (从图中移除)。

2. 递归调用 `dfs("MUC")`。

`MUC` 有邻居 `LHR`。**使用机票 `MUC->LHR`**。

3. 递归调用 `dfs("LHR")`。

`LHR` 有邻居 `SFO`。**使用机票 `LHR->SFO`**。

4. 递归调用 `dfs("SFO")`。

`SFO` 有邻居 `SJC`。**使用机票 `SFO->SJC`**。

5. 递归调用 `dfs("SJC")`。

`SJC` 没有邻居。`while` 循环结束。

因为`SJC`没有后续节点了，因此我们在这里将`SJC`插入到结果列表中。

**后序位置：** `result.addFirst("SJC")`。 `result = [SJC]`

现在我们本质上开始了递归过程的**回溯阶段**。

6. `dfs("SJC")` 返回。

`dfs("SFO")` 的循环结束 (没有更多邻居)。

**后序位置：** `result.addFirst("SFO")`。 `result = [SFO, SJC]`

7. `dfs("SFO")` 返回。

`dfs("LHR")` 的循环结束。

**后序位置：** `result.addFirst("LHR")`。 `result = [LHR, SFO, SJC]`

8. `dfs("LHR")` 返回。

`dfs("MUC")` 的循环结束。

**后序位置：** `result.addFirst("MUC")`。 `result = [MUC, LHR, SFO, SJC]`

9. `dfs("MUC")` 返回。

`dfs("JFK")` 的循环结束。

**后序位置：** `result.addFirst("JFK")`。 `result = [JFK, MUC, LHR, SFO, SJC]`

`dfs("JFK")` 返回。

最终结果：`[JFK, MUC, LHR, SFO, SJC]`，完全正确！

#### 如何满足字典序最小？- 优先队列

在第 2 步 `JFK` 有邻居 `MUC`... 如果 `JFK` 有多个邻居，比如 `[ATL, SFO]` 呢？ 

我们只需要确保在选择邻居时，*总是*选择字典序最小的那个。

因此这里的 **最佳数据结构：** `Map<String, PriorityQueue<String>>`

- `Key (String)`: 出发机场。
- `Value (PriorityQueue<String>)`: 目的地机场。`PriorityQueue` (最小堆) 自动保证我们每次 `poll()` 出来的都是字典序最小的邻居。
- `poll()` 操作还自带 "删除" 功能，完美契合了 "机票只能用一次" 的要求。

### 实现原理和步骤

####定义全局变量:构建图以及初始化结果列表

- `Map<String, PriorityQueue<String>> adj`: 邻接表，用于存图。
- `LinkedList<String> result`: 结果列表，用于 O(1) 头部插入。

####**构建图 (主函数 `findItinerary`):**

- 初始化 `adj` (HashMap) 和 `result` (LinkedList)。
- 遍历 `tickets` 列表。
- 对于每张机票 `[from, to]`，使用 `adj.computeIfAbsent(from, k -> new PriorityQueue<>()).add(to);` 来构建图。

####**启动 DFS:**

- 调用 `dfs("JFK")`。

####**`dfs(String airport)` 核心函数:**

获取 `airport` 对应的优先队列（目的地列表）: `PriorityQueue<String> destinations = adj.get(airport);`

#####**循环消耗机票:**

- `while (destinations != null && !destinations.isEmpty())`: (必须检查 `null`，防止机场只有入边没有出边)。
- `String next = destinations.poll();`: 取出并*移除*字典序最小的下一站。
- `dfs(next);`: 递归进入下一站。

#####**后序处理:**将当前站点加入结果列表

- 当 `while` 循环结束（意味着从 `airport` 出发的所有机票都用完了），将 `airport` 加入结果列表的*头部*。
- `result.addFirst(airport);`

####**返回结果:**

- 主函数返回 `result`。

### 实现代码

注意这是一个比较重要的算法，这个算法本质上是沿着所有的边走一遍的路径（没有边可以漏掉）。

```Java
class Solution {
    private LinkedList<String> res = new LinkedList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, PriorityQueue<String>> graph = new HashMap<>();
        for(List<String> ticket : tickets){
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.putIfAbsent(from, new PriorityQueue<>());
            graph.get(from).add(to);
        }
        dfs(graph, "JFK");
        return res;
        
    }
		//后序遍历DFS的方法
    //先加入后序节点，再加入当前节点
    private void dfs(Map<String,PriorityQueue<String>> graph, String curr){
        PriorityQueue<String> neighbors = graph.getOrDefault(curr, new PriorityQueue<>());

        while (!neighbors.isEmpty()) {
            String neighbor = neighbors.poll();
            dfs(graph, neighbor);
        }

        res.addFirst(curr);
    }
}
```

### 注意事项

1. **数据结构选型:** `Map<String, PriorityQueue<String>>` 是本题的关键。`Map` 快速定位出发机场，`PriorityQueue` 保证了字典序和机票的消耗。
2. **`poll()` vs `peek()`:** 必须使用 `poll()`。`poll()` 会移除元素，代表机票被"使用"了。如果使用 `peek()` 或普通迭代，会导致死循环。
3. **`LinkedList.addFirst()`:** 必须使用 `LinkedList` 的 `addFirst()` (O(1) 复杂度)。如果使用 `ArrayList.add(0, ...)`，每次插入都是 O(N) 复杂度，在图很深时会导致 TLE (超时)。
4. **`null` 检查:** `while (destinations != null ...)` 是必要的。如果一个机场是终点站（例如上例中的 "SJC"），它在 `adj` 中没有对应的 `key`，`adj.get("SJC")` 会返回 `null`。
5. **后序位置:** `result.addFirst(airport);` *必须* 放在 `while` 循环*之后*。这是 Hierholzer 算法的核心，确保了路径是反向构建的。

### 经验总结 - 欧拉路径

- "遍历所有边一次且仅一次" 是 **欧拉路径 (Eulerian Path)** 的明确信号。
- 解决欧拉路径问题，**Hierholzer 算法** 是标准套路。
- Hierholzer 算法的标准实现就是 **后序 DFS**：不断深入直到"卡住"，然后将"卡住"的节点（终点）加入结果，并回溯。
- 使用 `LinkedList.addFirst()` 是实现 Hierholzer 算法（反向构建路径）的优雅方式。
- "字典序最小" 的约束，通过在图的邻接表中使用 **`PriorityQueue`** 来巧妙地解决，将贪心选择融合到了图的遍历中。
