# 树类回溯问题

树（尤其是二叉树）的回溯在结构上更简单，因为它的“选择列表”是固定的（左、右子节点），并且由于树的无环特性，我们**通常不需要 `visited` 数组**。

树类回溯的核心，本质上是一种**深度优先搜索 (DFS)**：

- 最常见的形式是**前序遍历 (Pre-order Traversal)**
- 并在其基础上增加了“状态的维护与撤销”

## 常见的场景 - 路径问题

### **核心场景：路径**

 绝大多数树的回溯问题，都是在解决“**路径**”问题。

- **路径定义 1（最常见）：从根节点 (Root) 到 叶子节点 (Leaf)**。
- **路径定义 2：从根节点 (Root) 到 任意节点 (Any Node)**。
- **路径定义 3（较少见）：从任意节点 (Any Node) 到 任意节点 (Any Node)**。（注意：这类问题有时会演变为更复杂的 DFS 或 树形DP，例如 LeetCode 124. Max Path Sum，它已经超出了经典回溯的范畴）。

### 主要目标

#### 寻找所有解 - 找出所有满足特定条件的根到叶的路径

*例子：* LeetCode 113. 路径总和 II（找出所有和为 `targetSum` 的路径）。

*例子：* LeetCode 257. 二叉树的所有路径（找出所有路径并转为字符串）。

#### 寻找存在性 - 判断是否存在一条满足根到叶的路径

*例子：* LeetCode 112. 路径总和（是否存在和为 `targetSum` 的路径）。

#### 寻找特定值： 基于所有“根到叶”路径计算某个特定值

*例子：* LeetCode 129. 求根节点到叶节点数字之和（所有路径代表的数字之和）。

## 核心思想和套路

### 核心思想 - 基于DFS前序的回溯

这个思想在树中被完美地映射到**前序遍历**上：

#### 选择：将当前节点加入路径

- 当我们访问一个节点 `node` 时，我们**“选择”**将它加入到当前的路径 `path` 中。
- 同时，更新我们正在追踪的状态（例如 `currentSum += node.val`）。

#### 探索：基于当前选择向下探索

我们基于当前的选择，继续向下探索。

```Java
backtrack(node.left, ...)
backtrack(node.right, ...)
```

#### 撤销： 将当前节点从路径中删除

**这是最关键的一步。** 当对 `node.left` 和 `node.right` 的“探索”**全部完成**并返回后，意味着所有以 `node` 为起点的*子路径*都已处理完毕。

我们必须**“撤销”**第1步的选择，将 `node` 从 `path` 中移除（例如 `path.remove(path.size() - 1)`），并将状态复原（例如 `currentSum -= node.val`）。

**为什么？** 因为这样才能保证**“退回”**到 `node` 的父节点时，`path` 里的状态是正确的，以便父节点可以去探索它的**另一个**子节点（例如，从左子树退回后，再去探索右子树）。

## 树回溯过程中的要素

| **通用回溯要素**         | **树 (Tree) 的具体映射**                                     |
| ------------------------ | ------------------------------------------------------------ |
| **参数 (Parameters)**    | `(TreeNode node, List<Integer> path, ...)`  `node` 是当前节点，`path` 是从根到 *`node`的父节点* 的路径。 |
| **终止条件 (Base Case)** | **1. 探索到空节点：** `if (node == null) { return; }`  这是递归的真正终点，说明这条路走到底了。 |
|                          | **2. 满足条件的终止（通常在叶子节点）：**  `if (node.left == null && node.right == null)`  此时检查 `path`（加上当前 `node`）是否满足题意。 |
| **选择列表 (Choices)**   | 非常简单且固定：`node.left` 和 `node.right`。                |
| **剪枝 (Pruning)**       | * **隐式剪枝：** `if (node == null) return;` 本身就是剪枝。  * **显式剪枝：** （例如，在求路径和时，如果 `currentSum` 已经超过 `targetSum` 且所有节点值为正，可以提前返回）。 |
| **做出选择 (Choose)**    | `path.add(node.val);`  `currentSum += node.val;`             |
| **撤销选择 (Unchoose)**  | `path.remove(path.size() - 1);`  `currentSum -= node.val;`   |

## 实现原理和步骤：以路径总和II为例子

**目标：** 找到所有从根到叶，总和为 `targetSum` 的路径。

可以看出回溯过长所使用的DFS是**以当前节点为中心的**。

1. 检查节点是否合法，不合法则`return`
2. 将当前节点加入路径
3. 检查当前路径是否构成合法解，如果构成：
   1. 加入解集合
   2. 如果不能path不能继续追加，则`return`
4. 递归调用后继节点的回溯过程
5. 将当前节点中路径中删除。

另外还可以再复习一下，以**以后继节点为中心的DFS**：

1. 检查当前path是否构成合法解，如果构成
   - 则加入解集合
   - 检查path是否能够继续追加，不能则`return`
2. 遍历每一个后继节点
   1. 检查后继节点合法性，不合法则剪枝（`continue`）
   2. 将后继节点加入路径
   3. 递归调用后继节点的回溯过程
   4. 将后继节点从路径中删除

### 定义主函数:`pathSum(root, targetSum)`

- 初始化 `results = new ArrayList<>()` (存放所有满足条件的路径)。
- 初始化 `currentPath = new ArrayList<>()` (存放当前正在探索的路径)。
- 调用 `backtrack(root, targetSum, currentPath, results, 0)`。

###定义回溯函数:`backtrack(node,target,path,currentSum)`

#### 处理终止条件(Base Case): `node == null`

`if (node == null) return;`

#### 做出选择：将当前节点加入路径

- 将当前节点加入路径：`path.add(node.val);`
- 更新当前和：`currentSum += node.val;`

#### 检查是否满足成功条件（叶子节点）

`if (node.left == null && node.right == null)`：

- `if (currentSum == targetSum)`：
  - `results.add(new ArrayList<>(path));` // **必须**加 `path` 的副本
- *（注意：这里不需要 `return`，让函数自然走到最后的“撤销”步骤）*

####**探索 (Explore)**

递归探索左子树：`backtrack(node.left, target, path, results, currentSum);`

递归探索右子树：`backtrack(node.right, target, path, results, currentSum);`

#### 撤销选择 (Unchoose)

（当 `node.left` 和 `node.right` 都探索完毕后，代码会执行到这里）

将当前节点移出路径：`path.remove(path.size() - 1);`

（`currentSum` 不需要撤销，因为它是按值传递的。但如果 `currentSum` 是一个全局变量或引用类型，则也需要在此处撤销）

## 代码套路模板

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root,0,targetSum,path);
        return res;
    }

    private void backtrack(TreeNode node, int currentSum, int targetSum, List<Integer> path){
        if(node == null){
            return;
        }

        path.add(node.val);
        currentSum += node.val;
        if(node.left == null && node.right == null){
            if(currentSum == targetSum){
                res.add(new ArrayList<>(path));
            }
          //注意这里并不需要写一个return
          //否则会影响到后面的回溯恢复过程
          //不论是否找到，在达到叶子节点之后，都应该先撤销再返回
        }

        backtrack(node.left, currentSum,targetSum,path);
        backtrack(node.right, currentSum,targetSum,path);

        path.remove(path.size()-1);
        currentSum -= node.val;
    }
}
```

## LeetCode 113. 路径总和 II (Path Sum II)

- **简介：** 找出所有从根节点到叶子节点路径总和等于 `targetSum` 的路径。
- **考察点：** 最经典、最标准的树回溯模板。完美契合上述代码。

## LeetCode 257. 二叉树的所有路径 (Binary Tree Paths)

**简介：** 返回所有从根节点到叶子节点的路径（以字符串 "->" 连接的形式）。

**考察点：** 模板的变体。你需要维护的是 `String` 或 `StringBuilder` 而不是 `List<Integer>` 和 `currentSum`。

### 实现代码

```Java
class Solution {
    private List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path);
        return res;
    }

    private void backtrack(TreeNode node, List<Integer> path){
        if(node == null){
            return;
        }

        path.add(node.val);
        if(node.left == null && node.right == null){
            String pathStr = path.stream().map(String::valueOf).collect(Collectors.joining("->"));
            res.add(pathStr);
        }

        backtrack(node.left, path);
        backtrack(node.right, path);

        path.remove(path.size()-1);
    }
}
```



## LeetCode 112. 路径总和 (Path Sum)

- **简介：** 判断是否存在一条从根节点到叶子节点的路径，其总和等于 `targetSum`。
- **考察点：** “存在性”问题。可以优化回溯（DFS），使其返回 `boolean`。一旦找到一个解（`return true`），就可以利用 `||` (或) 操作符进行短路，立即终止其他分支的搜索。

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        return backtrack(root, 0, targetSum);
    }

    private boolean backtrack(TreeNode node, int currentSum, int targetSum){
        if(node == null){
            return false;
        }

        currentSum += node.val;
        if(node.left == null && node.right == null){
            if(currentSum == targetSum){
                return true;
            }
        }

        if(backtrack(node.left, currentSum, targetSum) || backtrack(node.right, currentSum, targetSum)){
            return true;
        }

        currentSum -= node.val;

        return false;
    }
}
```



## LeetCode 129. 求根节点到叶节点数字之和 (Sum Root to Leaf Numbers)

**简介：** 每条“根到叶”路径代表一个数字（例如 1->2->3 代表 123）。求所有这些数字的和。

**考察点：** 状态维护的变体。你在“选择”时不再是 `currentSum += val`，而是 `currentNum = currentNum * 10 + node.val`。你需要在回溯时（或者通过参数传递）正确地维护这个 `currentNum`。

```Java
class Solution {
    List<Integer> pathSumList = new ArrayList<>();
    public int sumNumbers(TreeNode root) {
        backtrack(root, 0);
        int sum = 0;
        for(int pathSum : pathSumList){
            sum += pathSum;
        }
        return sum;
    }

    private void backtrack(TreeNode node, int currentSum){
        if(node == null){
            return;
        }
        int prevSum = currentSum;
        currentSum = currentSum*10 + node.val;
        if(node.left == null && node.right == null){
            pathSumList.add(currentSum);
        }

        backtrack(node.left, currentSum);
        backtrack(node.right, currentSum);

        currentSum = prevSum;
    }
}
```



##LeetCode 437. 路径总和 III (Path Sum III)

###问题要点： 不一定经过根节点或者叶子节点

**简介：** 找出路径总和等于 `targetSum` 的路径的数目。

**注意：路径不需要从根节点开始，也不需要在叶子节点结束**，但必须是向下的。

**考察点：** 这是一个高频陷阱题。它**不是**一个简单的回溯。如果你使用标准回溯（从根开始），会漏掉“不从根开始”的路径。

### 核心思想： 前缀和 + 回溯

因为题目中说路径不需要经过根节点，也不需要再叶子节点结束。

也就意味着路径可能是一个**局部路径**，也就是某个**根-叶子路径**中间的一段子路径。

#### 前缀和：记录当前路径的<前缀和 - 前缀路径数量>

需要指出前缀和在这里的功能仅仅记录当前所在的**根-叶**路径，并且其记录的最远节点是**当前节点**。

**换言之，你得需要在回溯过程中，同步在前缀和Map中进行前进和恢复操作**。

### 标准的DFS回溯过程

其回溯过程和上述的标准DFS回溯过程没有差别。

//详细解析见哈希表部分







