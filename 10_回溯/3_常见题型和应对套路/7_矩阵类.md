# 矩阵类回溯问题

## 场景一：找路径 - 约束路径搜索 (Constrained Path Finding)

**场景**：在一个 `char[][]` 或 `int[][]` 网格中。

**约束**：你必须在网格中寻找一条路径，但这条路径有严格限制，最常见的是**“同一个单元格在一条路径中不能被重复访问”**。

**目标**：

1. **（存在性）** 寻找**是否存在**这样一条路径满足特定条件（如：拼成一个单词）。
2. **（全解性）** 寻找**所有**这样一条路径（如：所有访问了全部0的路径）。

### 核心思想和套路：试探 - 标记 - 探索 -撤销标记

这就像在迷宫里探路，但你有一个**严格的规则**：“你不能踏上你**当前**这条路已经走过的格子。”

#### 步骤1: **试探 (Probe)：**

 你站在 `(x, y)`，你面前有四个方向（上/下/左/右）作为你的“选择列表”。

#### 步骤2: **标记 (Mark / Choose)：**

 你选择“向上”走到 `(x-1, y)`。为了遵守规则，你必须立刻在 `visited[x-1][y]` 上做一个**临时标记**，表示“我这条路正走着呢，别回来”。

#### 步骤3: **探索 (Explore)：** 

从 `(x-1, y)` 出发，重复上述过程（递归）。

#### 步骤4: **撤销标记 (Unmark / Unchoose)：** 

这是回溯的精髓。

当你从 `(x-1, y)` 出发的所有后续探索（无论成功还是失败）都已**全部返回**时，你必须**擦除** `visited[x-1][y]` 上的临时标记。

#### **为什么必须撤销？** - 可能会污染其他分支

本质上`visited`记录的是当前路径的访问标记。

如果发现从**当前节点所出发的所有路径**都行不通的时候，也就说明**当前节点是不行**的。

但是有一种可能，就是其他分支经过当前节点的时候，有可能可以。

因此我们得撤销对当前节点的标记，防止干扰其他分支。

因为 `(x, y)` 探“上”失败后，可能要去探“右”到 `(x, y+1)`，而 `(x, y+1)` 这条**新路**可能需要路过 `(x-1, y)`。

如果你不撤销标记，`visited` 数组就会“污染”其他分支的可能性，导致丢解。

#### **核心套路：** `boolean[][] visited`或者原地修改`grid`

使用一个与 `grid` 等大的 `boolean[][] visited` 数组（或原地修改 `grid`），与递归函数**同生共死**。

在递归调用之前“标记”，在递归调用返回之后“撤销”。

###  回溯的要素映射

| **通用回溯要素**         | **矩阵约束路径搜索 (LC 79)**                                 |
| ------------------------ | ------------------------------------------------------------ |
| **参数 (Parameters)**    | `(int x, int y, boolean[][] visited, ...)`  `(x, y)`：当前坐标。 `visited`：**当前路径**的访问记录。 `...`：其他状态，如 `index` (单词索引)。 |
| **终止条件 (成功)**      | 到达目标。例如： `if (index == word.length())`               |
| **终止条件 (失败/剪枝)** | **在递归入口处立即检查**： <br>1. **越界**：`x < 0 || x >= R || ...`  <br>2. **已访问**：`visited[x][y] == true`  <br>3. **约束不符**：`board[x][y] != word.charAt(index)` |
| **选择列表 (Choices)**   | 四个（或八个）方向的邻居： `int[] dx = {0, 0, 1, -1};`  `int[] dy = {1, -1, 0, 0};` |
| **做出选择 (Choose)**    | `visited[x][y] = true;`  （有时也用原地修改：`char c = board[x][y]; board[x][y] = '#';`） |
| **探索 (Explore)**       | `backtrack(next_x, next_y, ...)`                             |
| **撤销选择 (Unchoose)**  | `visited[x][y] = false;`  （或者原地修改对应：`board[x][y] = c;`） |

### 实现原理 - 存在性问题（基于单词搜索）

我们以最经典的**“存在性”**问题（如 LeetCode 79. 单词搜索）为例，其目标是返回 `boolean`。

#### 初始化所需变量

##### **初始化标记数组：**

`boolean[][] visited = new boolean[R][C]`。

##### 以每一个单元格作为起点进行回溯

如果某个单元格遍历成功则返回`true`

`if (backtrack(i, j, ...)) return true;`

循环结束仍未 `true`，则 `return false`。

####DFS回溯过程的设计

#####步骤1: 检查成功的终止条件

如果单词中所有的字符都找到了，返回成功

```Java
if (state 满足成功条件) (例如 index == word.length())

return true;
```

#### 步骤2: 检查失败/剪枝的终止条件

```Java
if (越界 \|\| visited[x][y] \|\| 其他约束不符)
return false;
```

#### 步骤3: 做出选择

`visited[x][y] = true;`

#### 步骤 4：探索 (Explore)

这个步骤的目标是什么呢？

定义 `found = false`。

遍历四个方向（上/下/左/右）：

- `next_x = ...`, `next_y = ...`
- `if (backtrack(next_x, next_y, next_state))`：
  - `found = true;`
  - `break;` // **短路**：一旦找到解，无需再试其他方向

#### 步骤5: 撤销选择

- `visited[x][y] = false;`

- **注意：** 这一步**必须在** `found = true` 之后执行。

  `found` 只是一个局部变量，用于告诉*上一层*调用“我成功了”。

  但 `visited` 标记**必须撤销**，否则会污染到**主函数 `solve`** 中 `(i, j)` 的下一次循环（即另一个起点的尝试）。

#### 步骤6: 返回结果

`return found;`

### 代码套路模板

#### 路径存在性问题 - 以当前节点为中心的DFS访问

注意DFS回溯过程是**以当前节点为中心的DFS回溯**：

#####检查当前节点的合法性

- 是否越界
- 是否与字符串当前字符相同
- 是否已经标记为访问

##### DFS回溯三部曲

在DFS回溯过程中，真正起到**路径**作用的是**`visited`数组**。

###### 将当前节点加入路径（标记为已访问）

###### 递归调用访问每一个邻居节点 - 短路技巧

如果某个邻居节点访问合法，标记为true，然后**短路**（`break`）。

######将当前节点从路径中删除（标记为未访问）

```Java
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;
        boolean[][] visited = new boolean[rows][cols];
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                if(dfs(board, row, col, word, 0, visited)){
                    return true;
                }
            }
        }

        return false;
    }
    private int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    //注意这个DFS的不同之处
    //以当前节点为中心
    //所有的对于当前节点的检查/选择/撤回操作都是在当前轮进行的
    private boolean dfs(char[][] grid,int row, int col, String word, int index,boolean[][] visited){
        //如果已经全部检查成功，返回true
        if(index == word.length()){
            return true;
        }
        //检查当前节点是否符合条件
        int rows = grid.length;
        int cols = grid[0].length;
        //检查一： 当前位置是否越界
        if(row < 0 || row >= rows){
            return false;
        }
        if(col < 0 || col >= cols){
            return false;
        }
        //检查二： 当前位置字符是否和当前字符串字符相等
        if(grid[row][col] != word.charAt(index)){
            //不想等则返回false
            return false;
        }
        //检查三：当前字符是否已经访问过了
        if(visited[row][col]){
            return false;
        }
        //回溯三部曲
        //选择当前节点
        visited[row][col] = true;
        //递归调用
        //尝试在上下左右四个方向中寻找匹配的路径
       
        boolean found = false;
        for(int[] dir: dirs){
            int nextRow = row + dir[0];
            int nextCol = col + dir[1];
            
            if(dfs(grid, nextRow, nextCol, word, index+1, visited)){
                //如果找到了，
                //然后将找到的信息保存下来
                found = true;
                //就停止搜寻过程（break）
                break;
            }
        }
        //撤销对当前节点的标记
        visited[row][col] = false;
        //返回是否已经找到的信息
        return found;
    }
}
```

#### 路径数量问题：Leetcode 980

##### 问题概要

- `m * n`的矩阵
- 1 表示起点
- 2 表示终点
- 0 表示无障碍节点，可以通过
- 1 表示有障碍节点，不可以通过
- 矩阵中只有一个起点和一个终点
- 求可以从起点出发到达终点，并且经过了全部无障碍节点的路径的数量

##### 核心思想和套路

###### 在回溯过程中统计所经过的节点的总数

本质上来说，路径所经过的节点总数 = 起点（1） + 0节点的数量 = 0 节点的数量 + 1。

只要路径能够从起点到达终点，并且经过的节点总数 = 矩阵中0节点的数量 + 1， 那么该路径就是一个合法的解。

```Java
class Solution {
  	//0节点的数量+1
    private int targetCount = 1;
  	//符合条件的路径的数量
    private int resultCount = 0;
  	//当前路径所经历的节点总数 = 起点 + 0 节点的数量
    private int currentCount = 0;
    
    public int uniquePathsIII(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int startRow = 0;
        int startCol = 0;
        //1. 寻找起点
      	//2. 计算0节点的数量
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                 if(grid[row][col] == 1){
                    startRow = row;
                    startCol = col;
                }
                if(grid[row][col] == 0){
                    targetCount += 1;
                }
            }
        }
        boolean[][] visited = new boolean[rows][cols];
        backtrack(grid, startRow, startCol, visited);
        return resultCount;
        
    }
    private int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    private void backtrack(int[][] grid, int row, int col, boolean[][] visited){
        int rows = grid.length;
        int cols = grid[0].length;
        //检查当前节点是否合法
        //是否越界
        if(row < 0 || row >= rows){
            return;
        }
        if(col < 0 || col >= cols){
            return;
        }
        //是否是障碍节点
        if(grid[row][col] == -1){
            return;
        }
				//是否已经访问过了
        if(visited[row][col]){
            return;
        }
       	//检查当前路径是否满足条件
      	//当前节点是否是终点
      	//如果是终点，计算所经历的节点数是否等于0节点的数量 + 1
      	//如果符合，加入结果集
      	//因为已经到达终点，因此无论是否满足条件，都应该返回
        if(grid[row][col] == 2){
            //如果符合条件，加入结果集
            //经历的节点数量 = 0 节点的数量 + 1;
            if(currentCount == targetCount){
                resultCount++;
            }
             //到了终点了，不管是否符合条件都要return
            return;
        }

        //回溯三部曲
        //选择当前节点
        visited[row][col] = true;
        currentCount += 1;
        //递归调用逻辑
        for(int[] dir : dirs){
            int nextRow = row + dir[0];
            int nextCol = col + dir[1];
            backtrack(grid, nextRow, nextCol, visited);
        }
        //撤销标记逻辑
        visited[row][col] = false;
        currentCount -= 1;

    }
}
```

### Leetcode 212 在矩阵中搜索单词 + 多源DFS 

#### 问题要点

**输入**: 一个 `m x n` 的字符网格 `board` 和一个字符串数组 `words` (单词词典)。

**输出**: 一个 `List<String>`，包含所有出现在网格中的、词典里的单词。

**规则**:

- 单词可以由网格中水平或垂直方向上相邻的字母构成。
- 同一个单元格的字母在同一个单词的路径中**不能被重复使用**。
- 一个单词可以从网格的任意位置开始。

**示例:**

- `board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]]`
- `words = ["oath","pea","eat","rain"]`
- **输出**: `["eat", "oath"]`

####本质 - 多起点/多目标的路径查找问题

这是一个**多起点、多目标的路径查找问题**，目标是查找所有 `words` 中存在于 `board` 中的单词路径。

**问题的本质**：如何在一个二维网格中，**同时**、**高效地** 搜索大量具有**公共前缀**的字符串？

这道题是 [LeetCode 79: 单词搜索 I](https://leetcode.com/problems/word-search/) 的加强版。

- **在 "单词搜索 I" 中**，我们只需要在网格中寻找 **一个** 给定的单词。

  我们通常的做法是，从网格的每个单元格出发，进行**深度优先搜索 (DFS) + 回溯**，尝试匹配这个单词。

- **在 "单词搜索 II" 中**，我们需要寻找 **多个** 单词。

特点：

- **搜索空间大**：每个单词都可以从任意位置起始，路径分支**指数**级。
- **目标集合有限**：只关心 words 中的若干个单词，不是所有路径。

##### 直观但是低效的想法 - 对每一个单词进行DFS+回溯

一个最直观但低效的思路是：遍历 `words` 词典中的每一个单词，然后对每个单词都执行一次 "单词搜索 I" （**DFS+回溯**）的算法。

######**为什么这个思路低效？** - 时间复杂度$O(k \times m \times n \times 4^l)$

假设词典里有 `k` 个单词，网格大小为 `m x n`，单词平均长度为 `L`。那么对每个单词进行搜索的时间复杂度约为 $O(m \times n \times 4 ^ L)$。

那么总的时间复杂度将是 $O(k \times m \times n \times 4 ^l)$。

当 `k` 很大时，这个方法会超时 (Time Limit Exceeded, TLE)。

###### 低效的根源 - 大量的重复计算

在于大量的重复计算。

例如，当我们在搜索 "apple" 时，我们探索了路径 `a -> p -> p -> l -> e`。

之后，当我们搜索 "apply" 时，我们又会重复探索路径 `a -> p -> p -> l`。

这些对公共前缀的重复搜索是性能瓶颈。

这个问题的本质指向了一个经典的数据结构，专门用来处理字符串前缀问题——**Trie (前缀树)**。

#### 背景知识

#####多源DFS - 对于每个起点，依次调用 DFS

#####多源BFS - 将每个起点加入初始队列

##### 高效存储和检索字符串集合：前缀树 - Trie

Trie，又称字典树，是一种树形数据结构，用于高效地存储和检索字符串集合中的键。

###### Trie树的结构定义

- 每个节点代表一个字符前缀。

- 根节点代表空字符串。

- 从根节点到任意一个节点的路径，构成了一个字符串前缀。

- 每个节点通常包含一个指向子节点的数组或哈希表（例如，`children[26]` 用于存储 'a'-'z' 的小写字母），以及一个标记来指示该节点是否是一个完整单词的结尾。

```java
class TrieNode {
  char c;
  Map<Character, TrieNode> children;
  boolean isEndOfWord;
  
  public TrieNode(char c){
    this.c = c;
    children = new HashMap<>();
  }
}
```



###### 向Trie树中插入一个单词

```java
public void insert(String word){
  TrieNode node = root;
  for(char c : word.toCharArray()){
    if(node.children.get(c) == null){
      node.children.put(new TrieNode(c));
    }
    node = node.get(c);
  }
  node.isEndOfWord = true;
}
```

###### 判断是否存在某个前缀

```java
public boolean startsWith(String prefix){
  return searchPrefix(prefix) != null;
}
private TreeNode searchPrefix(String prefix){
  TrieNode node = root;
  for (char c : prefix.toCharArray()){
   
    if (node.children.get(c) != null) return null;
    node = node.children.get(c);
  }
  return node;
}
```

###### 查找完整单词

```java
public boolean search (String word){
  return searchPrefix(word) !=null;
}
```

###### Trie树的优势

**前缀共享**: 所有具有相同前缀的单词共享同一条Trie树路径，极大地节省了存储空间。

**高效查询**: 检查一个单词是否存在、或者是否存在以某个前缀开头的单词，时间复杂度为 `O(L)`，其中 `L` 是单词/前缀的长度。

######为什么Trie树适用于本场景？

对于本题，Trie的结构完美地契合了我们的需求：

**当我们在网格上进行DFS时，每走一步，就相当于在Trie树上往下走一个节点**。

如果下一步在Trie树上没有对应的子节点，说明不可能构成任何一个词典里的单词，我们就可以立即停止这条搜索路径（**剪枝**），从而避免了大量无效的搜索。

##### 深度优先搜索 + 回溯

DFS是遍历树或图的经典算法。

在网格问题中，它表现为从一个点出发，沿着一个方向“走到底”，然后再退回来（回溯），尝试其他方向。



**回溯** 是DFS的核心。

为了防止在构建同一个单词时重复使用单元格，我们需要一个机制来**标记**“已访问”的单元格。

在探索完一个路径后，必须**取消标记**，以便其他搜索路径可以再次使用该单元格。

一个常见的技巧是直接修改`board`上的字符（例如，改成一个特殊字符'#'），在回溯时再改回来。

#### 考察点

**数据结构设计**: 能否想到并正确实现 Trie (前缀树) 是解决此题的关键。

**算法组合**: 将 DFS/回溯算法与 Trie 数据结构巧妙地结合起来。

**优化意识**: 能否识别出朴素解法的性能瓶颈，并提出基于剪枝的优化方案。

**代码实现能力**: 编写无误的 DFS、回溯以及 Trie 的插入和遍历逻辑。

**细节处理**:

- 如何避免将同一个单词重复添加到结果列表中。
- 回溯时状态的正确恢复。

#### 模式匹配

##### DFS + 回溯

: 类似于 "岛屿数量"、"单词搜索 I"、"迷宫问题" 等，凡是在二维矩阵上进行路径搜索的题目，通常都会用到DFS和回溯。

##### 多目标搜索优化

当问题从“找一个”变成“找所有”或“找多个”时，通常需要一个**预处理步骤**来构建一个更高效的查找结构。

这里的Trie就是这个结构。

这提示我们，当面对大量查询且查询内容有重叠时，要思考能否构建一个索引或特殊数据结构来加速。



#### 核心思想和应对套路 - 用Trie指导DFS搜索实现高效剪枝

说句大白话，就是先将所有单词加入到Trie树，然后在DFS过程中，将Trie树的**当前父节点** 作为DFS递归函数的传递参数之一。

最重要的一点，Trie树的搜索过程**并非是包装在TrieTree内完成的**，而是在**DFS回溯函数中实现**的，也就是说我们需要在DFS回溯函数过程中直接遍历Trie树中的节点，而不是在通过Trie树暴露的接口来实现。

比如说我们以矩阵中的某个`cell`作为DFS的起点，那么我们的回溯函数定义就应该是:

```Java
public void backtrack(char[][] board, int row, int col, TrieNode parent){
  //....
}
```



##### 将所有单词加载到Trie树中

- 创建一个 Trie 数据结构。

- 遍历 `words` 词典，将所有单词插入到 Trie 中。

- **优化点**: 在Trie的结束节点上，可以直接存储该单词的字符串本身，而不是一个布尔标记。这使得找到单词后能直接添加到结果集。

##### 对每一个格子进行DFS回溯搜索

- 遍历 `board` 网格的每一个单元格 `(i, j)`。

- 将每个单元格作为搜索的起点，调用DFS函数。

##### 基于Trie树的DFS回溯过程

DFS函数 `dfs(board, i, j, trieNode, resultList)` 的每一步都与Trie树的节点移动**同步**。

###### 基于Trie节点状态进行**剪枝 (Pruning)**: 

在DFS中，移动到下一个字符 `c` 之前，先检查**当前 `trieNode` 是否有指向 `c` 的子节点**。

如果没有，说明从当前路径往下走不可能构成词典中的任何单词，立即返回，**终止这条无效的搜索路径**。

###### 处理**找到单词**的情况:

 如果当前的 `trieNode` 自身代表一个单词的结尾 (例如，`trieNode.word != null`)，就将这个单词添加到结果列表中。

###### 如何**避免重复添加**: 

找到一个单词后，立即将其从Trie中“删除”（例如，将 `trieNode.word` 设为 `null`），这样即使网格中有另一条路径能构成同一个单词，也不会被重复添加。

这是比使用 `HashSet` 更高效的去重方法。

######**回溯 (Backtracking)**:

- 标记当前访问的单元格 `(i, j)` (例如 `board[i][j] = '#'`).
- 对 `(i, j)` 的上、下、左、右四个邻居进行递归调用 `dfs`。
- 递归返回后，**恢复**当前单元格的状态 (例如 `board[i][j] = c`)。

#### 实现原理和步骤 

##### 定义TrieNode类

```Java
class TrieNode {
  Map<Character, TrieNode> children;
  String word;
  
  public TrieNode(){
    this.children = new HashMap<>();
    word = null;
  }
}
```

##### 构建Trie树

```Java
class TrieTree{
  TrieNode root;
  
  public TrieTree(){
    root = new TrieNode();
  }
  
  public void insert(String word){
    TrieNode node = root;
    for(char c : word.toCharArray()){
      if(node.children.get(c) == null){
        node.children.put(c,new TrieNode());
      }
    }
    node.word = word;
  }
}
```

##### 实现主函数findWords

- 初始化一个 Trie，并遍历 `words` 数组，将每个单词插入 Trie

- 初始化一个空的 `List<String> result` 用于存放结果。

- 获取 `board` 的行数 `m` 和列数 `n`。

- 使用双层循环遍历所有单元格 `(i, j)` from `(0,0)` to `(m-1, n-1)`。

- 从每个单元格调用 `dfs(board, i, j, trie.root, result)`。

- 返回 `result`。

##### DFS + 回溯实现

###### 边界和剪枝检查

- 如果 `i, j` 超出边界 (`i<0, i>=m, j<0, j>=n`)，返回。

- 如果当前单元格已被访问 (例如 `board[i][j] == '#'`)，返回。

###### Trie路径检查

- 获取当前字符 `c = board[i][j]`。

- 如果 `parentNode.children[c]` 为 `null`，说明Trie中没有这条路径，直接返回 (核心剪枝)。

###### 向下移动

`currentNode = parentNode.children[c]`。

###### 检查是否找到单词

- 如果 `currentNode.word != null`，说明我们找到了一个完整的单词。

- 将 `currentNode.word` 添加到 `result` 列表中。

- 设置 `currentNode.word = null`，防止重复添加。

###### 继续搜索

标记当前单元格为已访问: `board[i][j] = '#'`.

向四个方向递归:

- `dfs(board, i + 1, j, currentNode, result)`
- `dfs(board, i - 1, j, currentNode, result)`
- `dfs(board, i, j + 1, currentNode, result)`
- `dfs(board, i, j - 1, currentNode, result)`

###### 回溯

恢复单元格: `board[i][j] = c`。

#### 实现代码



```java
class Solution {
    class TrieNode {
        Map<Character,TrieNode> children;
        String word;

        public TrieNode(){
            children = new HashMap<>();
            word = null;
        }
    }

    private TrieNode root = new TrieNode();
		
  	
    private void insert(String word){
        TrieNode node = root;
        for(char c : word.toCharArray()){
            if(!node.children.containsKey(c)){
                node.children.put(c, new TrieNode());
            }
            node = node.children.get(c);
        }
        node.word = word;
    }

    List<String> res = new ArrayList<>();
    public List<String> findWords(char[][] board, String[] words) {
        //将所有单词插入到Trie树当中
        for(String word : words){
            insert(word);
        }
        //对board中的每一个字符进行DFS回溯
        int m = board.length;
        int n = board[0].length;
        for(int row = 0; row < m; row++){
            for(int col = 0; col < n; col++){
                dfs(board, row, col, root);
            }
        }
        return res;
    }
	  /**
	  * DFS回溯过程
	  */
    private void dfs(char[][] board, int row, int col, TrieNode prent){
        int m = board.length;
        int n = board[0].length;
        
        if(row < 0 || row >= m){
            return;
        }

        if(col < 0 || col >= n){
            return;
        }

        char c = board[row][col];
        if( c == '#'){
            return;
        }
        TrieNode curr = prent.children.get(c);
        if(curr == null){
            return;
        }
        if(curr.word != null){
            res.add(curr.word);
            curr.word = null;
        }
      //标记现场，为下一层递归准备现场
        board[row][col] = '#';
      //下一层递归调用
        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        for(int[] dir : dirs){
            int nr = row + dir[0];
            int nc = col + dir[1];
            dfs(board, nr, nc, curr);
        }
      //恢复现场
        board[row][col] = c;
    }
}
```

#### 注意事项

- **去重技巧**: 代码中 `currentNode.word = null;` 是一个非常关键的优化。它既能防止结果重复，又能在一定程度上剪枝（如果一个单词是另一个单词的前缀，如"app"和"apple"，找到"app"后，如果不做任何操作，搜索"apple"时还会再次将"app"加入结果，设为null则可避免）。这比用 `HashSet` 存储结果再转为 `List` 要高效。
- **回溯的实现**: 使用特殊字符`'#'`来标记访问过的位置是一种原地修改的常用方法，空间效率高。务必记得在递归调用之后将其恢复，否则会影响从其他单元格出发的搜索。
- **Trie 节点的 `word` 字段**: 将 `String word` 而不是 `boolean isWord` 存储在节点中，可以直接获取单词，省去了从Trie路径反向构造字符串的麻烦。
- **空输入处理**: 在函数开头处理 `board` 或 `words` 为空或null的边界情况，是良好编程习惯。

#### 经验总结

LeetCode 212 是一个综合性很强、质量非常高的题目，是面试中的常客。它完美地展现了如何通过**预处理**和**数据结构**来优化一个复杂的搜索问题。

- **核心启示**: "用空间换时间"。通过构建Trie，我们使用了额外的空间 `O(W)` (W是所有单词的总字符数)，但将搜索的时间复杂度从指数级的暴力搜索，大幅降低到了一个更可接受的水平。
- **思维模式迁移**: 这个 "预处理 + 引导式搜索" 的模式可以应用到很多问题上。当你发现你的算法在对多个目标进行重复的、有重叠的搜索时，就应该停下来思考：是否可以先将这些目标组织成一种特殊的数据结构（如Trie、K-D树、哈希表等），然后再利用这个数据结构来指导和加速你的搜索过程。
- **从 "I" 到 "II"**: LeetCode中很多问题都有 I 和 II 版本。II 版本通常是 I 版本的加强，要求处理多个输入或更复杂的约束。从 I 到 II 的思维跨越，往往是从 "暴力/单次求解" 到 "优化/批量处理" 的过程，这道题就是典范。

### Leetcode 1219: 可以获得最多黄金的路径

**题目简介**：给定一个 `int[][] grid` 代表金矿，找出你**一次**能采集到的最多黄金。你可以从任意非 0 单元格开始，但**不能重复访问**同一个单元格。

**为何最适合回溯**：

- **场景一（约束路径）**：这是一个“最优解”的约束路径问题。约束是“不能重复访问”。
- **“撤销”的必要性**：
  1. **选择**：你走到 `(x, y)`，标记 `visited[x][y] = true`，`currentGold += grid[x][y]`。
  2. **探索**：`maxGold = max(maxGold, backtrack(next_x, next_y, ...))`。
  3. **撤销**：`visited[x][y] = false`。
- **（关键）** 这道题的主函数需要一个 `for` 循环来尝试**所有**非 0 单元格作为**起点**。假设你从 `(i, j)` 出发的路径 `(i, j) -> (i+1, j)` 获得了 50 金。当这个递归完成后，你**必须**撤销 `(i, j)` 和 `(i+1, j)` 的 `visited` 标记，这样主循环才能尝试从 `(i+1, j)` 作为**新起点**出发，寻找可能存在的更优解（如 `(i+1, j) -> (i+2, j) ...`）。

```Java
//给定一个 m x n的矩阵
//每一个格子中有一个数字，表示这个格子中的黄金的数量， 0 表示这个格子是空的
//返回在下列限制下，你能够获得的最大黄金数量
//1. 你到达一个格子时候，就会获得格子里的所有黄金
//2. 你可以从上下左右四个方向移动
//3. 你不能够重复访问同一个格子
//4. 不能够访问空格子
//5. 你可以从任意格子开始，在任意格子结束你的收集活动（但必须不能是空格子）
class Solution {
    //尝试从每一个格子出发做DFS
    //DFS到终点的时候（该格子的没有非空邻居可以访问了），记录其黄金数量
    //比较
    private int res = 0;
    public int getMaximumGold(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                boolean[][] visited = new boolean[rows][cols];
                dfs(grid, row, col, visited, 0);
            }
        }

        return res;
        
    }

    int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};

    private void dfs(int[][] grid, int row, int col, boolean[][] visited, int prevSum){
        int rows = grid.length;
        int cols = grid[0].length;
        if(row < 0 || row >= rows){
            return;
        }
        if(col < 0 || col >= cols){
            return;
        }
        if(visited[row][col]) {
            return;
        }
        if(grid[row][col] == 0){
            return;
        } 

        int currentSum = prevSum + grid[row][col];
        visited[row][col] = true;

        for(int[] dir : dirs){
            int nextRow = row + dir[0];
            int nextCol = col + dir[1];
            dfs(grid, nextRow, nextCol, visited, currentSum);
        }
        res = Math.max(res, currentSum);
        visited[row][col] = false;
    }
}
```

### Leetcode 490: 足球走迷宫

#### 问题要点

1. **输入**：一个 $m \times n$ 的迷宫 `maze` (0 为通路, 1 为墙), 一个起点 `start` 和一个终点 `destination`。
2. **移动规则 (核心)**：球不能一步一步走。它会选择一个方向（上、下、左、右），然后**一直滚动**，直到**撞到墙**或**迷宫边界**才会停下。
3. **目标**：判断球是否能从 `start` 开始，经过一系列滚动，最终**停在** `destination` 位置。
4. **注意**：球只是路过 `destination` 是不行的，它必须**以此为停止点**。

#### 问题的本质和分析 - 图的遍历问题

这个问题的本质是一个**图的遍历 (Graph Traversal)** 问题。

- **图 (Graph)**：这个图是一个“隐式图”。
- **节点 (Nodes)**：图中的节点**不是**迷宫中的每一个格子 `(r, c)`，而是所有球可以**停下**的格子 `(r, c)`（即所有 `maze[r][c] == 0` 的格子）。起点 `start` 是我们的起始节点。
- **边 (Edges)**：两个节点 $A$ 和 $B$ 之间存在一条有向边 $(A \to B)$，当且仅当球可以从 $A$ 点开始，选择一个方向**一次滚动到底**，并最终停在 $B$ 点。

因此，原问题被转换为：**在这个隐式图中，是否存在一条从 `start` 节点到 `destination` 节点的路径？**

这个问题，我们可以使用两种经典的图遍历算法来解决：

1. **深度优先搜索 (DFS)**
2. **广度优先搜索 (BFS)**

#### 规律分析

1. **确定性**：从任何一个停止点 `(r, c)` 出发，向任意一个方向 `dir` 滚动，其最终的停止点是**唯一且确定的**。
2. **`visited` 数组的含义**：我们需要一个 `visited[m][n]` 数组来防止死循环（例如，在一个空旷的矩形区域里来回滚动）。`visited[r][c] = true` 的含义是：“我们**已经从 $(r, c)$ 这个停止点出发**，尝试过向所有四个方向滚动了。

#### 核心思想和套路 - DFS/BFS + 模拟球的滚动

无论是 DFS 还是 BFS，核心思想都是一样的：

#####**状态管理**：

- 使用一个 `Queue<int[]>` (BFS) 或系统调用栈 (DFS) 来存储“接下来要从哪些停止点出发”
- 使用一个 `boolean[][] visited` 来记录“哪些停止点已经被用作过出发点”。

#####**探索过程**：

- 从 `start` 点开始。
- 将其标记为 `visited`。
- (BFS) 将其加入队列。
- (DFS) 对其进行递归。

#####**模拟“滚动” (Roll)**：

- 这是本题**最关键**的子逻辑。
- 当从 `(r, c)` 准备向 `dir` 方向滚动时，你需要一个 `while` 循环：
  - 计算*下一个*位置 `(next_r, next_c)`。
  - `while` ( `(next_r, next_c)` 在边界内 且 `maze[next_r][next_c] == 0` ) {
    - 球没有停止，继续滚动：`r = next_r`, `c = next_c`
    - 更新 `next_r` 和 `next_c`
  - }
- `while` 循环结束后，`(r, c)` 就是球在这个方向上的**最终停止点**。

#####**遍历**：

- 对这个新的停止点 `(r, c)`，检查它是否是 `destination`。
- 如果它不是 `destination` 且**没有被 `visited` 过**，就将其标记为 `visited`，并将其加入队列 (BFS) 或对其进行递归 (DFS)。

#### 实现原理和步骤 - 基于DFS

我们以 **DFS** 为例（这更接近你原始代码的思路），来修正你代码中的问题。

#####**`hasPath` (主函数)**:

- 获取 `m` (rows) 和 `n` (cols)。
- 创建 `boolean[][] visited = new boolean[m][n]`。
- 保存终点 `destRow` 和 `destCol` (你已经做了，但也可以作为参数传递)。
- 调用 `dfs(maze, start[0], start[1], destination, visited)`。

#####**`dfs` (辅助函数)**:

- `boolean dfs(int[][] maze, int r, int c, int[] dest, boolean[][] visited)`

######**终止条件1 (已访问)**：`if (visited[r][c]) { return false; }`

  - *解释*：如果已经从这个点出发探索过了，说明从它出发的所有路径都到不了终点，直接返回 `false` 避免重复和死循环。

######**终止条件2 (到达终点)**：`if (r == dest[0] && c == dest[1]) { return true; }`

  - *解释*：我们当前**停在**了终点上，成功！

######**标记访问**：`visited[r][c] = true;`

  - *解释*：标记我们**正要从 $(r, c)$ 点出发**，尝试所有4个方向。**注意：一旦标记，永不撤销 (不能设回 false)**，因为这是图遍历，不是组合回溯。

######**遍历4个方向**：

  - 定义 `int[][] dirs = {{...}}`。
  - `for (int[] dir : dirs)`:
    - `int nr = r;`
    - `int nc = c;`
    - **模拟滚动 (核心)**：
      - `while` (下一个位置 `(nr + dir[0], nc + dir[1])` 合法且不是墙) {
        - `nr += dir[0];`
        - `nc += dir[1];`
      - }
      - 此时 `(nr, nc)` 是滚动到底的停止点。
    - **递归探索**：
      - `if (dfs(maze, nr, nc, dest, visited)) { return true; }`
      - *解释*：如果从这个新的停止点出发，*能*找到终点，那么整条路就通了，立刻返回 `true`。

######**失败**：如果4个方向都试过了，都无法到达终点，`return false;`。

#### 实现代码

```Java
class Solution {
    int destRow;
    int destCol;
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        int rows = maze.length;
        int cols = maze[0].length;
        destRow = destination[0];
        destCol = destination[1];

        int startRow = start[0];
        int startCol = start[1];

        boolean[][] visited = new boolean[rows][cols];

        return backtrack(maze, startRow, startCol, visited);
    }
    
    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};

    private boolean backtrack(int[][] grid, int row, int col, boolean[][] visited){
        int rows = grid.length;
        int cols = grid[0].length;

        if(row == destRow && col == destCol){
            return true;
        }
        if(visited[row][col]){
            return false;
        }

        visited[row][col] = true;
        //球一一直滚动
        for(int[] dir : dirs){
            int nextRow = row;
            int nextCol = col;
            //这是非常重要的技巧，可以确保NextRow和NextCol是最后一个合法的位置
            //判断nextRow + dir[0]和nextCol + dir[1]是否合法，而不是判断nextRow和nextCol是否合法
            while(nextRow+dir[0] >= 0 
            && nextCol+dir[1] >= 0 
            && nextRow+dir[0] < rows 
            && nextCol + dir[1] < cols
            && grid[nextRow+dir[0]][nextCol+dir[1]] == 0){
                nextRow = nextRow + dir[0];
                nextCol = nextCol + dir[1];
            }

            if(backtrack(grid, nextRow, nextCol, visited)){
                return true;
            }
        }
        // visited[row][col] = false;

        return false;

    }
}
```

#### 注意事项 - 这不是一个回溯问题

#####**最大的陷阱：移动规则**

- 错误：`next_r = r + dir[0]`，然后直接递归。
- 正确：`while(...)` 循环，模拟“滚动到底”。

#####**`visited` 数组的正确使用** - 他妈的这不是回溯题目

- 错误：在 DFS 递归返回后，`visited[r][c] = false;`（这是组合/排列回溯的模板，不适用于图遍历）。
- 正确：一旦 `visited[r][c] = true;`，就**永不修改**。它代表“从 `(r, c)` 出发的节点已被探索”。

#####**`while` 循环的条件**

- 循环条件检查的是**下一个**位置 `(nr + dir[0], ...)`，而不是**当前**位置 `(nr, ...)`。

#####**DFS vs BFS**

- DFS (递归) 代码通常更简洁。
- BFS (队列) 在求**最短路径**（如 LeetCode 505）时是必须的。对于本题（只问是否可达），两者均可。

#### 经验总结

LeetCode 490 是“迷宫”系列问题的基础。它教会我们最重要的一课：**仔细阅读题目中的“移动规则”**。

这个系列（490, 505, 499）的核心区别就在于：

- **LC 490 (The Maze)**: 是否可达？ (DFS / BFS)
- **LC 505 (The Maze II)**: 最短**距离** (BFS + 距离数组 `dist[][]`，类似 Dijkstra)
- **LC 499 (The Maze III)**: 最短距离 + 字典序最小的**路径** (Dijkstra + 优先队列 `PriorityQueue`)

##场景二：填格子 - 约束满足问题 (Constraint Satisfaction - CSP)

### 问题概要

**场景**：在一个 `N*N` 的棋盘上。

**约束**：你需要往棋盘上“放置”物品（如：皇后、数字），且这些物品之间必须满足特定的约束（如：皇后不同行/列/对角线，数独每行/列/宫无重复）。

**目标**：

1. **全解问题 (Find All Solutions)**：
   - *目标：* 找出**所有**能满足约束条件的完整棋盘布局。
   - *例子：* LeetCode 51. N 皇后，LeetCode 52. N 皇后 II（计数）。
2. **存在性问题 (Find Existence)**：
   - *目标：* 找出**任意一个**能满足约束条件的完整布局（或者判断是否存在）。
   - *例子：* LeetCode 37. 解数独。

经典的填充类题目：

**N皇后 (LC 51)**：任意两个皇后不能在同一行、同一列或同一对角线上。

**数独 (LC 37)**：每个 `'1'-'9'` 的数字在每一行、每一列、每一个 3x3 的九宫格中只能出现一次。

### 问题本质和分析

这类问题的本质是经典的**约束满足问题 (Constraint Satisfaction Problem, CSP)**。

- **变量 (Variables)**：就是网格中所有需要填充的**空单元格** `(row, col)`。
- **域 (Domain)**：就是每个单元格**可以尝试填充的值**的集合（例如数独的 `{'1'...'9'}`）。
- **约束 (Constraints)**：就是那些全局规则（例如“行/列/宫无重复”）。

#### 为什么回溯是最适合的？

因为这是一个**决策链**问题。

你在 `(0, 0)` 处填入 '5' 的这个“选择”，会**立即限制** `(0, 1)` 以及 `(1, 0)` 等单元格的“选择域”（它们不能再填 '5'）。

你必须一路探索下去（例如，填完一整行）。

如果在第 5 行时，你发现无论填什么数字都违反了约束（**死胡同**），你就知道你最初在 `(0, 0)` 填 '5' 的这个决策可能是错的。

于是，你**“回溯”**（撤销）到 `(0, 0)`，把它改回 `.`，然后尝试下一个选择，比如 '6'。

**“撤销 (Unchoose)”** 是这个问题的灵魂。

没有撤销，你就只是一个“一次性”的贪心算法，一旦选错就满盘皆输。

### 核心思想 - 逐个推进 - 尝试所有值

#### 推进遍历 - 一行一行的填写

我们定义一个固定的“遍历顺序”来填充棋盘。

最简单的是：**从 `(0, 0)` 到 `(N-1, N-1)`，一行一行地填。**

`backtrack(row, col)` 函数代表“我现在在 `(row, col)`，轮到我填这个格子了”。

#### 选择列表 - 看看可以填入哪些值？

- 在 `(row, col)` 格子，你的“选择列表”**不再是**“上/下/左/右”，而是**“可以填入的值”**。
- 例如，在数独中，`for (char num = '1'; num <= '9'; num++)`。

#### 约束检查 - 填入这个值是否合法？

在 `for` 循环内部，你做的第一件事就是**剪枝**：

`if (!isValid(board, row, col, num))`：如果把 `num` 放在 `(row, col)` 违反了规则（例如，这一行已经有 `num` 了），`continue;` 立即尝试下一个 `num`。

#### 回溯三部曲

当你确认了一个合法的值，现在你的工作就是启动你的**回溯三部曲**。

##### 选择 - 填充当前单元格

`board[row][col] = num;` // 做出一个**试探性**的放置。

（可选）`updateState(row, col, num, true);` // 更新用于 O(1) 检查的 `visited` 数组。

#####**探索 (Explore)：**

- `backtrack(next_row, next_col);` // 基于这个选择，递归地去填**下一个格子**。

#####**撤销 (Unchoose)：**

这是**最关键**的一步。

**无论成功还是失败，你都需要撤销刚才的试探性选择**。

当 `backtrack(next_row, next_col)` **返回**时（无论是成功还是失败），你都**必须**撤销你刚才的“试探性”选择。

`board[row][col] = '.';`

（可选）`updateState(row, col, num, false);` // 恢复 `visited` 数组。

**为什么？** 

因为 `for` 循环还要继续，去尝试 `num + 1` 这个**平行的选择**。

### 实现原理和步骤 - LC 37. 解数独为例

**目标：** `solveSudoku(board)`，返回 `boolean`（“存在性”问题）。

#### 构建和初始化三个快速检查数组

初始化三个状态数组，用于 $O(1)$ 检查约束：

##### 行检查数组：快速检查某个数字是否已经在某行出现

`boolean[][] rows = new boolean[9][10];`

这里`rows[row][num]`表示数字`nums`是否已经出现在`row`行。

##### 列检查数组：快速检查某个数字是否已经在某列出现

`boolean[][] cols = new boolean[9][10];`

这里`cols[col][num]`表示数字`num`是否已经出现在`col`列

##### Box检查数组：某个数字是否已经出现在某个Box

这个检查数组是适用于LC 37的检查，在题目要求中，我们除了需要检查数字是否已经出现在当前行和当前列，我们还需要检查数字是否已经出现在当前的**Box**。

在本题中，矩阵由`9 x 9`的单元格组成，矩阵中的格子由`3 x 3`的单元组成。

那么一个`9 x 9`的矩阵中，有多少个`3 x 3`的盒子呢？

我们得注意吗，它说的是分割之后的，也就是固定分割的，不是动态移动分割的。

就是很简单的将`9 x 9`的矩阵，平均划分成大小是`3 x 3`的格子。

所以说**不要想复杂了**，一共就9个固定的盒子，每一个单元格只属于一个固定的盒子。

我们又怎么识别某个单元格属于哪一个盒子呢？

###### 怎样计算九宫格中有多少盒子？

在一个 9x9 的网格中，计算 3x3 box (也称为“宫”或“块”) 的数量非常简单：

- **行向 (Horizontally):** 9 列可以被分成 $9 \div 3 = 3$ 组 (列 0-2, 列 3-5, 列 6-8)。
- **纵向 (Vertically):** 9 行可以被分成 $9 \div 3 = 3$ 组 (行 0-2, 行 3-5, 行 6-8)。

总的 box 数量就是行向组数乘以纵向组数：

$3 \times 3 = 9$

###### 怎么计算某个单元格属于哪一个盒子？

这个问题可以分两步走，我们现在已经知道，这些盒子本身也是一个二维的矩阵。

按照二维数组的存储算法，它们的索引应该是`boxes[0...2][0...2]`。

现在我们将其转化为一维的方式，我们已经知道，二维索引转化为一维索引的公式：

`oneDIndex = rowIndex * rowSize + col`;

我们可以看到，一维索引的范围是`[0...8]`。



现在按照上面的步骤，我们来计算`[row,col]`的一维box索引：

1. 计算对应的box二维索引：

   - $boxRowIndex = row / 3 $

   - $boxColIndex = col /3$

2. 通过box二维索引计算其一维索引：

   $boxIndex = boxRowIndex \times boxRowSize + boxColIndex$

3. 现在我们已经知道: boxRowSize 是 3.

   我们第1步带入第2步的公式可以得到：

   $boxIndex = row \div 3 \times 3 + col \div 3$

###### Box: 检查数组的定义

`box[boxIndex][num]`表示num是否出现在`box[boxIndex]`中。

这里的`boxIndex`就是`box`的一维索引。

#### 启动填写过程

我们按照之前所说的方法，从`[0,0]`位置开始，尝试使用回溯方法填充整个矩阵。

#####**步骤 1：处理“推进”（换行）**

###### 怎样进行换行？判断当前列是否已经到头了

当前列如果已经超过了`row size`， 则切换到下一行，并且将col重置为`0`。

- `if (col == 9) { col = 0; row++; }`

##### 步骤 2：处理“终止条件（成功）”

`if (row == 9) { return true; }` // 所有行都填完了

##### 步骤 3：跳过预设格子

在题目中，空白单元格中的值是`.`。

因此如果一个单元格的值不是`.`，就说明它已经被填充过了，不需要进行填充操作。

因此这里我们**不需要一个visited标记数组**。

`if (board[row][col] != '.') { return backtrack(row, col + 1); }`

##### 步骤 4：遍历“选择列表”（'1' 到 '9'）

`for (int num = 1; num <= 9; num++)`：

##### 步骤 5：剪枝（检查约束）

我们需要检查当前单元格所在的行/列/盒子是否已经存在这个数字了。

如果已经存在了，我们需要剪枝（`continue`）。

```
int box_idx = ...;
if (rows[row][num] || cols[col][num] || boxes[box_idx][num]) { continue; }
```

##### 步骤 6：做出选择 (Choose)

- `board[row][col] = (char)(num + '0');`
- `rows[row][num] = true; ...` // 更新状态

##### 步骤 7：探索 (Explore)

`if (backtrack(row, col + 1))`：// 探索下一个格子

- `return true;` // **短路**：下游返回 true，说明找到了解

##### 步骤 8：撤销选择 (Unchoose)

- （运行到这里，说明 `backtrack(row, col + 1)` 返回了 `false`，即 `num` 是死路）
- `board[row][col] = '.';`
- `rows[row][num] = false; ...` // 恢复状态

##### 步骤 9：处理“终止条件（失败）”

- （`for` 循环结束，'1' 到 '9' 都试过了，都不行）

- `return false;`

#### 实现代码

```Java
class Solution {
    private boolean[][] rows = new boolean[9][10];
    private boolean[][] cols = new boolean[9][10];
    private boolean[][] boxes = new boolean[9][10];
    public void solveSudoku(char[][] board) {
       for(int row = 0; row < 9; row++){
        for(int col = 0; col < 9; col++){
            if(board[row][col] != '.'){
                int num = board[row][col] - '0';
                int boxIndex = getBoxIndex(row, col);
                
                rows[row][num] = true;
                cols[col][num] = true;
                boxes[boxIndex][num] = true;
            }
        }
       }
        backtrack(board, 0, 0);
    }

    private boolean backtrack(char[][] board, int row, int col){
        //所有的列都填写完了，说明需要下一行
        if(col == 9){
            row++;
            col = 0;
        }
        //所有的行都填写完成，说明填写成功了，返回true；
        if(row >= 9){
            return true;
        }

        if(board[row][col] != '.'){
            return backtrack(board, row, col+1);
        }

        for(int num = 1; num <= 9; num++){
            if(!isValid(board, num, row, col)) continue;

            board[row][col] = (char)(num + '0');
            rows[row][num] = true;
            cols[col][num] = true;
            boxes[getBoxIndex(row, col)][num] = true;

            if(backtrack(board, row, col+1)){
                return true;
            }

            board[row][col] = '.';
            rows[row][num] = false;
            cols[col][num] = false;
            boxes[getBoxIndex(row, col)][num] = false;
        }   

        return false;
       
    }

    private boolean isValid(char[][] board, int num, int row, int col){
        if(rows[row][num]){
            return false;
        }
        if(cols[col][num]){
            return false;
        }
        int boxRowIndex = row / 3;
        int boxColIndex = col / 3;
        int boxIndex = boxRowIndex * 3 + boxColIndex;

        return !boxes[boxIndex][num];
    }

    private int getBoxIndex(int row, int col){
        int boxRowIndex = row / 3;
        int boxColIndex = col / 3;
        int boxIndex = boxRowIndex * 3 + boxColIndex;
        return boxIndex;
    }
}
```

### Leetcode 51 : N皇后问题

#### 问题要点

1. **$N$ 个皇后， $N \times N$ 棋盘**：这意味着每行必须有且仅有一个皇后，每列也必须有且仅有一个皇后。
2. **攻击约束**：
   - **行**：不能有两行相同（我们按行放置，天然满足）。
   - **列**：不能有两列相同。
   - **主对角线** (Top-Left to Bottom-Right)：不能有两个皇后在同一条主对角线上。
   - **副对角线** (Top-Right to Bottom-Left)：不能有两个皇后在同一条副对角线上。
3. **目标**：找到**所有**可能的解，而不是任意一个解或解的数量（那是 LeetCode 52）。
4. **输出格式**：`List<List<String>>`，需要一个辅助函数来根据皇后的位置生成棋盘字符串。

#### 问题本质和分析

这个问题的本质是一个**约束满足问题 (Constraint Satisfaction Problem)**。

我们要在 $N^2$ 个格子中选择 $N$ 个位置放皇后，同时满足一系列的约束条件。

- **搜索空间**：如果我们暴力搜索，每个格子都有放或不放两种状态，复杂度是 $O(2^{N^2})$，不可行。
- **优化搜索**：根据“问题要点 1”，我们知道每行*必须*放一个皇后。这启发我们不要在 $N \times N$ 的格子上搜索，而是进行 $N$ 次“决策”。
- **决策过程**：我们可以按行（从第 0 行到第 $N-1$ 行）来决策。
  - 在第 0 行，决策皇后放在哪一列？
  - 在第 1 行，决策皇后放在哪一列？
  - ...
- **约束**：当我们在第 `row` 行决定将皇后放在第 `col` 列时，我们必须检查这个位置 `(row, col)` 是否与*之前所有行*（0 到 `row-1`）中已放置的皇后冲突。

#### 规律观察 - 如何高效的检查冲突？

如何高效地检查冲突？假设我们正在第 `row` 行，尝试将皇后放在 `col` 列。我们需要检查这个位置是否被之前（`r < row`）的皇后 `(r, c)` 攻击。

##### **列冲突**：检查 `col` 是否在之前被使用过。

这个很简单，我们只需要检查当前列是否已经放置了就可以了。

#####**对角线冲突**：怎样计算`[row,col]`所在的对角线的索引？

###### **主对角线 (TL-BR)**：$index(r,c) = r - c$

在同一条主对角线上的两个点 $(r_1, c_1)$ 和 $(r_2, c_2)$，它们满足 $r_1 - c_1 = r_2 - c_2$。

###### **副对角线 (TR-BL)**：$index(r,c) = r + c$

在同一条副对角线上的两个点 $(r_1, c_1)$ 和 $(r_2, c_2)$，它们满足 $r_1 + c_1 = r_2 + c_2$。

观察结论：

为了 $O(1)$ 时间内检查冲突，我们可以使用三个 "used" 集合（或布尔数组）：

1. `usedCols`: 记录哪些**列**已被占用。
2. `usedDiag1`: 记录哪些**主对角线**已被占用。用 $row - col$ 作为索引。
3. `usedDiag2`: 记录哪些**副对角线**已被占用。用 $row + col$ 作为索引。

#### 模式和套路匹配

这个问题完美匹配**回溯算法 (Backtracking)**。

- **路径 (Path)**：当前已经放置的皇后的位置。
- **选择列表 (Choices)**：在当前行 `row`，所有 $N$ 个列 `(col = 0...N-1)` 都是潜在的选择。
- **结束条件 (Base Case)**：我们成功到达了第 $N$ 行（即 `row == n`），说明我们已经成功放置了 $N$ 个皇后。这是一个有效解，将其格式化后加入结果集。
- **剪枝 (Pruning)**：如果一个选择（在 `(row, col)` 放置皇后）违反了约束（列或对角线冲突），我们**不**继续向下递归，而是尝试当前行的下一个选择（下一列）。

这与你之前研究的**组合 (Combinations)** 和**排列 (Permutations)** 问题非常相似。

- **排列**：从 $N$ 个数中选 $N$ 个，`used` 数组防止重复使用*同一个数*。
- **N皇后**：从 $N$ 列中为 $N$ 行各选一个，`used` 数组（`usedCols`, `usedDiag1`, `usedDiag2`）防止*冲突*。

#### 核心思想和套路 (Core Idea and Strategy) - 按照行递归

使用 DFS（深度优先搜索）按行（`row`）递归，在每一行（`row`）中，用 `for` 循环遍历所有列（`col`）作为“选择”。

##### 回溯函数的定义：`backtrack(row)`

###### **Base Case**: `if (row == n)`:

找到一个完整解。

根据记录的皇后位置（例如一个 `int[n]` 数组）来生成 `List<String>` 格式的棋盘。

将棋盘加入最终结果 `results`。

`return`。

###### 遍历选择列表：当前行的每一个单元格

**剪枝：如果当前行/列/主对角线/副对角线已经有皇后**

`if (col 被占用 || (row, col) 的主对角线被占用 || (row, col) 的副对角线被占用)`:

- `continue;` // 尝试下一列

**选择当前单元格**

- 记录 `(row, col)` 为皇后位置。
- 标记 `col` 为已占用。
- 标记 $row - col$ 为已占用。
- 标记 $row + col$ 为已占用。

**递归解决下一行**

- `backtrack(row + 1);` // 解决下一行

###### 撤销选择

(为了让 `for` 循环的下一次迭代能正确运行)

取消标记 `col`。

取消标记 $row - col$。

取消标记 $row + col$。

#### 实现原理和步骤

#####全局变量的定义：

###### **结果集：**

`List<List<String>> results`， 存储所有的解集合，每一行是一个字符串，每一个解是一个字符串列表

######**棋盘大小：**`int n`

###### **列占用记录：**

`boolean[] usedCols`: 大小为 $N$， `used[col]`表示列`col`是否被占用

###### **主对角线占用记录：**

`boolean[] usedDiag1`: 大小为 $2N - 1$， 索引为 `row - col`

但 `row - col` 范围是 $[-(N-1), N-1]$。

为避免负索引，我们加一个偏移量 $N-1$。

索引变为 `row - col + (N-1)`。

`usedDiag1[row-col+N-1]`表示`[row,col]`所在的主对角线是否已经占用。

######副对角线占用记录

`boolean[] usedDiag2`: 大小为 $2N - 1$。

索引为 `row + col`。范围是 $[0, 2N-2]$，无需偏移。

###### 棋盘

根据传入的$N$的，定义一个$N \times N$的矩阵。

根据题意，矩阵的所有值默认设置为`.`

#####**`backtrack(int row)` 函数**定义

######**Base Case**: `if (row == n)`:所有行都填写完毕

- 调用 `generateBoard()` 辅助函数，传入 `queens` 数组。
- 将返回的 `List<String>` 添加到 `results`。
- `return`。

###### 循环遍历和回溯过程

**遍历当前行中的每一个元素：**

**Loop**: `for (int col = 0; col < n; col++)`:

- 计算对角线索引：
  - `diag1Idx = row - col + (n - 1);`
  - `diag2Idx = row + col;`

**检查当前元素所在列/主对角线/副对角线是否已经占用**

如果已经占用，则剪枝。

- **Check**: `if (usedCols[col] || usedDiag1[diag1Idx] || usedDiag2[diag2Idx])`:
  - `continue;`

**回溯三部曲之选择元素**

- **Choose**:
  - `board[row][col] = 'Q';`
  - `usedCols[col] = true;`
  - `usedDiag1[diag1Idx] = true;`
  - `usedDiag2[diag2Idx] = true;`

**回溯三部曲之递归调用**

- **Recurse**: `backtrack(row + 1);`

**回溯三部曲之撤销选择**

- **Unchoose (Backtrack)**:
  - `usedCols[col] = false;`
  - `usedDiag1[diag1Idx] = false;`
  - `usedDiag2[diag2Idx] = false;`
  - `board[row][col] = '.'`

#####**`generateBoard()` 辅助函数**：

```Java
private List<String> constructBoard(char[][] board){
        List<String> res = new ArrayList<>();
        for (int i = 0; i < board.length; i++){
            res.add(new String(board[i]));
        }
        return res;
    }
```

#### 实现代码

```Java
class Solution {
    private List<List<String>> results = new ArrayList<>();
    private boolean[] usedCols;
    private boolean[] usedDiag1;
    private boolean[] usedDiag2;
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for(int i = 0; i < n; i++){
            Arrays.fill(board[i], '.');
        }

        usedCols = new boolean[n];
        usedDiag1 =  new boolean[2 * n - 1];
        usedDiag2 = new boolean[2 * n - 1];
        backtrack(board, 0);
        return results;
    }

    private void backtrack(char[][] board, int row){
        int n = board.length;
        if(row == board.length){
            results.add(formatBoard(board));
            return;
        }

        for(int col = 0; col < n; col++){
            int diag1Index = row - col + n - 1;
            int diag2Index = row + col;
            if(usedCols[col] || usedDiag1[diag1Index] || usedDiag2[diag2Index]){
                continue;
            }

            board[row][col] = 'Q';
            usedCols[col] = true;
            usedDiag1[diag1Index] = true;
            usedDiag2[diag2Index] = true;

            backtrack(board, row+1);

            board[row][col] = '.';
            usedCols[col] = false;
            usedDiag1[diag1Index] = false;
            usedDiag2[diag2Index] = false;
        }
    }

    private List<String> formatBoard(char[][] board){
        List<String> result = new ArrayList<>();
        for(char[] row : board){
          result.add(new String(row));  
        }
        return result;
    }
}
```





### Leetcode 52: N皇后问题II

#### 实现代码

实现的思路基本上和Leetcode 51是一样的，只是本题是一个计数题目。

```Java
//N皇后问题
//计算总数量
class Solution {
    private boolean[] cols;
    private boolean[] diag1;
    private boolean[] diag2;
    private int count = 0;
    public int totalNQueens(int n) {
        cols = new boolean[n];
        diag1 = new boolean[2 * n - 1];
        diag2 = new boolean[2 * n - 1];

        char[][] board = new char[n][n];
        for(char[] row : board){
            Arrays.fill(row,'.');
        }

        backtrack(board, 0);
        return count;

    }

    private void backtrack(char[][] board, int row){
        int n = board.length;
        if(row == n){
            count++;
            return;
        }

        for(int col = 0; col < n; col++){
            int diag1Index = row - col + n - 1;
            int diag2Index = row + col;

            if(cols[col] || diag1[diag1Index] || diag2[diag2Index]){
                continue;
            }

            board[row][col] = 'Q';
            cols[col] = true;
            diag1[diag1Index] = true;
            diag2[diag2Index] = true;

            backtrack(board, row+1);

            board[row][col] = '.';
            cols[col] = false;
            diag1[diag1Index] = false;
            diag2[diag2Index] = false;
        }
    }
}
```







