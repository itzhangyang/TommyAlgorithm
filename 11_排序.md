# 11. **排序**

## 常见的排序类问题类型以及策略

| 问题类型                        | 示例题目                                   | 主要策略                                     |
| ------------------------------- | ------------------------------------------ | -------------------------------------------- |
| **1. 自定义排序**               | 根据频率排序、按特定规则排序字符串/数组    | 使用排序函数的自定义比较器（`cmp` 或 `key`） |
| **2. Top K 元素问题**           | 找出数组中前 K 大/小的元素                 | 快速选择、堆排序                             |
| **3. 归并思想的问题**           | 逆序对计数、区间合并等                     | 分治 + 归并排序                              |
| **4. 桶排序 / 计数排序**        | 高效排序有限整数范围的数组，如出现频率统计 | 桶排序、计数排序                             |
| **5. 荷兰国旗问题（三色排序）** | LeetCode 75. Sort Colors                   | 双指针（low, mid, high）                     |
| **6. 原地排序要求**             | 数组去重、重排等                           | 双指针 / 原地交换                            |
| **7. 间接排序问题**             | 按某个属性排序结构体数组，如 (id, score)   | 稳定排序，自定义排序器                       |
| **8. 基于排序优化的问题**       | 寻找三数之和、区间合并                     | 先排序再遍历双指针或栈                       |

## Leetcode题目收集

| 题号     | 题目名称                              | 题型分类         | 解题策略                               |
| -------- | ------------------------------------- | ---------------- | -------------------------------------- |
| **56**   | Merge Intervals                       | 区间合并         | **先排序后合并**（按起点升序）         |
| **75**   | Sort Colors                           | 荷兰国旗问题     | **双指针原地排序**（三路划分）         |
| **88**   | Merge Sorted Array                    | 有序数组合并     | **双指针从后往前合并**                 |
| **215**  | Kth Largest Element in an Array       | Top K 问题       | **快速选择**或**最小堆**               |
| **347**  | Top K Frequent Elements               | 频率统计排序     | **哈希表 + 最小堆**或**桶排序**        |
| **451**  | Sort Characters By Frequency          | 自定义排序       | **哈希表计数 + 桶排序 / 自定义比较器** |
| **912**  | Sort an Array                         | 实现排序         | **快速排序、归并排序等经典实现**       |
| **973**  | K Closest Points to Origin            | Top K 问题       | **最大堆**或**快速选择**               |
| **148**  | Sort List (链表排序)                  | 归并排序         | **链表归并排序（递归或迭代）**         |
| **3005** | Count Elements With Maximum Frequency | 桶排序应用       | **哈希表 + 桶统计最大频率**            |
| **621**  | Task Scheduler                        | 桶排序思想       | **任务频率统计 + 桶思想计算最短时间**  |
| **2389** | Longest Subsequence With Limited Sum  | 排序 + 前缀和    | **排序 + 前缀和 + 二分查找**           |
| **274**  | H-Index                               | 数组排序         | **排序 + 数学判断条件**                |
| **1636** | Sort Array by Increasing Frequency    | 自定义排序       | **频率统计 + 自定义比较器**            |
| **973**  | K Closest Points to Origin            | Top K + 排序距离 | **堆 / 快速选择**                      |

## 常用排序算法时间复杂度对比

| 排序算法 | 时间复杂度                  | 空间复杂度 | 是否稳定     | 适用场景             |
| -------- | --------------------------- | ---------- | ------------ | -------------------- |
| 快速排序 | O(n log n) 平均，O(n²) 最坏 | O(log n)   | 否           | 大多数通用排序       |
| 归并排序 | O(n log n)                  | O(n)       | 是           | 需要稳定排序         |
| 堆排序   | O(n log n)                  | O(1)       | 否           | Top K 问题           |
| 计数排序 | O(n + k)                    | O(k)       | 是           | 元素是整数且范围有限 |
| 桶排序   | O(n + k)                    | O(n + k)   | 取决于子排序 | 元素分布均匀         |
| 插入排序 | O(n²)                       | O(1)       | 是           | 小规模数据或基本有序 |
| 冒泡排序 | O(n²)                       | O(1)       | 是           | 教学用途，实际很少用 |

## 典型问题与策略详解

### 自定义排序

**典型题目**： 按照字符频率排序、按多个字段排序（如先按照分数将许，再按照姓名升序）

**策略**：使用`Arrays.sort`/`collections.sort()`或者自定义`comparator`

**代码示例+模板**

```java
//数组排序
Arrays.sort(people,(a,b)->{
  if(a.age != b.age) return a.age-b.age;
  return a.name.compareTo(b.name);
});

//列表排序
Collections.sort(strList,(a.b)->b.length()-a.length());
```

####Leetcode 56: 区间合并问题

//纤细过程见数组和字符串章节

```Java
//区间合并

class Interval{
    int start;
    int end;
    public Interval(int start, int end){
        this.start = start;
        this.end = end;
    }
}
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b) -> a[0] - b[0]);
        List<Interval> result = new ArrayList<>();
        Interval prev = new Interval(intervals[0][0], intervals[0][1]);
        result.add(prev);
        
        for(int i = 1; i < intervals.length; i++){
            Interval curr = new Interval(intervals[i][0], intervals[i][1]);
            if(curr.start <= prev.end){
                prev.end = Math.max(prev.end, curr.end);
            }else{
                result.add(curr);
                prev = curr;
            }
        }

        int[][] ans = new int[result.size()][2];
        for(int i = 0; i < result.size(); i++){
            ans[i] = new int[]{result.get(i).start, result.get(i).end};
        }
        return ans;

    }
}
```



### Top K 问题

**典型问题**： 数组中的前K个大元素、K个最小值

**策略**： 使用堆（java中的`priorityQueue`）

**Java 小顶堆模板（前K个大元素）**：

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
for (int num:nums){
  minHeap.offer(num);
  if (min.size>k){
    minHeap.poll();//去掉小的
  }
}
```

**Java 小顶堆模板（前K小元素）**

```Java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(a,b->b-a);
for (int num:nums){
  maxHeap.pop();//去掉大的
}
```

#### Leetcode 347: Top K Frequent Elements



### 归并排序变种

**典型题目：** 逆序对个数、合并区间类问题

**策略：** 使用归并排序的分治思想

**Java归并排序+模板（适用于逆序对等）**

```java
void mergeSort(int[] arr, int left, int right){
  if (left >= right) return;
  int mid = left+(right-left)/2;
  mergeSort(arr,left,mid);
  mergeSort(arr,mid+1,right);
  merge(arr,left,mid,right);
}

void merge(int[] arr, int left, int mid, int right){
  int[] temp = new int[right-left+1];
  int i=left;j=mid+1;k=0;
  while(i<=mid&&j<=right){
    if (arr[i] <= arr[j]) temp[k++]=arr[i++];
    else temp[k++] = arr[j++];//逆序对统计逻辑可在此处理
  }
  while(i<=mid) temp[k++]=arr[i++];
  while(j<=right) temp[k++]=arr[j++];
  for (int x=0;x<=temp.length;x++){
    arr[left+x]=temp[x];
  }
}
```

####Leetcode 148 链表排序

基于归并排序的方法排序一个链表。

##### 定义归并排序函数

- 定义一个排序函数`mergeSort(nums,start,end)`

##### 将链表从中点处一分为二

###### 确保中点作为前半部分的结尾

链表节点数量是基数的时候不会导致任何问题，在链表节点数量为偶数的时候，我们有两种取中点的方式：

- 取前半段的最后一个节点作为结尾
- 取后半段的第一个最为结尾

在这里我们应当确保中点在**前半部分的结尾**，~~而不是后**半部分的开头**~~。

如果使用后半部分，会导致**无限循环**问题，比如：

当 `sortList` 接收到 `[1, 2]` 时：

1. `getMid(head)` 返回节点 `2`。
2. `mid = 2`
3. `head2 = mid.next` 也就是 `null`。
4. `mid.next = null` (将 `2.next` 设为 `null`，但 `head` 仍然是 `1 -> 2`)。
5. 递归调用 `sortList(head)`，也就是再次调用 `sortList([1, 2])`。
6. 程序陷入无限循环。

###### 怎样确保取前半段的最后一个节点作为结尾？

```Java
while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
```



### 桶排序/计数排序

**典型题目：** 排序整数范围小的数据，比如成绩或者频率统计问题

**策略：** 根据数值分布到桶中或者直接统计频率

**Java计数排序模板：**

```java
int[] count = new int[maxVal+1];// maxVal为数组中的最大值
for (int num:nums){
  count[num]++;
}
List<Integer> result = new ArrayList<>();
for(int i=0;i<count.length;i++){
  for (int j=0;j<count[i];j++){
    result.add(i);//或写回nums[]
  }
}
```

####Leetcode 3005: Count Elements With Maximum Frequency



### 三色旗问题（荷兰国旗问题）

**典型题目：** Leetcode 75. Sort Colors

**策略：**原地双指针+区间划分

三色旗问题可以作为一种专门的排序方法进行学习。

#### 三个指针的定义和作用

##### 左指针（left）： 指向0区域的右边界，`[0...left]`中确保任何时候都是只有0

左指针的最初位置是-1，表示一开始待定区域没元素。

##### 中间指针：指向1区域的右边界`[left+1, mid]`时候都是1



##### 右指针： 指向 2区域的左边界，`[p2...n-1]`中确保任何时候都只有2

#### 三个指针将数组划分为四个区域

##### 0区域[0....left]：任何时候都是0

该区域初始状态下为空， 因此我们可以将left指针设置为-1；

##### 1区域[left+1...curr-1]：任何时候都是1

该区域初始状态下同样为空。

##### 待定区域：[curr....right-1]:属于正在被筛选的区域

##### 2区域:任何时候都是2

#### 我们的任务： 从待定区域中挑选物品到指定区域

按照我们的逻辑，待定区域一开始就是整个数组。

我们的任务就是从待定区域中选择元素，分发到它该去的地方。

如果说找到了一个0元素，那就应该去0区域，1元素就应该去1区域，2元素就应该去2区域。

由于题目对于什么元素在前什么元素在后有了明确规定。

##### 当前元素为0: 扩展0区域 

根据我们的定义：

- **`[0, left]` 区间**：全部是 `0`。

- **`[left + 1, curr - 1]` 区间**：全部是 `1`。

- **`[curr, right - 1]` 区间**：这是**未处理**的"未知"区间。

- **`[right, n - 1]` 区间**：全部是 `2`。

**当 `nums[curr] == 0` 时：** 你把它与 `[left+1]` 位置的元素（已知是 `1`）交换。

交换后，`nums[curr]` 变成了 `1`。

`curr` 指针的任务（处理 `0`）已经完成，并且新位置（`curr`）的 `1` 也自动归位了，所以 `curr` 可以前移。

##### 当元素为1： 扩展1区域

我们不需要左任何元素交换，因为根据定义`[left+1, curr-1]`属于1区域。

因此我们只需要前移curr指针，就实现了扩展1区域的目标。

##### 当前元素为2: 扩展2区域

如果当前元素为2的时候，我们交换`nums[curr]`和`nums[right-1]`。

**当 `nums[curr] == 2` 时：** 你把它与 `[right-1]` 位置的元素（未知）交换。

交换后，`nums[curr]` 是一个**未知数**（可能是0或1）。

`curr` 必须停在原地，以便在下一次循环中处理这个新换来的元素。

```java
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int left = -1;
        int curr = 0;
        int right = n;
        //上述指针将数组分为四个区域
        //0区域[0..left]， 初始状态为空[0..-1]
        //1区域[left+1...curr],
        //未定区域[curr...right], 初始状态：[0...n-1]
        //2区域
        while(curr < right){
            if(nums[curr] == 0){
                left++;
                swap(nums,left,curr);
                curr++;
            }else if(nums[curr] == 1){
                curr++;
            }else{
                right--;
                swap(nums,curr,right);
            }
        }
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### Leetcode 75: 荷兰国旗问题

### 原地排序要求

**典型题目：** 去重、移动零、奇偶排序

**策略：** 双指针、快慢指针、交换操作

**移动零Java模板：**

```java
void moveZeros(int[] nums){
  int slow=0;
  for (int fast=0;fast<=nums.length;fast++){
    if (nums[fast] !=0){
      nums[slow++] = nums[fast];
    }
  }
  
  while(slow < nums.length){
    nums[slow++]=0;
  }
}
```

#### Leetcode 283: 移动0 - 本质上和快速排序类似

```Java
//两个区域：
//合格区域和代选区域
//[0...left] 合格区域
//[left + 1, curr-1] 1区域？
//[curr, n-1]代选区域？
class Solution {
    public void moveZeroes(int[] nums) {
        int left = -1;
        int curr = 0;
        while(curr < nums.length){
            if(nums[curr] != 0){
                left++;
                swap(nums,left,curr);
            }
            //应不应该呢？
            curr++;
        }
    }

    private void swap(int[] nums, int i , int j ){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



###间接排序问题

**典型题目：** 结构体排序，比如线按照分数降序，再按照姓名升序

```java
class Student{
  int score;
  String name;
}

Arrays.sort(students,(a,b)->{
  if (b.score != a.score) return b.score-a.score;
  return a.name.compareTo(b.name);
})
```



### 基于排序优化的问题

**典型题目：**

-  Leetcode 15. 三数之和
-  合并区间



**Java 三数之和模板（排序+双指针）**

```java
class Solution {
    
    public List<List<Integer>> threeSum(int[] nums) {
       Arrays.sort(nums);

       List<List<Integer>> res = new ArrayList<>();

       for (int i=0; i < nums.length - 2; i++){
        //去重
        if (i > 0 && nums[i] == nums[i-1]) continue;

        int left = i+1; 
        int right = nums.length - 1;
        
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0){
                res.add(Arrays.asList(nums[i],nums[left],nums[right]));

                //跳过左右重复的元素,移动到重复元素序列的最后一个
                while (left < right && nums[left] == nums[left+1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                // 移动左右指针
                left++;
                right--;
            }else if (sum < 0){
                left++;
            }else{
                right--;
            }
        }
       }
       return res; 
    }   
}
```

#### Leetcode 15: 三数之和 - 排序 + 去重 + 双指针

#####前提操作：排序

为了能够进行后面的去重和双指针操作，我们需要提前对数组从小到大进行排序。

##### 贡献法： 以每一个数字`nums[i]`为中心

###### 去重： 如果`nums[i] == nums[i-1]`

这种情况需要直接跳过`nums[i]`， 因为我们之前已经基于`nums[i-1]`计算过了，为了防止出现重复，我们直接跳过即可。

###### 双指针的定义

**left**: 从`i+1`到向右遍历，直到`right`

**right**:从`n-1`向左遍历，直到`left`

###### sum == 0: 记录结果

如果说当前的三数之和是0， 则：

- 记录结果，将三个数字加入结果集

- 左指针去重，向右移动到最后一个与当前值相同的元素上

  ```
  while(left < right && nums[left] == nums[left+1]) left++;
  ```

- 有指针去重，向左移动到最后一个与当前值相同的元素上

  ```Java
  while(left < right && nums[right] == nums[right - 1]) right--
  ```

- 继续移动左右指针：

  - 左指针前右移动一步
  - 有指针向左移动一步

###### sum < 0 : 向右移动左指针

此时说明我们需要一个更大的数字，向右移动左指针即可。

###### sum > : 向左移动右指针

此时说明我们需要一个更小的数字，向左移动右指针即可。

#常见排序算法套路模板

##归并排序

###核心思想-分解-合并

和快速排序的思想一样，归并排序的思想同样是分解 - 解决 - 合并。

归并排序同样使用了递归的思想。

####分解 - 将数组不断对半切分

分解过程是指将一个大的、难以直接解决的问题，不断地分解成更小的、与原问题形式相同的子问题，直到这些子问题小到可以被轻松解决。

在排序中，这意味着将包含n个元素的数组，不断地对半切分，直到每个子数组只包含一个元素。

一个元素的数组天然就是有序的。

####合并 - 将已经解决的子问题合并成原问题的解

**这是归并排序最关键的一步**。

它指的是将两个已经有序的子数组，合并成一个大的有序数组。这个合并操作是整个算法效率的保证。

####通俗的理解 - 扑克牌排序

象一下整理一副打乱的扑克牌。

你不会直接在手里整理52张牌，而是先把它们分成两堆（26张），再把这两堆牌各自继续分成两堆（13张），如此反复，直到你手里只剩下一张张的牌（单个元素天然有序）。

然后，你开始进行“合并”操作：拿起两堆单张的牌，按顺序合成一堆2张的有序牌堆；

再拿起两个2张的有序牌堆，按顺序合成一个4张的有序牌堆……最终，你将两个26张的有序牌堆合并，就得到了一个完整的、52张的有序扑克牌。

###归并排序的实现原理

归并排序的实现主要包含两个核心部分：**递归切分** 和 **合并**。

####递归切分数组 - 自顶向下

这个过程是**自顶向下**的，目标是将数组不断切分。

#####递归函数的定义

- 定义一个排序函数 `mergeSort(arr, left, right)`，表示对数组 `arr` 从索引 `left` 到 `right` 的部分进行排序。
- **终止条件：** 如果 `left >= right`，说明这个子数组最多只有一个元素，无需排序，直接返回。

#####递归过程的实现

###### 寻找中点：mid = (left + right) /2

- 找到中间位置: `mid = (left + right)/2`

###### 分别对左右部分进行排序

- 对左半部分进行递归排序：`mergeSort(arr,left,mid)`
- 对有半部分进行递归排序: `mergeSort(arr,mid + 1, right)`

####### 合并左右部分

- 在左右两个部分都排序完成后，调用`merge(arr,left,mid,right)`将这两个有序数组合并成一个

####合并过程的实现 - 合并两个有序数组 - 基于三指针

这是归并排序的精髓所在，负责将两个已排序的子数组（`arr[left...mid]` 和 `arr[mid+1...right]`）合并。

#####构建临时结果数组

- 创建一个临时数组 `temp`，其大小足以容纳两个待合并的子数组。

- 定义三个指针：
  - 左子数组的起始位置 ：`i`，指向`left`
  - 右边子数组的起始位置：`j` 指向右子数组的起始位置 (`mid + 1`)
  - 合并后的临时数组的起始位置：`t` 指向临时数组 `temp` 的起始位置 (0)。

#####比较左右数组的每一个元素按照顺序放入临时数组

- 循环比较 `arr[i]` 和 `arr[j]` 的值。

- 如果 `arr[i] <= arr[j]`，就将 `arr[i]` 放入 `temp[t]`，然后 `i` 和 `t` 都向后移动一位。

- 否则，将 `arr[j]` 放入 `temp[t]`，然后 `j` 和 `t` 都向后移动一位。

- 重复此过程，直到其中一个子数组的所有元素都被放入 `temp` 中。

#####处理剩余的元素 - 可能有数组还没处理完

- 此时，必定有一个子数组还有剩余元素（因为它的元素都比较大）。

- 将这个子数组中所有剩余的元素依次复制到 `temp` 数组的末尾。

#####将合并后的临时数组拷贝至原数组

- 最后，将临时数组 `temp` 中的所有元素按顺序拷贝回原数组 `arr` 的相应位置（从 `left` 开始）。

####实现代码

```java
public void mergeSort(int[] arr){
  if (arr==null || arr.length<=1){
    return;
  }
  mergeSort(arr,0,arr.length-1);
}

private void mergeSort(int[] arr, int left, int right){
  if (left >= right) return;
  //选择left和right中间的数字作为中点
  int mid = left+(right-left)/2;
  // 归并排序中点左侧部分
  mergeSort(arr,left,mid);
  // 归并排序中点右侧部分
  mergeSort(arr,mid,right);
  // 合并中点左侧和右侧
  merge(arr,left,mid,right);
}

private void merge(int[] arr, int left, int mid, int right){
  int[] temp = new int[right-left+1];
  //从left 到right合并
  int i=left,j=mid+1,k=0;
  while(i<=mid && j<=right){
    if (arr[i]<=arr[j]){
      temp[k++]=arr[i++];
    }else{
      temp[k++]=arr[j++];
    }
  }
  while(i<=mid) temp[k++]=arr[i++];
  while(j<=right) temp[k++]=arr[j++];
  //将temp数组copy到arr[left,right]
  System.arrayCopy(temp,0,arr,left,temp.length);
}
```

###时间和空间复杂度

- 时间复杂度：`O(nlogn)`
- 空间复杂度：`O(n)`

###经验总结

- **对稳定性有要求时：** 如果业务场景要求相等元素的原始顺序不能被打乱，归并排序是绝佳选择（例如，按成绩排序，如果成绩相同，则保持原有的学号顺序）。
- **数据量巨大，内存不足时（外部排序）：** 当文件大到无法一次性载入内存时，归并排序的思想可以被用来实现外部排序。先将文件分块读入内存排序，生成多个有序的临时文件，最后再将这些临时文件进行多路归并。
- **链表排序：** 归并排序非常适合对链表进行排序。因为链表的插入操作 (O(1)) 比数组的插入操作 (O(n)) 高效得多，并且链表在合并时不需要像数组那样使用大块的连续临时空间。

**与快速排序的对比：**

- **时间：** 快速排序的平均性能通常优于归并排序，因为它有更好的缓存局部性（in-place 操作），常数因子更小。但快速排序的最坏情况是 O(n2)，而归并排序始终是 O(nlogn)。
- **空间：** 快速排序是原地排序，平均空间复杂度为 O(logn)（递归栈深度），优于归并排序的 O(n)。
- **稳定性：** 归并排序是稳定的，而标准实现的快速排序是不稳定的。

##快速排序：分区 + 分治

通过这次学习，放眼整个算法理论，排序是一种**基础**、**重要**但是**不简单**的算法。

快速排序的核心思想是 **分治法 (Divide and Conquer)**。

简而言之，就是将一个大问题分解为若干个相同或相似的小问题，然后分别解决这些小问题，最后将小问题的解合并，从而得到原问题的解。

###分区过程： 将数组划分为三个部分 - `[left,pivot-1][pivot][pivot+1...right]`

####选择基准元素：第一个或者最后一个

从待排序的数组中，选择一个元素作为“基准”（Pivot）。

####将数组划分为三个部分：`[left,pivot-1][pivot][pivot+1...right]`

然后，重新排列数组。

- 将所有**小于基准**的元素移动到基准的**左边**
- 所有**大于基准**的元素移动到基准的**右边**。

这个过程称为**分区 (Partition)**。

完成分区后，基准元素就位于其最终排序后的正确位置上。

```Java
int pivot = partition(nums, left,right)://返回分区后的基准元素索引
```

####分别对左右分区递归排序

对基准左边的子数组和右边的子数组，递归地重复第一步的分解过程，即分别对它们进行快速排序。

```Java
quickSort(nums,left,pivot - 1);
quickSort(nums,pivot + 1, right);
```

###实现原理和步骤详解

下面我们通过一个具体的例子来详细拆解快速排序的实现步骤。假设我们有数组 `[6, 1, 2, 7, 9, 3, 4, 5, 10, 8]`。

####主函数 - 快速排序过程

第一次双指针过程 - 快速排序过程

严格来说属于双指针过程，但是不属于滑动窗口过程。

因为在这个过程中，指针的位置并没有发生所谓的移动操作。

快速排序的过程是每次调用**分区操作**将当前的`[left,right]`区间切割为`[left,pivot - 1],[pivot],[pivot + 1, right]`三个部分，并获得pivot索引，其中：

- `[left, pivot-1]`区间内存放比`pivot`元素小的元素
- `pivot`就是pivot元素的最终为止
- `[pivot+1, right]`区间内存放比`pivot`大的元素

然后再分别对左分区和右分区执行相同的**递归操作**。

```Java
public void quickSort(int[] nums,int left, int right){
  if(left >= right) return;
  //返回pivot的最终索引
  int pivotIndex = partition(nums,left, right);
  
  quickSort(nums,left, pivot - 1);
  quickSort(nums,pivot + 1, right);
}
```

####分区过程：基于双指针

关于双指针分区套路，详细参考**数组和字符串**章节部分。

这个过程和**三色旗**的思想有些类似。

它选择数组的**最后一个元素**作为基准（pivot）。

#####分区过程的核心思想 - 逐步扩大合格区域范围

我们已经知道分区的目标是将数组分为三个部分：

- 小于**小于等于基准**的区域
- **大于基准**的区域
- 基准元素本身

现在我们先设定一个**合格区域**。

你从头到尾检查每一个人，一旦发现合格的人，就

- 让他和**合格区域边界后的第一个人**交换位置

  比如现在我们的合格区域是`[first...last]`

  如果发现了一个新的合格元素，那么我们的合格区域就变成了`[first...last, last+1]`

- 这样，我们的**合格区域就扩大了一格**

#####选择基准元素：最后一个元素作为基准

一般情况下我们约定俗称的选择**最后一个元素**作为基准元素。

對於數組 `[7, 2, 1, 6, 8, 5, 3, 4]`，基准 `pivot` 就是 `4`。

#####初始化指针 - 双指针

我们需要两个指针来协同工作：

######左指针： 合格区域的右边界

- 左指针（指针`i`）,指向**合格区间**的右边界。

  它的起始位置在`low - 1`，表示这个区域一开始是空的。

###### 右指针：从左到右寻找合格元素

- 右指针（指针`j`），用来遍历从左到右的左右待处理的元素

```Java
private int partition(int[] nums, int low, int high){
  int i = low - 1;
  for(int j = low; j < high; j++){
    //....
  }
}
```

#####查找并交换元素

右指针`j`从头开始遍历所有的元素，对于每一个元素，检查其是否小于基准`pivot`

如果小于基准元素，则进行交换操作。

###### 不合格： 继续前移有指针

`j = 0`, `arr[0]` 是 `7`。`7 > pivot(4)`，不滿足條件，繼續。

- `arr`: `[7, 2, 1, 6, 8, 5, 3, 4]`
- `i = -1`

######合格： 交换`nums[i+1]`和`nums[j]`并扩大合格区域边界（前移作指针）

`j = 1`, `arr[1]` 是 `2`。`2 <= pivot(4)`，滿足條件！

- **擴大邊界**: `i` 先加一，`i` 變為 `0`。
- **交換**: 交換 `arr[i]` 和 `arr[j]` (即 `arr[0]` 和 `arr[1]`)。
- `arr`: `[2, 7, 1, 6, 8, 5, 3, 4]`
- `i = 0` (現在 `arr[0]` 屬於小於等於基准的區域)

`j = 2`, `arr[2]` 是 `1`。`1 <= pivot(4)`，滿足條件！

- **擴大邊界**: `i` 加一，變為 `1`。
- **交換**: 交換 `arr[i]` 和 `arr[j]` (即 `arr[1]` 和 `arr[2]`)。
- `arr`: `[2, 1, 7, 6, 8, 5, 3, 4]`
- `i = 1` (現在 `arr[0...1]` 區域都合格)

`j = 3`, `arr[3]` 是 `6`。`6 > pivot(4)`，不滿足條件。

`j = 4`, `arr[4]` 是 `8`。`8 > pivot(4)`，不滿足條件。

`j = 5`, `arr[5]` 是 `5`。`5 > pivot(4)`，不滿足條件。

`j = 6`, `arr[6]` 是 `3`。`3 <= pivot(4)`，滿足條件！

- **擴大邊界**: `i` 加一，變為 `2`。
- **交換**: 交換 `arr[i]` 和 `arr[j]` (即 `arr[2]` 和 `arr[6]`)。
- `arr`: `[2, 1, 3, 6, 8, 5, 7, 4]`
- `i = 2` (現在 `arr[0...2]` 區域都合格)

```Java
if(nums[j] <= pivot){
      i++;
      swap(nums,i,j);
}
```

###### 最后：将基准元素放到合格区域右边界（左指针）的下一个位置

```
swap(nums,i+1,high);
```



###### 返回基准元素索引

分區操作完成，基准 `4` 已經位於其最終的排序位置（索引 `3`）。函數返回這個索引 `i + 1` (即 `3`)。後續的遞歸調用將基於這個索引來處理左右兩個更小的子數組。

```Java
return i+1;
```

###### 基线条件

当一个子数组的长度为 0 或 1 时，它自然就是有序的，此时递归停止。

这个过程会一直持续下去，直到所有子数组都被排序，最终整个数组就变得有序了。

###模板代码

```java
public void quickSort(int[] arr){
  if (arr==null || arr.length<=1) return;
  quickSort(arr,0, arr.length-1);
}

private void quickSort(int[] arr, int left, int right){
  if (left >= right) return;
  int pivot = partition(arr, left,right);
  //经过partition之后，pivot已经在最终的位置了，因此不需要再改动pivot的位置
  quickSort(arr,left,pivot-1);
  quickSort(arr,pivot+1, right);
}
private int partition(int[] arr, int left, int right){
  //选取arr[right]作为pivot
  int pivot = arr[right];
  // 这里有一点快慢指针的思想
  // 慢指针i，用来修改小于pivot的部分的数组
  // arr[0...i]中的元素都是小于等于pivot的
  int i=left;
  //从左(left)到右(right)开始检查，如果发现某个元素小于
  for (int j=left;j<right;j++){
    //如果说某个元素arr[j]比pivot小，则交换arr[i]和arr[j]
    //如果说元素arr[j] 比pivot大，则不需要交换，i继续停留在下一个位置
    if(arr[j] <= pivot){
      swap(arr,i,j);
      i++;
    }
  }
  // 最终的结果是
  //arr[0...i-1]都是比pivot小的
  //arr[i+1...right-1]都是比pivot大的
  // arr[i]也比pivot大，因此需要交换一下arr[i]和arr[right]
  swap(arr,i,right);
  // 返回pivot的索引
  return i;
}

private void swap(int[] arr, int i,int j){
  int temp = arr[i];
  arr[i]=arr[j];
  arr[j]=temp;
}
```

###时间复杂度

- 最好&平均：`O(nlogn)`
- 最坏：`O(n^2)`
- 空间复杂度：`O(logn)` 递归栈空间

##堆排序

#### 核心思想

构造`大顶堆`，每次取出堆顶元素放到最后

#### 什么是堆？

`堆`是一棵`完全二叉树`，在一棵用`数组`表示的完全二叉树中，假设当前的节点的位置为`i`，并且数组的位置是从`0`开始的：

- 其左子节点的位置为`2*i+1`
- 其右子节点的位置为`2*i+2`
- 其父节点的位置为`(i-1)/2`

| 优势                 | 说明                                           |
| -------------------- | ---------------------------------------------- |
| **空间紧凑**         | 没有额外指针，节省空间                         |
| **无需指针操作**     | 不需要创建 Node 或维护结构，纯数学索引         |
| **高效交换**         | 交换只需交换数组值，不需要重建结构             |
| **可用顺序数组建堆** | 原地构建最大/最小堆，只需 O(n) 时间（Heapify） |

#### 使用数组实现的核心操作

##### 插入上浮

插入新元素到数组末尾，用`(i-1)/2` 向上比较交换

##### 删除下沉

删除堆顶元素之后，将最后元素放到堆顶，用`2i+1/2i+2`下沉维护

##### 堆化建堆

从最后一个非叶子节点开始，从上往下逐个`heapify(i)`;



#### 模板代码

```java
int[] heap;//堆
int size;//堆的大小

    public HeapSorter(int[] array) {
        this.heap = array;
        this.size = array.length;
    }

// 对外暴露的排序接口
    public void sort() {
        buildMaxHeap();  // Step 1: 构建最大堆

        for (int i = size - 1; i > 0; i--) {
            swap(0, i);        // Step 2: 将堆顶元素放到末尾
            size--;            // 减小堆大小
            heapify(0);        // Step 3: 重新堆化
        }
    }

private void buildMaxHeap(){
  for(int i=size/2-1;i>=0;i--){
    //从堆顶的元素开始堆化
    heapify(i);
  }
}

// 对heap[i] 进行
private void heapify(int i){
  // 默认largest=i;
  int largest =i;
  // i的左子节点为 2i+1
  int left = 2*i+1;
  // i的右子节点 2i+2
  int right = 2*i+2;
  
  // largest指向max(i,i.left,i.right);
  //如果左子节点比largest值大，largest指向左子节点
  if (left <size && heap[left] > heap[largest]){
    largest=left;
  }
  //如果右子节点比largest值大，largest指向右子节点
  if (right<size && heap[right] >heap[largest]){
    largest=right;
  }
  
  //如果说 largest指向了i的子节点，说明存在i的子节点比i大的情况，因此需要交换largest和i的位置
  if (largest != i){
    swap(i,largest);
    // 交换之后，对largest进行堆化
    heapify(largest);
  }
}

private void swap(int i,int j){
  int temp = heap[i];
  heap[i]=heap[j];
  heap[j]=temp;
}
```

#### Leetcode 最接近原点的K个点
