

### 线性动态规划（一维）

适用于佩波那契数列/爬楼梯/最大子序和（股票买卖）

#### 代码套路

```java
//1. 确定状态
int[] dp = new int[n+1]; // dp[i] 表示第i步的最优解
//2. 初始化起点状态
dp[0] = ...;
dp[1]=...;

for (int i=2;i<=n;i++){
  //3. 状态转移方程
  dp[i] = Math.max(dp[i-1,dp[i-2]+nums[i]]);
}
//4. 返回结果
return dp[n];


```

#### Leet code 70:计数问题- 爬楼梯-线形动态规划

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

##### 套路分析

###### 定义状态

`dp[i]`为爬到第i层楼梯的方法数

###### 定义选择

考虑从那几层可以到达第i 层？

- i-1层，到达i-1层有`dp[i-1]`种方法
- i-2层，到达i-2层有`dp[i-2]`中方法

###### 定义状态方程

到达i的方法数等于到达i-1和i-2的方法数的总和

- 假设有`d[i-1]`中方法爬到楼梯`i-1`

- 假设有`d[i-2]`中方法爬到楼梯`i-2`

- 那么有多少种方法爬上楼梯`i`?

  - 从楼梯`i-1`跨一步
  - 从楼梯`i-2`跨两步

  因此走到楼梯`i`的方法有`dp[i-1]+dp[i-2]`种方法

`dp[i]=dp[i-1]+dp[i-2]`

###### 明确初始状态和边界

可以确定第一层只有一种方法，第二层有两种方法，第三层开始有3种方法，第四层有五种方法...

因为最多会用到i-1和i-2, 因此我们只要定义dp[1]和dp[2]作为起点即可。

###### 返回最终结果

`return dp[n]`;

##### 代码实现

```java
    // 一维动态规划套路
    public int climbStairs(int n) {
        if (n==1 || n==2) return n;
        int[] dp= new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=2; // 2层有两种方法 1. 从0直接到2 2. 从0爬到1，从1 爬到2
        //dp[3]
        // 0-1,1-2,2-3
        // 0-2,2-3
        // 0-1,1-3
        for (int i=3; i<=n;i++){
            // 状态转移方程，总结状态转移方程是难点，注意总结规律
            dp[i] = dp[i-2]+dp[i-1];
        }
        return dp[n];
    }
```

#### Leetcode 139: 是否存在问题：拆分单词

给你一个字符串 `s` 和一个字符串字典 `wordDict`，请你判断 `s` 是否可以被空格拆分成一个或多个在字典中出现的单词。

##### 状态定义

`int[] dp = new int[s.length+1]`

`dp[i]`=true, 表示s中`[0...i-1]`的子串可以由word dict中的单词组成

`dp[0]`=true; 空字符串在任何情况下都可以被组装

##### 状态转移方程

对于`i=[1...n]`:

- 如果字符`[1...j]`可以由词典中的单词组成
- 并且字符`[j,i)`也在词典中

那么就意味着子串`[0...i-1]`可以由词典中的词组成

```java
        for(int i=1;i<=s.length();i++){
            for (int j=0;j<i;j++){
                if(dp[j] && wordDict.contains(s.substring(j, i))){
                    dp[i]=true;
                    break;//找到一个就够了，防止过多遍历
                }
            }
        }
```

##### 代码实现

需要注意状态转移方程是利用`前值（可能是一个或者多个）`来计算当前值的

```java
    public boolean wordBreak(String s, List<String> wordDict) {
        //首先应该反过来，想办法解析s中的单词吗？
        //dp[i] 为word dict是否中包含s[0,i-1]其中所有单词 
        boolean[] dp = new boolean[s.length()+1];
        dp[0]=true;
        for(int i=1;i<=s.length();i++){
            for (int j=0;j<i;j++){
                if(dp[j] && wordDict.contains(s.substring(j, i))){
                    dp[i]=true;
                    break;//找到一个就够了，防止过多遍历
                }
            }
        }
        return dp[s.length()];
    }
```

#### 最值问题：完全背包问题-Leetcode 322

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是`无限`的。

##### 分析

从最后一句话可以判定该题目可能是一个`完全背包问题`，因为每一种硬币都可以无限量使用。

##### 定义状态

`dp[i]`表示凑足总额为`i`所需要的最少硬币数量

`i`的范围`[0....amount]`

##### 初始化状态

- `dp[0]=0;`

- 求最小值，默认状态值全部初始化为`Integer.MAX_VALUE`

```java
        for(int i=1;i<=amount;i++){
            dp[i]=Integer.MAX_VALUE;
        }
```



##### 状态转移方程

背包问题的两层遍历：

- 遍历物品（`0-1背包`和`完全背包`通用）

- 遍历dp值：

  - 对于`完全背包`问题，遍历过程`从小到大[num....target]++`

    对于每一种硬币面额`coinAmount`:

    - 对于每个`j=[coinAmount...targetAount]`
    - `dp[j]=Math.min(dp[j],dp[j-coin]+1)`

  - 对于`0-1背包`问题，遍历过程`从大到小[target...num]--`

```java
//遍历金额（物品）
for (int coin: coins){
// 遍历dp值,完全背包问题的空间为[num...target] - num每一个物品的权重（价值，重量...）
  for (int j=coin;j<=amount;j++){
    dp[j] = Math.min(dp[j],dp[j-coin]+1);
  }
}
```





#### 0-1背包和完全背包问题的区别和对应策略

| 背包类型     | 每个物品可以选几次？      | 循环顺序                         | 场景示例                       |
| ------------ | ------------------------- | -------------------------------- | ------------------------------ |
| **0-1 背包** | 每个物品最多选 **1 次**   | **体积从大到小**（防止重复使用） | 选商品是否放入背包（不能重复） |
| **完全背包** | 每个物品可以选 **无限次** | **体积从小到大**（允许重复使用） | 硬币找零、无限商品放背包       |

##### 遍历顺序详解（核心）

假设`dp[j]`是表示**`体积为j的背包所能达到的最大价值/最小价值/最多组合数`**

###### 0-1背包：每个物品只能用一次，求最大价值

```java
for (int i = 0; i < n; i++) {  // 遍历物品
    for (int j = capacity; j >= weight[i]; j--) {  // 从大到小
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

从 **大到小遍历容量**，是为了防止本轮 `dp[j]` 用到了新更新的 `dp[j - weight[i]]`，相当于重复用了这个物品。//为什么？

###### 完全背包：**每个物品可以用无限次**，求最大价值

```java
for (int i = 0; i < n; i++) {  // 遍历物品
    for (int j = weight[i]; j <= capacity; j++) {  // 从小到大
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

从 **小到大遍历容量**，允许 `dp[j - weight[i]]` 是已经更新过的，意味着当前物品可以用多次。

##### 理解方式

**0-1 背包**：每个物品都是“一次性”的，你用了它，就不能再用了，**必须从“旧状态”推“新状态”，所以容量从大到小**。

**完全背包**：每个物品是“可复用”的，**推状态时可以继续用自己更新过的自己，所以从小到大**。

#### 总结口诀

- **0-1 背包**：容量从 **大到小**，防止**重复使用**

- **完全背包**：容量从 **小到大**，允许**多次使用**

#### 一维线性DP相关的Leetcode 题目

###### 基础线性 DP 表格（爬楼梯、打家劫舍、路径类）

| 题号 | 题目                            | 难度   | 状态定义 `dp[i]`      | 状态转移                                      |
| ---- | ------------------------------- | ------ | --------------------- | --------------------------------------------- |
| 70   | Climbing Stairs                 | Easy   | 到达第 i 阶的方法数   | `dp[i] = dp[i-1] + dp[i-2]`                   |
| 746  | Min Cost Climbing Stairs        | Easy   | 到达第 i 阶的最小花费 | `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`     |
| 198  | House Robber                    | Medium | 抢到第 i 家的最大金额 | `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`     |
| 213  | House Robber II                 | Medium | 环状抢劫（拆两段）    | `max(rob(0, n-2), rob(1, n-1))`               |
| 121  | Best Time to Buy and Sell Stock | Easy   | 第 i 天前最大利润     | `dp[i] = max(dp[i-1], prices[i] - min_price)` |

###### 子数组/子序列类线性 DP

| 题号 | 题目                                      | 难度   | 状态定义 `dp[i]`     | 状态转移                                          |
| ---- | ----------------------------------------- | ------ | -------------------- | ------------------------------------------------- |
| 53   | Maximum Subarray                          | Easy   | 以 i 结尾的最大和    | `dp[i] = max(dp[i-1] + nums[i], nums[i])`         |
| 152  | Maximum Product Subarray                  | Medium | 以 i 结尾的最大乘积  | 需维护 `max[i]` 和 `min[i]`                       |
| 300  | Longest Increasing Subsequence            | Medium | 以 i 结尾的 LIS 长度 | `dp[i] = max(dp[j] + 1)` if `nums[i] > nums[j]`   |
| 674  | Longest Continuous Increasing Subsequence | Easy   | 连续递增子序列长度   | `dp[i] = (nums[i] > nums[i-1]) ? dp[i-1] + 1 : 1` |

###### 背包/组合类线性 DP

| 题号 | 题目                       | 难度   | 状态定义 `dp[i]`          | 状态转移                               |
| ---- | -------------------------- | ------ | ------------------------- | -------------------------------------- |
| 322  | Coin Change                | Medium | 凑出金额 i 所需最少硬币数 | `dp[i] = min(dp[i], dp[i - coin] + 1)` |
| 518  | Coin Change II             | Medium | 凑出金额 i 的组合数       | 完全背包：正序遍历                     |
| 139  | Word Break                 | Medium | s[0..i) 是否可由字典组成  | `dp[i]                                 |
| 416  | Partition Equal Subset Sum | Medium | 能否用子集凑出 sum/2      | 01 背包：逆序遍历                      |
| 377  | Combination Sum IV         | Medium | 和为 target 的排列个数    | `dp[i] += dp[i - num]` (排列考虑顺序)  |

###### 进阶类线性 DP

| 题号 | 题目                                          | 难度   | 状态定义 `dp[i]`              | 状态转移                       |
| ---- | --------------------------------------------- | ------ | ----------------------------- | ------------------------------ |
| 673  | Number of LIS                                 | Medium | 以 i 结尾的最长递增子序列个数 | 结合 LIS + 计数                |
| 123  | Best Time to Buy and Sell Stock III           | Hard   | 最多交易两次的最大利润        | 多状态 DP，但可压缩为线性      |
| 309  | Best Time to Buy and Sell Stock with Cooldown | Medium | 带冷却期的交易                | 维护 hold, sold, rest 三种状态 |
| 91   | Decode Ways                                   | Medium | 字符串解码方式数              | `dp[i] = dp[i-1] (+ dp[i-2])`  |



### 二维动态规划（区间或者状态组合）

#### 二维动态算法解决了什么问题？- 具有两个维度的问题

适用于解决**`问题具有两个维度（区间，状态组合）`**的场景

适用用最长公共子序列、背包问题、编辑距离

| 应用场景类型 | 举例                                            | Leetcode |
| ------------ | ----------------------------------------------- | -------- |
| 区间类问题   | 最小/最大合并代价、戳气球、回文划分、矩阵链乘法 | 321，132 |
| 状态组合类   | 背包、编辑距离、字符串匹配、最长公共子序列      | 1143，72 |
| 博弈问题     | 石子游戏、谁先取胜                              |          |

#### 二维动态规划的核心核心-二维数组保存字问题的最优解

将原问题拆解为子问题，并用一个二维数组保存子问题的最优解，以避免重复计算。

**通常用一个 `dp[i][j]` 表示从状态 `i` 到状态 `j` 的最优值**。

#### 二维动态规划的原理是什么？

本质上所有的动态规划本质都是基于`最优子结构`+`重叠子问题`。

二维动态规划的特点是：

- 状态 `dp[i][j]` 依赖于 `i` 和 `j` 的组合

- 需要根据问题特性设计转移方程，比如

  ```java
  for (int len=2;len<=n;len++){
    for (int =0;i+len-1<n;i++){
      int j = i+len-1;
      for (int k=i;k<j;k++){
        //需要根据问题的特征设计转移方程
        dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+cost);
      }
    }
  }
  ```

#### 套路模板

| 类型       | 状态定义                       | 遍历顺序             | 状态转移方式                                       |
| ---------- | ------------------------------ | -------------------- | -------------------------------------------------- |
| 区间型     | `dp[i][j]` 表示区间[i,j]最优值 | 从小区间到大区间     | 枚举划分点 `k`，合并子区间 `dp[i][k] + dp[k+1][j]` |
| 状态组合型 | `dp[i][j]` 表示两个状态的组合  | 按 `i`、`j` 顺序遍历 | 根据状态是否相等，决定 `dp[i][j]` 怎么转移         |

##### 区间动态模型

###### 区间类动态规划问题的特征

- 要处理一个连续区间`[i,j]`
- 求出该区间的`最小代价/最大得分`
- 通常是`合并`,`划分`，`组合`，`爆破`类型，比如戳气球，合并石子，回文切割等

```java
//定义DP数组
int n = ...;
int[][] dp = new int[n][n];

//初始化
for(int i=0;i<n;i++){
  dp[i][i] = baseCase;
}

//按照区间长度枚举
//枚举长度不同的区间，长度从2到n，并计算所有不同长度的区间的最值
//对于每一种不同长度，利用滑动窗口枚举所有的区间，并计算他们的最值
//枚举不从的长度区间，从2到n
for(int len=2;len<=n;len++){
  //从做到右滑动窗口遍历所有长度为len的区间
  //第一个窗口的起点为0;
  int firstStart = 0;
  //最后一个窗口的终点为n-len+1;
  int lastStart = n-len+1;
  for (int start = firstStart;satrt<= lastStart;start++){
    //区间的结束为止为start+len-1
    int end=start+len-1;
    // 设置dp[start][end]初始值为MAX_VALUE(求最小值，则设置默认值为MAX_VALUE)
    dp[start][end]=Integer.MAX_VALUE;
    // 更新dp数组值
    for (int k=start;k<end;k++){
      //最小值为区间[i,k]最优值+[k+1,j]最优值+
      dp[i][j]=Math.min(dp[i][j],dp[i][k]+dp[k+1][j]+cost[i][j]);
    }
  }
}
```

###### `dp[i][j]` 表示什么意思？

表示处理区间`[i,j]`所需的最优值（最小/最大代价、最多得分）

- 合并 `[i...j]`这一段石子所需要的最小花费
- 爆破`[i...j]`的气球后的最多得分

###### 为什么要按照`区间长度len`进行枚举？

因为我们是**从短区间开始构建大区间的解**

比如要算`[0,4]`的最优解，你需要先有`[0,1]`,`[1,2]`,`[2,3]`,`[3,4]`这些子区间的结果

遍历的顺序就是

- 长度为2的区间`[0,1]`,`[1,2]`,`[2,3]`,`[3,4]`
- 长度为三的区间 `[0,2]`,`[1,3]`,`[2,4]`...

这是构建更大的区间的基础。

###### `for (int i = 0; i + len - 1 < n; i++)` 是什么意思？

这一步枚举所有**长度为 `len` 的区间** `[i, j]`：

```
int j = i + len - 1; // 区间右端点
```

举例：`len = 3` 时，合法区间包括 `[0,2]`, `[1,3]`, `[2,4]`, … 直到 `j < n`。

###### `for (int k = i; k < j; k++)` 是干什么的？

这一层是**枚举区间 `[i, j]` 的划分点** `k`，将它拆成两个子区间：

```
[i, j] 划分为：
- 左：dp[i][k]
- 右：dp[k+1][j]
```

然后通过子区间合并推导出当前区间的最优解：

```
dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + cost[i][j]);
```

> `cost[i][j]` 是区间合并的额外代价（视题目而定，比如合并的总和、戳爆某个气球等）

###### 初始化：`dp[i][i] = baseCase`

表示当区间只有一个元素（即 `i==j`）的时候，处理这个区间的最优解。

- 通常是 0（表示无需操作）
- 有些题可能是初始值（如自己本身的得分）

###### 套路口诀

```
定义状态要动脑，区间组合最基本；
单点初始化，区间长度推；
从短到长搞枚举，划分区间靠中点；
合并子区间，加上代价得最优；
转移方程最关键，调试细节多验证。
```



##### 最优解问题-合并石子算法

> 有一堆石子，每次只能合并相邻的两个堆，代价是两个堆的总和。求把所有石子合并成一堆的最小代价。

- 石子数组为 `stones = [4, 1, 3, 2]`
- 我们希望用区间 DP 求最小合并代价

###### 解法关键点(DP套路)

###### 定义状态数组`dp[i][j]`

- `dp[i][j]`表示将从`stones[i]`到`stones[j]`的石子合并以后所需要的最大代价（注意题干的描述，每次只能合并`相邻`的石子）
- `sum[i][j]`表示这段区间的总和，用于`合并代价`

###### 定义状态转移方程

`dp[i][j]=dp[i][k]+dp[k+1][j]+sum[i,j]`

###### 定义初始状态

? 没有初始状态？

```java
public int merge(int[] stones){
  int n = stones.length;
  int[][] dp = new int[n][n];
  
  for (int len=2;len<=n;len++){
    for (int i=0;i+len<n;i++){
      int j = i+len-1;
      dp[i][j] = Integer.MAX_VALUE;
      for (int k=i;k<j;k++){
        dp[i][j] = Math.min(dp[i][j],dp[i][k]+dp[k+1][j]+sum(stones,i,j));
      }
    }
  }
}


private int sum(int[] stones, int i, int j){
  int sum=0;
	for(int m=i;m<=j;m++){
    sum +=stones[m];
  }
  return sum;
}
```



#####状态组合动态规划

###### 什么是二维状态组合型动态规划？

在二维状态组合型 DP 中，每个状态由 **两个变量** 决定，通常形式为：

```
dp[i][j] = 表示某个以 i 和 j 为维度的子问题的最优解
```

这两个维度可以是：

| i          | j            | 示例含义               |
| ---------- | ------------ | ---------------------- |
| 元素索引   | 容量/时间    | 背包问题、时间分配问题 |
| 行号       | 列号         | 路径问题、棋盘类问题   |
| 子序列长度 | 最后一个字符 | 字符串匹配类问题       |
| 子集个数   | 和/差值      | 子集和问题、分割类问题 |

###### 状态组合的含义与模板结构-01背包问题

给定

- 一个容量为`w`的背包
- `n`个物品，每个物品有：
  - 重量`w[i]`
  - 价值`v[i]`

目标：从`n`个物品中选择若干个，使得他们的总重量不超过`w`，且总价值最大

**每个物品只能选择或者不选择，不能够选择一半或者部分**。

**状态定义**

先定义 `dp[i][j]` 表示什么。常见定义：

- `dp[i][j] = 使用前 i 个元素，容量为 j 时的最大值`
- `dp[i][j] = 到达坐标 (i, j) 的最小路径和`

**状态转移方式**

```
dp[i][j] = 状态组合(dp[i-1][j], dp[i][j-1]...) + 当前贡献值
```

或者

```
dp[i][j] = max/min(dp[...], dp[...])
```

###### 模板代码结构（Java）-01背包问题

**状态定义**

`dp[i][j]` 表示前 `i` 个物品，在容量为` j` 时的最大总价值(**记忆下来**，后续套路可用)

**状态转移方程**

- 如果前`i-1`个物品在容量为`j`的情况下最大价值为`dp[i-1][j]`
- 那么要使前`i`个物品在容量为`j`的情况下价值最大：
  - 不选择物品`i`,则为`dp[i-1][j]`
  - 选择物品`i`，则变成前`i-1`个物品在容量为`j-weight[i]`的情况下再加上物品`i`的价值`v[i]`

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])
```

当前最大值为`选择当前物品`和`不选择当前物品`两种情况下下的`较大者`:

- 不选择当前物品：`dp[i-1][j]` 

- 选当前物品（前提是` j >= weight[i]`）：`dp[i-1][j - weight[i]] + value[i]`

  选中当前物品的情况下，最大总价值为(**这个公式十分重要，如果有必要的话记忆下来**)

  **前`i-1`个物品在容量为`当前容量`-`当前物品重量(j-weigt[i])`情况下的`最大值[d[i-1][j-weight[i]]]`+`当前物品的价值(values[i])`**

  

###### 代码套路模板

```java
public int knapsack(int[] weights, int[] values, int capacity){
  int n = weights.lengthl;
  // 套路步骤一，定义状态dp[i][j]
  //注意这里数组的dp[0][0]是不使用的,dp[0][0]=0;
  //注意物品编号和实际数组下标的关系
  int[][] dp = new int[n+1][capacity+1];
  
  for (int i=1;i<=n;i++){
    int w = weights[i-1];
    int v = values[i-1];
    for (int j=0;j<= capacity;j++){
      // 套路，状态转移过程
      if (j<w){
        //如果当前物品的重量大于背包的当前总容量，那么dp[i][j] = dp[i-1][j](为不选择物品i的最大价值)
        d[i][j] = dp[i-1][j];
      }else{
        //如果当前物品重量小于等于背包的当前总容量，那么dp[i][j] 为以下两种情况之下的较大值
        // 1. 不选中该物品dp[i-1][j]
        // 2. 选中该物品 dp[i-1][j-w]+v
        dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-w]+v);
      }
    }
  }
  return dp[n][capacity];
}
```

##### 相关Leet code题目

| 题目       | 类型       | 链接         |
| ---------- | ---------- | ------------ |
| 01背包     | 背包       | Leetcode 416 |
| 最小路径和 | 路径       | Leetcode 64  |
| 编辑距离   | 字符串编辑 | Leetcode 72  |