# 组合计数类问题

##问题要点

**场景 (Scenario):** 通常题目会要求在一个满足特定规则的集合中，计算出所有有效“方案”、“方法”、“序列”、“组合”的总数。

**目标 (Goal):** 输出一个整数，代表**方案总数**。

由于结果可能非常大，题目常常要求对一个大的质数（如 $10^9+7$）取模。

## 核心思想和套路

解决组合计数问题，基本上可以归结为以下几种核心思路和方法。

通常需要根据数据范围和问题特性来选择最合适的一种或多种组合使用。

### 套路一： 万能方法 - 暴力搜索 - DFS/回溯

这是最直观的“万能”方法，也是思考所有计数问题的起点。

#### 使用场景

- 数据规模小
- 问题约束复杂，难以找到清晰的数学规律或者递推关系
- 作为验证其他方法正确性的小数据量对拍程序

#### 核心思想 - 利用回溯枚举所有可能的情况

- 递归地枚举所有可能的情况。
- 在递归的每一步，根据题目的约束条件进行“剪枝”，去掉无效的选择。
- 当构造出一个完整的、有效的方案时，计数器加一。

#### 代码套路模板

以投骰子问题为例。

问题可以转化为一个图的DFS问题。

对于每一个当前位置，其节点便是当前所投出的值，邻居便是所有的六种可能的值。



```Java
class Solution {
    long count = 0;
    int MOD = 1_000_000_007;

    public int solve(int n, ...args) {
        dfs(0, new ArrayList<>(), ...args);
        return (int) count;
    }

    // index: 当前处理到第几个位置
    // path: 当前已经构建的路径/方案
    private void dfs(int index, List<Integer> path, ...args) {
        // 剪枝：如果当前路径已经不合法，提前返回
        if (!isValid(path)) {
            return;
        }

        // 递归终止条件：成功构建了一个完整方案
        if (index == n) {
            count = (count + 1) % MOD;
            return;
        }

        // 遍历当前位置的所有可能选择
        for (int choice = 1; choice <= 6; choice++) { // 假设是掷骰子
            path.add(choice);
            dfs(index + 1, path, ...args);
            path.remove(path.size() - 1); // 回溯，撤销选择
        }
    }
}
```

#### 题目集合

| LeetCode #                                    | 题目                   | 高频原因与解题思路                                           |
| --------------------------------------------- | ---------------------- | ------------------------------------------------------------ |
| **78. Subsets**                               | **子集**               | **(必考基础)** 这是回溯法的“Hello World”。考察如何通过递归构建一个集合的所有子集。核心思路是对于每个元素，都有“选”和“不选”两种决策，通过 DFS 遍历这棵决策树。 |
| **46. Permutations**                          | **全排列**             | **(必考基础)** 考察如何生成一个集合的全排列。与“子集”不同，这里需要考虑元素的顺序。核心思路是使用一个 `used` 数组来标记哪些元素已被使用，每次从未被使用的元素中选择一个加入当前排列。 |
| **39. Combination Sum**                       | **组合总和**           | **(高频变体)** 考察在包含重复元素的集合中（但每个元素可无限次使用），找出和为目标值的所有组合。这是“子集”问题的变体，关键在于 DFS 的下一层递归是从当前索引开始，而不是 `index + 1`，以此来表示元素可以重复使用。 |
| **17. Letter Combinations of a Phone Number** | **电话号码的字母组合** | **(高频实用)** 一个非常经典的面试题，将实际问题抽象成回溯模型。输入数字字符串，输出所有可能的字母组合。本质上也是一个多层决策树，每一层代表一个数字，分支是该数字对应的所有字母。 |
| **131. Palindrome Partitioning**              | **分割回文串**         | **(综合应用)** 将回溯与字符串处理结合。要求将一个字符串分割成若干子串，使得每个子串都是回文串。核心思路是 DFS 遍历所有可能的分割点，对分割出的前缀子串判断是否为回文，如果是，则继续对剩余部分进行递归分割。 |

### 套路二：最核心的方法 - 动态规划

这是组合计数问题**最核心、最常见**的解决方法。

#### 动态规划方法的适用场景

- 数据规模较大（例如 n 可达 $10^3 \to 10^5$）。

- 问题可以被分解为**规模更小**、**结构相同**的重叠子问题。

- 问题的**约束是“局部”的**，即第 `i` 步的决策只与前面有限几步（通常是第 `i-1` 步）的状态有关。

#### 动态规划方法的核心思想

##### 状态定义：`dp[问题规模i][问题状态j]`

设计 `dp` 数组，`dp[i][j]...` 的含义必须能清晰地描述一个子问题的解。

通常 `i` 代表问题规模（如序列长度），`j` 等其他维度代表子问题的“状态”（如结尾字符、当前总和等）。

##### 状态转移方程: `dp[i][...]` 如何由 `dp[i-1][...]` 或其他更小的子问题推导出来?

这是最关键的一步，思考 `dp[i][...]` 如何由 `dp[i-1][...]` 或其他更小的子问题推导出来。

##### 确定边界/初始条件

- `dp[0]` 或 `dp[1]` 的值是什么，为整个递推提供起点。

#### 代码套路模板

```Java
class Solution {
    public int solve(int n, ...args) {
        int MOD = 1_000_000_007;

        // 1. 定义状态: dp[i][j] 表示长度为 i，以状态 j 结尾的方案数
        long[][] dp = new long[n + 1][STATE_COUNT];

        // 2. 初始条件
        dp[0][...] = ...; // 或者 dp[1][...] = ...;

        // 3. 状态转移 (循环递推)
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < STATE_COUNT; j++) {
                // 根据题意，从 dp[i-1] 的某些状态转移而来
                // dp[i][j] = (dp[i-1][k1] + dp[i-1][k2] + ...) % MOD;
            }
        }

        // 4. 计算最终结果
        long result = 0;
        for (int j = 0; j < STATE_COUNT; j++) {
            result = (result + dp[n][j]) % MOD;
        }
        return (int) result;
    }
}
```

#### DP的变种或者优化

- **记忆化搜索:** 自顶向下的DP实现，逻辑更接近DFS，但增加了备忘录来避免重复计算。
- **状态压缩DP:** 当状态 `j` 可以用一个二进制数表示时使用。
- **数位DP:** 专门解决“计算 `[L, R]` 区间内满足特定数位性质的整数个数”的问题。

#### 题目集合

| LeetCode #                         | 题目                 | 高频原因与解题思路                                           |
| ---------------------------------- | -------------------- | ------------------------------------------------------------ |
| **62. Unique Paths**               | **不同路径**         | **(DP入门典范)** 一个机器人在 m x n 网格中从左上角走到右下角，有多少种走法。`dp[i][j]` 定义为到达格子 `(i, j)` 的路径数，状态转移方程为 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。 |
| **70. Climbing Stairs**            | **爬楼梯**           | **(最简单的DP)** 爬 n 阶楼梯，每次可以爬1或2阶。这是最经典的斐波那契数列问题。`dp[i]` 定义为爬到第 `i` 阶的方法数，`dp[i] = dp[i-1] + dp[i-2]`。用于考察最基本的 DP 思想。 |
| **377. Combination Sum IV**        | **组合总和 IV**      | **(背包思想)** 给定不同整数的数组 `nums` 和一个目标 `target`，找出和为 `target` 的组合个数（**顺序不同视为不同组合**）。这是典型的完全背包计数问题。`dp[i]` 定义为和为 `i` 的组合数，`dp[i] = sum(dp[i - num]) for num in nums`。 |
| **91. Decode Ways**                | **解码方法**         | **(序列型DP)** 将数字字符串解码成字母，求总方法数。`dp[i]` 定义为字符串前 `i` 个字符的解码方法数。转移时需要考虑 `s[i-1]` 单独解码，以及 `s[i-2:i]` 组合解码两种情况，并判断其合法性。 |
| **96. Unique Binary Search Trees** | **不同的二叉搜索树** | **(卡特兰数)** 给定 `n`，求由 `1...n` 这 `n` 个节点能构成多少种不同的二叉搜索树。`dp[i]` 定义为 `i` 个节点能构成的不同BST数量。枚举 `j` (`1` 到 `i`) 作为根节点，则左子树有 `j-1` 个节点，右子树有 `i-j` 个节点，`dp[i] += dp[j-1] * dp[i-j]`。 |

#### Leetcode 62: 矩阵左上角到右下角的路径数量

```Java
//机器人从左上角走到右下角的路径的数量
//机器人智能向右走或者向下走
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //到[0,0]的路线只有一个
        dp[0][0] = 1;
        for(int i = 1; i < m; i++){
            dp[i][0] = 1;
        }

        for(int j = 1; j < n; j++){
            dp[0][j] = 1;
        }

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
```

#### Leetcode 377: 组合总和 IV - 使用完全背包解决排列问题

**(背包思想)** 给定不同整数的数组 `nums` 和一个目标 `target`，找出和为 `target` 的组合个数（**顺序不同视为不同组合**）。这是典型的完全背包计数问题。

这是一个完全背包解决排列问题。

##### 需要特别注意完全背包的转化方程



```Java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;
        int[][] dp = new int[n+1][target+1];

        dp[0][0] = 1;
        //dp[0][j] = 0;
        //dp[i][0] = 1;

        for(int i = 1; i <= n; i++){
            dp[i][0] = 1;
        }
        for(int j = 1; j <= target; j++){
          //需要特别注意完全背包的转化方程
            for(int i = 1; i <= n; i++){
                int num = nums[i-1];
                dp[i][j] = dp[i-1][j];
                if(j >= num){
                    dp[i][j] += dp[n][j-num]//dp[n][j-num]，不是dp[i][j-num]!;
                }
            }
        }
        return dp[n][target];
    }
}
```

#### Leetcode 96: **不同的二叉搜索树**

给定 `n`，求由 `1...n` 这 `n` 个节点能构成多少种不同的二叉搜索树。

`dp[i]` 定义为 `i` 个节点能构成的不同BST数量。

枚举 `j` (`1` 到 `i`) 作为根节点，则左子树有 `j-1` 个节点，右子树有 `i-j` 个节点，`dp[i] += dp[j-1] * dp[i-j]`。

解析详见二叉树章节。

```Java
class Solution {
    public int numTrees(int n) {
        //dp[i]表示以i为根节点的二叉搜索树有多少？
        //dp[i] = dp[i-1] * dp[n-i];
        int[] dp = new int[n+1];
        //null树也得算上
        dp[0] = 1;
        // dp[1] = 1;

        for(int i = 1; i <= n; i++){
           for(int j = 1; j <=i; j++){
            dp[i] += dp[j-1] * dp[i-j];
           }
        }
        return dp[n];
    }
}
```

#### Leetcode 91: 不同的解码方法

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
"1" -> 'A' "2" -> 'B' ... "25" -> 'Y' "26" -> 'Z'
```

然而，在 **解码** 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（`"2"` 和 `"5"` 与 `"25"`）。

例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1, 1, 10, 6)`
- `"KJF"` ，将消息分组为 `(11, 10, 6)`
- 消息不能分组为 `(1, 11, 06)` ，因为 `"06"` 不是一个合法编码（只有 "6" 是合法的）。

注意，可能存在无法解码的字符串。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。如果没有合法的方式解码整个字符串，返回 `0`。

题目数据保证答案肯定是一个 **32 位** 的整数。

#### 实现代码

```Java
class Solution {
    public int numDecodings(String s) {
        if(s.startsWith("0")) return 0;
        if(s.contains("00")) return 0;
        int n = s.length();
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            char curr = s.charAt(i-1);
            if(curr == '0'){
                if(i < 2) {
                    dp[i] = 0;
                }else{
                    char prev = s.charAt(i-2);
                    int num = (prev - '0') * 10 + (curr - '0');
                    if(num <= 20){
                      dp[i] = dp[i-2];
                    }else{
                        dp[i] = 0;
                    }
                }
                
            }else{
                dp[i] = dp[i-1];
                char prev = s.charAt(i-2);
                int num = (prev - '0') * 10 + (curr - '0');
                if(10 < num && num <= 26){
                    dp[i] += dp[i-2];
                }
            }
        }
        return dp[n];
    }
}
```

#### Leetcode 1155 [掷骰子等于目标和的方法数](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/)

这里有 `n` 个一样的骰子，每个骰子上都有 `k` 个面，分别标号为 `1` 到 `k` 。

给定三个整数 `n`、`k` 和 `target`，请返回投掷骰子的所有可能得到的结果（共有 `kn` 种方式），使得骰子面朝上的数字总和等于 `target`。

由于答案可能很大，你需要对 `109 + 7` **取模**。

##### 问题的本质 - 分组背包问题

- **背包容量 (Capacity):** `target` (目标总和)
- **物品 (Items):** 这里有 `n` 个 "物品组"，代表 `n` 个骰子。
- **物品的选择 (Choices):** 对于第 `i` 个骰子（第 `i` S- "组"），你**必须**从中选择一个 "物品"，这个 "物品" 的 "重量" (或 "价值") 就是它的点数 `val`（`val` 可以在 1 到 `k` 之间）。
- **目标 (Goal):** 找到恰好装满背包（总和为 `target`）的方法总数。

由于你必须从 `n` 个组中各选一个，这使其成为一个经典的计数型DP。

##### 核心思想和套路 - 计数型DP

这是一个非常典型的**动态规划 (Dynamic Programming)** 问题，具体来说，它属于 **“计数型DP” (Counting DP)**。

它最常被归类为**背包问题 (Knapsack Problem)** 的一种变体。



#####应当使用的范式套路

解决这类计数型DP，我们通常使用以下“三板斧”范式：

######步骤一：定义状态 (State Definition)



我们通常需要至少两个维度来定义状态：

- `dp[i][j]`：表示**使用 `i` 个骰子**，掷出的**总和恰好为 `j`** 的**方法总数**。

######步骤二：状态转移方程 (State Transition)



我们要计算 `dp[i][j]`（用 `i` 个骰子凑成 `j`），可以考虑第 `i` 个骰子掷出了什么。

第 `i` 个骰子可以掷出 `val`（其中 $1 \le val \le k$）。

如果第 `i` 个骰子掷出了 `val`，那么前 `i-1` 个骰子就必须凑成 `j - val`。

因此，`dp[i][j]` 等于所有可能情况的总和：

- 第 `i` 个骰子掷出 1，前 `i-1` 个骰子凑成 `j-1` (方法数: `dp[i-1][j-1]`)
- 第 `i` 个骰子掷出 2，前 `i-1` 个骰子凑成 `j-2` (方法数: `dp[i-1][j-2]`)
- ...
- 第 `i` 个骰子掷出 `k`，前 `i-1` 个骰子凑成 `j-k` (方法数: `dp[i-1][j-k]`)

把它们加起来（并且别忘了取模 $10^9 + 7$）：

$$dp[i][j] = (dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-k]) \mod (10^9 + 7)$$

(注意：要确保 `j-val` 是有效的，即 `j-val >= 0`)

###### 步骤三：初始化 (Base Case)



- `dp[0][0] = 1`
  - **含义：** 使用 0 个骰子，凑成总和 0，有且只有一种方法（就是什么都不做）。
- 所有其他的 `dp[0][j]` (当 `j > 0` 时) 都为 0。

###### 步骤四：最终答案 (Final Answer)



根据我们的状态定义，最终答案就是：`dp[n][target]`。

##### 实现代码

```Java
//本质上是什么？
//求方法数
//现在的状态是没有能够识别其范式和题型
class Solution {
    private final int MOD = 1000000007;
    public int numRollsToTarget(int n, int k, int target) {
        //dp[i][j]使用N个骰子，投出J值的方法
        int[][] dp = new int[n+1][target+1];
        dp[0][0] = 1;
        //dp[0][1...Target] = 0
        //dp[1...N][0] = 0

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= target;j++){
                dp[i][j] = 0;
                for(int v = 1; v <= k; v++){
                    if(j >= v){
                        dp[i][j] = (dp[i][j] + dp[i-1][j-v]) % MOD;
                    }
                }
            }
        }
        return (int)dp[n][target];
    }
}
```



### 套路三： 组合数学公式

当问题可以抽象为经典的数学模型时，可以直接求解。

#### 适用场景

- 问题不关心具体的序列，只关心元素的构成。
- 问题可以转化为“选择”、“排列”、“分配”等标准模型。
- 常见模型：
  - **排列 (Permutation):** 从n个不同元素中取k个，考虑顺序。$A_n^k=\frac {n!}{(n−k)!}$
  - **组合 (Combination):** 从n个不同元素中取k个，不考虑顺序。$C_n^k=\frac{n!k!}{(n−k)}$
  - **隔板法 (Stars and Bars):** 将n个相同物品分给k个不同的人，要求每人至少一个。相当于在n-1个空中插k-1个板。方案数为 $C_{n−1}^{k−1}$。

#### 核心思想 - 将问题抽象成数学公式

- 将问题抽象成数学模型。

- 使用公式计算。

- 在模运算下，除法需要用**乘法逆元**来计算。通常使用费马小定理或扩展欧几里得算法预处理阶乘和阶乘的逆元。

#### 代码套路模板

代码套路模板 (计算组合数 $C_n^k\pmod{M}$):

```java
class Solution {
    int MOD = 1_000_000_007;
    long[] fact; // 存储阶乘
    long[] invFact; // 存储阶乘的逆元

    // 快速幂，用于求逆元
    long power(long base, long exp) {
        long res = 1;
        base %= MOD;
        while (exp > 0) {
            if (exp % 2 == 1) res = (res * base) % MOD;
            base = (base * base) % MOD;
            exp /= 2;
        }
        return res;
    }

    // 费马小定理求逆元 (要求 MOD 是质数)
    long modInverse(long n) {
        return power(n, MOD - 2);
    }

    // 预处理阶乘和逆元
    void precompute(int maxN) {
        fact = new long[maxN + 1];
        invFact = new long[maxN + 1];
        fact[0] = 1;
        invFact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
            invFact[i] = modInverse(fact[i]);
        }
    }

    // 计算组合数
    long combinations(int n, int k) {
        if (k < 0 || k > n) {
            return 0;
        }
        return fact[n] * ((invFact[k] * invFact[n - k]) % MOD) % MOD;
    }

    public int solve(int n, int k) {
        precompute(n);
        return (int) combinations(n, k);
    }
}
```

#### 题目集合

| LeetCode #                         | 题目                 | 高频原因与解题思路                                           |
| ---------------------------------- | -------------------- | ------------------------------------------------------------ |
| **62. Unique Paths**               | **不同路径**         | **(排列组合)** 同一个问题，换个角度思考。从 `(0,0)` 到 `(m-1, n-1)`，总共需要走 `(m-1) + (n-1)` 步，其中必须有 `m-1` 步是向下走（或 `n-1` 步向右走）。问题转化为在 `m+n-2` 步中选择 `m-1` 步向下的组合数，即 `C(m+n-2, m-1)`。 |
| **77. Combinations**               | **组合**             | **(组合定义)** 如果题目只是问从 `n` 个数中取 `k` 个的组合**数量**是多少，而不是要生成所有组合，那么可以直接套用组合公式 `C(n, k) = n! / (k! * (n-k)!)`。虽然原题要求生成所有组合，但理解其数学本质是关键。 |
| **118. Pascal's Triangle**         | **杨辉三角**         | **(二项式系数)** 杨辉三角的每个数 `C(n, k)` 就是二项式系数，代表组合数。这道题本身就是对组合公式性质的可视化，考察你对 `C(n, k) = C(n-1, k-1) + C(n-1, k)` 这个递推公式的理解。 |
| **60. Permutation Sequence**       | **排列序列**         | **(阶乘/康托展开)** 找出 `n` 个数的全排列中第 `k` 个排列是什么。暴力生成所有排列再取第 `k` 个会超时。正确做法是利用阶乘的性质，逐位确定第 `k` 个排列的数字。例如，对于 `n` 个数，以某个数开头的排列有 `(n-1)!` 种，可以用 `k` 去除以 `(n-1)!` 来确定第一位是什么数字。 |
| **96. Unique Binary Search Trees** | **不同的二叉搜索树** | **(卡特兰数)** 这题的 DP 解法本质上是在推导卡特兰数的递推式。如果面试者知道卡特兰数，可以直接说出其通项公式 Cn=n+11C2nn，这能极大地展示其数学功底。 |

匯出到試算表

###套路四： 容斥原理 - 至少/至多/不包含

当“至少满足一个条件”的情况难以计算，而“一个都不满足”或“同时满足多个特定条件”的情况更容易计算时使用。

#### 使用场景

- 题目包含“至少”、“至多”、“不包含”等否定性或复杂性的约束。

- “正难则反”的思路。

#### 核心思想 - 容斥原理

- 方案总数 = (至少满足0个约束) - (至少满足1个约束) + (至少满足2个约束) - ...
- 符号 `+` 或 `-` 取决于满足的约束个数是偶数还是奇数。

#### 实现原理和实现步骤

#####容斥原理的简单解释

######实现原理

容斥原理的本质是**修正重复计算**。

当我们想求几个集合并集的大小（即“至少满足一个条件”的方案数）时，一个最朴素的想法是直接把每个集合的大小加起来。

但这样做，多个集合重叠的部分（即“同时满足多个条件”的方案）就被重复加了多次。

容斥原理就是一套精确的“加加减减”的修正流程。

######使用例子来解释

假设一个班里，喜欢数学的有 A 个人，喜欢语文的有 B 个人。问“至少喜欢一门学科”的人数。

1. **初步相加（包含多了）：** 我们先简单地把人数相加：A+B。
2. **发现问题：** 那些**同时喜欢数学和语文**的人，在计算 A 时被算了一次，在计算 B 时又被算了一次。他们被重复计算了。
3. **减去重复（修正）：** 为了修正，我们必须减去这个被重复计算的部分，也就是“同时喜欢数学和语文”的人数，记为 $∣A\cap{B}∣$。
4. **得到公式：** 所以，总人数 = $∣A∣+∣B∣−∣A\cap{B}∣$。

如果再加一门“喜欢英语”的（集合 C），情况会更复杂：

1. **初步相加：** $∣A∣+∣B∣+∣C∣$
2. **减去两两重叠的：**$ −(∣A\cap{B}∣+∣A\cap{C}∣+∣B\cap{C}∣)$
3. **发现新问题：** 那些**三门都喜欢**的人（AcapBcapC），在第一步被加了3次，在第二步作为三个交集的一部分，又被减了3次。结果他们现在一次都没被算进去，这不对。
4. **再次修正：** 我们必须把三门都喜欢的这部分人再加回来：$+∣A\cap{B}\cap{C}∣$。

######原理总结

这个过程的规律是：

- 先把所有**只满足一个条件**的方案数加起来。
- 再减去所有**同时满足两个条件**的方案数。
- 再加上所有**同时满足三个条件**的方案数。
- 再减去所有**同时满足四个条件**的方案数。
- ...如此交替加减，直到考虑完所有情况。

符号的 `+` 或 `-` 取决于我们正在考虑的“条件组合”的大小是奇数还是偶数。

#####容斥原理的切入点：正难则反

与其费力地“包含”所有合法的分类，不如反过来，从一个更大的、更容易计算的集合中，“排除”掉那些不合法的情况。

这就是潜入在DP中的容斥思想：

`当前状态的合法方案数 = (一个易于计算的“总”方案数) - (其中不合法的方案数)`

- **“总”方案数 (The "Superset"):** 这通常是一个不完全考虑所有约束的、更容易计算的数字。

  在序列型DP中，它常常是**所有上一阶段的合法方案总和**。

  例如，`sum[i-1]`，即任何合法的长度为`i-1`的序列，我们都先假设可以在其末尾添加当前元素。

- **不合法的方案数 (The "Invalid Set"):** 这是指在“总”方案数中，有哪些方案在添加了当前元素后，恰好“首次”违反了某个约束条件。
  - **追溯源头：** 关键在于，这些不合法的方案一定是由某个**特定的、更早阶段的合法状态**转移而来的。我们需要准确地识别并计算出这些“非法源头”的数量。
  - **再次容斥：** 有趣的是，计算这些“非法源头”的数量时，可能又需要用到一次“总数-非法”的逻辑。

##### 实现原理和步骤

###### 定义简化的DP

- 首先，定义一个能够描述问题解的核心状态，但暂时忽略掉那些让转移变得复杂的约束。

- 例如：`dp[i][j]` 代表处理到第 `i` 步，以状态 `j` 结尾的**合法**方案数。
- 同时，常常需要一个辅助数组 `sum[i]` 来记录 `dp[i]` 这一层所有状态的总和。

###### 构想“总数”作为转移的起点:

- 在状态转移的开始，将当前状态 `dp[i][j]` 的值初步设定为一个易于计算的超集。

- 通常是 `dp[i][j] = sum[i-1]`。这一步的含义是：“我们先假设所有来自上一阶段的合法方案都能转移到当前状态”。

###### 识别非法条件

- 精确地找出在第 `i` 步，是什么样的操作或情况会**首次**违反约束。

- 例如：“追加数字 `j` 导致了连续 `k+1` 个 `j` 的出现”。

###### 定位并计算非法之源

- 根据上一步的非法条件，反向推导出这个非法的状态是由哪个**更早的、合法的**状态演变而来的。

- **提问自己：** “一个方案要在第 `i` 步变得非法，那么它在第 `i-1`、`i-2`... 步必须是什么样的？”

- 通过这个追溯，你会定位到一个更小的子问题，例如 `dp[i-k-1][...]` 和 `sum[i-k-1]`。

- 利用这些更小子问题的解，计算出需要被减去的“非法源头”的数量。例如 `invalid_sources = sum[i-k-1] - dp[i-k-1][j]`。

###### 完成状态转移方程

从第2步的“总数”中，减去第4步计算出的“非法源头”数量。

```
dp[i][j] = (sum[i-1] - invalid_sources + MOD) % MOD;
```

务必处理好边界条件。这个减法只在 `i` 足够大，能够容纳整个非法结构时才发生。

###### 整合为标准的DP流程

**创建DP表和辅助表：** `dp[][]`, `sum[]`。

**设置初始条件：** 通常是 `sum[0] = 1` （代表空方案有1种），`dp[0][...]` 为0。

**设计循环：** 按照正确的顺序（通常是 `i` 从 1 到 `n`）进行迭代，确保计算当前状态时，所有依赖的子问题都已被解决。

**提取答案：** 循环结束后，从 `sum[n]` 或 `dp[n][...]` 中得到最终解。

#### 代码套路模板

```java
class Solution {
    // 假设有 m 个约束条件
    public int solve(int n, int m) {
        long totalWays = 0;

        // 遍历所有约束条件的子集 (从 1 到 2^m - 1)
        for (int i = 1; i < (1 << m); i++) {
            int subsetSize = 0;
            // 计算当前子集的大小
            for (int j = 0; j < m; j++) {
                if ((i >> j) & 1) {
                    subsetSize++;
                }
            }

            // 计算同时满足当前子集中所有约束的方案数
            long waysForThisSubset = calculateWays(i, n);

            // 根据子集大小决定是加是减
            if (subsetSize % 2 == 1) {
                totalWays = (totalWays + waysForThisSubset) % MOD; // 奇数加
            } else {
                totalWays = (totalWays - waysForThisSubset + MOD) % MOD; // 偶数减
            }
        }

        // 最终结果可能是 全集 - totalWays，或直接是 totalWays，取决于题目问法
        long universe = calculateAllPossibleWays(n);
        return (int)((universe - totalWays + MOD) % MOD);
    }

    private long calculateWays(int subsetMask, int n) {
        // ... 实现计算特定约束组合下的方案数
        // 这本身可能是一个DP或组合数学问题
        return 0;
    }
}
```

#### Leetcode 1223: 投骰子模拟

##### 问题要点

- **输入数据：**
  - 投骰子次数：`n`
  - `rollMax[6+1]`: 点数`i(1..6)`不能够**连续出现**超过`rollMax[i]`次 

- **目标:** 计算掷 `n` 次骰子的有效序列总数。
- **骰子:** 一个标准的 6 面骰子，点数为 1 到 6。
- **约束:** 对于每个点数 `i` (从 1 到 6)，它不能连续出现的次数超过 `rollMax[i-1]` 次。
- **输出:** 结果需要对 $10^9+7$ 取模。

**例子：**

```
n = 2`, `rollMax = [1, 1, 2, 2, 3, 3]
```

掷两次骰子，总共有 $6\times6$=36 种序列。

无效序列是：(1, 1) 和 (2, 2)，因为 `rollMax[0]=1`, `rollMax[1]=1`。

其他序列如 (3, 3) 是有效的，因为 `rollMax[2]=2`。

所以有效序列总数为 36−2=34。

##### 问题的本质和分析 - **局部约束**的**组合计数**

**计数问题:** 我们要求的是“总共有多少种方法”。

**序列构建:** 问题的解是一个长度为 `n` 的序列。

**约束:** 约束条件（`rollMax`）是“局部”的，它只关心序列的尾部有多少个连续相同的数字，而不关心序列前面的部分。

这种“构建一个长度为n的序列，且在每一步构建时都有特定约束”的特性，强烈暗示了**动态规划 (Dynamic Programming)** 是解决此问题的正确方法。

为什么不能用暴力法？因为总的可能性是 $6^n$，当 `n` 达到 5000 时，这是一个天文数字，暴力枚举所有情况然后检查有效性是绝对不可行的。

##### 背景知识 - 容斥原理

虽然这里没有直接使用复杂的容斥公式，但其核心思想——**“正难则反”**——至关重要。

我们计算 `dp[i][j]` (长度为 `i` 且以 `j` 结尾的序列数) 时，一个巧妙的思路是：先计算出所有可能追加 `j` 的情况（即所有长度为 `i-1` 的有效序列），然后减去那些追加 `j` 后会变得“无效”的情况。

```
（有效数） = （总可能数） - （无效数）
```

##### 模式匹配

- **模式:** 求解构造一个长度为 `n` 的序列，且满足某些限制条件的方案数。
- **常见状态:** `dp[i][j]` 表示 “构造了长度为 `i` 的序列，且该序列以状态 `j` 结尾的方案数”。
  - 在本题中，状态 `j` 就是指骰子的点数。
- **类似问题:**
  - LeetCode 91. 解码方法 (Decode Ways)
  - LeetCode 70. 爬楼梯 (Climbing Stairs)
  - LeetCode 514. 自由之路 (Freedom Trail)
  - 不含连续1的二进制数个数。

这些问题都涉及到一个共同点：第 `i` 步的决策依赖于第 `i-1` 步（或更早的几步）的状态。

##### 核心思想和套路

**核心思想：使用DP，并通过“总数-非法数”的思路来简化状态转移。**

###### 定义DP状态

`dp[i][j]`：表示掷了 `i` 次骰子，且最后一次掷出点数是 `j+1` 的有效序列总数。（`j` 的范围是 `0` 到 `5`）

转化：本质上就是数组的第`i`个值等于`j-1`的有效序列总数。

###### 定义辅助DP状态

我们已经知道$dp[i][j]$表示投了`i`次骰子，并且最后一次投出点数是`j+1`的**有效序列总数**

我们使用`sum[i]`表示掷了 `i` 次骰子的**所有有效序列总数**

显然，$sum[i]=\sum_{j=0}^5dp[i][j]$。

这个 `sum` 数组是优化的关键，它避免了在计算 `dp[i][j]` 时重复地去循环求和。

###### 推到状态转移方程

现在我们想要计算`dp[i][j]`。

**总可能数是多少？**

考虑在**任何**一个长度为`i-1`的有效序列末尾添加一个`j-1`。 这样的序列有多少？

**因为`sum[i]`表示所有长度为`i`的序列的数量**，因此答案就是`sum[i-1]`个。

**无效可能数是多少？**

哪些情况在添加了`j+1`之后会变得无效？

当且仅当原先长度为 `i-1` 的序列已经以 `k = rollMax[j]` 个连续的 `j+1` 结尾时。

**追溯无效的源头？**

一个长度为 `i-1` 且以 `k` 个 `j+1` 结尾的序列，其结构必然是：

- `(一个长度为 i-1-k 的有效序列，其结尾不是 j+1) + (k 个 j+1)`。

**计算无效可能数**

现在我们假设$k = rollMax[j]$， 根据上面的推导，我们需要计算：

长度为 `len = i-1-k` 的有效序列中，结尾不是 `j+1` 的有多少个？

我们已经知道的内容：

- 总数是 `sum[i-1-k]`
- 结尾是 `j+1` 的有 `dp[i-1-k][j]` 个。

所以，结尾不是 `j+1` 的就是 `sum[i-1-k] - dp[i-1-k][j]` 个。

所以这里的无效数量为: $sum[i-1-k] - dp[i-1-k][j]$

**整合状态转移方程**

$dp[i][j] = \underbrace{sum[i-1]}_{\text{总可能数}} - \underbrace{(sum[i-1-k] - dp[i-1-k][j])}_{\text{无效数，其中 k=rollMax[j]}}$

###### 处理边界

这个减法只在 `i-1 >= k` (即 `i > k`) 时才需要执行。

如果 `i <= k`，那么无论如何都不可能凑齐 `k+1` 个连续的 `j+1`，所以没有无效情况。

此时 `dp[i][j] = sum[i-1]`。

特别地，当 `i = k+1` 时，`i-1-k = 0`。

我们需要定义 `sum[0]=1`（代表一个空序列），`dp[0][j]=0`。

此时减去的就是 `sum[0] - dp[0][j] = 1`，正好对应 `j+1` 连续出现 `k+1` 次这一种无效情况。

##### 实现原理和步骤

**初始化:**

- 定义 `MOD = 10^9 + 7`。
- 创建 `dp` 数组: `long[][] dp = new long[n + 1][6];`
- 创建 `sum` 数组: `long[] sum = new long[n + 1];`
- 设置**基础情况 (Base Case):** `sum[0] = 1;` 这代表长度为 0 的序列（空序列）有 1 种。这是所有计算的起点。

**迭代计算:**

- 外层循环 `i` 从 `1` 到 `n` (表示序列长度)。
- 内层循环 `j` 从 `0` 到 `5` (表示骰子点数 `j+1`)。
- **在 `i` 循环开始时，计算 `sum[i-1]`**: `sum[i-1] = (dp[i-1][0] + ... + dp[i-1][5]) % MOD;` (实际上，这个 `sum` 值在上一次 `i` 循环结束时就已经算好了)。

**状态转移:**

- 对于每个 `(i, j)`：
  - `k = rollMax[j]`。
  - **总可能性:** `dp[i][j] = sum[i-1];`
  - **减去非法:**
    - 如果 `i > k` (长度足够产生超限连续数):
      - `long invalid = (sum[i - 1 - k] - dp[i - 1 - k][j] + MOD) % MOD;` (注意 `+MOD` 防止负数)。
      - `dp[i][j] = (dp[i][j] - invalid + MOD) % MOD;`
    - 如果 `i == k` (这里原文是 i > k，但 `i=k+1` 才首次出现问题，我们用 `i>k` 已经是 `i-1-k>=0`，`i=k` 时 `i-1-k` 是负数，逻辑上没问题，但是实现的时候 `i-k` 才是 `rollMax[j]+1` 的长度，所以是 `i > rollMax[j]` 时才需要减。
    - **纠正和简化条件**：`i - k` 是连续 `j` 的数量，当 `i-k=1` 时，连续数是 `k+1`。所以需要减去的条件是 `i - k >= 1`，即 `i > k`。如果 `i <= k`，则不可能有 `k+1` 个连续的 `j`，所以什么都不用减。
    - 修正一下上面 `i==k` 的分析，当 `i == k+1` 时，减去的是 `sum[0]-dp[0][j]=1`，也就是全都是 `j` 的情况。当 `i == k` 时，`i-1-k = -1`，数组越界，但逻辑上此时也不需要减。所以，判断 `i > k` 即可。

**更新 `sum[i]`:**

- 在内层 `j` 循环结束后，更新当前的 `sum[i]` 值：`sum[i] = (sum[i] + dp[i][j]) % MOD;`

**返回结果:**

- 所有循环结束后，最终答案就是 `sum[n]`。

##### 实现代码

```java
class Solution {
    public int dieSimulator(int n, int[] rollMax) {
        int MOD = 1_000_000_007;

        // dp[i][j] := 掷 i 次骰子，最后一次为 j+1 的有效序列数
        long[][] dp = new long[n + 1][6];
        
        // sum[i] := 掷 i 次骰子的所有有效序列总数
        long[] sum = new long[n + 1];

        // Base Case: 长度为 0 的序列（空序列）有 1 种
        sum[0] = 1;

        // 从长度为 1 开始，迭代到 n
        for (int i = 1; i <= n; i++) {
            long currentSum = 0; // 用来计算 sum[i]
            
            // 遍历 6 个可能的结尾点数
            for (int j = 0; j < 6; j++) {
                // 1. 总可能性: 在任何长度为 i-1 的有效序列后加上 j+1
                //    这个数量就是 sum[i-1]
                dp[i][j] = sum[i - 1];

                // 2. 减去无效情况
                //    无效情况是指添加 j+1 后，末尾连续 j+1 的数量超过了 rollMax[j]
                int k = rollMax[j];
                
                // 如果当前长度 i 大于限制 k，才可能出现无效情况
                if (i > k) {
                    // 无效的源头是：一个长度为 i-1-k 的序列，其结尾不是 j+1
                    // 数量为 sum[i-1-k] - dp[i-1-k][j]
                    long invalidCount = (sum[i - 1 - k] - dp[i - 1 - k][j] + MOD) % MOD;
                    dp[i][j] = (dp[i][j] - invalidCount + MOD) % MOD;
                }
                // 特殊情况：如果 i == k，说明新序列结尾是 k 个连续的 j+1。
                // 这时要减去的是 i-1-k = -1 的情况，但我们知道无效序列只有1个，即全部是 j+1。
                // 我们的公式在 i = k+1 时，i-1-k=0，减去 sum[0]-dp[0][j]=1，正好处理了这种情况。
                // 如果 i == k, 那么 i-k=0, 我们需要减去长度为 k+1 的情况，所以是 i=k+1 时才减。
                // 上面的 `if (i > k)` 判断已经包含了 `i=k+1` 的情况，所以逻辑是正确的。
                // 有些实现会写成 if(i >= k+1)，也是一样的。
                
                currentSum = (currentSum + dp[i][j]) % MOD;
            }
            sum[i] = currentSum;
        }
        return (int) sum[n];
    }
}
```

##### 注意事项

- **模运算的正确使用:** 在每一步加法和减法后都进行取模，尤其是在减法中要 `+ MOD` 来防止出现负数。
- **数据类型:** 中间计算结果可能超过 `int` 的范围，使用 `long` 来存储 `dp` 和 `sum` 数组可以避免溢出，最后返回时再转为 `int`。
- **数组索引:** 问题中的 `rollMax` 是针对点数 1-6 的，而我们的 `j` 是 0-5。要确保 `rollMax[j]` 对应的是点数 `j+1` 的限制，代码中已经正确处理了。
- **Base Case 的重要性:** `sum[0] = 1` 是整个递推的基石。它为 `i=1` 的计算提供了 `sum[0]`，也为后续的容斥减法提供了 `sum[0]` 的值。

##### 经验总结

LeetCode 1223 是一个中等偏上难度的动态规划问题，它非常典型地展示了如何处理带序列约束的计数问题。

1. **识别模式:** 看到“求长度为n的序列方案数”且“约束只与结尾有关”，就要立刻想到序列型DP `dp[i][j]`。
2. **化繁为简:** 直接计算 `dp[i][j]` 可能需要考虑多种情况（结尾是1个j，2个j，...）。采用“总数 - 非法”的容斥思想，可以大大简化转移逻辑。
3. **善用辅助空间:** `sum` 数组是本题从 O(ncdot6cdot6) 优化到 O(ncdot6) 的关键。这种用空间换时间的思想在DP优化中很常见。
4. **严谨推导:** DP的核心在于状态转移方程。必须一步步严谨地推导，并用小例子（如 `n=2`, `rollMax=[1,1,1,1,1,1]`）来验证自己的方程是否正确。
5. **细节决定成败:** 模运算、边界条件、数组索引，任何一个细节出错都可能导致错误答案。

通过深入理解这道题，你可以掌握一类重要的DP问题的通用解决思路和技巧。

### 总结： 解题策略流程

#### 分析问题和数据范围

- `n` 很小 (e.g., < 20)? -> 考虑 **DFS/回溯**。

- `n` 很大 (e.g., > 1000)? -> 几乎肯定是 **DP** 或 **数学公式**。

#### 尝试建立模型

- 能否直接套用排列组合公式？约束条件是否简单？ -> **组合数学**

- 约束条件是否复杂，包含“至少/不”？ -> 考虑 **容斥原理**

- 问题是否具有明显的阶段性，且后一阶段只依赖前一阶段？ -> **动态规划**

#### 设计DP

- **状态定义：** `dp[i][...]` 是什么？这是最关键的一步。

- **状态转移：** `dp[i]` 如何从 `dp[i-1]` 得到？考虑所有可能的前置状态。
  - 如果转移逻辑复杂，可以试试用“总数 - 非法”的容斥思想简化转移。

- **初始化：** 边界 `dp[0]` 或 `dp[1]` 是什么？

#### 编码实现

- 注意使用 `long` 防止中间过程溢出。
- 每次加减乘除后及时取模 `MOD`。
- 减法取模注意 `(a - b + MOD) % MOD`。
- 如果用组合数学，记得预处理阶乘和逆元。

#### 题目集合

| LeetCode #                                              | 题目                           | 高频原因与解题思路                                           |
| ------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------ |
| **357. Count Numbers with Unique Digits**               | **计算各个位数不同的数字个数** | **(补集思想)** 求 `[0, 10^n)` 范围内各位数字都不同的数的个数。可以直接正面计算：1位数有10个，2位数的第一位有9种选择(1-9)，第二位有9种选择(0-9中去掉第一位)，... 但也可以用容斥的补集思想：总数 - 至少有两位相同的数。正面计算此题更简单，但体现了“满足A” = “全集U” - “不满足A”的思路。 |
| **902. Numbers At Most N Given Digit Set**              | **最大为 N 的数字组合**        | **(Digit DP)** 这类问题被称为“数位DP”，是组合计数中的高阶技巧，其思想和容斥有相通之处。计算 `[1, N]` 中满足某种条件的数的个数，通常转化为计算 `[1, 9]`, `[1, 99]`, ... 等位数更少的数的个数（这些容易用排列组合计算），再加上位数与N相同且小于N的数的个数。这个“分段求和”的过程蕴含了容斥的分类思想。 |
| **233. Number of Digit One**                            | **数字 1 的个数**              | **(高频难题)** 计算 `[1, n]` 的所有整数中，数字‘1’出现的总次数。暴力法会超时。标准解法是按位分析，计算‘1’在个位、十位、百位...上分别出现了多少次。这个过程需要精细的数学分析和分类讨论，可以看作是容斥原理在数位问题上的复杂应用。 |
| **600. Non-negative Integers without Consecutive Ones** | **不含连续1的非负整数**        | **(数位DP)** 找 `[0, n]` 中二进制表示不含连续‘1’的数的个数。这也是一个经典的数位DP问题。通常会先预处理出长度为 `i` 的二进制数中有多少个满足条件的（这本身是一个斐波那契数列），然后在处理 `n` 时，根据 `n` 的二进制位逐位进行统计，类似容斥地加上所有合法的“前缀”。 |
| **1178. Number of Valid Words for Each Puzzle**         | **猜字谜**                     | **(Bitmask + 状态压缩)** 这题虽然不是直接的容斥公式，但其解决思路与容斥相关。对于每个 `puzzle`，需要找到 `words` 中有多少个满足条件的词。高效的解法是预处理 `words`，用 bitmask 统计所有子集出现的频率。在匹配 `puzzle` 时，需要遍历 `puzzle` 的所有子掩码（submask），这可以看作是在“构造”所有可能的合法单词集合，与容斥中“构造”集合的思想一致。 |
