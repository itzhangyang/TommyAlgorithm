# 网格类问题 - 坐标类型动态规划

坐标类动态规划问题和**坐标位置**有很大的关系。

它的状态划分和维数有关，一般情况下，一维坐标系用一维动态规划表示状态信息，二维坐标系用二维动态规划数组表示状态信息，以此类推。

这里以二维坐标系为例，设计二维动态规划数组`dp`,其中`dp[i][j]`表示位置`(i,j)`的**最值**或者**计数**。

根据问题描述确定`dp[i][j]`与其他元素，比如`dp[i-1][j]`或者`dp[i][j-1]`之间的关系，从而得到**状态转移方程**。

在求`dp[i][j]`时，`i`和`j`的**枚举顺序** 应当和问题要求的路径或者方向一致

##路径类问题 - 网格或者类图结构中的最短路径

- **场景**：给定一个二维网格，通常带有起始点（如左上角）和终点（如右下角）。
- **目标**：寻找一条从起点到终点的路径，使得这条路径满足最优性质（如路径上数字之和最小/最大），或者计算出所有可能路径的总数。
- **移动规则**：每一步的移动方向通常是受限的，最经典的是**只能向右或向下移动**。
- **典型题目**：LC 64 (最小路径和), LC 62 (不同路径), LC 120 (三角形最小路径和)。

###实现方法 - 自顶向下或者自底向上

#### **自顶向下（Top-Down）**：

我们从 `dp[0][0]` 开始，逐行计算 `dp[i][j]`，直到最后一行。

#### **自底向上（Bottom-Up）**：

我们可以从最后一行开始，`dp[i][j]` 表示“从 `(i,j)` 出发到底部的最小路径和”。

状态转移方程变为 `dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])`。

这种从下往上计算的方式同样是线性的。

###问题本质和分析 - 有向无环图中起点到终点的最小路径和

这类问题的本质是在一个**有向无环图（DAG）**上寻找最优路径。

网格中的每个单元格 `(i, j)` 都是一个节点，而允许的移动方向（如向右、向下）就是有向边。

由于移动方向是固定的，不存在环路，且一个节点的状态只依赖于能到达它的前置节点，这完美符合动态规划的应用条件。

###核心套路 - 二维动态规划

问题的状态由其在网格中的二维坐标 `(i, j)` 天然地定义，因此使用一个二维数组 `dp[i][j]` 来存储子问题的解是最直观和自然的。

状态从起点开始，沿着移动方向线性推进，直到终点，这也是一种线性DP的体现。

###原理和步骤 - 以矩阵最小路径和为例(Leetcode 64)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

####状态定义： `DP[i][j]`表示从起点到终点的最小路径和

`dp[i][j]` 表示从起点 `(0, 0)` 到达网格位置 `(i, j)` 的最小路径和。

####确定选择： 移动方向的限制

要想到达 `(i, j)`，只能从两个方向来：

- 从上方 `(i-1, j)` 向下移动。
- 从左方 `(i, j-1)` 向右移动。

####状态转移方程

#####求最小路径和

`dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1])`

#####求路径总数

`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

####明确初始状态

#####**起点**：`dp[0][0] = grid[0][0]`

#####**边界**：最顶上一行和最左边一列

- 网格的第一行 `dp[0][j]`，只能从左边过来，所以 `dp[0][j] = grid[0][j] + dp[0][j-1]`。
- 网格的第一列 `dp[i][0]`，只能从上边过来，所以 `dp[i][0] = grid[i][0] + dp[i-1][0]`。

####返回结果

**返回结果**：最终结果是到达右下角终点的最小路径和，即 `dp[m-1][n-1]`。

###实现代码

```java
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        //到达dp[i][j]的最小路径和
        int[][] dp = new int[m][n];

        //初始状态
        //到达grid[0][0]的代价为grid[0][0];
        dp[0][0] = grid[0][0];
        
        //对于最左和最上的格子，
        //第一行每一个格子其最小代价为dp[0][i-1]+griod[i]
        for(int j = 1; j < n; j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        //第一列，每一个格子的最小代价为dp[i][0] = dp[i-1]+grid[i-1][0]
        for(int i = 1; i < m; i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        //状态转移和遍历逻辑
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[m-1][n-1];
    }
```

###注意事项 

**边界初始化**是该题型的关键，也是最容易出错的地方。

**空间优化**：由于 `dp[i][j]` 只依赖于其上方和左方的单元格，可以使用一个一维数组来优化空间，将空间复杂度从 O(M*N) 降至 O(N)。

###经验总结

网格路径问题是二维 DP 最直观的应用之一。一旦识别出问题是在网格中寻找带约束的最优路径，就应该立刻联想到此 DP 模型。其解题结构（初始化边界 -> 嵌套循环填充）非常固定。

### Leetcode 62: 矩阵左上角到右下角的路径数量

同样需要特别注意第一行和第一列的处理问题。

#### 实现代码

```Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        
        for(int row = 1; row < m; row++){
           dp[row][0] = dp[row-1][0] ;
        }
        
        for(int col = 1; col < n; col++){
            dp[0][col] = dp[0][col-1];
        }

        for(int row = 1; row < m; row++){
            for(int col = 1; col < n; col++){
                dp[row][col] = dp[row-1][col] + dp[row][col-1];
            }
        }

        return dp[m-1][n-1];
        
    }
}
```



###Leetcode 120 三角形最小路径[自底而上]

给定一个三角形结构，从顶端走到底端，每一步只能移动到**下一行相邻的位置**，要求找出路径上数字之和的最小值。

例如：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

**输出：11（路径 2 → 3 → 5 → 1）**

####状态定义

`dp[i][j]`表示从`(i,j)`出发到最底部的最小和

- `i`表示当前的行号(从上到下)
- `j`表示当前行中的第`j` 个元素（从左到右）

####状态转移方程

```
dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])
```

从`(i,j)`出发到底部的最小路径值是为当前节点`(i,j)`的权重+`min(下一行j节点到底部的最小值，下一行j+1节点到底部的最小值)`

因为你每次只能往下一行的相邻两个位置走。

####初始状态

- 只有最后一行每个节点的路径是确定的(就是自身的权重)

  ```
  dp[last_row][j] = triangle[last_row][j]
  ```

####遍历顺序-逆向自定而上遍历

1. 从**倒数第二行**开始往上走（自底向上）
2. 对每一行，从做到右遍历每个元素
3. 每次更新`dp[i][j]`

####代码实现

```java
public int minimumTotal(List<List<Integer>> triangle){
  int n = triangle.size();
  //状态定义
  int[][] dp = new dp[n][n];//这个三角形是正三角形吗
  
  //初始化最后一行
  //dp[i][j] = triangle[i][j]
  for(int j=0;j<triangle.get(n-1).size();j++){
    dp[n-1][j]=triangle.get(n-1).get(j);
  }
  
  //遍历：从倒数第二行开始遍历
  //注意：第i行就有i个元素
  for (int row=n-2;row>=0;i++){
    // 对于每一个元素，取决于下一层选择了什么元素
    for(int col=0;col<=row;col++){
      dp[row][col] = triangle.get(row).get(col)+Math.min(dp[row+1][col],dp[row+1][col+1]);
    }
  }
  
  //返回出发点的最小路径值
  return dp[0][0];
}
```

####五步法总结

| 步骤       | 内容                                                        |
| ---------- | ----------------------------------------------------------- |
| 1️⃣ 子问题   | 从某个点到底部的最小路径和                                  |
| 2️⃣ 状态定义 | `dp[i][j]` 表示从位置 `(i, j)` 到底部的最小路径和           |
| 3️⃣ 状态转移 | `dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])` |
| 4️⃣ 初始化   | `dp[n-1][j] = triangle[n-1][j]`                             |
| 5️⃣ 结果     | `dp[0][0]` 即为答案                                         |

###LeetCode 576: Out of Boundary Paths (出界的路径数)

####问题要点

**环境**: 一个 `m x n` 的网格。

**起点**: 一个球的起始坐标 `(startRow, startColumn)`。

**行动**: 球可以向四个相邻的单元格（上、下、左、右）移动。

**限制**: 最多可以移动 `maxMove` 次。

**目标**: 找出所有能将球移出网格边界的路径数量。

**约束**: 答案可能很大，需要对 $10^9+7$ 取模。

####问题本质和分析 - 带步数限制的网格路径计数问题

我们从一个起点出发，每一步都有四种选择。

我们需要统计在 `maxMove` 步之内，所有“出界”的路径总数。

#####初步分析 - 看起来可以使用DFS

最直观的想法是使用深度优先搜索 (DFS)。

###### DFS方法的思路

定义一个函数 `dfs(moves, r, c)`，表示从 `(r, c)` 位置出发，还有 `moves` 步可以走，能够出界的路径数。

- **递归基 (Base Cases):**
  1. 如果 `(r, c)` 已经越界 ( `r < 0`, `r >= m`, `c < 0`, or `c >= n`)，说明我们找到了一条出界路径。返回 `1`。
  2. 如果 `moves == 0`，但球仍在界内，说明步数用尽，无法再移动，这条路径对结果没有贡献。返回 `0`。
- **递归步骤 (Recursive Step):** 从当前位置 `(r, c)` 尝试走向四个方向 `(nr, nc)`，递归调用 `dfs(moves - 1, nr, nc)`，并将四个方向的结果累加起来。

######DFS方法存在的问题 - 大量重复的计算

这种纯粹的 DFS 会导致大量的重复计算。

例如，从 `(r, c)` 移动到 `(r+1, c)` 再移回来到 `(r, c)`，此时的状态是 `(moves-2, r, c)`。

这个状态可能从很多其他路径到达。

每次都重新计算会造成指数级的时间复杂度，导致超时 (Time Limit Exceeded)。

##### 基于DFS的解决方法 - 虽然有性能问题，但是值得研究学习

###### 定义递归函数 - 从当前状态出发，有多少条出路

我们需要一个函数，它能告诉我们“从当前状态出发，有多少条出路”。

这个函数需要包含所有决定状态的变量：当前位置 `(r, c)` 和剩余步数 `moves`。 

函数签名：`long dfs(int r, int c, int moves)。`

我们使用 `long` 来存储返回值，因为在递归的深层，路径数的中间和可能会很大，尽管最终答案要取模，但这是个好习惯。

###### 编写递归的终止条件

这是递归的出口，没有它，递归将无限进行下去。

- **成功出界**: 如果当前位置 `(r, c)` 已经超出了网格的边界（`r<0` 或 `r>=m` 或 `c<0` 或 `c>=n`），这意味着我们刚刚完成了一次成功的“出界”移动。这是一条有效的出界路径，所以我们返回 `1`。
- **失败终止**: 如果剩余步数 `moves` 变成了 `0`，但球仍然在界内，说明能量耗尽，这条路最终没能出去。所以它对总数没有贡献，返回 `0`

###### 编写递归的递推步骤

递归函数的**递推**过程是十分重要的，指的是由之前的状态值组合计算当前状态值的过程。

如果不在终止条件下，说明球还在界内且还有步数。此时，我们需要探索所有可能性。

- 初始化一个计数器 `count = 0`。
- 遍历四个方向（上、下、左、右）。
- 对于每一个方向，计算出下一个格子的坐标 `(nr, nc)`。
- 调用递归函数 `dfs(nr, nc, moves - 1)` 来解决子问题。
- 将子问题返回的结果累加到 `count` 上。
- `count = (count + dfs(nr, nc, moves - 1)) % MOD;`

###### 返回结果

当四个方向都探索完毕后，`count` 就包含了从 `(r, c)` 出发、在 `moves` 步内出界的所有路径数。返回 `count`。

###### 实现代码

```java
  public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        return (int)dfs(startRow, startColumn, m, n, maxMove);
    }
    
    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    int MOD = 1000000007;
    private long dfs(int row, int col, int m, int n, int moves){
      //判断是否满足条件
        if(row < 0 || row >= m || col < 0 || col >= n){
            return 1;
        }
      //是否应该终止
        if(moves == 0) return 0;
        long count = 0;
				//累加四个方向的可达路径的数量
        for(int[] dir : dirs){
            int nr = row + dir[0];
            int nc = col + dir[1];
            count = (count + dfs(nr, nc, m, n, moves - 1)) % MOD ;
        }
        return count;
    }
```

##### 也许最优解应该是DFS + 记忆搜索化

既然使用朴素的DFS存在性能问题，并且主要的性能问题是重复计算的问题。

我们应该概率使用**记忆化搜索** 来进行优化。

###### 定义状态: 三维数组

与 329 题不同，这里仅仅有坐标 `(row, col)` 是不足以定义一个状态的，因为“剩余步数”也至关重要。

因此，我们的状态是一个三元组：`(row, col, movesLeft)`。

###### 定义DFS函数

`dfs(r, c, k)` 的含义是：**“从单元格 `(r, c)` 出发，最多走 `k` 步，能够走出边界的路径总数是多少”**。这是整个解法的核心。

###### 记忆化

因为状态是三维的，所以我们需要一个三维的 `memo` 数组：`memo[row][col][movesLeft]`，用来缓存 `dfs(row, col, movesLeft)` 的计算结果。

###### 递归的终止条件

- **成功出界：** 如果当前坐标 `(r, c)` 已经越界了（`r<0, r>=m, c<0, c>=n`），说明我们已经成功找到一条出界路径。返回 `1`。

- **步数耗尽：** 如果剩余步数 `k` 已经为 0，但我们仍然在界内，说明这条路失败了，无法再出界。返回 `0`。

###### 递归过程

- 检查 `memo[r][c][k]` 是否已经计算过。如果计算过，直接返回结果。

- 初始化当前状态的结果 `count = 0`。

- 遍历四个方向，得到下一个坐标 `(nextR, nextC)`。

- 对每个方向，递归调用 `dfs(nextR, nextC, k-1)`，并将返回的结果累加到 `count` 上。

- **注意取模！** 因为结果可能很大，每次累加后都要对 `10^9 + 7` 取模。

- 将最终的 `count` 存入 `memo[r][c][k]` 并返回。

###### 实现代码

```Java
import java.util.Arrays;

class Solution {
    // 定义模数
    private final int MOD = 1_000_000_007;
    // 定义方向数组
    private final int[][] DIRS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    // 记忆化数组，存储状态 (r, c, k) 的结果
    private int[][][] memo;
    private int m, n;

    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        this.m = m;
        this.n = n;
        // memo 数组的维度是 m x n x (maxMove+1)
        this.memo = new int[m][n][maxMove + 1];
        
        // 初始化 memo 数组为一个特殊值（例如-1），用于区分“未计算”和“结果为0”
        for (int[][] plane : memo) {
            for (int[] row : plane) {
                Arrays.fill(row, -1);
            }
        }

        return dfs(startRow, startColumn, maxMove);
    }

    /**
     * @param r 当前行
     * @param c 当前列
     * @param k 剩余移动次数
     * @return 从 (r, c) 出发，在 k 步内出界的路径数
     */
    private int dfs(int r, int c, int k) {
        // Base Case 1: 成功出界
        if (r < 0 || r >= m || c < 0 || c >= n) {
            return 1;
        }
        
        // Base Case 2: 步数用尽但仍在界内
        if (k == 0) {
            return 0;
        }

        // 记忆化检查
        if (memo[r][c][k] != -1) {
            return memo[r][c][k];
        }

        long count = 0;
        // 探索四个方向
        for (int[] dir : DIRS) {
            int nextR = r + dir[0];
            int nextC = c + dir[1];
            
            // 递归调用，步数减1
            count += dfs(nextR, nextC, k - 1);
            // 每次相加后都取模，防止溢出
            count %= MOD;
        }

        // 将结果存入 memo 并返回
        memo[r][c][k] = (int) count;
        return memo[r][c][k];
    }
}
```

######注意事项

1. **状态维度的确定：** 这是关键！要准确识别出定义一个唯一子问题需要哪些参数。在本题中，`（位置，剩余步数）` 共同构成了状态。
2. **Memoization数组的初始化：** 因为 `0` 是一个合法的返回值（表示从某状态出发有0条路径可以出界），所以 `memo` 数组不能用 `0` 来标记“未计算”。必须使用一个在答案范围之外的特殊值，比如 `-1`。
3. **取模运算：** 题目要求对结果取模。为了防止中间计算结果溢出（`long` 类型也可能溢出，虽然在本题数据规模下 `long` 足够），最安全的方式是在 **每一次加法操作后** 都进行取模。
4. **复杂度：**
   - **时间复杂度:** O(m×n×maxMove)。因为状态总数是 m×n×maxMove，通过记忆化，每个状态只会被计算一次。
   - **空间复杂度:** O(m×n×maxMove)。主要是 `memo` 数组和递归栈的开销。

######经验总结

你的直觉非常棒！通过 LeetCode 329 和 576 的对比，我们可以总结出一个非常重要的经验：

**解决网格类搜索问题的核心是定义状态。**

- 在 329 题中，状态只和 **位置** `(r, c)` 有关，因为路径长度没有限制，我们只关心从该点出发的最长路径。
- 在 576 题中，状态和 **位置 `(r, c)`** 与 **剩余资源 `k`** （这里是步数）都有关。

##### 现在我们再来看基于动态规划的解法

**网格 DP (Grid DP)**: 问题背景是二维网格，状态的转移发生在相邻的格子之间。

**路径计数 DP (Path Counting DP)**: 目标是计算**有多少种方法**，这是 DP 的一个典型应用场景。

**状态带有额外维度**: 除了坐标 `(r, c)`，还有一个额外的限制维度——步数 `k`。因此，DP 状态很自然地会包含这个维度。

通过模式匹配，我们可以确定这是一个典型的动态规划问题，状态定义应该为 `dp[k][i][j]`。

###### 状态定义

我们定义 `dp[k][i][j]` 表示：**通过 `k` 步移动，恰好到达网格单元格 `(i, j)` 的路径数量**。

###### 状态转移方程

要想到达 `(i, j)` 位置，并且花费了 `k` 步，那么在第 `k-1` 步时，球必然位于 `(i, j)` 的四个相邻位置之一。

假设相邻位置为 `(prev_i, prev_j)`。

因此，状态转移方程为： `dp[k][i][j] = sum(dp[k-1][prev_i][prev_j])`

更具题一些：

$dp[k][i][j]=(dp[k−1][i−1][j]+dp[k−1][i+1][j]+dp[k−1][i][j−1]+dp[k−1][i][j+1])$

需要注意边界，只加**界内的邻居**.

###### 如何计算最终结果？

题目要求的是“出界”的路径数。

一条路径在第 `k` 步出界，意味着它在第 `k-1` 步时必然位于边界上的某个单元格，然后一步跨出界外。

因此，我们可以在构建 DP 表的同时，累计**出界的路径数**。



在计算 `dp[k][...][...]` 时，我们遍历所有 `dp[k-1][i][j]` > 0 的单元格 `(i, j)`。

对于每个这样的单元格，我们尝试向四个方向移动：

-  如果移动后的位置 `(ni, nj)` **在界内**，则它会贡献给 `dp[k][ni][nj]`。
-  如果移动后的位置 `(ni, nj)` **在界外**，则表示从 `(i, j)` 出发、走了 `k-1` 步的这 `dp[k-1][i][j]` 条路径，在第 `k` 步都成功出界了。我们将这个数量累加到最终结果 `ans` 中。

##### 动态规划详细原理和步骤

###### DP状态定义- 小球在移动了**恰好 `k` 步**之后，位于单元格 `(i, j)` 的路径数量

这是整个解法的基石。我们需要一个能够唯一描述子问题的状态。对于这道题，子问题由三个要素决定：

1. 走了多少步 (`k`)
2. 当前所在的行 (`i`)
3. 当前所在的列 (`j`)

因此，我们可以定义一个三维 DP 数组：

```
dp[k][i][j]
```

其含义是：小球在移动了**恰好 `k` 步**之后，位于单元格 `(i, j)` 的路径数量。

- **第一维 `k`**: 步数，范围从 `0` 到 `maxMove`。
- **第二维 `i`**: 行坐标，范围从 `0` 到 `m-1`。
- **第三维 `j`**: 列坐标，范围从 `0` 到 `n-1`。

###### DP 状态转移方程 - 每一次计算K+1的数据

我们的目标是填满这个三维表格。`dp[k][i][j]` 的值如何依赖于之前的状态呢？

要想到达 `(i, j)` 这个格子，并且恰好用了 `k` 步，那么在第 `k-1` 步的时候，**小球必然位于 `(i, j)` 的四个相邻格子之一**。

所以，在第 `k` 步到达 `(i, j)` 的路径数，等于所有从相邻格子走一步到达 `(i, j)` 的路径数之和。

而从相邻格子 `(prev_i, prev_j)` 出发走一步到达 `(i, j)` 的路径数，就是第 `k-1` 步到达 `(prev_i, prev_j)` 的路径数 `dp[k-1][prev_i][prev_j]`。

`dp[k][i][j] = dp[k-1][i-1][j] + dp[k-1][i+1][j] + dp[k-1][i][j-1] + dp[k-1][i][j+1]`

在实际计算时，对于 `(i-1, j)` 等这些相邻格子，**我们必须保证它们在网格边界内，才能从 DP 数组中取值**。

###### 如何计算最终结果

`dp` 数组记录的是到达**界内**格子的路径数。

而题目要求的是**出界**的路径数。如何建立联系？

一条路径在第 `k` 步出界，意味着它在第 `k-1` 步时，必然位于**边界上的某个单元格**，然后从这个单元格走了一步，跨出了边界。

所以，我们的整体思路是：

从 `k=0` 开始，一步步地构建我们的 `dp` 表。

在构建 `dp[k]` 的过程中，我们检查所有在 `k-1` 步时可以到达的格子 `(i, j)`（即 `dp[k-1][i][j] > 0` 的格子）。

对于每一个这样的格子，我们尝试向四个方向移动。

- 如果移动后的位置 `(ni, nj)` **在界内**，它就会对 `dp[k][ni][nj]` 产生贡献。
- 如果移动后的位置 `(ni, nj)` **在界外**，这说明这 `dp[k-1][i][j]` 条路径都在第 `k` 步成功出界了。我们将这个数目累加到最终的答案 `ans` 中。

###### 算法步骤

**初始化**:

- 定义模数 `MOD = 10^9 + 7`。
- 创建一个三维数组 `dp[maxMove + 1][m][n]`。使用 `long` 类型防止中间和溢出。
- 设置**初始条件（Base Case）**：在 `0` 步时，只有一种可能，就是小球在起点。 `dp[0][startRow][startColumn] = 1;`- **就是从起点到起点本身**
- 初始化结果 `ans = 0`。

**迭代填表**:

外层循环 `k` 从 `0` 到 `maxMove - 1` (代表当前步数)。

中层循环 `i` 从 `0` 到 `m - 1` (遍历所有行)。

内层循环 `j` 从 `0` 到 `n - 1` (遍历所有列)。

如果 `dp[k][i][j] > 0`，说明在第 `k` 步时，有路径可以到达 `(i, j)`。

- 遍历四个方向，计算出下一步的坐标 `(ni, nj)`。
- **判断出界**:
  - 如果 `(ni, nj)` 越界，将 `dp[k][i][j]` 累加到 `ans`。`ans = (ans + dp[k][i][j]) % MOD;`
  - 如果 `(ni, nj)` 未越界，更新下一步的状态。`dp[k + 1][ni][nj] = (dp[k + 1][ni][nj] + dp[k][i][j]) % MOD;`

**返回结果**:

所有循环结束后，`ans` 就累加了所有在 `1` 到 `maxMove` 步之间出界的路径总数。返回 `ans`。

##### 实现代码

```java
class Solution {
    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        final int MOD = 1000000007;

        // dp[k][i][j] 表示使用 k 步恰好到达 (i, j) 的路径数
        // 使用 long 防止中间结果溢出
        long[][][] dp = new long[maxMove + 1][m][n];

        // 初始条件：0 步时，只有起点有 1 条路径
        dp[0][startRow][startColumn] = 1;

        // 存储最终出界的路径总数
        long ans = 0;

        // 方向数组：上、下、左、右
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        // 迭代步数 k，从 0 到 maxMove - 1
        // k 代表当前所处的步数
        for (int k = 0; k < maxMove; k++) {
            // 遍历网格中的所有格子
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    // 如果在第 k 步时，有路径可以到达 (i, j)
                    if (dp[k][i][j] > 0) {
                        // 尝试从 (i, j) 向四个方向移动
                        for (int[] dir : dirs) {
                            int ni = i + dir[0];
                            int nj = j + dir[1];

                            // 如果下一步出界了
                            if (ni < 0 || ni >= m || nj < 0 || nj >= n) {
                                // 将这些路径数累加到结果中
                                ans = (ans + dp[k][i][j]) % MOD;
                            } else {
                                // 如果下一步还在界内，则更新 k+1 步的状态
                                dp[k + 1][ni][nj] = (dp[k + 1][ni][nj] + dp[k][i][j]) % MOD;
                            }
                        }
                    }
                }
            }
        }

        return (int) ans;
    }
}
```

### Leetcode 329 -矩阵中的最长递增路径

####问题要点

给定一个 `m x n` 的整数矩阵 `matrix`，你需要找出其中最长递增路径的长度。

对于每一个单元格，你可以向四个方向（上、下、左、右）移动。

你 **不能** 在对角线上移动，也 **不能** 移动到矩阵边界之外。

#### 方法一：基于DFS方法

##### 问题的本质和分析 - 有向无环图的最长路径问题

从本质上看，这个问题可以被建模成一个 **有向无环图（DAG）** 的最长路径问题。

- **图的节点 (Nodes):** 矩阵中的每个单元格 `(i, j)` 都可以看作是图中的一个节点。
- **图的边 (Edges):** 如果两个相邻的单元格 `(i, j)` 和 `(x, y)` 满足 `matrix[x][y] > matrix[i][j]`，那么就存在一条从 `(i, j)` 指向 `(x, y)` 的有向边。

- **问题转化:** 题目要求的最长递增路径，就等价于在这个有向图中寻找一条最长的路径。

因为路径是“递增”的，所以我们不可能在路径中重复访问同一个节点，即这个图是 **无环** 的。

对于图的最长路径问题，一个朴素的想法是从每个节点出发，通过深度优先搜索（DFS）遍历所有可能的路径，然后找到最长的那一条。

##### 记忆化搜索的方式

然而，单纯的DFS会导致大量的重复计算。

例如，在计算从 `A` 出发的最长路径时，我们可能会计算出从 `B` 出发的最长路径。

而在后续从另一个节点 `C` 出发时，可能又会再一次遇到节点 `B`，并重新计算从 `B` 出发的最长路径。

这种重复计算是导致效率低下的主要原因。

为了解决这个问题，**记忆化搜索 (Memoization)** 应运而生。

##### 核心思想和套路 - DFS

###### 核心思想 - 计算从每个单元格处罚的最长递增路径

对矩阵中的每一个单元格，都计算从它出发能走出的最长递增路径长度，然后在所有结果中取最大值。

###### 核心套路

1. **遍历起点:** 使用两层循环遍历矩阵中的每一个单元格 `(i, j)`，将其作为起始点。

2. **深度优先搜索 (DFS):** 从该起始点 `(i, j)` 开始，向其四个相邻且值更大的单元格进行递归搜索。

3. **记忆化 (Memoization):** 创建一个与原矩阵大小相同的缓存矩阵 `memo`（或称为 `dp` 表），用来存储从每个单元格 `(i, j)` 出发的最长递增路径的长度。

   **在每次进行DFS计算前，先检查 `memo[i][j]` 是否已经有值**：

   - 如果有值，说明这个子问题已经被计算过，直接返回缓存的结果，避免重复计算。
   - 如果没有值，则进行常规的DFS计算，并在计算出结果后，将其存入 `memo[i][j]` 中，以备后续使用。

##### 实现原理和步骤

###### 初始化

- 获取矩阵的行数 `m` 和列数 `n`。

- 创建一个 `m x n` 的二维数组 `memo`，并用一个特殊值（例如 `0`）来初始化，表示所有单元格的最长路径长度尚未计算。

- 初始化一个变量 `maxLength` 为 `0`，用来记录全局的最长路径。

###### 主循环过程

- 使用双层 `for` 循环遍历矩阵中的每一个单元格 `(i, j)` 从 `(0, 0)` 到 `(m-1, n-1)`。

- 在循环中，调用 `dfs(matrix, i, j, memo)` 函数，计算从当前单元格 `(i, j)` 出发的最长递增路径。

- 用 `dfs` 函数的返回值更新 `maxLength = max(maxLength, dfs(...))`。

###### DFS辅助函数

- **记忆化检查 (Base Case 1):** 检查 `memo[row][col]` 是否不为 `0`。如果是，则直接返回 `memo[row][col]`。
- **初始化当前路径长度:** 初始化从 `(row, col)` 出发的最长路径 `currentMax` 为 `1`（因为路径至少包含当前单元格自身）。
- **探索邻居:** 定义一个方向数组 `dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}` 来方便地遍历四个方向。
- **遍历四个方向:**
  - 计算相邻单元格的新坐标 `(newRow, newCol)`。
  - 检查新坐标是否越界。
  - 检查相邻单元格的值 `matrix[newRow][newCol]` 是否 **严格大于** 当前单元格的值 `matrix[row][col]`。
  - 如果满足条件，则递归调用 `dfs(matrix, newRow, newCol, memo)`，并用 `1 +` 递归结果来更新 `currentMax`。即 `currentMax = max(currentMax, 1 + dfs(matrix, newRow, newCol, memo))`。
- **缓存并返回结果:** 递归结束后，`currentMax` 中存储的就是从 `(row, col)` 出发的最长递增路径长度。将其存入缓存 `memo[row][col] = currentMax`，然后返回 `currentMax`。

###### 最终结果

主循环结束后，`maxLength` 中存储的就是整个矩阵中的最长递增路径长度，返回该值即可。

##### 实现代码

```Java

class Solution {
    int[][] dp ;
    public int longestIncreasingPath(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        dp = new int[m][n];
        for(int row = 0; row < m; row++){
            for(int col = 0; col < n; col++){
                 dfs(matrix, row, col);
            }
        }

        int max = 0;
        for(int row = 0; row < m; row++){
            for(int col = 0; col < n; col++){
                max = Math.max(dp[row][col], max);
            }
        }

        return max;

    }
    //处理邻居节点的
    //一开始应当检查解
    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    private int dfs(int[][] matrix, int row, int col){
        if(dp[row][col] != 0) return dp[row][col];

        int m = matrix.length;
        int n = matrix[0].length;

        int currMaxLen = 1;
        for(int[] dir : dirs){
            int nextRow = row + dir[0];
            int nextCol = col + dir[1];
            if(nextRow < 0 || nextRow >= m){
                continue;
            }
            if(nextCol < 0 || nextCol >= n){
                continue;
            }
            if(matrix[nextRow][nextCol] <= matrix[row][col]){
                continue;
            }
            
            int len = 1 + dfs(matrix, nextRow, nextCol);
            currMaxLen = Math.max(currMaxLen, len);
            
        }

        dp[row][col] = currMaxLen;
        return dp[row][col];
    }
}
```

##### 注意事项 (Important Notes)

**严格递增:** 题目要求的是“递增”路径，即下一个单元格的值必须 **严格大于** 当前单元格。

**缓存的初始值:** 缓存数组 `memo` 的初始值必须是一个在正常结果范围之外的值。因为路径长度至少为1，所以用 `0` 作为未计算的标记是安全的。

**递归深度:** 在最坏的情况下，例如一个蛇形递增的矩阵，递归深度可能达到 `m * n`。如果矩阵非常大，可能会导致栈溢出（StackOverflowError），但这在 LeetCode 的测试用例规模下通常不会发生。

**时间复杂度:** O(m×n)。由于记忆化的存在，每个单元格 `(i, j)` 的 `dfs` 函数体内的计算（不包括递归调用）是常数时间的。每个单元格只会被真正计算一次，之后其结果就会被缓存。因此，总的时间复杂度等于单元格的数量。

**空间复杂度:** O(m×n)。主要是由 `memo` 缓存数组和递归调用栈所占用的空间决定。

##### 经验总结

1. **问题建模:** 学会将问题抽象成熟悉的模型，如本题的图论模型（DAG上的最长路径），有助于找到正确的解题方向。
2. **识别重叠子问题:** 当你发现你的递归/DFS算法中，同一个状态（例如本题中“从(i,j)出发”）被反复求解时，立即考虑使用记忆化或动态规划进行优化。
3. **记忆化搜索的范式:** “先查缓存，再计算，后存缓存”是记忆化搜索的标准流程。这个模式可以应用于大量类似的题目中。

#### 套路二： 基于动态规划 - 自底向上的地推解法

虽然记忆化搜索本质上是“自顶向下”的动态规划，但我们通常所说的“纯”动态规划指的是“自底向上”的递推解法。

对于此题，这种方法虽然不如记忆化搜索直观，但它能更深刻地揭示问题背后的拓扑序和计算依赖关系。

##### 问题本质和分析

从动态规划的角度分析，我们需要定义状态、找到状态转移方程，并确定计算顺序。

###### 状态定义 - 从单元格处罚的最长递归路径的长度

`dp[i][j]` 表示从矩阵单元格 `(i, j)` **出发** 的最长递增路径的长度。我们的最终目标就是求出所有 `dp[i][j]` 中的最大值。

###### 状态转移方程

对于一个单元格 `(i, j)`，它的最长递增路径长度，取决于它能走向的、值更大的邻居。

如果 `(x, y)` 是 `(i, j)` 的一个相邻单元格，并且 `matrix[x][y] > matrix[i][j]`，那么从 `(i, j)` 就存在一条可以走向 `(x, y)` 的路径。 

因此，`dp[i][j]` 的值应该是 `1` (代表它自身) 加上它所有**合法的、值更大的邻居** `(x, y)` 所对应的 `dp[x][y]` 中的最大值。

 数学公式表达为：

$$dp[i][j]=1+max(dp[x][y]∣(x,y) is\quad a \quad neighbor\quad of (i,j)\quad and\quad matrix[x][y]\quad matrix[i][j])$$

如果 `(i, j)` 没有任何值比它大的邻居，那么 `max` 部分为 0，`dp[i][j]` 就等于 `1`

###### 计算顺序 - DP方法的最大难点

这是纯 DP 解法的 **最大难点**。

观察状态转移方程，我们发现，要计算 `dp[i][j]`，我们必须 **首先知道** 所有比 `matrix[i][j]` 值大的邻居的 `dp` 值。

这与我们常规的从左到右、从上到下的 DP 遍历顺序完全不同。

计算的依赖关系是基于单元格的 **值**，而不是它们在矩阵中的 **位置**。



如何确定一个正确的计算顺序？

既然计算 `dp[i][j]` 依赖比它值大的邻居，那么反过来看，我们可以**从小到大**计算。

当我们计算一个值较小的单元格 `A` 的 `dp` 值时，它所依赖的值更大的邻居 `B` 的 `dp` 值可能还未计算，此路不通。



正确的思路是：**从值最大的单元格开始计算，逐步计算到值最小的单元格。** 

或者 **从值最小的单元格开始，更新其对值较大邻居的贡献**。

我们采用后一种，因为它更符合“自底向上”的构建过程。



具体来说：

- 先计算矩阵中值最小的那些单元格的 `dp` 值。
- 然后计算值次小的单元格的 `dp` 值，此时，它们可以参考（依赖）的邻居一定是比自己值更小的，而那些更小值的 `dp` 值我们已经计算过了。
- 以此类推，直到所有单元格的 `dp` 值都被计算出来。



##### 模式套路匹配

- **网格DP (Grid DP):** 这是一个在二维网格上进行动态规划的典型问题。

- **依赖特定顺序的DP:** 不同于简单的路径问题（如LeetCode 62, 64），本题的 DP 状态依赖关系不规则，无法通过简单的从左上到右下的遍历来解决。

- **拓扑排序 (Topological Sort):** 问题的本质是在一个由单元格组成的有向无环图（DAG）上找最长路。确定 DP 的计算顺序等价于对这个 DAG 进行拓扑排序。将所有单元格按照值从小到大排序，实际上就是一种有效的拓扑排序方式。

因此，本题匹配的模式是 **“基于拓扑序的动态规划”**。



##### 核心思想和套路 - 拓扑排序

###### 核心思想

将所有单元格按照它们的值从小到大进行排序，然后依次遍历这些排好序的单元格来计算 `dp` 值。

###### 核心套路

**数据扁平化与排序:** 创建一个列表或数组，存储所有单元格的坐标 `(row, col)` 和值 `value`。然后将这个列表按照 `value` 从小到大排序。

**DP 数组初始化:** 创建一个和矩阵大小相同的 `dp` 数组。由于任何路径的长度至少为1（单元格自身），我们可以将所有 `dp[i][j]` 初始化为 `1`。

**迭代计算:** 遍历排好序的单元格列表。对于当前遍历到的单元格 `(r, c)`，我们去考察它的四个邻居 `(pr, pc)`（Previous Row, Previous Col）。

**状态更新:** 如果邻居 `(pr, pc)` 的值 `matrix[pr][pc]` **小于** 当前单元格的值 `matrix[r][c]`，这意味着存在一条从 `(pr, pc)` 到 `(r, c)` 的递增路径。此时，`dp[r][c]` 可以被 `dp[pr][pc]` 更新。 状态转移方程演变为： `dp[r][c] = max(dp[r][c], 1 + dp[pr][pc])` 因为我们是按值从小到大处理的，所以在计算 `dp[r][c]` 时，所有比它值小的邻居 `(pr, pc)` 的 `dp` 值 `dp[pr][pc]` 都必然已经被计算并确定为最终值了。

**记录最大值:** 在每次更新 `dp` 值的过程中，用一个全局变量来追踪出现过的最大 `dp` 值。



##### 实现原理和步骤

######**初始化:**

- 获取矩阵的行数 `m` 和列数 `n`。
- 创建一个 `m*n` 大小的列表 `cells`，用于存储 `[row, col, value]`。
- 遍历原矩阵，将每个单元格的坐标和值存入 `cells` 列表。

###### 对list进行从小到大**排序:**

- 使用 `Collections.sort` 或 `Arrays.sort` 对 `cells` 列表进行排序，排序的依据是单元格的值（`value`），升序排列。

######**DP 计算:**

- 创建一个 `m x n` 的 `dp` 数组，并将所有元素初始化为 `1`。
- 初始化全局最大长度 `maxLength = 1`。
- 遍历排好序的 `cells` 列表。对于每一个 `cell`，取出其坐标 `(r, c)`。
- 对 `(r, c)` 的四个方向进行探索，得到邻居坐标 `(pr, pc)`。
- 检查邻居坐标是否合法，并且 `matrix[pr][pc] < matrix[r][c]`。
- 如果条件满足，则根据 `dp[r][c] = Math.max(dp[r][c], 1 + dp[pr][pc])` 来更新 `dp[r][c]`。
- 每次更新后，用 `maxLength = Math.max(maxLength, dp[r][c])` 更新全局最大值。

**返回结果:**

- 循环结束后，`maxLength` 即为所求的答案。

##### 实现代码

```Java
class Cell{
    int row;
    int col;
    int val;
    public Cell(int row, int col, int val){
        this.row = row;
        this.col = col;
        this.val = val;
    }
}
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        List<Cell> cells = new ArrayList<>();
        for(int row = 0; row < m; row ++){
            for(int col = 0; col < n; col++){
                cells.add(new Cell(row, col, matrix[row][col]));
            }
        }

        cells.sort((a,b) -> a.val - b.val);

        int[][] dp = new int[m][n];
        int maxLen = 0;

        int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};
        for(Cell cell : cells){
            int row = cell.row;
            int col = cell.col;
            dp[row][col] = 1;
            for(int[] dir: dirs){
                int nextRow = row + dir[0];
                int nextCol = col + dir[1];
                if(nextRow < 0 || nextRow >= m){
                    continue;
                }
                if(nextCol < 0 || nextCol >= n){
                    continue;
                }
                if(matrix[nextRow][nextCol] >= cell.val){
                    continue;
                }

                dp[row][col] = Math.max(dp[row][col], 1+dp[nextRow][nextCol]);
            }
            maxLen = Math.max(dp[row][col], maxLen);
        }

        return maxLen;
    }
}
```

##### 注意事项

**时间复杂度:** O(mnlog(mn))。主要瓶颈在于对所有 `m*n` 个单元格进行排序。后续的 DP 计算过程是 O(mn)，因为每个单元格只被遍历一次，每次有四个方向的常数时间操作。

**空间复杂度:** O(mn)。用于存储 `cells` 列表和 `dp` 数组。

**与记忆化搜索对比:**

- **效率:** 记忆化搜索的时间复杂度是 O(mn)，优于此处的排序+DP方法。这是因为记忆化搜索“按需计算”，跳过了许多无关的子问题，而排序法则需要对所有元素进行一次全局排序。
- **直观性:** 对于这类依赖关系复杂的网格问题，记忆化搜索（自顶向下）的代码通常更符合人类的直观思维，实现起来也更直接。纯 DP（自底向上）则需要仔细分析计算顺序，相对复杂。

##### 经验总结

**DP的核心是顺序:** 动态规划的精髓在于找到正确的计算顺序，以保证在计算任何状态时，它所依赖的状态都已经被计算完毕。

**拓扑序是解决复杂依赖的钥匙:** 当 DP 的依赖关系不是简单的行列顺序时，要立刻联想到其背后的图模型，并思考如何通过排序（如按值排序）或拓扑排序来确定计算顺序。

**灵活选择实现方式:** 虽然本题可以用纯 DP 解决，但记忆化搜索（DFS + Memoization）提供了一个更简洁、高效且易于思考的实现。这两种方法是等价的，都是动态规划思想的体现。在面试和竞赛中，遇到类似问题，**优先考虑记忆化搜索**，因为它通常能更快地写出正确的代码。而理解纯 DP 的解法，则能让你对动态规划的底层原理有更深刻的认识。

### Leetcode 176: 地下城游戏

#### 问题要点

##### 问题描述

**目标:** 骑士从左上角 `(0, 0)` 出发，需要到达右下角 `(m-1, n-1)` 拯救公主。

**路径:** 骑士只能向右或向下移动。

**房间效果:** 每个房间都有一个整数，正数表示增加生命值，负数表示减少生命值（恶魔），0 表示没有效果。

**生命值约束:** 骑士的生命值在任何时候都必须大于 0 (HP > 0)。

**求解:** 计算骑士出发时所需的 **最低初始健康点数**，以确保他能成功到达终点。

##### 关键点

- **不是求路径和:** 题目不是要求路径和最大或最小，而是要求在满足“任意时刻血量 > 0”的条件下，初始血量的最小值。
- **“未来”决定“现在”:** 骑士在某个点的决策，不仅取决于当前房间的值，更重要的是取决于从这个点出发到终点的后续路径有多“危险”。为了保证后续路径能够走通，当前点的血量必须足够高。

#### 问题本质和分析 - 带有路径约束的最小化初始值

这道题的本质是一个 **“带有路径约束的最小化初始值”** 问题。常规的从左上到右下的动态规划思路在这里会遇到困难。

#####为什么从左上角开始DP行不通？

- 假设我们定义 `dp[i][j]` 为从 `(0,0)` 到 `(i,j)` 所需的最小初始生命值。
- 当我们从 `(i-1, j)` 或 `(i, j-1)` 到达 `(i, j)` 时，我们确实可以计算出到达 `(i,j)` 这一步需要的最小生命值。
- **但是，这个值无法保证我们从 `(i,j)` 出发能够成功到达终点。** 例如，从 `(0,0)` 到 `(i,j)` 的最优路径可能让我们在 `(i,j)` 点的剩余血量变得很低，虽然足以到达 `(i,j)`，但不足以支撑走完后面更危险的路。
- DP 的核心是“无后效性”，即当前状态的决策只与之前的状态有关，与之后的状态无关。但在这个问题中，`(i,j)` 点的决策（需要多少血量）恰恰被后续的路径所影响，破坏了常规DP的无后效性。

因此，我们需要转变思路。既然“未来”决定“现在”，那么我们不妨 **从终点反向推导回起点**。

#### 核心思想和套路 - 反向动态规划

##### 状态定义 - 从某点到右下角所需要的健康点数

`dp[i][j]` 表示：从 `(i, j)` 点出发，到达右下角公主所在地，**在 `(i, j)` 点至少需要拥有的健康点数**。我们的目标就是求解 `dp[0][0]`。

##### 状态转移方程

骑士在 `(row, col)` 点，下一步可以移动到 `(row+1, col)` （下）或者 `(row, col+1)` （右）。

###### 考虑右边或者下边的房间的影响

为了保证能活下来，他必须选择一条对生命值要求更低的路。

- 从 `(i, j)` 到 `(i+1, j)` 需要 `dp[i+1][j]` 的生命值。

- 从 `(i, j)` 到 `(i, j+1)` 需要 `dp[i][j+1]` 的生命值。

因此，从 `(i, j)` 出发，后续路径至少需要 `min(dp[i+1][j], dp[i][j-1])` 的生命值。

###### 考虑当前房间的影响 - 从当前节点出发至少需要多少健康点呢？

现在，我们考虑 `(row, col)` 房间本身 `dungeon[i][j]` 的影响：

理论上我们我们当前的健康点需要确保在经过了`[row,col]`之后，还能够剩余`min(dp[row+1][col],dp[row][col+1])`。

也就是说： 

$H+dungeon[i][j]≥min(dp[i+1][j],dp[i][j+1])$

- 骑士在 `(i, j)` 点拥有的生命值，加上 `dungeon[i][j]` 后，必须等于后续路径所需的最低生命值。
- 设在 `(i, j)` 点需要的生命值为 `H`，则 `H + dungeon[i][j] = min(dp[i+1][j], dp[i][j-1])`。
- 所以 `H = min(dp[i+1][j], dp[i][j-1]) - dungeon[i][j]`。

###### 考虑全局的限制：必须大于0

最后，我们必须记住，骑士的生命值在任何时候都必须大于0，即 `H >= 1`。

- 所以，`dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])`。

##### 初始化

我们从终点 `(m-1, n-1)` 开始计算。

骑士到达 `(m-1, n-1)` 后，战斗结束。

为了在进入这个房间后活下来，他的生命值 `H` 必须满足 `H + dungeon[m-1][n-1] >= 1`。

因为 `H` 是整数，所以 `H >= -dungeon[m-1][n-1] + 1`。

同时 `H` 必须至少为 1。

所以，`dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])`。

举例：

- 如果 `dungeon[m-1][n-1]` 是 -5，你需要 `max(1, 1 - (-5)) = 6` 点生命。进入后剩下 1 点。
- 如果 `dungeon[m-1][n-1]` 是 3，你需要 `max(1, 1 - 3) = 1` 点生命。进入后剩下 4 点。

#### 实现原理和步骤

**创建 DP 表:** 创建一个 `(m x n)` 的二维数组 `dp`。为了方便处理边界，也可以创建一个 `(m+1 x n+1)` 的数组，并将边界值初始化为极大值（表示不可达）。

**初始化 Base Case:** 计算 `dp[m-1][n-1]` 的值。

**迭代计算:** 从右下角开始，向上和向左进行迭代。

- 填充最后一行：`dp[m-1][j]` 只能从 `dp[m-1][j+1]` 转移而来。
- 填充最后一列：`dp[i][n-1]` 只能从 `dp[i+1][n-1]` 转移而来。
- 填充其他部分：使用状态转移方程 `dp[i][j] = max(1, min(dp[i+1][j], dp[i][j-1]) - dungeon[i][j])` 来计算。

**返回结果:** `dp[0][0]` 就是最终的答案。

#### 实现代码

```Java
//地下城与勇士
//找到左上角和右下角之间的最长路径
//矩阵最大路径和
//第一行和第一列
//dp[i][j]
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length;
        int n = dungeon[0].length;
        int[][] dp = new int[m][n];
        dp[m-1][n-1] = Math.max(1, -dungeon[m-1][n-1] + 1);

        for(int col = n - 2; col >= 0; col--){
            dp[m-1][col] = Math.max(1, dp[m-1][col+1] - dungeon[m-1][col]);
        }

        for(int row = m - 2;  row >= 0; row--){
            dp[row][n-1] = Math.max(1, dp[row+1][n-1] - dungeon[row][n-1]);
        }

        for(int row = m-2; row >= 0; row--){
            for(int col = n - 2; col >=0; col--){
                dp[row][col] =Math.max(1,Math.min(dp[row+1][col], dp[row][col+1]) - dungeon[row][col]);
            }
        }

        return dp[0][0];
    }
}
```

#### 注意事项

**反向思维:** 这是解决此问题的关键。正向DP的思路会陷入局部最优而无法保证全局最优。

**生命值 > 0:** 题目要求是 `HP > 0`，即 `HP >= 1`。所以在推导 `dp[i][j]` 时，最终结果必须和 1 取 `max`，确保骑士在进入任何房间前至少有 1 点生命。

**边界处理:** 初始化最后一行和最后一列是DP的基础，需要正确处理。使用一个稍大的DP表并初始化哨兵值（极大值）也是一种常见的处理边界的技巧。

**状态定义:** 清晰地定义 `dp[i][j]` 的含义是解决DP问题的基石。在这里，它是“从 `(i,j)` 出发到终点所需要的最小生命值”，而不是“从起点到 `(i,j)` 怎么样”。

#### 经验总结

**识别反向DP:** 当你发现一个DP问题中，当前状态的最优决策依赖于未来状态的结果时，要立刻想到“反向DP”或“从终点向起点DP”。这类问题通常要求一个初始值，而这个初始值需要保证整个过程都满足某个约束条件。

**精确定义DP状态:** DP问题的核心是状态定义。花时间想清楚 `dp[i][j]` 到底代表什么，是成功的一半。对于此题，关键在于 DP 状态定义包含了“从该点到终点”这一未来的信息。

**从 base case 验证状态转移方程:** 写出状态转移方程后，可以带入 base case 进行验证。例如，计算 `dp[m-2][n-1]` 时，它的后续路径只有 `dp[m-1][n-1]`，看看你的方程是否能正确处理这种情况。

**先写二维再优化:** 对于可以空间优化的DP问题，建议先用二维数组完整实现逻辑，确保正确性后，再考虑用一维数组进行空间优化。这能让思路更清晰，降低出错率。

### 网格最优子结构问题

#### 场景和目标

- **场景**：通常是一个由 '0' 和 '1'（或其它有特殊含义的值）组成的二维网格。
- **目标**：在网格中寻找一个符合特定形状和属性的**最大/最优的连续子矩阵**。
- **典型题目**：LC 221 (最大正方形)。

#### 本质和分析

这类问题的目标不是寻找一条“路径”，而是在网格中定位并度量一个最优的二维“形状”或“区域”。

其状态转移的核心，是基于几何或位置的约束条件，而不仅仅是路径的累加。

#### 核心套路 - 考虑内部更小的子结构

一个大的最优子结构（如一个 `k x k` 的正方形）的存在，必然要求其内部也包含着更小的最优子结构（如 `(k-1) x (k-1)` 的正方形）。

这种依赖关系使其适合用 DP 求解。

#### 原理和步骤

##### 定义状态 - 以当前位置为右下角的最大正方形变成

状态的定义非常关键，必须能承载足够的历史信息以进行递推。

对于“最大正方形”，一个绝佳的定义是：`dp[i][j]` 表示以矩阵中 `(i, j)` 位置为**右下角**所能构成的最大正方形的**边长**。

##### 确定选择

- 如果 `matrix[i][j] == '0'`，那么以它为右下角不可能形成正方形，`dp[i][j] = 0`。
- 如果 `matrix[i][j] == '1'`，那么它能形成的正方形大小，受限于其**上方、左方、左上方**三个方向所能形成的正方形的“短板”。因此，`dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`。

##### 明确初始状态

- `dp` 数组的第一行和第一列可以直接根据 `matrix` 的值来初始化。如果 `matrix[i][j] == '1'`，则 `dp[i][j] = 1`。

##### 返回结果

1. 最大正方形可能以任何一个 `(i, j)` 为右下角，所以我们需要在遍历过程中记录所有 `dp[i][j]` 的最大值 `maxSide`，最终返回其面积 `maxSide * maxSide`。

#### 实现代码

```java
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        //到达dp[i][j]的最小路径和
        int[][] dp = new int[m][n];

        //初始状态
        //到达grid[0][0]的代价为grid[0][0];
        dp[0][0] = grid[0][0];
        
        //对于最左和最上的格子，
        //第一行每一个格子其最小代价为dp[0][i-1]+griod[i]
        for(int j = 1; j < n; j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        //第一列，每一个格子的最小代价为dp[i][0] = dp[i-1]+grid[i-1][0]
        for(int i = 1; i < m; i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        //状态转移和遍历逻辑
        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[m-1][n-1];
    }
```

#### 注意事项

**状态定义的精确性**至关重要。“以 `(i, j)` 为右下角”是解决此问题的关键切入点。

**状态依赖**：要清晰地理解为什么依赖的是左、上、左上三个方向的 `min` 值。可以画图推演，如果其中任何一个方向的 `dp` 值为 0，都无法构成一个边长大于 1 的正方形。

最终结果是**遍历过程中的最大值**，而不是 `dp` 表右下角的值。

#### 经验总结

当问题要求在网格中寻找具有某种几何特征（如正方形、矩形）的最优子区域时，可以尝试定义 `dp[i][j]` 为以 `(i,j)` 为**某个固定角（如右下角）**的子结构的最优属性。这种定义状态的方式是解决此类问题的突破口。