# 博弈类问题

博弈类问题是算法竞赛和面试中的常见题型，它通常涉及**两个“绝顶聪明”的玩家**，在一个有明确规则的游戏中**轮流**进行操作，以期达到某个目标（例如最大化自己的得分或确保自己获胜）。

当游戏的**状态空间有限且无环**时，动态规划是解决这类问题的有力武器。

## 博弈类问题的场景

### 双人博弈

游戏中只有两个玩家，我们称之为玩家A（先手）和玩家B（后手）。

### 回合制

 玩家轮流进行操作。

### 信息完全透明

 游戏中的所有信息对双方都是已知的，不存在隐藏信息（如扑克牌中的手牌）。

### 完全绝顶聪明

每个玩家在轮到自己时，都会选择对自己最有利的策略。

这意味着玩家A会尽力最大化自己的最终收益，而玩家B也会尽力最大化自己的收益（等价于**最小化玩家A的最大收益**）。

这就是 **Minimax（最小最大化）思想** 的基础。

### 游戏会结束

 游戏必须在有限步内结束，不能无限进行下去。

### 无随机性

 游戏过程不涉及随机因素，如掷骰子。

### 状态可定义并且没有后效性

游戏的任何一个局面都可以被一个“状态”所描述，并且从这个状态转移到下一个状态的决策，只与当前状态有关，与如何到达这个状态无关。

这正是DP的基础。

##经典案例

**取石子游戏 (Stone Game):** 一堆或多堆石子，两人轮流取，取走最后一个的获胜/失败。

**硬币游戏 (Coin Game):** 一排硬币，两人轮流从两端取，目标是最大化自己取到的总价值。

**棋盘游戏:** 在棋盘或网格上移动棋子，吃掉对方或到达某个位置。

## 核心目标 - 胜负或者最大得分

博弈问题的目标通常是以下两种之一：

1. **胜负判断 (Winning/Losing):** 判断先手玩家是否有必胜策略。这是一种**布尔类型**的结果。
2. **最优得分计算 (Optimal Score):** 计算先手玩家在双方都采取最优策略的情况下，最终能获得的最大（或最小）分数，或者能领先对手的最大分差。**计算分差是更通用、更强大的方法。**

## 核心思想和套路

### 核心思想：Minimax + 动态规划

博弈DP的核心思想是 **逆向思维** 和 **Minimax**。

我们不是从游戏的开始推演到结束，而是从游戏的终点（最简单的状态）倒推回起点。

#### 状态定义

 DP的状态通常用来描述游戏的一个特定局面。

例如，对于一排硬币，状态可以是 `(i, j)`，表示还剩下从索引 `i` 到 `j` 的硬币。

#### DP值的含义：`dp[i][j]` - `(i...j)`可以获得的最大分差

 DP数组（或记忆化搜索的返回值）的含义至关重要。

一个常见的、强大的定义是：

> `dp[i][j]` 表示在游戏局面 `(i, j)` 下，**当前轮到的玩家** 相对于对手，能获得的最大 **分差**。

注意我们说的是从**当前轮开始的净胜分**，而不是全局的净胜分。

#### 决策 - 拿走`i`还是拿走`j`	

在当前状态下，玩家可以做出多种选择。

例如，从 `(i, j)` 的硬币中，可以拿走 `i` 或者拿走 `j`。

#### 状态转移 - **当前轮开始的净胜分**

玩家会选择一个决策，使得自己的最终收益最大化。

假设当前玩家在 `(i, j)` 局面，他有两种选择：

##### 拿走`nums[i]`：

按照上面说的，我们计算的是从当前轮开始的最大净胜分。

所以当前轮开始之前，玩家A手上的当前轮分数是0.

拿了`nums[i]`之后，他的得分增加了 `nums[i]`。

接下来，游戏局面变为 `(i+1, j)`，轮到对手行动。

根据我们的定义，在 `(i+1, j)` 局面下，对手能获得的最大分差是 `dp[i+1][j]`。

所以，当前玩家选择拿 `nums[i]` 后，他最终能领先对手的分数是 `nums[i] - dp[i+1][j]`。

##### 拿走`nums[j]`

同样的道理。

他的得分增加了 `nums[j]`。

接下来，游戏局面变为 `(i, j-1)`，轮到对手行动。在 `(i, j-1)` 局面下，对手能获得的最大分差是 `dp[i, j-1]`。

所以，当前玩家选择拿 `nums[j]` 后，他最终能领先对手的分数是 `nums[j] - dp[i, j-1]`。

##### 最终的状态转移方程

$dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-11] )$

这个方程完美地体现了Minimax思想：我在我的所有选择（`max`）中，选择一个能使我最终收益最大化的。

而我的最终收益，又取决于我这次的得分减去 **对手在后续局面中的最优表现**。

## 实现原理和步骤

### 分析游戏规则

明确游戏的状态、玩家的决策、胜利/失败条件以及得分计算方式。

### 定义DP状态

- 确定描述游戏局面需要哪些参数。例如，`dp[i][j]` 表示剩下 `i`到`j`的物品。

- 明确 `dp[i][j]` 的具体含义。强烈推荐使用 **“当前玩家能获得的最大分差”** 这个定义。

### 寻找基本状态

- 找到游戏最简单的局面，也就是递归的终点。

- 例如，在取硬币问题中，当 `i == j` 时，只剩一枚硬币，当前玩家必然取走它，获得的分差就是 `nums[i]`。

  所以 `dp[i][i] = nums[i]`。

### 推导状态转移方程

- 根据玩家的决策，写出从一个状态到另一个状态的转移逻辑。

- 应用Minimax思想，在自己的所有决策中取 `max`，在对手的所有决策中取 `min`（这通常通过 `我的得分 - 对手的最优结果` 来体现）。

### 选择实现方式

#### 自底向上（Bottom-Up）的迭代 - 按照区间迭代的方式

需要仔细设计循环的顺序，确保在计算 `dp[i][j]` 时，它所依赖的子问题（如 `dp[i+1][j]` 和 `dp[i][j-1]`）已经被计算出来了。对于区间DP，通常是按区间长度从小到大进行遍历。

## 实现代码

```Java
class Solution {
    public boolean predictTheWinner(int[] nums) {
        int n = nums.length;
        if(n <= 1){
            return true;
        }
        int[][] dp = new int[n][n];
        for(int i = 0; i < n;i++){
            dp[i][i] = nums[i];
        }

        for(int len = 2; len <= n; len++){
            for(int i = 0; i <= n - len; i++){
                int j = i + len - 1;

                dp[i][j] = Math.max(nums[i]- dp[i+1][j], nums[j] - dp[i][j-1]);
            }
        }

        return dp[0][n-1] >= 0;
    }
}
```

## 注意事项

### **DP定义的清晰性：**

 `dp` 数组的定义是解题的关键。一旦定义模糊，状态转移方程就很难写对。“当前玩家能获得的最大分差”是一个非常通用且鲁棒的定义。

### **迭代顺序：** 按照区间长度迭代

如果使用 Bottom-Up 方法，必须保证计算 `dp[i][j]` 时，其依赖项（如 `dp[i+1][j]`）已经被计算过。这通常意味着需要按区间长度、或者对角线方向进行遍历。

### **数据范围：**

 注意题目给出的数据范围，得分相加是否可能导致整型溢出。如果可能，需要使用 `long` 类型。

### **胜负判断 vs 分数计算：**

 如果题目只要求判断胜负，可以设计 `dp` 值为布尔类型（`true` 表示当前玩家必胜）。但这种定义在处理分数时会失效。而使用“分差”定义，既可以判断胜负（分差是否 `>= 0`），也可以计算具体分数，适用性更广。

## 经验总结

1. **首选记忆化搜索：** 对于博弈DP问题，记忆化搜索的思考路径更自然，代码实现更直观，不易出错。它将复杂的游戏过程直接转化为递归函数的调用栈。
2. **抓住“分差”核心：** “最大化自己的得分”本质上就是“最大化自己与对手的得分差”。将 `dp` 值的含义定义为分差，可以 elegantly 地将两个玩家的对抗统一到一个状态转移方程里。
3. **模板化思考：** 遇到类似问题，迅速套用模板：
   - **状态：** `(i, j)` 表示剩余区间。
   - **DP定义：** `dp[i][j]` = 当前玩家在 `[i, j]` 上的最大分差。
   - **转移：** `dp[i][j] = max( val[i] - dp[i+1][j], val[j] - dp[i][j-1] )`。
   - **Base Case：** `dp[i][i] = val[i]`。
4. **扩展与变种：**
   - **取多个物品：** 如果每次可以从两端取1个或多个物品，那么决策就变成了循环。
   - **不同游戏规则：** 例如，取走最后一个算输。只需在最后判断胜负时反转逻辑即可。
   - **二维博弈：** 状态可能变为 `dp(x1, y1, x2, y2)`，表示在一个矩形区域内的博弈。

## 区间类博弈游戏

###Leetcode 877: 石子游戏

两位玩家 Alice 和 Bob 轮流从一排石子堆中选择一堆取走（可以选最左或最右的），每堆石子有一定数量。假设双方都足够聪明（即总是采取最优策略），求最终两人得分之差（Alice - Bob）。

```
piles = [3, 9, 1, 2]
```

Alice 先手，Bob 后手，最终 Alice 和 Bob 的**最大分数差**是多少？

####核心思想-零和博弈 + 最优子结构

这个问题是一个典型的**零和博弈（Zero-Sum Game）**。某人得的越多，对方就得的越少。

设当前可选区间是 `piles[i..j]`，我们希望知道当前回合玩家在这一范围内**最多能比对方多拿多少分**（最大得分差）。我们将这个问题**转换为一个最大化“差值”的问题**。

####基本原理：记忆化搜索 or 自底向上动态规划

- 每次轮到当前玩家时，可以选择左边或右边的石头堆。

- 拿了之后轮到对方操作，对方也会选择能让自己利益最大化的方式。

- 所以我们需要对后续操作结果进行**递归建模**或**动态规划建模**。

#####状态定义-`dp[i][j]`表示在区间`[i,j]`当前玩家与对方最终得分的最大差值

`dp[i][j]` 表示在 `piles[i..j]` 区间内，当前玩家与对方最终的最大得分差值（当前玩家 - 对手）

#####状态初始化-`dp[i][i]=piles[i]`

#####遍历逻辑-按照区间从大到小的顺序遍历区间

- 外层遍历区间的大小`[2...n]`
- 内层从做到右遍历每一个区间

我们可以从区间长度小的状态开始构建，到大的状态。最终我们要求的是 `dp[0][n-1]`。

#####状态转移方程

因为DP是按照区间从小到大记录的，所以对于任何一个 区间`[i...j]`:

- `[i+1...j]`的最大差值`dp[i+1][j]`是已知的 score()
- `[i...j-1]`的最大差值`dp[i][j-1]`是已知的

因为Alice先开始搬的，假设Alice抱了`stones[i]`,那么最大差值就变成：**`stones[i]`-当前最大差值**

当前玩家在 `piles[i..j]` 中可以做两种选择：

- 选左边：`piles[i] - dp[i+1][j]` ->第`i`堆石头数量 - `[i+1...j]`最大差值
  - 当前先手选手选择了**左端的石堆**，也就是下标为 `start` 的一堆石子，他直接拿走这些石子，相当于当前操作获得 `piles[start]` 的分数。
  - 现在轮到对方（也就是当前的后手）去面对新的区间 `[start + 1, end]`。而我们站在“当前先手”的视角看这个值，表示“后手**将变成新一轮的先手**，他在 `[start + 1, end]` 范围内也会执行最优策略，拿到 `dp[start + 1][end]` 这个差值”。但注意，这个差值是**后手比你多拿多少分**，所以你要从你的得分中**减去**这个值。

- 选右边：piles[j] - `dp[i][j-1]` ->第`j`堆石头数量 - `[i...j-1]`最大差值

**因为下一个状态是对方来操作，所以我们要减去“对方”在剩下区间中能取得的最大得分差**

```java
dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])
```

可以这么理解，我们在每一轮中，都在计算**我比对手多拿多少分？**

#####边界条件

当 i == j 时，只有一堆石头，当前玩家只能拿这堆：
`dp[i][i]` =` piles[i]`

####实现代码

```java
 public int stoneGameDiff(int[] piles) {
        int n = piles.length;
        int[][] dp = new int[n][n];

        // base case: only one stone
        for (int i = 0; i < n; i++) {
            dp[i][i] = piles[i];
        }

        // 枚举区间长度，从2到n
        for (int len = 2; len <= n; len++) {
          int firstStart = 0;
          int lastStart = n-len;
            for (int start = 0; start <= n - len; start++) {
                int end = start + len - 1;
                dp[start][end] = Math.max(
                    piles[start] - dp[start + 1][end],
                    piles[end] - dp[start][end - 1]
                );
            }
        }

        return dp[0][n - 1];  // 返回得分差（先手 - 后手）
    }
```

####总结结构

| 项目             | 内容                                                         |
| ---------------- | ------------------------------------------------------------ |
| **问题类型**     | 动态规划 - 博弈类（区间DP + 零和博弈）                       |
| **状态定义**     | `dp[i][j]`: 当前玩家在区间 `[i..j]` 内的最大得分差值         |
| **状态转移方程** | `dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])` |
| **边界条件**     | `dp[i][i] = piles[i]`                                        |
| **目标值**       | `dp[0][n-1]`                                                 |
| **遍历方式**     | 按区间长度递增遍历（区间DP）                                 |

###Leetcode 486 : 预测赢家

##### 问题要点

**输入:** 一个非负整数数组 `nums`。

**游戏规则:**

1. 两名玩家（玩家1和玩家2）轮流从数组的两端取走一个数字。
2. 玩家1先手。
3. 游戏一直持续到所有数字都被取走。

**胜利条件:** 得分总和较高的玩家获胜。如果分数相同，玩家1也算作获胜。

**核心假设:** **两名玩家都以最优策略进行游戏**。这意味着每个玩家在做选择时，都会选择能让自己最终获胜的策略。

**输出:** 一个布尔值，预测玩家1最终是否能获胜。

##### 问题的本质和分析 - 贪心算法有效吗？

###### 本题的本质 - 完全信息博弈问题

这道题的本质是一个**双人、零和、完全信息博弈**问题。

- **双人博弈:** 只有两个玩家。

- **零和:** 不是严格的零和（总分固定），但一方的收益就是另一方的损失。

  你拿走一个数，对方就拿不到了。目标是让自己的分数**相对**于对手最大化。

- **完全信息:** 双方都知道所有可用的选择和其后果。

###### 最关键的陷阱：贪心算法的失效

初学者最容易想到的就是贪心策略：在每一步，我都选择两端中较大的那个数。

正如我们之前分析的，这个策略是错误的。

- **错误原因:** 贪心只考虑了**当前步骤的局部最优**，而没有考虑这个选择会对**未来和对手**产生的影响。

  一个优秀的玩家会“弃车保帅”，可能会为了在未来拿到一个更大的数字，而暂时放弃当前看来较大的数字。

- **正确思路:** 必须假设你的对手和你一样聪明。

  在你做选择时，你必须预判："如果我选了这个，对手会怎么选来最大化他的利益？" 

  这是一个递归的思考过程，引出了动态规划或递归的解法。

##### 背景知识 - 博弈轮 **Minimax (极小化极大) 算法**

这道题主要涉及到算法思想，而非高深的数学定理。

- **Max 玩家 (我方):** 总是试图在所有可能的未来局面中，选择一个能让自己得分**最大化**的走法。

- **Min 玩家 (对手):** 总是试图在所有可能的未来局面中，选择一个能让 Max 玩家得分**最小化**的走法（也就是让他自己得分最大化）。

  我们的解法正是模拟了这个过程：`我选择一个数` - `对手在他能选择的局面里的最优结果`。

##### 考察点

面试官通过这道题主要想考察你：

1. **问题建模能力:** 能否识别出这是一个博弈问题，而不是简单的贪心问题。这是最重要的一步。
2. **递归思想:** 能否将一个大问题分解成性质相同的小问题。例如，在 `[i...j]` 区间内的输赢问题，可以分解为在 `[i+1...j]` 或 `[i...j-1]` 区间内的输赢问题。
3. **动态规划 (DP) 的应用:** 能否发现递归中的“重叠子问题” (Overlapping Subproblems)，并使用记忆化搜索或DP表来优化，避免重复计算。特别是对**区间DP**的掌握。
4. **编码能力:** 能否清晰、无误地实现递归或DP的逻辑，包括正确的状态定义、状态转移方程和边界条件。

##### 模式匹配 - 区间动态规划

当你看到 "两人轮流"、"从序列/数组两端取物"、"最优策略" 这类关键词时，就应该立刻联想到这个模式。

**模式:** **区间动态规划 (Interval DP) + 博弈论 (Game Theory)**

**类似问题:**

- **LeetCode 877. 石子游戏 (Stone Game):** 几乎是同样的问题，只是这道题的数组长度是偶数，可以证明先手必胜。但解法思想完全一样。
- **LeetCode 464. 我能赢吗 (Can I Win):** 另一个博弈问题，虽然不是从数组两端取，但也是通过递归+状态压缩来判断输赢。
- 其他一些棋盘类游戏，如井字棋，也蕴含了Minimax思想。

##### 核心思想和套路 - 求最大分差

解决这类博弈问题的核心套路，是**将“玩家分数”转化为“分数差”**。

###### DP数组的定义 - `DP[i][j]`表示[i...j]区间内的最大分差

不直接计算玩家1和玩家2各自的分数，而是定义 `dp[i][j]` 为：

**在数组的 `[i...j]` 区间内，当前先手玩家能比对手多拿到的最高分数是多少。**

###### 状态转移方程

让我们来推导状态转移方程：

假设当前轮到你，面对 `nums[i...j]` 区间。你有两个选择：

**选择 `nums[i]`:**

- 你拿到了 `nums[i]` 分。
- 接下来，轮到你的对手，他面对的是 `nums[i+1...j]` 区间。
- 根据 `dp` 的定义，对方在这个区间能比你多拿 `dp[i+1][j]` 分。
- 所以，你选择 `nums[i]` 后，你最终会比对手多拿的分数是 `nums[i] - dp[i+1][j]`。（你拿的分减去对手接下来会比你多拿的分）。//这是为什么？

**为什么最终比对手多拿的分数是$nums[i] - dp[i+1][j]$**?

- $dp[i+1][j] = score_b[i+1...j] - score_a[i+1..j]$

  $\rightarrow score_a[i...j] = nums[i] + score_a[i+1,j]$

  

- 因为A拿了`nums[i]`，因此：$score_b[i...j] = score_b[i+1...j]$ 

- $dp[i][j] = score_a[i...j] - score_b[i...j]$

- $\rightarrow dp[i][j] = nums[i] +score_a[i+1...j] - score_b[i+1..j]$

- 因为$dp[i+1][j] = score_b[i+1...j] - score_a[i+1..j]$， 所以：

  $\rightarrow dp[i][j] = nums[i] - dp[i+1][j]$

**选择 `nums[j]`:**

- 你拿到了 `nums[j]` 分。
- 接下来，对手面对 `nums[i...j-1]` 区间，他能比你多拿 `dp[i...j-1]` 分。
- 所以，你选择 `nums[j]` 后，你最终会比对手多拿的分数是 `nums[j] - dp[i...j-1]`。

作为最优玩家，你肯定会选择对自己最有利的，即上述两种情况中的最大值。

所以最终的状态转移方程就是：

$dp[i][j]=max(nums[i]−dp[i+1][j],nums[j]−dp[i][j−1])$

###### 边界条件（Base condition）

当 `i == j` 时，区间只有一个数，当前玩家直接拿走，比对手多拿 `nums[i]` 分。

$dp[i][i]=nums[i]$

###### 最终判断

我们计算出 `dp[0][n-1]`，它代表玩家1（作为第一个先手）在整个游戏结束后，能比玩家2多拿的分数。如果 `dp[0][n-1] >= 0`，则玩家1获胜。

##### 实现原理和步骤 - 基于动态规划

- 创建一个 `n x n` 的 `dp` 二维数组。

- **确定遍历顺序:** 
  - 因为计算 `dp[i][j]` 需要 `dp[i+1][j]` 和 `dp[i][j-1]` 的值（即它的下方和左方的值），所以我们需要斜着遍历或者按区间长度遍历。**按区间长度从小到大是最清晰的**。

- **初始化:** `for (int i = 0; i < n; i++) { dp[i][i] = nums[i]; }` (区间长度为1)。

- **外层循环 (区间长度):** `for (int len = 2; len <= n; len++)`

- **内层循环 (区间起点):** `for (int i = 0; i <= n - len; i++)`

  - 计算区间终点: `int j = i + len - 1;`

  - 应用状态转移方程: `dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);`

- **返回结果:** `dp[0][n-1] >= 0`。

##### 实现代码

```java
class Solution {
    //基于动态规划的做法
    public boolean predictTheWinner(int[] nums) {
        int n = nums.length;
        //dp[i][j]表示[i...j]区间内的最大分差
        int[][] dp = new int[n][n];

        //区间只有一个元素的时候，最大分差就是元素的值
        for(int i = 0; i < n; i++){
            dp[i][i] = nums[i];
        }

        //按照区间从小到大的方式遍历和更新状态
        for(int len = 2; len <=n; len++){
            for(int start = 0; start <= n - len; start++){
                int end = start + len - 1;
                //dp[start][end]
                //选择start 
                dp[start][end] = Math.max(nums[start] - dp[start+1][end], nums[end] - dp[start][end-1]);
            }
        }
        return dp[0][n-1] >=0;
    }
}
```

##### 注意事项 (Notes)

- **空间优化:** 对于DP解法，你会发现计算 `dp` 表的第 `i` 行只依赖于第 `i+1` 行。因此，可以将 `dp` 表从二维优化到一维，将空间复杂度从 O(n2) 降到 O(n)。
- **偶数长度:** 如果题目保证数组长度是偶数（如LC 877石子游戏），总分是奇数还是偶数可能会影响平局的可能性。但本题的逻辑 `score >= 0` 已经完美处理了平局情况，所以无需特殊处理。
- **理解分数差:** 再次强调，`dp` 值的含义是 "净胜分"，而不是某个玩家的绝对分数。这是该解法最巧妙、最核心的地方。

##### 经验总结 (Experience Summary)

"预测赢家" 是一个非常经典的博弈DP入门题。它完美地展示了：

1. **贪心策略的局限性**以及如何用反例来证伪。
2. 如何将一个复杂的博弈问题**建模**为递归关系。
3. 如何通过**改变状态定义**（从绝对分数到相对分数差）来简化状态转移。
4. **区间DP**的典型应用和遍历方式。

一旦你掌握了这道题的思想，遇到类似的 "轮流取数"、"最优博弈" 问题时，就能快速识别出模式并套用核心思想来解决。

## Leetcode 464: 我能赢吗

### 问题要点

这是一个改编版的“100游戏”。游戏规则如下：

- 两名玩家参与游戏。
- 有一个从 1 到 `maxChoosableInteger` 的公共整数池。
- 玩家轮流从池中选择一个 **之前没有被选过** 的整数，加到一个从0开始的累计总和上。
- 第一个使累计总和 **达到或超过** `desiredTotal` 的玩家获胜。
- 你需要判断，在假设两名玩家都采取 **最优策略** 的情况下，先手玩家是否能 **保证** 获胜。

**核心限制:**

- `maxChoosableInteger` 不会超过 20。
- `desiredTotal` 不会超过 300。
- 数字不能重复使用。

### 问题的本质和分析

这道题的本质是一个 **博弈论 (Game Theory)** 问题。

更具体地说，它是一个 **必胜/必败状态** 的分析问题。

由于玩家都采取最优策略，这引出了 **极大极小值算法 (Minimax)** 的思想。

####最优策略：是否存在必胜的方法？ 

如果当前玩家有多种选择，其中至少有一种选择能让他 **必胜**，他一定会做出这种选择。

如果无论他怎么选，对方都有办法获胜，那么他就是 **必败** 的。

#### 状态定义 - 哪些数字已经被使用了？

游戏的核心状态由如下两个问题共同决定：

- **哪些数字已经被用掉了**
- **当前还差多少达到目标**

由于后者可以由前者推算出来，因此最关键的状态就是 **“已使用数字的集合”**。

 游戏在任何时刻的状态，可以由两个关键因素定义：**已经被使用的数字集合** 和 **当前的累计总和**。

然而，累计总和可以从初始的 `desiredTotal` 和已选数字中推导出来，所以最核心的状态是 **“哪些数字已经被使用了”**。

#### 状态转移：选择一个数字：加入集合并更新累计值

玩家A选择一个数字 `i`，游戏状态就转移到了一个新的状态：数字 `i` 被加入已使用集合，累计总和增加 `i`。

现在轮到玩家B，面对这个新状态，他是否能赢？

#### 输赢判断 - 是否存在让对手必败的数字？

当前玩家能赢，当且仅当他能找到 **至少一个** 可选的数字 `i`，使得选择 `i` 之后，**对手** 在新的游戏状态下是 **必败** 的。

### 规律观察：有哪些边界情况？

在深入算法之前，我们可以观察到一些明显的边界情况：

####边界情况1: **初始总和已满足：**

 如果 `desiredTotal <= 0`，先手玩家甚至不需要选择数字就已经赢了，返回 `true`。



####边界情况2**永远无法达到总和：**

 如果池中所有数字的总和（即 1+2+...+maxChoosableInteger）都小于 `desiredTotal`，那么没有任何玩家能够达到目标，所以先手玩家不可能赢，返回 `false`。

这个总和可以用等差数列公式 $\frac {n(n+1)}2$ 快速计算。

### 模式和套路匹配： 状态压缩动态规划（State Compression DP）

#### 状态压缩： 用一个整数表示一个集合状态

##### 怎么表示一组数值表示的状态？

动态规划的关键是能够定义和存储状态。

在这个问题中，状态是**已使用数字的集合**。

我们如何将一个集合（例如 `{1, 3, 4}`）作为DP数组的下标呢？



##### 状态压缩的核心思想 - 二进制每一个位表示一个数字是否使用

**利用整数在计算机中以二进制形式存储的特性，将一个整数的每一位（bit）与集合中的一个元素进行一对一的映射。** 

这样，一个 `N` 位的二进制数就可以表示一个大小为 `N` 的集合的所有子集状态。

###### 映射关系

我们将数字 `k` (从1到N) 映射到整数的第 `k-1` 位上（从右往左数，第0位开始）。

###### 状态表示

- 如果第 `k-1` 位是 `1`，代表数字 `k` **已被使用**。

- - 如果第 `k-1` 位是 `0`，代表数字 `k` **尚未使用**。

#### 状态压缩的实现原理： 二进制位操作

通过位运算，我们可以高效地对这个“状态整数”（通常称为 **位掩码 `mask`**）进行查询和修改。

假设我们需要操作数字`k`:

##### 检查数字是否被使用(check)：`(1 << (k-1) && mask == 1)`

假设我们需要检查数字`k`是否已经使用。

我们只需要检查mask的第`k-1`位是否为1即可。

实现步骤如下：

1. 构造一个只有第`k-1`位是1的数字

   `int x = 1 << (k-1)`

2. 然后和`mask`进行**按位与**操作。

3. 如果结果不是0，则说明`mask`在该位上的值也是1；

##### 将数字设置为已经使用: 

如果需要将数字`k`设置为已经使用，只需要将`mask`的第`k-1`位设置为1，其他不变。

实现原理如下：

1. 构造一个只有第`k-1`位的数字`1 << (k-1)`
2. 然后和`mask`进行按位或操作即可：`1 << (k-1) | mask`
3. 结果就是所求的新状态

#### 为什么使用状态压缩？

**高效**：位运算是CPU级别的指令，速度极快。

**便捷**：一个 `int` 类型的 `mask` 可以直接作为数组下标 `dp[mask]`，查询和存取状态结果的时间复杂度是 O(1)。

**空间节省**：`boolean[20]` 数组需要20字节，而一个 `int` 只需要4字节。

### 核心思想和套路

#### DP数组的定义：当前状态下当前玩家是否能够保证获胜？

我们前面讨论过，使用掩码来保存数字使用状态是最好的。

**我们的数字使用范围是`[1...n]`， 因此一共有$2 ^ n$个不同的状态。**

也就是说，掩码的位数是`n`，但是掩码的值有$2 ^ n$个。

 注意二进制的运算中$1 << n = 2 ^ n$



我们的DP状态数组定义如下：

`boolean[] dp = new boolean[1 << n]`

 `dp[mask]` 的含义是：在 `mask` 所代表的“已用数字集合”的局面下，**轮到当前行动的玩家**是否能保证获胜。



#### 状态转移方程

对于一个状态 `mask`，我们要判断 `dp[mask]` 的值。

当前玩家会检查所有**可用**的数字 `i`。

当且仅当 **存在** 一个可用的数字 `i`，使得以下两个条件之一成立，  `dp[mask]` 为 `true`。

- **选择i后直接获胜：**`currentSum + i >= desiredTotal` (选择 `i` 后直接获胜)
- **选择 `i` 后，游戏进入新状态 `mask'`，而在这个新状态下，对手是必败的：**`!dp[mask | (1 << (i-1))]` 
  - 对手的`mask`变成`newMask = mask | i <<(i-1)`
  - 只要`dp[newMask] == false`，那么当前玩家就赢了



#### 遍历顺序

这是本方法成功的关键。

为了计算 `dp[mask]`，我们需要 `dp[mask | (1 << (i-1))]` 的值。

注意到新状态的整数值一定比原状态大。

因此，我们的DP计算顺序必须是**逆向的**：从 `mask` 值最大的状态（游戏后期）开始，一直计算到 `mask = 0`（游戏初始状态）。



### 实现原理和步骤

#### 处理边界情况：检查`desiredTotal`与数字总和

检查 `desiredTotal` 和数字总和。

#### 初始化DP数字

`boolean[] dp = new boolean[1 << maxChoosableInteger]`

#### **主循环 (逆向遍历所有状态)**：

```Java
for(int mask = (1 << maxChoosaleInteger) - 1; mask >= 0; mask--){
  //...
}
```

#### 计算当前状态的总和

在循环内，根据 `mask` 的位来计算 `currentSum`。

虽然可以在循环外预处理以优化，但放在内部逻辑更清晰。

#### 内层循环 (枚举当前玩家的选择)

遍历所有数字 `i` from 1 to `maxChoosableInteger`。

#### 检查数字是否可用

使用位运算 `(mask & (1 << (i-1))) == 0`。

#### 应用状态转移逻辑

- 判断 `currentSum + i >= desiredTotal`。

- 如果不能直接赢，则获取新状态 `nextMask = mask | (1 << (i-1))`，并查询 `!dp[nextMask]`。

#### 更新DP表

如果找到任何一个能赢的走法，立即设置 `dp[mask] = true`，并用 `break` 跳出内层循环（因为已经确定是必胜态，无需再检查其他走法）。

#### 返回结果

整个循环结束后，`dp[0]` 就是我们想要的答案，它代表游戏初始状态（没有数字被使用）下先手的输赢情况。

### 实现代码

```Java
class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        // 边界情况1: 目标已满足或为负，先手直接赢
        if (desiredTotal <= 0) {
            return true;
        }

        // 边界情况2: 所有数字总和都达不到目标
        int sum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;
        if (sum < desiredTotal) {
            return false;
        }

        // dp[mask] 的含义是：在 mask 这个状态下，当前玩家是否能赢。
        // mask 的第 k-1 位为 1，表示数字 k 已被使用。
        boolean[] dp = new boolean[1 << maxChoosableInteger];

        // 必须从后往前遍历，因为 dp[mask] 的计算依赖于比 mask 更大的状态
        for (int mask = (1 << maxChoosableInteger) - 1; mask >= 0; mask--) {
            int currentSum = 0;
            // 计算当前 mask 状态下，已选数字的总和
            for (int j = 0; j < maxChoosableInteger; j++) {
                if ((mask & (1 << j)) != 0) { // 检查第 j 位是否为 1
                    currentSum += (j + 1); // j 代表数字 j+1
                }
            }

            // 遍历当前玩家所有可能的选择（即选择一个未被使用的数字）
            for (int i = 0; i < maxChoosableInteger; i++) {
                // 检查数字 i+1 是否可用
                if ((mask & (1 << i)) == 0) { // 检查第 i 位是否为 0
                    int choice = i + 1;

                    // 情况一: 选择 choice 直接获胜
                    if (currentSum + choice >= desiredTotal) {
                        dp[mask] = true;
                        break; // 找到一个必胜策略，无需再试其他选择
                    }

                    // 情况二: 选择 choice 后，对手在新局面下必败
                    int nextMask = mask | (1 << i);
                    if (!dp[nextMask]) {
                        dp[mask] = true;
                        break; // 找到一个必胜策略
                    }
                }
            }
            // 如果内层循环正常结束（没有 break），说明没有找到任何必胜策略，
            // dp[mask] 保持 Java 默认的 false 值，代表必败。
        }

        // 返回初始状态（mask=0，没有数字被使用）的结果
        return dp[0];
    }
}
```

### 注意事项

- **迭代顺序**：再次强调，对于博弈类DP，迭代顺序是灵魂。本题必须逆序，保证计算 `dp[mask]` 时，所有它依赖的 `dp[nextMask]` 都已是已知值。
- **数字与位的映射**：代码中将数字 `k` (1 to N) 映射到二进制位 `k-1` (0 to N-1)。在整个实现中必须保持这个映射的一致性。
- **复杂度**：时间复杂度为 O(N⋅2N)，因为有两个嵌套循环，外层循环 2N 次，内层 N 次。空间复杂度为 O(2N)，用于存储DP表。

### 经验总结 (Experience Summary)

#### 超级有用的二进制运算

1. **左移运算 `<<`**：用于创建掩码和计算状态总数。
2. **按位与 `&`**：用于检查某个数字是否已被使用。
3. **按位或 `|`**：用于将某个数字标记为已使用。

##### 左移运算(`<<`): 创建工具和计算空间

左移运算是所有操作的基础。它有两个关键用途：

######**用途一：计算状态总数**

- **代码**：`new boolean[1 << maxChoosableInteger]`

- **目的**：计算 $2^N$ (2的N次方)，以此来确定DP数组需要多大的空间来存储所有可能的状态。

- **原理**：`1 << N` 的意思是将二进制的 `1` 向左移动 `N` 位。

  例如 `1 << 4` 会将 `0001` 变为 `10000`（十进制的16），这正好是 24。

  因此，它能快速计算出由 `N` 个元素构成的集合的所有子集数量。

###### 用途二：创建操作工具（工具掩码）

**代码**：`1 << i` 或 `1 << (k-1)`

**目的**：生成一个特定的“工具掩码”，这个掩码只有我们想操作的那一位是 `1`，其他位都是 `0`。

**示例**：我们想操作数字 `3`，它对应的是第 `2` 位（从0开始计数）。

- `1 << 2` 会生成二进制 `0100`（十进制的4）。
- 这个 `0100` 就是我们接下来用来检查或设置第 `2` 位的“探针”或“画笔”。

##### 按位与 (`&`)：检查状态

这是最常用的查询操作。

- **目的**：检查在当前的 `mask` 中，某一个特定的数字是否已经被使用。
- **代码**：`(mask & (1 << i)) == 0`
- **原理**：“按位与”运算的规则是，只有当两个二进制数的对应位都为 `1` 时，结果的那一位才为 `1`，否则为 `0`。
  - 我们用 `mask` 与我们上面创建的“工具掩码” `(1 << i)` 进行 `&` 运算。
  - 因为“工具掩码”只有第 `i` 位是 `1`，所以 `&` 运算的结果只可能在第 `i` 位上是 `1` 或者 `0`。
  - 如果 `mask` 的第 `i` 位本来就是 `1`，那么 `&` 的结果就不为 `0`。
  - 如果 `mask` 的第 `i` 位本来就是 `0`，那么 `&` 的结果必然为 `0`。
- **示例**：当前状态 `mask = 13` (二进制 `1101`)，表示数字 {1, 3, 4} 已被使用。我们要检查数字 `3` (对应第 `2` 位) 是否可用。
  - 工具掩码是 `1 << 2` -> `0100`。
  - 运算：`1101 & 0100` 结果是 `0100` (不等于0)。
  - **结论**：数字 `3` 已被使用。

##### 按位或 (`|`)：设置状态

这是最常用的更新操作。

- **目的**：在当前 `mask` 的基础上，将一个新选择的数字标记为“已使用”，生成下一个状态。
- **代码**：`nextMask = mask | (1 << i)`
- **原理**：“按位或”运算的规则是，只要两个二进制数的对应位中有一个是 `1`，结果的那一位就是 `1`。
  - 我们用 `mask` 与“工具掩码” `(1 << i)` 进行 `|` 运算。
  - 因为“工具掩码”只有第 `i` 位是 `1`，所以这个操作能精准地将 `mask` 的第 `i` 位“点亮”为 `1`，而完全不影响 `mask` 的其他位。
- **示例**：当前状态 `mask = 5` (二进制 `0101`)，表示数字 {1, 3} 已被使用。现在玩家选择了数字 `2` (对应第 `1` 位)。
  - 工具掩码是 `1 << 1` -> `0010`。
  - 运算：`0101 | 0010` 结果是 `0111`。
  - **结论**：新的状态 `nextMask` 是 `7` (二进制 `0111`)，代表 {1, 2, 3} 都已被使用。

##### 快速参考标

| 运算符   | 名称   | 在本题中的用途                                    | 示例代码 (操作数字k，对应位k-1)         |
| -------- | ------ | ------------------------------------------------- | --------------------------------------- |
| **`<<`** | 左移   | 1. 计算状态总数 ($2^N$) 2. 创建用于操作的工具掩码 | `1 << maxChoosableInteger` `1 << (k-1)` |
| **`&`**  | 按位与 | **检查**数字 `k` 是否被使用                       | `if ((mask & (1 << (k-1))) != 0)`       |
| **`      | `**    | 按位或                                            | **设置**数字 `k` 为“已使用”状态         |

#### **识别信号**：状态压缩DP的使用场景

看到 “从N个物品中选择的子集状态” 且 `N` 很小（通常 ≤20），就要立刻想到状态压缩DP。

#### **博弈DP的逆向性**：

很多博弈论问题的迭代式DP解法都具有“逆向推导”的特性。因为一个状态的输赢取决于“未来”状态，所以计算时要从“未来”（游戏终局）向“现在”（游戏开局）进行。

#### **抽象化能力**：

状态压缩DP的核心是将一个看似复杂的“集合状态”抽象成一个简单的整数 `mask`，然后在这个整数上运用位运算进行高效的状态转移。掌握这种抽象能力是解决此类问题的关键。



## Leetcode 1140: 石子游戏II

### 问题要点

**游戏类型**: 这是一个双人、回合制、确定性、**完全信息**的博弈游戏。Alice 先手。

**游戏目标**: 两位玩家都希望**最大化**自己最终获得的石子总数。

**游戏规则**:

1. 初始时，有 `N` 堆石子，每堆石子的数量由数组 `piles` 给出。这些石子排成一行。
2. 游戏开始时，有一个初始参数 `M = 1`。
3. 在当前玩家的回合，他可以从剩余石子的最前面取走 `X` 堆石子，其中 `1 <= X <= 2 * M`。
4. 取完后，轮到下一个玩家。同时，`M` 的值会更新为 `max(M, X)`。

**问题求解**: 假设 Alice 和 Bob 都采取最优策略，请求出 Alice 最终能获得的最大石子数量。

### 问题本质和分析 (Problem Essence and Analysis)

这个问题的核心是**最优策略下的最大化得分**。

由于双方都想最大化自己的得分，这本质上是一个 **Minimax (极小化极大)** 问题。

- **Alice 的目标**: 最大化 (Alice的得分)。

- **Bob 的目标**: 最大化 (Bob的得分)。

由于总石子数是固定的，Alice 最大化自己的得分，就等价于最小化 Bob 的得分。反之亦然。

这是一个典型的博弈论问题。

因为游戏的状态是确定的（由剩余石子的起始位置 `i` 和当前的 `M` 值决定），并且没有随机因素，所以我们可以用动态规划来解决。

为什么是动态规划？

#### **最优子结构**: 

 假设Alice从`[i...n-1]`中抱走了`x`堆石头。

那现在剩下的石头是`[i+x ... n-1]`,`M = max(M,x)`

新的`x`的区间则是`1 <= x <= 2 * M`。

对此我们可以反过来思考，我们可以县计算后面的问题，再计算前面的问题。

也就是说，解决从 `i` 开始、`M` 为某个值的游戏，可以依赖于解决它之后（即 Alice 取了 `X` 堆后）从 `i+X` 开始、`M` 更新为 `max(M, X)` 的子问题的解。



#### **重叠子问题**: 

在游戏的不同决策路径中，我们可能会多次遇到相同的状态（例如，都是从第5堆石子开始，且当前的 `M` 都是3）。

为了避免重复计算，我们可以用记忆化存储（Memoization）来优化。

### 规律观察

####**关键状态**: 剩余起始索引和当前M值

游戏在任何时刻的局面都可以由两个变量唯一描述：`i` (剩余石子的起始索引) 和 `M` (当前 M 的值)。

####**目标转化**: 求最大净胜分

直接计算 Alice 能得多少分是困难的，因为它取决于对手的选择。

一个更有效的策略是计算 **“当前玩家能比对手多拿多少石子”**，即 **净胜分**。

- 设当前子游戏总石子数为 `S`，当前玩家得分为 `A`，对手得分为 `B`。
- 净胜分 `d = A - B`。
- 同时有 `A + B = S`。
- 联立方程可得 `A = (S + d) / 2`。
- 因此，只要我们求出了先手玩家在**初始状态下的最大净胜分**，就能求出她的最终得分。

### 模式套路匹配

#### 定义DP状态：`dp[i][M]`

`dp[i][M]` 表示当剩余石子从索引 `i` 开始，当前 `M` 值为 `M` 时，**轮到当前操作的玩家** 所能获得的 **最大净胜石子数**。

#### 确定状态转移

 为了计算 `dp[i][M]`，当前玩家会考虑所有可能的选择 `X` (其中 `1 <= X <= 2*M`)。

- 玩家选择拿 `X` 堆，获得 `sum(piles[i]...piles[i+X-1])` 个石子。

- 游戏进入下一个状态：起始索引变为 `i+X`，`M` 更新为 `max(M, X)`。

- 此时轮到对手。在那个状态下，对手能获得的最大净胜分是 `dp[i+X][max(M, X)]`。

- 因此，从当前玩家的视角看，当他选择拿 `X` 堆后，他最终的净胜分是 `(自己拿到的石子) - (对手在后续游戏中能净胜的石子)`。

  对于每一个`x`属于`[i...2M]`，我们需要依次一算其净胜分，然后取最大值。

  即： $dp[i][M] = max_{i \le x \le {2M}}(x条件下[i...i+x-1]的净胜分之和)$

  

  现在我们需要求$x条件下[i...i+x-1]$的净胜分之和.

  对于$[i...i+x-1]$中的每一个`k`而言，其净胜分是$piles[k] - dp[i+1][max(M,X)]$

  那么对于$[i...i+x-1]$而言，其净胜分之和就是 $$\sum_{k=i}^{i+x-1}(piles[k]) - dp[i+1][max(M,X)]$$

  

  按照上面的推导，对于`k`属于`[i,i+x-1]`, 我们需要累计计算`(自己拿到的石子) - (对手在后续游戏中能净胜的石子)`

  对于任意一个`x`和`i`以及`m`，我们需要获得其对手在这个条件下能够获得的**后续最大净胜分**。

  

  最后我们推导出来的状态转移公式：

  $$dp[i][M] = max_{i \le X \le {2M} \quad and \quad {i+X} \le N}(\sum_{k=i}^{i+X-1}(piles[k]) - dp[i+x][max(M,X)])$$

#### 确定迭代顺序 - 从后向前遍历

观察状态转移方程，`dp[i][M]` 的计算依赖于 `dp[i+X][...]` 的值，其中 `X >= 1`。

这意味着 `i+X` 总是大于 `i`，`dp[i+x][..]`需要先于`dp[i][M]`计算。



因此，为了确保在计算 `dp[i]` 时所有依赖项 `dp[i+X]` 都已被计算，我们必须 **从后向前** 遍历 `i`，即 `i` 从 `n-1` 递减到 `0`。

对于 `M` 的遍历顺序没有严格要求，可以从 `1` 到 `n`。



### 核心思想和套路 (Core Idea and General Approach)

#### 从子问题构建

Bottom-Up DP 的核心是从最小的子问题开始解决，然后利用这些解来构建更大问题的解。

- **最小子问题**: 游戏快结束时的情况，即 `i` 接近 `n` 的状态。例如，当 `i = n-1` 时，玩家只能拿最后一堆，后续没有子问题。
- **最终问题**: 我们要求解的原始问题，即 `dp[0][1]`。

#### 空间换时间

我们用一个二维数组 `dp[n+1][n+1]` 来存储所有可能子问题的解，避免重复计算。

#### 利用后缀和进行优化

为了在 O(1) 时间内计算 $$\sum_{k=i}^{i+x-1}piles[k]$$，我们预先计算一个**后缀和数组**。

### 实现原理和步骤

#### 初始化

##### 创建DP状态数组

获取石子堆数 `n`。

创建 DP 表 `dp`，大小为 `dp[n+1][n+1]`。

`dp[n][M]` 对应着没有石子可拿的情况，净胜分为 0，Java 中默认初始化为 0，正好符合我们的 base case。

##### 构建后缀和数组

创建后缀和数组 `suffixSum`，大小为 `n+1`。`suffixSum[i]` 表示从 `piles[i]` 到结尾的总和。

`suffixSum[n] = 0`。

#### 迭代循环填充DP表

##### 外层循环：从`n-1`到`0`

遍历石子起始索引 `i`，从 `n-1` 递减到 `0`。

##### 中层循环(M值)：从1到n

遍历 `M` 值，从 `1` 递增到 `n`。（`M` 的上限理论上可以优化，但 `n` 是一个安全的上界）。

##### 内层循环X: 从1到2*M

遍历当前玩家的选择 `X`，从 `1` 递增到 `2*M`。同时要确保 `i + X <= n`，防止越界。

##### 计算和更新

- 在 `X` 循环内部，利用**后缀和数组**，计算当前拿走的石子数（$$\sum_{k=i}^{i+x-1}piles[k]$$） `currentStones = suffixSum[i] - suffixSum[i + X]`。
- 获取对手在子问题中的净胜分 `opponentDiff = dp[i + X][Math.max(M, X)]`。
- 计算当前选择 `X` 带来的净胜分($$\sum_{k=i}^{i+x-1}(piles[k]) - dp[i+x][max(X,M)]$$) `currentDiff = currentStones - opponentDiff`
- 用 `currentDiff` 更新 `dp[i][M]` 的最大值。
- `dp[i][M] = Math.max(dp[i][M], currentDiff)`。

#### 获取最终结果

根据我们上面所推导的公式：$$A = (s + d)/2$$。

现在我们计算出了Alice在游戏中的最大净胜分`d = dp[0][1]`。

根据后缀和我们可以获得总的石子数量：`totalStones = suffixSum[0]`

根据公式 `Alice的得分 = (totalStones + dp[0][1]) / 2` 计算最终答案。

### 实现代码

代码中存在问题，需要考虑其他的实现方案。或者是基于递归的动态规划实现。

```Java
class Solution {
    public int stoneGameII(int[] piles) {
        int n = piles.length;
        if (n == 0) {
            return 0;
        }

        // 1. 预处理后缀和
        // suffixSum[i] 表示从 piles[i] 到 piles[n-1] 的石子总和
        int[] suffixSum = new int[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suffixSum[i] = piles[i] + suffixSum[i + 1];
        }

        // 2. 初始化 DP 表
        // dp[i][M] 表示从索引 i 开始，M 为 M 时，当前玩家能获得的最大净胜分
        // dp[n][..] 默认为 0，表示没有石子可拿，净胜分为 0，作为 base case
        int[][] dp = new int[n + 1][n + 1];

        // 3. 迭代填充 DP 表
        // i 必须从后向前，因为 dp[i] 依赖于 dp[i+X]
        for (int i = n - 1; i >= 0; i--) {
            // M 可以从前向后
            for (int M = 1; M <= n; M++) {
                // 遍历所有可能的选择 X
                for (int X = 1; X <= 2 * M && i + X <= n; X++) {
                    // 当前玩家拿走的石子数
                    int currentStones = suffixSum[i] - suffixSum[i + X];
                    
                    // 对手在下一个状态 (i+X, max(M, X)) 下能获得的净胜分
                    int opponentDiff = dp[i + X][Math.max(M, X)];
                    
                    // 当前玩家选择拿 X 堆后的净胜分
                    int currentDiff = currentStones - opponentDiff;
                    
                    // 更新 dp[i][M] 为所有选择 X 中能得到的最大净胜分
                    dp[i][M] = Math.max(dp[i][M], currentDiff);
                }
            }
        }

        // 4. 最终结果在 dp[0][1] 中
        int aliceNetWin = dp[0][1];
        int totalStones = suffixSum[0];
        
        // 5. 根据净胜分和总石子数计算Alice的得分
        return (totalStones + aliceNetWin) / 2;
    }
}
```

### 注意事项 (Important Notes)

**循环顺序至关重要**: `i` 的循环必须是 `n-1` 到 `0` 的递减顺序，这是保证动态规划无后效性的关键。

**DP 表的大小**: `dp[n+1][n+1]` 是一个安全的尺寸。`i` 的范围是 `0` 到 `n`，`M` 的最大值不会超过 `n`（因为 `M` 是 `X` 的最大值，而 `X` 最多为 `n`）。将大小设为 `n+1` 可以方便地处理边界情况 `i+X = n`。

**Base Case 的处理**: 在 Bottom-Up 方法中，Base Case 不是通过递归的终止条件实现的，而是通过 DP 表的初始状态。这里 `dp[n][...] = 0` 就是我们的 Base Case，表示当没有石子时，净胜分为 0。

**与递归版的对比**: 迭代版避免了递归的开销，在 `n` 很大时性能可能更好。但对于某些人来说，Top-Down 递归版的代码可能更贴近思考过程，更容易写对。

###经验总结 (Experience Summary)

**博弈 DP 的核心转化**: 无论是递归还是迭代，解决这类问题的核心都是将 "最大化绝对得分" 转化为 "最大化相对净胜分"。

**Bottom-Up 的思维模式**: 思考问题的顺序是 "如果我知道了所有更小的子问题的解，我如何计算当前问题的解？"。这需要你精准地找到状态之间的依赖关系，从而确定正确的迭代顺序。

**后缀和/前缀和是常规武器**: 在处理数组区间和问题时，第一时间想到用前缀和或后缀和进行预处理，将求和操作从 `O(N)` 降到 `O(1)`，是动态规划问题中常见的优化手段。

**实践出真知**: Top-Down 和 Bottom-Up 两种 DP 实现方式各有优劣，都应该熟练掌握。对于同一个问题，尝试用两种方式都实现一遍，可以极大地加深对动态规划思想的理解。

### 方法二：基于递归的动态规划

我们从上面的分析中已经得出，状态转换方程中存在着**自底而上**的依赖关系。

者往往意味着我们可以使用递归型动态规划来解决这个问题。

#### 模式套路匹配 (Pattern Matching) - 自定向下的带记忆化的动态规划

- **递归 (Recursion)**: 我们定义一个递归函数 `solve(state)`，它通过调用自身来解决子问题 `solve(next_state)`。
- **记忆化 (Memoization)**: 我们用一个“备忘录”（通常是数组或哈希表）来存储已经解决过的子问题的答案。当递归函数被调用时，它首先检查备忘录。如果答案已存在，就直接返回，避免了大量的重复计算。

####核心思想和套路

##### 定义递归函数`solve(i,M)`

在当前轮到某位玩家，剩余石子从索引 `i` 开始，当前 `M` 值为 `M` 的情况下，**该玩家能获得的最大净胜分**。 

##### 思考递推关系： solve(i,M)和 solve(i+x, max(m,x))

现在`i`和`M`条件下，当前玩家需要做出选择，即拿走`x`堆石子(`i <= x <= 2*M`)。

他会遍历所有合法的 `X` (`1 <= X <= 2*M`)。

对于每一个选择`x`:

- 他可以获得的石子总数（分数）是$\sum_{k=i}^{i+x-1}(piles[k])$的分数。

- 然后，游戏进去子问题状态`(i+1,max(M,X))`，此时轮到对手。

- 对手在这个子问题中，能够获得的最大净胜分是`solve(i+X,max(X,M))`

- 因此，从当前玩家的视角看，他做出选择`x`后的净胜分是:

  $$\sum_{k=i}^{i+x-1}(piles[k])-solve(i+x,max(x,m))$$

当前玩家是理性的，他会选择那个能使这个最终净胜分 最大化 的 X。

 所以：  `solve(i, M) = max(对所有合法的X){ sum_X - solve(i+X, max(M, X)) }`。

##### 确定Base Case

如果 `i >= n`，表示没有石子可拿了。此时净胜分为0。这是递归的终点。

#### 实现原理和步骤

##### 初始化过程 

###### 处理边缘情况：`piles`为空

处理 `piles` 为空的边缘情况。

###### 构建后缀和数组 - 区间和计算性能提升到$O(1)$

创建一个后缀和数组 `suffixSum`，使得可以在 O(1) 时间内查询任意 `piles[i]` 到结尾的石子总和。

这是关键的性能优化。

###### 构建记忆化表

创建一个二维数组 `memo[n][n+1]`。

使用 `Integer` 类型，这样它的默认值 `null` 可以清晰地表示“该状态尚未计算”。

##### 递归过程的实现：`solve(i,M)`

###### 递归函数的定义：`private int solve(int i, int M)`

函数会返回`[i...n-1]`在`M`的条件下的最大净胜分。

###### 步骤一：检查Base Case(i >=n)

检查 `if (i >= n)`，如果是，返回 `0`。

###### 步骤二：检查记忆化表`memo[i][M]`

检查 `if (memo[i][M] != null)`，如果是，直接返回 `memo[i][M]`。

###### 步骤三：递归逻辑

- 初始化一个变量 `maxDiff = Integer.MIN_VALUE` 来记录最大净胜分。
- （循环x）写一个 `for` 循环，遍历所有可能的选择 `X` (从 `1` 到 `2*M`，且 `i+X <= n`)。
  - 利用**后缀和函数**，计算当前拿走的石子数 `currentStones = suffixSum[i] - suffixSum[i + X]`。
  - 递归调用 `opponentDiff = solve(i + X, Math.max(M, X))` 来获取对手在子问题中的净胜分。
  - 计算当前选择 `X` 带来的净胜分 `currentDiff = currentStones - opponentDiff`。
  - `maxDiff = Math.max(maxDiff, currentDiff)`。

###### 步骤四： 结果存入记忆化表`memo[i][M]`

在函数返回之前，将计算出的结果存入备忘录：`memo[i][M] = maxDiff`。

###### 返回结果

**返回结果**: `return maxDiff`。

##### 调用递归过程并计算结果

根据公式 `Alice的得分 = (总石子数 + Alice的净胜分) / 2` 来计算并返回最终答案。

#### 实现代码

```Java
class Solution {
    private Integer[][] memo ;
    private int[] piles;
    private int[] suffixSum;
    public int stoneGameII(int[] piles) {
        int n = piles.length;
        if (n == 0) {
            return 0;
        }
        // dp[i][M] 表示在[i...n-1]和M限制下的最大净胜分
        this.memo = new Integer[n][n + 1];
        this.piles = piles;

        // 构建后缀数组
        this.suffixSum = getSuffixSum(piles);
        
        int maxDiff = solve(0, 1);
        int total = suffixSum[0];

        return (maxDiff + total) /2;
    }

    private int solve(int i, int M){
        int n = piles.length;
        if(i >= n){
            return 0;
        }
        if(memo[i][M] != null){
            return memo[i][M];
        }

        int maxDiff = Integer.MIN_VALUE;

        for(int x = 1; x <= 2 * M && i+x <= n; x++){
            int currentSum = suffixSum[i] - suffixSum[i+x];
            int opponentDiff = solve(i+x, Math.max(x, M));
            int currentDiff = currentSum - opponentDiff;
            maxDiff = Math.max(maxDiff, currentDiff);
        }

        memo[i][M] = maxDiff;
        return maxDiff;
    }

    // 优化后的 getSuffixSum 函数
    private int[] getSuffixSum(int[] piles) {
        int n = piles.length;
        int[] suffixSum = new int[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suffixSum[i] = piles[i] + suffixSum[i + 1];
        }
        return suffixSum;
    }
}
```

#### 注意事项

**记忆化表的选择**: 使用 `Integer[][]` 而不是 `int[][]` 是一个很好的实践，因为 `null` 可以明确地表示“未计算”，避免了与可能的计算结果（如0或-1）发生冲突。

**递归深度**: 对于这道题，`n` 最大为100，递归深度远未达到会导致栈溢出的程度，所以递归是一个安全且高效的选择。

**后缀和的重要性**: 如果没有后缀和，每次计算 `currentStones` 都需要一个循环，会导致算法超时。这是一个必须的优化。

**理解返回值**: 一定要清晰地记住 `solve(i, M)` 返回的是 **净胜分**，而不是绝对得分。这是整个算法设计的基石。



#### 经验总结

**递归是博弈论问题的自然表达**: 递归的调用和返回过程，完美地模拟了玩家之间轮流做决策、并从未来结果倒推当前最优选择的Minimax过程。

**化繁为简**: “最大化净胜分”的思路是解决此类双人博弈问题的标准技巧。它将两个玩家的目标统一到了一个单一的返回值中，极大地简化了递推关系。

**三步法构建递归DP**:

1. **定义函数** (状态是什么，返回值是什么)。
2. **寻找递推关系** (如何用子问题解构建当前问题解)。
3. **确定Base Case** (递归的终点在哪里)。

- 再加上**记忆化**这个优化，就构成了完整的解题框架。

## Leetcode 1406: 石子游戏III

### 问题要点

这个题目本质上属于Leetcode 1140的简化版本。

- 原本的M值定义去掉了
- 每次选择从`1 <= x <= 2 * M`，修改成了简单的`1 <= x <= 3`
- 结果不再是求最大分数，而是求谁赢了，因此我们之需要求最大净胜分即可，不再需要考虑计算最大分数

### 核心思想

#### 状态定义：`dp[i]`-`[i...n-1]`的最大净胜分

我们现在只需要定义一个一维数组即可。

### 实现代码

```Java
//固定的每次拿走前1-3堆石子
//每堆石子的分数是stoneValue[i]
class Solution {
    private Integer[] memo;
    private int[] suffixSum;
    private int[] stoneValue;
    public String stoneGameIII(int[] stoneValue) {
        int n = stoneValue.length;
        if(n == 0){
            return "Tie";
        }
        this.suffixSum = getSuffixSum(stoneValue);
        this.stoneValue = stoneValue;

        this.memo = new Integer[n];

        int maxDiff = solve(0);
        if(maxDiff > 0){
            return "Alice";
        }else if(maxDiff == 0){
            return "Tie";
        }else{
            return "Bob";
        }


        
    }

    private int solve(int i){
        int n = stoneValue.length;
        if(i >= n){
            return 0;
        }
        if(memo[i] != null){
            return memo[i];
        }

        int maxDiff = Integer.MIN_VALUE;
        //对于每一个x属于[i,i]
        for(int x = 1; x <= 3 && i + x <= n;  x++){
            int currentSum = suffixSum[i] - suffixSum[i+x];
            int opponentDiff = solve(i+x);
            int currentDiff = currentSum - opponentDiff;
            maxDiff = Math.max(currentDiff, maxDiff);
        }

        memo[i] = maxDiff;
        return maxDiff;
    }

        // 优化后的 getSuffixSum 函数
    private int[] getSuffixSum(int[] piles) {
        int n = piles.length;
        int[] suffixSum = new int[n + 1];
        for (int i = n - 1; i >= 0; i--) {
            suffixSum[i] = piles[i] + suffixSum[i + 1];
        }
        return suffixSum;
    }
}
```



