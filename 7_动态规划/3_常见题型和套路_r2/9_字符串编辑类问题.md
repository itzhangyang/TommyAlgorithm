##字符串编辑类（如编辑距离）

#### 场景描述-字符串编辑距离

给定两个字符串 `word1` 和 `word2`，返回将 `word1` 转换为 `word2` 所使用的最少操作数。
 你可以对一个字符串进行以下三种操作之一：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

#### 核心思想+动态规划+双指针指向两个不同的word

将大问题（两个字符串的编辑距离）分解为多个小问题（两个`前缀`的`编辑距离`），使用**递推**或**记忆化搜索**记录子问题的解，避免重复计算。

#### 基本原理

将原问题转化为求解两个字符串前缀之间的最短编辑路径，用二维数组保存中间结果，逐步构造完整解。

#### 状态定义 -`dp[i][j]` 表示将 `word1[0..i-1]` 转换为 `word2[0..j-1]` 的**最小操作数**

令 `dp[i][j]` 表示将 `word1[0..i-1]` 转换为 `word2[0..j-1]` 的**最小操作数**。

####状态转移方程

考虑当前两个字符 `word1[i-1]` 和 `word2[j-1]`：

- **若相等**：无需操作
  `dp[i][j] = dp[i-1][j-1]`
- **若不等**：选择三种操作中最小的一个 + 1

```
dp[i][j] = min(
    dp[i-1][j] + 1,     // 删除 word1[i-1]，删除掉之后，编辑距离就变成了dp[i-1][j]=>word1[0...i-2]和word2[0...j-1] 之间的编辑距离+删除操作本身
    dp[i][j-1] + 1,     // 将word1[0...i-1]转换成word2[0...j-2](操作次数dp[i][j-1])，再在末尾追加字符word[j-1](操作次数1)
    dp[i-1][j-1] + 1    // 替换 word1[i-1] -> word2[j-1]
)
```

##### 删除：删除字符word1[i-1]

就是将`word1[i-1]`从word1中删除，重新从word1[i-2]计算，这个时候就变成了dp`[i-1][j]`+1 (删除操作)

##### 插入：将word[0...i-1]转化为word2[0...j-2]，再追加word[j-1]

这种情况下`dp[i][j]=dp[i][j-1]+1`

##### 替换：将word1[i-1]替换为word2[j-1]

**目标**：将 `word1[i-1]` 替换为 `word2[j-1]`

- 示例：

  - `word1 = "hi"`, `word2 = "ho"`
  - 将 `i` 替换为 `o`，`word1` 变为 `"ho"`，就对齐了

- 状态转移：

  ```
  CopyEdit
  dp[i][j] = dp[i-1][j-1] + 1
  ```

- 解释：这一步我们把两个字符匹配上了（虽然是强行替换的），所以 `i` 和 `j` 都往前推进。



#####  状态转移方程详细解析

为了方便理解，我们假设变化后的字符串是`temp`, `temp[0...m]`和`word2[0...m]`具有相同的值。

在`word1[i-1]`和`word2[j-1]`不同的情况下，需要注意只能通过三种情况来使得`word1[i-1]`上的字符串根`word1[0...i-1]` 变成`word2[0...j-1]`

- 删除`word1[i-1]`, 退回重新从`word1[i-2]` 开始计算，这个时候操作次数就是`dp[i-1][j]`+删除操作
  - 然后将`word1[i-2]`转化成`word2[0...j-1]`,操作数是`dp[i-1][j]`;
  - 删掉原来的`word1[i-1]`, 操作数为`1`;

- 在`word1[0...i-1]`的末尾，插入一个字符`word2[j-1]`,这样它更接近目标字符串`word2[0...j-2]`
  - 我们先把`word1[0...i-1]` 变成`word2[0...j-2]`，这个操作次数是`dp[i][j-1]`
  - 然后再插入一个`word2[j-1]`，得到`word2[0....j-1]`, 操作次数为`1`

- 我们同时回退
  - 然后将`word1[0...i-2]`变成`word2[0...j-2]`,操作次数为`dp[i-1][j-1]`
  - 然后再将`word2[j-1]`插入到`变化后`的`word1[0...i-2]`的最后， 操作数为`1`

####初始化（边界条件）

- `dp[0][j] = j`：空字符串变成 word2 前 j 个字符 → 插入 j 次

- `dp[i][0] = i`：word1 前 i 个字符变成空字符串 → 删除 i 次

#### 推荐学习路径

1. ✅ 先记模板（**真的可以记，别有心理负担**）
2. ✅ 记住含义：`dp[i][j] = word1[0..i-1]` 变成 `word2[0..j-1]` 的最小操作数
3. ✅ 然后对照小例子（比如 "abc" → "ac"）
4. ✅ 最后再去搞懂“为什么是插入、删除、替换”



#### 遍历逻辑

从小到大遍历 `i` 和 `j`（bottom-up），即从 `dp[0][0]` 一直到 `dp[m][n]`，逐步构建完整解。

#### 代码实现

```java
public int minDistance(String word1, String word2){
  int m = word1.length;
  int n = word2.length;
  
  //定义dp数组
  int[][] dp = new int[m+1][n+1];
  
  //初始化边界
  //对于任意i,dp[i][0]=i
  //要么在word1中删掉全部字符（i个字符，操作i次）
  //要么在word2中插入word1中的所有字符(i个字符，操作i次)
  for(int i=0;i<=m;i++) dp[i][0]=i;
  //对于任意i,dp[0][j]=j
  for(int j=0;j<=n;j++) dp[0][j]=j;
  
  //遍历逻辑
  //外层遍历word1
        for (int i = 1; i <= m; i++) {
            char c1 = word1.charAt(i - 1);
          //内层遍历word2
            for (int j = 1; j <= n; j++) {
                char c2 = word2.charAt(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1];  // 无需操作
                } else {
                    dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1,     // 删除
                                 dp[i][j - 1] + 1),    // 插入
                                 dp[i - 1][j - 1] + 1  // 替换
                    );
                }
            }
        }
}
```

#### 相关题目

1. **72. Edit Distance（Leetcode）**

2. **115. Distinct Subsequences**

   ```Java
   //s中和t相等的子序列的数量
   //dp[i][j] 表示前s的前i个字符中包含的t的前j个字符的数量？
   
   class Solution {
       public int numDistinct(String s, String t) {
           int m = s.length();
           int n = t.length();
           int[][] dp = new int[m+1][n+1];
   
           //dp[0][0] = 1
           //dp[0][1...n] = 0;
           //dp[x][0] = 1 
           for(int i = 0; i <=m; i++){
               dp[i][0] = 1;
           }
   
           for(int i = 1; i <= m; i++){
               for(int j = 1; j <= n; j++){
                   dp[i][j] = dp[i-1][j];
                   if(s.charAt(i-1) == t.charAt(j-1)){
                       dp[i][j] += dp[i-1][j-1];
                   }
               }
           }
           return dp[m][n];
       }
   }
   ```

   

3. **97. Interleaving String**

   

4. **583. Delete Operation for Two Strings**

5. **712. Minimum ASCII Delete Sum**