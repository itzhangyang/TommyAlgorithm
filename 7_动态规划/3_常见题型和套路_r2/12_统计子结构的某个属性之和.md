# 贡献法 - 统计子结构的某个属性之和

注意是**子结构的某个属性之和**，不是~~子结构中的元素的某个属性之和~~。

贡献法是一种巧妙的计数思想，它通过转换计数角度，将一个复杂问题分解为计算各个独立元素的贡献之和，从而避免了对问题整体进行暴力枚举。

##贡献法主要解决了什么问题？- 统计所有子结构（如子数组、子字符串）的某个属性总和

贡献法主要用于解决**“统计所有子结构（如子数组、子字符串）的某个属性总和”**这类问题。

具体来说，当你遇到以下类型的题目时，就应该优先考虑贡献法：

###**计算所有子数组/子字符串的某个值的总和**：

- 例：计算所有子数组的**最大值**之和。
- 例：计算所有子数组的**最小值**之和。
- 例：计算所有子数组的**和**的总和。

###**计算所有子数组/子字符串的某个属性出现次数的总和**：

- 例：计算所有子串的**唯一字符数**之和 (LC 828, LC 2262)。
- 例：统计在所有子数组中，数字 `X` 总共出现了多少次。

这类问题的共同特点是，如果按照题意直接求解，通常需要两层循环（$O(N^2)$）来枚举所有的子结构，然后再对每个子结构计算其属性，总复杂度可能达到 $O(N^2)$ 或 $O(N^3)$，对于 $N=10^5$ 的数据规模来说是无法接受的。

贡献法可以将复杂度通常优化到 $O(N)$ 或 $O(NlogN)$。

##什么条件下可以使用贡献法？

###可加性：所有子结构的简单线性求和

例如，总和 = `sum(min(sub1)) + sum(min(sub2)) + ...`。

如果问题的目标是求最大值、或某种复杂的非线性组合，则通常不适用。

###独立性：**独立于其所在子结构的其他具体元素**来计算

单个基本元素（如 `A[i]`）的贡献，可以**独立于其所在子结构的其他具体元素**来计算。

它的贡献只取决于自身的**值**和**相对位置**（例如，由左右第一个比它小/大的元素所决定的边界）。

###关键信号： 所有子结构的某个属性的总和或者总计数

> **问题的目标是计算一个数值，这个数值是针对“所有子数组”或“所有子字符串”的某个属性的总和或总计数，且暴力解法（$O(N^2$) 或更高）会超时。**

###一个详细的核查清单

在实战中，你可以通过以下清单来逐一判断：

| 条件                        | 详细说明                                                     | 检查要点                                                     |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 目标是求和**           | 题目的最终输出是一个**数字**，代表一个**总和**或**总数**。   | **问自己**：我是要计算一个累加的总量，还是寻找一个具有最优属性的**特定**子结构？<br> * `YES`: "**所有子数组**的最小值之和" -> **适用**<br> * `NO`: "最大子数组和" (LC 53) -> **不适用** (这是寻找单个最优子数组) |
| **2. 贡献可被清晰定义**     | 你能清晰地定义出单个元素 `A[i]` 在什么情况下、对最终答案贡献了多少。 | **问自己**：对于元素 `A[i]`，它在子数组中扮演的“角色”（如最小值、唯一字符等）是否能让它产生一个明确的数值贡献？<br> * `YES`: 在“最小值之和”中，`A[i]` 若成为最小值，就贡献 `A[i]`。 <br> * `YES`: 在“唯一字符数之和”中，`A[i]` 若成为唯一字符，就贡献 1。<br> * `NO`: 在“所有子数组的中位数之和”中，`A[i]` 是否是中位数，取决于子数组中所有其他元素，无法简单定义其贡献。 |
| **3. 贡献的边界可高效计算** | 计算单个元素 `A[i]` 的贡献，通常需要找到它的影响范围边界 `L` 和 `R`。这个查找过程必须是高效的。 | **问自己**：我是否有高效的工具（如**单调栈**、**哈希表**、双指针等）来为**每个**元素快速（通常是均摊 O(1) 或 O(logN)）找到它的左、右边界？<br> * `YES`: 找左/右第一个更小/大的元素 -> 单调栈 O(N)<br> * `YES`: 找上一个/下一个相同字符 -> 哈希表 O(N)<br> * `NO`: 如果确定边界本身就需要对每个 `i` 进行一次 O(N) 扫描，那总复杂度将退化为 $O(N^2)$，贡献法失去优势。 |
| **4. 无后效性**             | 计算一个元素的贡献时，不需要考虑其他不相关元素的贡献计算过程。每个元素的贡献都是独立事件，最后简单相加即可。 | **问自己**：计算 `A[i]` 的贡献时，我需要用到 `A[j]` (j≠i) 的贡献结果吗？<br> * `YES`: 几乎所有贡献法问题都满足此条。`A[i]` 的贡献和 `A[j]` 的贡献是平行计算的。<br> * `NO`: 动态规划中很多问题不满足，`dp[i]` 的计算依赖于 `dp[i-1]` 的结果。这是贡献法和某些DP问题的区别。 |

##核心思想 - 计算每个元素对于最终答案的贡献

贡献法的核心思想是：**转换计数的主体，从“枚举子结构”变为“枚举基本元素，并计算每个元素对最终答案的贡献”。**

思考路径的转变如下：

###常规思路是什么样子的？- 主体是子结构

1. 先计算划分子结构
2. 计算每个子结构的指定属性

```python
total_value = 0
for sub in all_substrings:
    value = calculate_property(sub)
    total_value += value
```

###贡献法的思路是什么样子的？- 主体是元素

1. 直接遍历每一个元素
2. 对于每一个元素
   1. 找出所有的其所属的子结构
   2. 计算其在该每一个子结构中的贡献值
   3. 累加该元素在所有子结构中的贡献值
3. 累加所有元素在所有子结构中的贡献值

```Python
total_value = 0
for element in all_elements:
    contribution = calculate_contribution_of(element)
    total_value += contribution
```

这个思路的主体是 `element` (构成子结构的基本元素，如数组中的一个数字或字符串中的一个字符)。

###什么是贡献（contribution）？

**“贡献”的定义**：对于一个元素 `A[i]`，它的“贡献”指的是**在所有包含`A[i]`的子结构中，它对该子结构的属性值产生了多少影响**。

例如，在“计算所有子数组的最小值之和”问题中，元素 `A[i]` 的贡献就是：**在所有以 `A[i]` 为最小值的子数组中，`A[i]` 作为最小值被累加了多少次**。

##实现原理详解 - 三个步骤

要成功应用贡献法，需要清晰地完成以下三步：

###确定贡献主体  - 基本元素是啥？

明确你要计算贡献的“基本元素”是什么。

通常就是数组中的每个数字 `A[i]` 或字符串中的每个字符 `S[i]`。

###定义并计算单个元素的管辖范围和贡献

这是最关键的一步。

你需要回答这个问题：“**元素 `A[i]` 在多少个子数组中‘扮演了关键角色**’，以及**它扮演该角色时对总和的贡献是多少？**”



这个**关键角色**取决于题目。

- 如果是“最小值之和”，关键角色就是“成为子数组的最小值”。
- 如果是“唯一字符数之和”，关键角色就是“成为子串中的唯一字符”。

为了计算这个贡献，我们通常需要找到该元素的**“管辖范围”**或**“影响范围”**。

这个范围通常由其**左边第一个“破坏”其性质的元素**和**右边第一个“破坏”其性质的元素**来界定。

###通用逻辑归纳

####寻找子数组的范围

##### 寻找左右边界L和R

假设我们关注元素 `A[i]`。

1. 找到 `i` 左边第一个不满足某种条件的元素位置 `L`。
2. 找到 `i` 右边第一个不满足某种条件的元素位置 `R`。

那么，所有跨越 `i` 且在 `(L, R)` 区间内的子数组，都可能受到 `A[i]` 的影响。

#####怎么统计包含 `A[i]` 的子数组？

- 其左端点可以选择的范围是 `[L+1, i]`，共有 `i - L` 个选择。

- 其右端点可以选择的范围是 `[i, R-1]`，共有 `R - i` 个选择。 

根据**乘法原理**，总共有 $(i - L) \times (R - i)$ 个子数组的“关键角色”由 `A[i]` 担任。

##### 计算贡献值

**贡献值 = 元素特征值 * 元素所在子结构个数**

如果 `A[i]` 每次贡献的值就是 `A[i]` 本身，那么它的总贡献就是： `contribution(A[i]) = A[i] * (i - L) * (R - i)`

####寻找左右边界的利器 - 单调栈

**单调栈 (Monotonic Stack)** 是最高效、最常用的寻找左/右第一个更小/更大元素（即 `L` 和 `R`）的工具，可以在 O(N) 的时间内处理完所有元素。

####累加所有元素的贡献

写一个循环，遍历所有基本元素，在循环内计算每个元素的贡献，并将其累加到最终答案中。

```python
total_answer = sum(contribution(A[i]) for i in 0..N-1)
```

##代码套路模板 - Leetcode 907

我们以一个经典的题目为例：**LeetCode 907. 子数组的最小值之和 (Sum of Subarray Minimums)**

**问题**：给定一个整数数组 `arr`，找到 `sum(min(b))` 的总和，其中 `b` 遍历 `arr` 的所有子数组。

```Java
import java.util.Stack;

class Solution {
    public int sumSubarrayMins(int[] arr) {
        int MOD = 1_000_000_007;
        int n = arr.length;

        // Step 1: 确定贡献主体 -> 数组中的每个元素 arr[i]

        // Step 2.1: 计算每个元素的左边界 L
        // left[i] = i 左边第一个比 arr[i] 小的元素的距离 (i - L)
        int[] left = new int[n];
        Stack<Integer> stack = new Stack<>(); // 存放索引的单调递增栈
        for (int i = 0; i < n; i++) {
            // 维持栈的单调性
            // 注意：这里用 <= 是为了处理重复元素，确保每个重复元素都能找到唯一的管辖范围
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            // L = stack.isEmpty() ? -1 : stack.peek();
            // 距离 = i - L
            left[i] = i - (stack.isEmpty() ? -1 : stack.peek());
            stack.push(i);
        }

        // 清空栈，用于计算右边界
        stack.clear();

        // Step 2.2: 计算每个元素的右边界 R
        // right[i] = i 右边第一个比 arr[i] 小的元素的距离 (R - i)
        int[] right = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            // 维持栈的单调性
            // 注意：这里用 <，与左边的 >= 对应，确保重复元素不被重复计算
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                stack.pop();
            }
            // R = stack.isEmpty() ? n : stack.peek();
            // 距离 = R - i
            right[i] = (stack.isEmpty() ? n : stack.peek()) - i;
            stack.push(i);
        }

        // Step 3: 累加所有元素的贡献
        long totalContribution = 0;
        for (int i = 0; i < n; i++) {
            // A[i] 的贡献 = A[i] * (以A[i]为最小值的子数组个数)
            // 子数组个数 = 左边可选的起点数 * 右边可选的终点数
            long count = (long)left[i] * right[i];
            long contribution = (arr[i] * count);
            totalContribution = (totalContribution + contribution) % MOD;
        }

        return (int)totalContribution;
    }
}
```

### 一个错误的实现

```Java
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] prevSmaller = findPrevSmaller(arr);
        int[] nextSmaller = findNextSmaller(arr);

        // int[] dp = new int[n];
        int ans = 0;

        for(int i = 0; i < n; i++){
            int left = prevSmaller[i];
            int right = nextSmaller[i];
            int contribution = (i - left) * (right - i ) * arr[i];
            ans += contribution;
        }
        return ans;
    }


    //单调栈寻找next smaller
    //利用单调递增栈
    //
    private int[] findNextSmaller(int[] arr){
        int n = arr.length;
        Stack<Integer> incrStack = new Stack<>();
        int[] res = new int[n];
        Arrays.fill(res, n);

        for(int i = 0; i < n; i++){
            while(!incrStack.isEmpty() && arr[incrStack.peek()] >= arr[i]){
                res[incrStack.pop()] = i;
            }
            incrStack.push(i);
        }
        return res;
    }

    private int[] findPrevSmaller(int[] arr){
        int n = arr.length;
        Stack<Integer> incrStack = new Stack<>();
        int[] res = new int[n];
        Arrays.fill(res, -1);
        
        for(int i = n-1; i >= 0; i--){
            while(!incrStack.isEmpty() && arr[incrStack.peek()] >= arr[i]){
                res[incrStack.pop()] = i;
            }
            incrStack.push(i);
        }

        return res;
    }
}
```

#### 错误1: 没有考虑long类型和MOD逻辑

- 每一个元素所属的子数组数量本身可能会比较大，因此应当使用long类型存储子数组的数量
- 每一次累加的时候应该MOD

#### 错误2: 不正确的重复处理

This is the more subtle logical error.

For each element `arr[i]`, your goal is to count the number of subarrays where `arr[i]` is the minimum.

When duplicate elements exist, we need a **consistent** rule to decide which duplicate "wins" as the minimum. 

For example, in the subarray `[5, 2, 8, 2, 6]`, which `2` is the minimum? 

If we aren't careful, we'll miscount.

##### You need to ensure that the boundaries  are asymmetric

A standard way to solve this is to make the boundaries **asymmetric**:

- For the left boundary, find the index of the first element that is **strictly smaller** (`< arr[i]`).
- For the right boundary, find the index of the first element that is **smaller or equal** (`<= arr[i]`).

Your current implementation for both `findPrevSmaller` and `findNextSmaller` uses the condition `arr[incrStack.peek()] >= arr[i]`.

 This causes both functions to find the "smaller or equal" boundary, which incorrectly partitions the subarrays when duplicates are present.



**How to fix it:** 

The simplest fix is to adjust the logic in your `findPrevSmaller` function to find the **strictly smaller** element. 

You can do this by changing the comparison operator in its `while` loop.

#### The corrected implementation 

```Java
class Solution {
    private final int MOD = 1000000007;
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] prevSmaller = findPrevSmaller(arr);
        int[] nextSmaller = findNextSmaller(arr);

        // int[] dp = new int[n];
        long ans = 0;

        for(int i = 0; i < n; i++){
            int left = prevSmaller[i];
            int right = nextSmaller[i];
            //第一个注意点，需要使用long类型存储count和contribution
            long count = (long) (i - left) * (right - i ) ;
            long contribution = count * arr[i];
            ans  = (ans + contribution) % MOD;
        }
        return (int)ans;
    }


    //单调栈寻找next smaller
    //利用单调递增栈
    //
    private int[] findNextSmaller(int[] arr){
        int n = arr.length;
        Stack<Integer> incrStack = new Stack<>();
        int[] res = new int[n];
        Arrays.fill(res, n);

        for(int i = 0; i < n; i++){
            while(!incrStack.isEmpty() && arr[incrStack.peek()] > arr[i]){
                res[incrStack.pop()] = i;
            }
            incrStack.push(i);
        }
        return res;
    }

    private int[] findPrevSmaller(int[] arr){
        int n = arr.length;
        Stack<Integer> incrStack = new Stack<>();
        int[] res = new int[n];
        Arrays.fill(res, -1);
        
        for(int i = n-1; i >= 0; i--){
            while(!incrStack.isEmpty() && arr[incrStack.peek()] >= arr[i]){
                res[incrStack.pop()] = i;
            }
            incrStack.push(i);
        }

        return res;
    }
}
```



##在子序列中找出特定字符串的数量 - Leetcode 115 

##### 问题要点

**输入**: 两个字符串 `s` (源字符串) 和 `t` (目标字符串)。

**输出**: 一个整数，表示 `s` 的子序列中等于 `t` 的数量。

**子序列 (Subsequence)**: 从原始字符串中删除零个或多个字符，而不改变其余字符的相对顺序，形成的新字符串。

- 例如: `"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是。

**不同 (Distinct)**: 这里的“不同”指的是构成子序列的字符在 `s` 中的**来源索引**不同。

- 例如: `s = "rabbbit"`, `t = "rabbit"`。
  - 第一个 "rabbi" 可以由 `s` 中的 `r-a-b(索引2)-b(索引3)-i-t` 构成。
  - 第二个 "rabbi" 可以由 `s` 中的 `r-a-b(索引2)-b(索引4)-i-t` 构成。
  - 第三个 "rabbi" 可以由 `s` 中的 `r-a-b(索引3)-b(索引4)-i-t` 构成。
- 所以尽管最后形成的字符串都是 "rabbit"，但因为构成它们的 `b` 的来源索引组合不同，所以是 3 个不同的子序列。

##### 问题本质和分析 - 计数型动态规划问题

这个问题的本质是一个**计数型动态规划问题**。我们要计算的是“方法总数”或“组合总数”。

当我们试图从 `s` 中构建 `t` 时，对于 `s` 中的每一个字符，我们都有一个选择：

1. **使用**这个字符来匹配 `t` 中对应的字符（如果它们相等）。
2. **不使用**这个字符，跳过它，尝试用 `s` 中后面的字符来匹配。

由于一个选择会影响后续的可能性，并且子问题的解决可以被重复利用（例如，计算从 `s` 的后半部分匹配 `t` 的后半部分的方法数），这强烈暗示了动态规划是解决此问题的正确路径。

暴力递归解法会因为大量的重复计算而超时，例如，`count(s, t)` 的计算会多次依赖于 `count(s[1:], t)` 和 `count(s[1:], t[1:])` 等等。

##### 模式匹配 - 双序列 DP

这个问题属于一个非常经典的动态规划模型：**双序列DP (Two-Sequence DP)**。

这类问题的特点是：

- 输入是两个序列（通常是字符串或数组）。

- 需要定义一个二维DP状态 `dp[i][j]` 来表示处理到第一个序列的第 `i` 个元素和第二个序列的第 `j` 个元素时的解。

- 状态转移通常依赖于 `dp[i-1][j]`, `dp[i][j-1]`, 和 `dp[i-1][j-1]`。

与此问题相似的经典题目有：

- **Longest Common Subsequence (最长公共子序列)**: 状态定义和转移类似，但目标是求长度而不是计数。

- **Edit Distance (编辑距离)**: 同样是双序列DP，但目标是求最少操作次数。

- **0/1 Knapsack (0/1背包问题)**: 思想上相通。对于 `s` 中的每个字符，我们有“用”或“不用”两种选择，这类似于背包问题中对每个物品“放”或“不放”的选择。

##### 核心思想和套路 

解决这类问题的核心套路是定义清晰的DP状态，并推导出正确的状态转移方程。

###### DP定义 - `dp[i][j]`表示`s[0...i-1]`构成`t[0...j-1]`的子序列的数量

我们定义 `dp[i][j]` 表示：

> 使用 `s` 的前 `i` 个字符（即 `s[0...i-1]`），能够构成 `t` 的前 `j` 个字符（即 `t[0...j-1]`）的**不同子序列的数量**。

我们的最终目标是求 `dp[m][n]`，其中 `m` 是 `s` 的长度，`n` 是 `t` 的长度。

###### 状态转移方程

为了计算 `dp[i][j]`，我们需要考虑 `s` 的第 `i` 个字符 `s[i-1]` 和 `t` 的第 `j` 个字符 `t[j-1]`。

分为两种情况：

1. $s[i-1] != t[j-1]$ => $dp[i][j] = dp[i-1][j]$ 

   `s` 的第 `i` 个字符 `s[i-1]` 无法匹配 `t` 的第 `j` 个字符 `t[j-1]`。

   因此，我们**不能使用** `s[i-1]` 来构成 `t` 的末尾。

   所有能构成 `t[0...j-1]` 的方案，必然只能来自于用 `s` 的前 `i-1` 个字符 `s[0...i-2]` 来构成。

   因此 : $dp[i][j] = dp[i-1][j]$

2. $s[i-1] == t[j-1]$ => $dp[i][j]=dp[i−1][j]+dp[i−1][j−1]$

   `s` 的第 `i` 个字符 `s[i-1]` 与 `t` 的第 `j` 个字符 `t[j-1]` 相等。

   此时我们有两种选择来构成 `t[0...j-1]`：

   - **不选择`s[i-1]`**:

     我们跳过 `s[i-1]`，用 `s` 的前 `i-1` 个字符 `s[0...i-2]` 来构成 `t[0...j-1]`。

     这种情况下的数量是:`dp[i-1][j]`

   - **选择`s[i-1]`**

     我们用 `s[i-1]` 来匹配 `t[j-1]`。

     那么接下来，我们只需要用 `s` 的前 `i-1` 个字符 `s[0...i-2]` 来构成 `t` 的前 `j-1` 个字符 `t[0...j-2]`。

     这种情况下是:`dp[i-1][j-1]`

   因为这两种选择是**互斥**的，所以总方法数是两者之和。

   $dp[i][j]=dp[i−1][j]+dp[i−1][j−1]$

###### 基本情况 (Base Cases)

- `dp[i][0]` (for i=0...m):

  - `t` 是空字符串，`s` 是任意长度的前缀。

  - 从任意字符串中构成一个空字符串的方法只有一种：什么都不选。

  - 所以 `dp[i][0] = 1`。

- `dp[0][j]` (for j=1...n):

  - `s` 是空字符串，`t` 是非空字符串。

  - 从空字符串中不可能构成任何非空字符串。

  - 所以 `dp[0][j] = 0`。

- `dp[0][0] = 1`: `s` 和 `t` 都是空字符串，有一种方法构成。这与第一个基本情况一致。

##### 实现原理和步骤

######初始化DP数组

1. 获取 `s` 和 `t` 的长度，分别记为 `m` 和 `n`。

2. 创建一个 `(m+1) x (n+1)` 大小的二维数组 `dp`。**注意**：结果可能非常大，超出 `int` 范围，所以 `dp` 数组最好使用 `long` 类型。

3. 初始化基本情况：

   - 将 `dp` 数组的第一列 (`dp[i][0]`) 全部设置为 `1`。

   - `dp` 数组的第一行（除了 `dp[0][0]`）默认为 `0`，无需额外设置。

###### 状态转移过程

1. 使用嵌套循环遍历 `dp` 数组：

   - 外层循环 `i` 从 `1` 到 `m` (代表 `s` 的长度)。

   - 内层循环 `j` 从 `1` 到 `n` (代表 `t` 的长度)。

2. 在循环内部，根据 `s.charAt(i-1)` 和 `t.charAt(j-1)` 是否相等，应用上面推导出的状态转移方程来填充 `dp[i][j]`。

3. 循环结束后，`dp[m][n]` 就是最终答案。将其转换回 `int` 类型返回（如果题目要求）。

##### 实现代码

```java
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();

        int[][] dp = new int[m+1][n+1];

        //构成空序列的方法只有一个
        dp[0][0] = 1;
        
        //dp[0][j] = 0;
        //dp[i][0] = 1
        for(int i = 1; i < m; i++){
            dp[i][0] = 1;
        }

        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                char cs = s.charAt(i-1);
                char ct = t.charAt(j-1);
                if(cs != ct){
                    dp[i][j] = dp[i-1][j];
                }else{
                    //如果两个字符相等， 有两个选项
                    //选择s[i-1]， 则 dp[i-1][j-1]
                    //不选择s[i-1],则 dp[i-1][j]
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                }
            }
        }

        return dp[m][n];
    }
```

##### 注意事项

**整数溢出**: 计数的总数可能很大，超过 `Integer.MAX_VALUE`。在计算过程中，`dp` 数组应使用 `long` 类型，最后返回时再根据题目要求强制转换为 `int`。

**DP数组大小**: `dp` 数组的大小是 `(m+1) x (n+1)`，这是为了方便处理 `i=0` 或 `j=0` 的边界情况，使得代码更简洁。

**索引对应**: `dp[i][j]` 对应的是 `s` 的前 `i` 个字符和 `t` 的前 `j` 个字符。在代码中，这分别对应 `s.charAt(i-1)` 和 `t.charAt(j-1)`。这个 `i` 和 `i-1` 的对应关系要理清。

**空间优化的遍历方向**: 使用一维数组优化时，内层循环必须**从后往前**，这是保证状态转移正确性的关键。

##### 经验总结

- **识别问题类型**: 遇到涉及两个字符串/序列的计数或最优化问题时，要优先考虑**双序列DP**。

- **定义状态是关键**: `dp[i][j]` 的含义必须清晰、无歧义。通常定义为“`s` 的前 `i` 个字符与 `t` 的前 `j` 个字符”相关的解。

- **推导状态转移**: 核心是分析最后一个元素（`s[i-1]`）的两种情况：**用它** 或 **不用它**。

  - 当 `s[i-1] == t[j-1]` 时，两种选择的方案数相加。

  - 当 `s[i-1] != t[j-1]` 时，只有一种选择（不用它）。

- **处理好边界**: DP的边界条件（base case）是整个递推的起点，必须正确初始化。

- **思考优化**: 写出二维DP解法后，观察状态转移的依赖关系，如果只依赖前一行/列，就可以考虑使用滚动数组或一维数组进行空间优化。

##Leetcode 467: 环绕字符串中唯一的子字符串 

##### 问题要点

给定一个字符串 `s`，我们需要找到它的子串在无限环绕字符串 `"...zabcdefghijklmnopqrstuvwxyzabcdefg..."` (我们称之为 `base`) 中作为子字符串出现的、唯一的、非空子字符串的数量。

这里的`环绕`指的是**'z'后面可以接'a'**。

**唯一的子字符串**指的是，即使 `s` 中有多个 "ab"，它也只被计数一次。

**例子**

- **输入:** `s = "a"`

- **输出:** `1` ("a")

- **输入:** `s = "cac"`

- **输出:** `2` 

  因为子字符串 "a" 和 "c" 在 `base` 中。

  注意 "c" 出现了两次，但作为唯一的子字符串只计数一次)

- **输入:** `s = "zab"`

- **输出:** `6` (子字符串 "z", "a", "b", "za", "ab", "zab" 都在 `base` 中)

##### 问题的本质和分析

**问题的核心在于如何高效地计算 `s` 中所有满足条件的、且不重复的子字符串总数**。

###### 一个朴素的想法 - 暴力枚举所有子串

一个朴素的想法是生成 `s` 的所有子字符串，然后逐一检查它们是否是 `base` 的一部分，最后用一个哈希集合（HashSet）去重并计数。但 `s` 的长度可达 $10^5$，其子字符串数量级为 $O(N^2)$，这个方法会超时。



我们需要一个更聪明的计数方法。

问题的关键在于 `base` 字符串的特性：它是一个**有序的字母序列循环**。

这意味着任何在 `base` 中合法的子字符串都必须是**字母表顺序连续**的，例如 "abc" 或 "yza"。



让我们考虑以某个特定字符结尾的子字符串。

例如，对于 `s = "dabc"`, 以 'c' 结尾且在 `base` 中合法的子字符串有 "c", "bc", "abc"。

这三个字符串都以 'c' 结尾。

如果我们找到了 `s` 中最长的、以 'c' 结尾的、且在 `base` 中合法的子字符串是 "abc"，它的长度是 3。

那么，所有以 'c' 结尾的合法子字符串 ("c", "bc", "abc") 都被这个最长的子字符串 "abc" 包含了。

因此，以 'c' 结尾的唯一合法子字符串的数量就是这个最长子字符串的长度，即 3。



这个观察是解决问题的突破口。

**问题从“找到所有唯一的合法子字符串”转化为“对每个字母 'a' 到 'z'，找到 `s` 中以该字母结尾的最长合法子字符串的长度，然后将这些长度相加”。**



**为什么这样是正确的？**

假设以 'c' 结尾的最长合法子字符串是 "abc"。

任何其他以 'c' 结尾的合法子字符串，例如 "bc"，必然是 "abc" 的**后缀**，因此它已经被计入 "abc" 的长度 3 之中了。

我们不需要单独考虑它。

同样，如果 `s` 中还有另一个不连续的 "c"，它自己构成一个长度为 1 的合法子字符串，但因为我们已经找到了一个更长的以 'c' 结尾的 "abc" (长度3)，所以这个单独的 "c" 提供的贡献 (1) 小于我们已经记录的贡献 (3)，我们只关心最大长度。



因此，我们的总数就是： (以 'a' 结尾的最长合法子串长度) + (以 'b' 结尾的最长合法子串长度) + ... + (以 'z' 结尾的最长合法子串长度)



##### 模式匹配

- **动态规划 (DP)**：特别是那种利用数组记录状态，通过一次遍历来解决问题的类型。`dp[i]` 代表了以第 `i` 个字母结尾的某个最优属性。

- **字符串处理**：涉及到遍历字符串并根据字符间的关系进行逻辑判断。

- **贡献法计数**：最终结果由各个独立部分（以'a'结尾的，以'b'结尾的...）的贡献累加而成。

##### 核心思想和套路

###### DP的定义 `dp[i]`表示以字母i结尾的子串最大的长度

创建一个大小为 26 的数组，我们称之为 `maxLen`。

`maxLen[i]` 用来存储在整个字符串 `s` 的扫描过程中，所遇到的以字符 `'a' + i` 结尾的、且符合 `base` 环绕连续性的最长子字符串的长度。

###### 遍历和更新

- 遍历输入字符串 `s`，同时维护一个变量 `currentLen`，表示**当前**在 `s` 中连续的、且符合 `base` 规则的子字符串的长度。

- 从 `s` 的第二个字符开始，比较当前字符 `s[i]` 和前一个字符 `s[i-1]`。

- 如果 `s[i]` 是 `s[i-1]` 在环绕字母表中的下一个字符（即 `'s[i]' - 's[i-1]' == 1` 或 `'s[i]' == 'a' && 's[i-1]' == 'z'`），说明连续性没有中断，我们将 `currentLen` 加一。

- 如果连续性中断，则重置 `currentLen` 为 1，因为当前字符 `s[i]` 本身构成了一个长度为 1 的合法子字符串。

- 在每一步计算出 `currentLen` 后，我们都需要更新 `maxLen` 数组。

  对于当前字符 `s[i]`，它对应的索引是 `idx = s[i] - 'a'`。

  我们将 `maxLen[idx]` 更新为 `max(maxLen[idx], currentLen)`。

  这一步确保了 `maxLen[idx]` 始终记录的是**全局**最长的、以该字符结尾的子串长度。

###### 计算结果

**计算结果**：遍历完整个字符串 `s` 后，`maxLen` 数组中就存储了以 'a' 到 'z' 各个字母结尾的最长合法子串的长度。将 `maxLen` 数组中的所有值求和，即为最终答案。

##### 实现原理和步骤

**初始化**:

- 创建一个整型数组 `maxLen`，长度为 26，并全部初始化为 0。`maxLen[0]` 对应 'a', `maxLen[1]` 对应 'b', 以此类推。
- 初始化一个整型变量 `currentLen = 0`，用于追踪当前连续子串的长度。

**遍历 `s`**:

- 使用一个 `for` 循环从 `i = 0` 到 `s.length() - 1` 遍历字符串。
- 在循环内部，判断是否连续：
  - 如果是第一个字符 (`i == 0`)，那么连续性必然中断（或者说重新开始），`currentLen` 设为 1。
  - 如果不是第一个字符，检查 `s.charAt(i)` 是否是 `s.charAt(i-1)` 的环绕后继。
    - `s.charAt(i) - s.charAt(i-1) == 1`
    - `s.charAt(i-1) == 'z' && s.charAt(i) == 'a'`
  - 如果连续，`currentLen++`。
  - 如果不连续，`currentLen = 1`。
- 更新 `maxLen` 数组：
  - 获取当前字符 `char c = s.charAt(i)`。
  - 计算其在数组中的索引 `int index = c - 'a'`。
  - 更新 `maxLen[index] = Math.max(maxLen[index], currentLen)`。

**求和**:

- 遍历 `maxLen` 数组，将所有元素累加起来。
- 返回总和。

##### 实现代码

```java
class Solution {
    //给定一个字符串s，求s中有多少非空子串在base中出现
    public int findSubstringInWraproundString(String s) {
        //以每个字母结尾的子串的最大长度
       int[] maxLen = new int[26];
       int currentLen = 0;

       for(int i = 0; i < s.length(); i++){
            if(i == 0){
                currentLen = 1;
            }else if(s.charAt(i) - s.charAt(i-1) == 1){
                currentLen++;
                
            }else if(s.charAt(i-1) == 'z' && s.charAt(i) == 'a'){
                currentLen++;
            }else{
                currentLen = 1;
            }

            char c = s.charAt(i);
            int idx = c - 'a';
            maxLen[idx] = Math.max(currentLen, maxLen[idx]);
            
       }

       int ans = 0;
       for(int len : maxLen){
        ans += len;
       }

       return ans;
        
    }

   
}
```

##### 注意事项

- **边界条件**：处理 `s` 为空或长度为 1 的情况。当 `i=0` 时，`currentLen` 必须从 1 开始。

- **环绕判断**：`'z'` 到 `'a'` 的连续性判断 `(prevChar == 'z' && currentChar == 'a')` 是关键，不能遗漏。

- **`maxLen` 的更新逻辑**：必须是 `Math.max(maxLen[index], currentLen)`。因为 `s` 中可能有多段不连续的、以同一个字符结尾的子串（如 "axbya"），我们只关心能形成的最长的那一段所带来的贡献。例如，对于 `s = "cac"`，第一次遇到 'c'，`currentLen`=1, `maxLen['c'-'a']`=1。第二次遇到 'c'，`currentLen` 也是 1，`maxLen['c'-'a']` 仍然是 1。最终 'c' 的贡献就是 1。对于 `s = "abcade"`，处理到 `abc` 时，`maxLen['c'-'a']`=3。后面处理到 `de` 时，即使又出现了 'c'，但 `currentLen` 较小，不会覆盖已经记录的最大值 3。

- **最终求和**：不要忘记最后一步是将 `maxLen` 数组的所有元素相加。总数不是 `maxLen` 数组的最大值，而是其和。

##### 经验总结

- **转化问题视角**：遇到复杂的计数问题，特别是涉及“唯一”或“去重”时，尝试从另一个角度思考。直接统计所有情况再用 `Set` 去重通常是暴力解法。高效的解法往往是找到一种不重不漏的计数规则。本题的转化——从“统计所有唯一子串”到“统计以各字符结尾的最长子串长度之和”——是解题的精髓。
- **DP 状态定义**：想清楚 `dp[i]` (或本例中的 `maxLen[i]`) 应该代表什么。一个好的状态定义是成功的一半。在这里，`maxLen[i]` 代表“全局最优解”（以字符`i`结尾的最长长度），而不是“局部当前解”，这一点至关重要。
- **“贡献法”思想**：在计数问题中，可以考虑每个元素或每个位置对最终结果的“贡献”。本题中，以字符 `c` 结尾的最长子串长度 `L`，就对总数贡献了 `L`。我们累加每个字符的贡献即可。这种思想在组合数学和算法题中非常常见。

##Leetcode 940 不同的子序列 II

##### 问题要点

- **输入**: 一个字符串 `s` (仅含小写字母)。

- **任务**: 计算 `s` 的所有**不同**且**非空**的子序列的总数。

- **核心挑战**: 字符串中可能包含重复字符，需要精确去重。

- **输出要求**: 结果对 $10^9+7$ 取模。

##### 问题本质和分析 - 基于贡献法

问题的本质是一个动态计数问题。

面对这一类问题，一个强大的分析工具就是**贡献法**。

贡献法的核心就是：**与其直接去计算最终的总数，不如去计算每个基本元素对总数产生了多少贡献**。

在本题中，**基本元素**就是字符串中的每一个字符。

我们需要问自己：当遍历到字符`s[i]`时，它为**不同子序列的总数**这个最终答案贡献了多少**新的、之前从未出现过**的子序列？

##### 模式匹配 - 贡献法

当你遇到需要在序列（字符串、数组）上进行“计数不同子序列/子数组”这类问题时，贡献法是一个非常值得尝试的模式。

**使用贡献法的条件**

1. 对一个组合结构（如子序列）进行计算
2. 存在重复元素，导致简单的计数方法会产生大量重复
3. 问题可以被分解，每一个的解可以基于前面的结果。

这个模式下，核心思路就是：**定义`dp[i]为第i个元素（或者以i结尾）产生的贡献`**

##### 核心思想和套路

###### 定义单个字符的贡献

当我们处理到一个字符串`c`时，它贡献就是它能够创造出的所有的**新的、独一无二**的子序列的数量。

###### 如何计算每一个字符的贡献？

假设我们已经处理了`s`之前的`i-1`个字符，并且已经知道了此刻不同子序列的总数为`total_so_far`

现在我们遇到了第`i`个字符`c`。

1. `c`可以被追加到之前的所有的`total_so_far`个不同的子序列的末尾，这会产生`total_so_far`个以`c`结尾的新的子序列。
2. `c`本身也可以独立成为一个子序列。

所以字符`c`所带来的潜在贡献时`total_so_for + 1`。

这些都是以`c`结尾的子序列。

###### 如何利用贡献法处理重复？ - 覆盖旧的贡献

假设`s = aba`

- 处理第一个`a`的时候，`total_so_far = 0`。 因此它的贡献就是`0 + 1 = 1`。这个贡献就是`{"a"}`。

- 处理`b`的时候，`total_so_far = 1`，它的贡献时`1 + 1 = 2`。这个贡献是`{"b","ab"}`。

- 处理第二个`a`的时候，`total_so_far`已经变成了`1 + 2 = 3`。

  它的心贡献应该是`3 + 1 =4 `。这四个新贡献的子序列应该是`{a,aa,ba,aba}`。

我们发现，这4个新贡献完全包含了第一个`a`的贡献的`{"a"}`，并且还包含了更多(`"aa","ba","aba"`)。

结论： 一个字符串`c`的贡献，会**完全覆盖并扩展**上一次同样字符的贡献。

因此，我们不需要做复杂的减法去重。我们只需要使用新的贡献值**覆盖**旧的贡献之即可。

###### 贡献法的DP实现

我们可以用一个DP数组 `dp[26]` 来记录**贡献**。

`dp[k]`：表示当前以字符 `('a' + k)` 结尾的不同子序列的总数。这本身就是该字符到目前为止的**净贡献**。

**推导过程 (`s = "aba"`)**

1. **初始状态**: `dp = [0, 0, ...]`
2. **处理 `s[0] = 'a'`**:
   - 当前总贡献 `sum(dp)` = 0。
   - `'a'` 的新贡献 = `sum(dp) + 1` = 1。
   - 更新 `dp['a'-'a'] = 1`。
   - `dp` 状态: `[1, 0, 0, ...]`
3. **处理 `s[1] = 'b'`**:
   - 当前总贡献 `sum(dp)` = 1。
   - `'b'` 的新贡献 = `sum(dp) + 1` = 2。
   - 更新 `dp['b'-'a'] = 2`。
   - `dp` 状态: `[1, 2, 0, ...]`
4. **处理 `s[2] = 'a'`**:
   - 当前总贡献 `sum(dp)` = 1 + 2 = 3。
   - `'a'` 的新贡献 = `sum(dp) + 1` = 4。
   - **用新贡献覆盖旧贡献**: 更新 `dp['a'-'a'] = 4`。
   - `dp` 状态: `[4, 2, 0, ...]`
5. **最终结果**:
   - 遍历结束，总的不同子序列数 = 所有贡献之和 = `sum(dp)` = 4 + 2 = 6。

##### 实现原理和步骤

1. **初始化**: 
   - 创建一个长整型数组 `dp[26]`，用于存储每个字符的贡献。初始值全为0。
   - 定义模数 `MOD`。
2. **遍历字符串**: 对字符串 `s` 的每个字符 `c` 进行迭代。
3. **计算当前总贡献**: 
   - 在循环内部，首先计算 `dp` 数组的当前总和 `total_contribution_so_far`。
   - 这代表了在处理 `c` 之前，已经累积的所有不同子序列数量。
4. **计算 `c` 的新贡献**: 
   - `c` 字符本次的贡献值等于 `(total_contribution_so_far + 1) % MOD`。
5. **更新贡献**: 
   - 将 `c` 对应在 `dp` 数组中的值更新为它的新贡献：`dp[c - 'a'] = new_contribution`。
6. **计算最终答案**: 
   - 循环结束后，`dp` 数组里存储了每个字符的最终净贡献。
   - 将它们全部相加并取模，即为最终答案。

##### 实现代码

```java
class Solution {
    public int distinctSubseqII(String s) {
        int MOD = 1_000_000_007;
        
        // dp[i] 存储以字符 ('a' + i) 结尾的不同子序列的数量，
        // 这也代表了该字符到目前为止的“净贡献”。
        long[] dp = new long[26];

        for (char c : s.toCharArray()) {
            // 在计算当前字符c的贡献之前，先累加之前所有字符的贡献总和。
            long totalContributionSoFar = 0;
            for (long contribution : dp) {
                totalContributionSoFar = (totalContributionSoFar + contribution) % MOD;
            }

            // 当前字符c的新贡献 = (之前的总贡献 + c本身)
            long newContribution = (totalContributionSoFar + 1) % MOD;
            
            // 将字符c的贡献值更新为最新计算出的值。
            // 这个“覆盖”操作是贡献法处理重复的关键。
            dp[c - 'a'] = newContribution;
        }

        // 最终结果是所有字符贡献的总和。
        long finalResult = 0;
        for (long contribution : dp) {
            finalResult = (finalResult + contribution) % MOD;
        }

        return (int) finalResult;
    }
}
```

##### 注意事项 (Important Notes)

- **使用 `long` 类型**: 中间累加过程可能超过 `Integer` 的最大值，使用 `long` 来存储贡献值和总和是防止溢出的安全做法。
- **及时取模**: 在每次加法操作后都应立即取模，这是模运算的基本准则。
- **理解“覆盖”**: 理解 `dp[c - 'a'] = new_contribution` 这一步是“覆盖”而非“累加”，是掌握此解法的核心。它意味着字符 `c` 的贡献被重新定义，旧的贡献因为冗余而被舍弃。

##### 经验总结

- **贡献法是化繁为简的利器**: 它将一个全局的、复杂的计数问题，分解为一系列局部的、更简单的贡献计算问题，思路清晰，不易出错。

- **“覆盖式更新”是处理重复的妙招**: 在涉及序列和重复元素的DP计数问题中，“覆盖”旧状态/旧贡献是一种非常优雅且高效的去重技巧。它避免了繁琐的“加了再减”的逻辑。

- **抓住问题本质**: 无论方法如何，核心都是要找到一种方式来唯一地标识和计算每个不同的子序列。贡献法通过“以哪个字符结尾”来对子序列进行分类，确保了在计数的过程中不会遗漏或重复。

