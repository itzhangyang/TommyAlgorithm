# 常见题型以及应对策略整理

| #    | 数据结构       | 场景描述                | 状态定义与初始化                                             | 遍历逻辑                     | 状态转移方程                                                | 常见目标          | 核心思想              | 注意事项                         | Leetcode题号示例             |
| ---- | -------------- | ----------------------- | ------------------------------------------------------------ | ---------------------------- | ----------------------------------------------------------- | ----------------- | --------------------- | -------------------------------- | ---------------------------- |
| 1    | 数组           | 子数组最大和            | `dp[i]`: 以 i 结尾的最大和；`dp[0] = nums[0]`                | i 正序                       | `dp[i] = max(dp[i-1] + nums[i], nums[i])`                   | 最大和            | 局部最优构造全局最优  | 结果为 `max(dp)`，而非 `dp[n-1]` | 53, 918, 1749                |
| 2    | 数组           | 0-1 背包问题            | `dp[i][j]`: 前 i 个物品容量为 j 的最大价值；`dp[0][*]=0`     | i 正序, j 逆序               | `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`        | 最大价值          | 选或不选              | j 从大到小遍历，避免重复使用     | 416, 494, 474, 1049, 879     |
| 3    | 数组           | 完全背包问题            | 同上；物品可选多次；`dp[0][*]=0`                             | i 正序, j 正序               | `dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])`          | 最大价值          | 可重复选物品          | j 从小到大遍历                   | 322, 518, 377, 139, 70       |
| 4    | 数组           | 子集/目标和问题         | `dp[i][j]`: 前 i 个数凑成 j 是否可行 / 有几种方案            | i 正序，j 正序               | `dp[i][j] = dp[i-1][j]`                                     |                   | dp[i-1][j - nums[i]]` | 可行性/方案数                    | 转换为背包问题               |
| 5    | 数组           | 最长上升子序列（LIS）   | `dp[i]`: 以 nums[i] 结尾的 LIS；初始值 1                     | i 正序，j < i                | `dp[i] = max(dp[j] + 1)` if `nums[j] < nums[i]`             | 最大长度          | 枚举所有前小值        | 可二分优化为 O(nlogn)            | 300, 354, 673, 376           |
| 6    | 字符串         | 最长公共子序列（LCS）   | `dp[i][j]`: s1 前 i 与 s2 前 j 最长公共子序列                | i, j 正序                    | 相等：`dp[i-1][j-1]+1`；否则：`max(dp[i-1][j], dp[i][j-1])` | 最大长度          | 双串对比状态          | 子序列可不连续                   | 1143, 516, 583               |
| 7    | 字符串         | 编辑距离                | `dp[i][j]`: word1 转 word2 的最小操作数；`dp[0][j]=j, dp[i][0]=i` | i, j 正序                    | 相等：`dp[i][j]=dp[i-1][j-1]`；否则：`min(增,删,改)`        | 最小操作数        | 编辑操作递推          | 初始空串处理非常关键             | 72, 583, 1611                |
| 8    | 数组           | 股票买卖问题            | `dp[i][k][s]`: 第 i 天，第 k 次交易，s 是否持股              | i 正序                       | 各题型不同：买、卖、冷冻等状态转移                          | 最大利润          | 状态机建模            | 状态爆炸时注意空间优化           | 121, 122, 123, 188, 309, 714 |
| 9    | 区间数组       | 区间合并/合并代价问题   | `dp[i][j]`: 区间 [i,j] 的最小合并代价；`dp[i][i] = 0`        | 区间长度从小到大，内层枚举 k | `dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost[i][j])`        | 最小代价          | 枚举所有分割点        | 配合前缀和加速合并代价           | 312, 1000, 546               |
| 10   | 字符串         | 正则匹配（带 * 和 .）   | `dp[i][j]`: s[0..i-1] 与 p[0..j-1] 是否匹配；`dp[0][0] = true` | i, j 正序                    | `*`：`dp[i][j]=dp[i][j-2]`                                  |                   | `dp[i-1][j]`          | 是否匹配                         | 状态转移模拟匹配过程         |
| 11   | 图（状态压缩） | 压缩状态最短路径（TSP） | `dp[mask][u]`: 访问mask中所有点，以u结尾路径长度             | 枚举 mask 和结尾点 u         | `dp[mask][u] = min(dp[prev][v] + dist[v][u])`               | 最短路径          | 状态压缩 + 记忆       | 状态数为 2^n，适用于 n≤15        | 847, 943, 698                |
| 12   | 树结构         | 树形DP（子树依赖）      | `dp[u]`: 节点u为根的子树最优解；DFS 初始化                   | 后序遍历                     | `dp[u] = 合并子树 dp + 本节点贡献`                          | 最大和/路径       | 自底向上合并状态      | 通常结合 DFS 完成                | 337, 124, 834, 236           |
| 13   | 数位（整数）   | 数位 DP                 | `dp[pos][tight][...]`: 当前位置状态的计数/总数               | 高位到低位，按位递归         | `dp[pos] = Σ dp[next_pos]` 满足限制条件                     | 计数/构造数       | 高位递归 + 记忆化搜索 | tight 限制与前导零处理细节多     | 233, 600, 902                |
| 14   | 概率/期望      | 概率/期望类问题         | `dp[i]`: 当前状态下的最大概率/期望值                         | 通常顺序不限                 | `dp[i] = Σ(p[j]*dp[j]) + 当前代价`                          | 最大概率/最小期望 | 概率转移 + 加权平均   | 浮点误差处理，边界概率正确处理   | 688, 837, 808                |

# 线形动态规划类问题

线性 DP 是动态规划中最基础的一类，其状态 `dp[i]` 通常只与它前面的一个或几个有限的状态（如 `dp[i-1]`, `dp[i-2]`）相关。问题模型通常建立在数组或序列上。

##线性动态规划类问题的特征

###问题基于线性结构

问题的输入通常是一个数组或者字符串

###状态定义是一维的

`dp`数组的定义是一维的`dp[i]`。这个`i`代表了问题在线性结构上推进的位置或者阶段。

`dp`的定义通常有：

- **以i结尾的最优解**，或者
- **前i个元素的最优解**

###状态转移具有局部性

`dp[i]`的计算通常只依赖于前面一个或者几个有限的、固定的状态。

最常见的就是 `dp[i-1]`、`dp[i-2]` 等。它不会跳跃式地依赖于 `dp[0]`、`dp[i/2]` 等远距离的状态。

###计算顺序是线性的

`dp` 数组的填充过程通常是从左到右、单向进行的，即从 `dp[0]` 逐步计算到 `dp[n]`。

##常见的当前值与前值关系分析





##基础递推类问题（佩波那契/爬楼梯）

场景：问题可以被分解为与前一步或前两步相关的、结构完全相同的子问题。

目标： 计算到达某个点的总方法数或总成本。

- 典型题目如 LC 70 (爬楼梯)
- LC 746 (使用最小花费爬楼梯)。

###问题的本质和分析 - 佩波那契数列的变种

这类问题的本质是斐波那契数列的变种。

当前状态的值是其前几个状态值的直接组合（通常是相加或取最值）。

这是理解“最优子结构”和“状态转移”最直观的入门题型。

###核心套路 - 动态规划

这类问题完美契合 DP 的应用场景：子问题有重叠（计算 `dp[5]` 和 `dp[6]` 都会用到 `dp[4]`），且当前问题的解可以由子问题的解推导出来。

###原理和步骤 - 以爬楼梯为例

1. **定义状态**：`dp[i]` 表示爬到第 `i` 阶楼梯的总方法数。

2. **确定选择**：要到达第 `i` 阶，只能从第 `i-1` 阶（爬1步）或第 `i-2` 阶（爬2步）上来。

3. **状态转移方程**：到达第 `i` 阶的方法数等于到达前两阶方法数的总和，即 `dp[i] = dp[i-1] + dp[i-2]`。

4. **明确初始状态**：`dp[1] = 1`（到第1阶只有1种方法），`dp[2] = 2`（到第2阶有2种方法：1+1 或 2）。

5. **返回结果**：最终结果是 `dp[n]`。

###实现代码

```java
// 题型核心模板：爬楼梯 (LC 70)
public int climbStairs(int n) {
    if (n <= 2) {
        return n;
    }
    // 1. 定义状态数组
    int[] dp = new int[n + 1];

    // 4. 明确初始状态
    dp[1] = 1;
    dp[2] = 2;

    // 迭代求解
    for (int i = 3; i <= n; i++) {
        // 3. 状态转移方程
        dp[i] = dp[i-1] + dp[i-2];
    }

    // 5. 返回最终结果
    return dp[n];
}
```

###注意事项

注意初始条件的设置，是 `dp[0]`、`dp[1]` 还是 `dp[2]`，这取决于状态转移方程和问题定义。

这类问题通常可以用空间优化，只保留前两个状态，将空间复杂度从 O(N) 降到 O(1)。

###经验总结

这是最简单的 DP 模型，是练习 DP 思维的绝佳起点。其核心在于识别出问题与斐波那契数列的相似结构。

###Leetcode 91: 解码方法

你得到了一个只包含数字的字符串，要求你计算这个字符串有多少种方式可以被解码成字母。

> **规则**：'A' -> 1, ..., 'Z' -> 26
> 输入只能由数字组成，不能包含字母或其他字符。

####核心思想

这是一个典型的动态规划题目，每个位置`i`的解码方式取决于：

- 它自己一个字符是否可以解码(`s[i-1] != 0`)
- 它和前一个字符组成的两位数是否可以解码（`10 <= s[i-2...i-1] <=26`）

##### 状态定义-`dp[i]`表示以`s[0...i-1]`结尾的字符串可以被解码的总方法数

为了简化边界，通常会使用`dp[0]`表示空字符串(方法数为`1`，表示什么都不做)

##### 遍历方式-从做到右线性遍历

每次看`i-1`和`i-2`的情况是否能够解码，并相应的更新状态

- 如果 `s[i-1]`可解码，则`dp[i] = dp[i-1]`
- 如果`s[i-2]`和`s[i-1]`合并起来的两位数可以解码，则`dp[i] += dp[i-2] `

##### 状态转移方程以及解析

假设`s`的长度为`n`，从第一个字符开始

```java
//当前数字可以被解码的情况
if (s.charAt(i-1) != '0'){
  dp[i] += dp[i-1];
}
//当前数字与前一位数字合成的两位数可以被解码的情况
if (i >= 2){
  int twoDigit = Integer.parseInt(s.substring(i-2,i));
  if (twoDigit >= 10 && twoDigit <= 26){
    dp[i] += dp[i-2];
  }
}
```

##### 代码实现

```java
public int numDecodings(String s){
        if (s == null || s.length() == 0 || s.charAt(0) == '0') {
            return 0;
        }

        int n = s.length();
        int[] dp = new int[n + 1]; // dp[i] 表示前 i 个字符的解码方法数
        dp[0] = 1; // 空字符串一种解法
        dp[1] = 1; // 非零首位只有一种解法
				
  			//外层遍历：按照元素逐层遍历
        for (int i = 2; i <= n; i++) {
  					//内层逻辑，基于当前元素向前寻找特定元素或者区间
            char oneChar = s.charAt(i - 1);
            char twoChar1 = s.charAt(i - 2);

            // 单个字符合法（非0）
            if (oneChar != '0') {
                dp[i] += dp[i - 1];
            }

            // 两个字符合法（在10到26之间）
            int twoDigit = (twoChar1 - '0') * 10 + (oneChar - '0');
            if (twoDigit >= 10 && twoDigit <= 26) {
                dp[i] += dp[i - 2];
            }
        }

        return dp[n];
}
```

##### 注意事项

1. **输入以 0 开头时非法**：比如 `"06"`，应直接返回 `0`
2. **不能把 `"0"` 作为独立解码**：只能出现在 `"10"` 到 `"26"` 中
3. **长度为 1 的情况要特殊处理**：初始化时处理好 `dp[1]`
4. **字符串越界问题**：使用 `substring(i-2, i)` 时需保证 `i >= 2`

#####  经验总结

| 项目     | 内容                                                |
| -------- | --------------------------------------------------- |
| 问题类型 | 字符串 + 动态规划                                   |
| 状态设计 | `dp[i]` 表示前 `i` 个字符的解码方法数               |
| 状态转移 | 单个字符有效加 `dp[i-1]`，两个字符有效加 `dp[i-2]`  |
| 初始化   | `dp[0]=1`, `dp[1]=1`（前提是 `s.charAt(0) != '0'`） |
| 空间优化 | 可以优化为 O(1) 使用两个变量 `prev1` 和 `prev2`     |
| 易错点   | 不合法的 0、两位数不在合法区间                      |

###Leetcode 983: Minimum Cost For Tickets（最低票价）

####问题要点

#####问题描述

在一个火车旅行的国家，你需要在一个**特定的日期序列（`days` 数组）里**旅行。

火车票有三种类型，价格分别为 `costs[0]`，`costs[1]` 和 `costs[2]`：

**1 天通行证 (1-day pass)**：价格为 `costs[0]`，允许你在购买当天以及之后的 0 天内（即仅当天）旅行。

**7 天通行证 (7-day pass)**：价格为 `costs[1]`，允许你在购买当天以及之后的 6 天内旅行。

**30 天通行证 (30-day pass)**：价格为 `costs[2]`，允许你在购买当天以及之后的 29 天内旅行。

你需要计算并返回完成所有旅行计划所需的最低费用。

###### 示例

```
days = [1, 4, 6, 7, 8, 20]
costs = [2, 7, 15]
```

**输出:** `11`

#####示例解释

- 在第 1 天，买一张 1 天通行证，花费 2。这张票覆盖第 1 天。

- 在第 4 天，买一张 7 天通行证，花费 7。这张票覆盖第 4, 6, 7, 8 天。

- 在第 20 天，买一张 1 天通行证，花费 2。这张票覆盖第 20 天。 总花费是 2 + 7 + 2 = 11。

####问题的本质和分析

这个问题的本质是一个**最优化问题**（Optimization Problem）。

我们需要在一系列决策中，找到一个决策序列，使得总成本最低。

具体来说，对于每一个需要旅行的日子 `d`，我们都面临一个**决策**：

1. 买一张 1 天票来覆盖今天。
2. 买一张 7 天票来覆盖今天以及未来几天。
3. 买一张 30 天票来覆盖今天以及未来更多天。

这个决策会影响到未来的决策。

例如，如果今天买了一张 7 天票，那么接下来的 6 天内如果需要旅行，就无需再买票，从而影响了后续日子的决策。

这种“当前决策影响未来决策”的特性，以及求解“最优解”的目标，是动态规划问题（Dynamic Programming, DP）的典型特征。

####背景知识 - 动态规划

这个问题本身不涉及非常高深的数学理论，但其核心思想与以下概念紧密相关：

- **最优子结构 (Optimal Substructure):** 问题的最优解可以由其子问题的最优解有效地构造出来。

  对于本题，要计算到第 `i` 天的最低花费，我们可以依赖于在它之前的某几天的最低花费。

  例如，到第 `i` 天的花费，可能是由“到第 `i-1` 天的最低花费 + 买一张 1 天票”或者其他选项推导出来的。

- **重叠子问题 (Overlapping Subproblems):** 在解决问题的过程中，许多子问题的解会被重复计算。

  例如，在递归求解时，我们可能会多次尝试计算到第 `k` 天的最低费用。

  动态规划通过“记忆化”（Memoization）或“表格法”（Tabulation）来存储子问题的解，避免重复计算。

从更广义的角度看，它属于运筹学（Operations Research）中的一类规划问题，目标是在给定约束下最大化收益或最小化成本。

####核心思想和套路 - 动态规划

#####状态定义

确定 `dp` 数组的含义。这是最关键的一步。

`dp[i]` 通常表示“解决到规模 `i` 的子问题的最优解”。

在本题中，一个自然的想法是定义 `dp[i]` 为 **“完成到第 `i` 天（一年中的第 `i` 天）为止的旅行计划所需的最低费用”**。

注意，这里的 `i` 是指日历上的天数，而不是 `days` 数组的索引。

#####确定状态转移方程

找到 `dp[i]` 和 `dp[j]` (其中 `j < i`) 之间的关系。

对于第 `i` 天，有两种情况：

- **如果第 `i` 天不需要旅行:**

   那么到第 `i` 天的最低花费和到第 `i-1` 天是一样的。即 `dp[i] = dp[i-1]`。

- **如果第 `i` 天需要旅行:** 我们有三种选择来覆盖第 `i` 天的旅行：

  1. **买 1 天票:** 花费是 `dp[i-1] + costs[0]`。

  2. **买 7 天票:** 这张票可以覆盖 `[i-6, i]` 这 7 天。

     所以我们只需要支付到 `i-7` 天的费用，再加上这张 7 天票的钱。

     花费是 `dp[i-7] + costs[1]`。

  3. **买 30 天票:** 这张票可以覆盖 `[i-29, i]` 这 30 天。

     花费是 `dp[i-30] + costs[2]`。 

     我们在这三个选择中取最小值。

     所以 `dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1], dp[i-30] + costs[2])`:

     $dp[i] = min(dp[i-1]+cost[0],dp[i-7]+cost[1],dp[i-30]+costs[2])$

     

#####确定初始状态和边界条件

- `dp[0] = 0`，表示第 0 天之前没有任何花费。

- 在计算 `dp[i-7]` 或 `dp[i-30]` 时，如果索引小于 0，应视为 0。

  - 当`i-7`<=0 时，$dp[i-7] = 0$
  - 当`i-7` > 0时，$dp[i-7]$不为0

  - 例如 `dp[max(0, i-7)]`。

####实现原理和步骤

#####**确定 DP 数组的大小:** 

旅行计划最多到 `days` 数组中的最后一天。所以我们可以创建一个大小为 `last_day + 1` 的 `dp` 数组。

##### **标记需要旅行的日子:** 

为了快速判断某一天是否需要旅行，可以使用一个 `boolean` 数组或 `Set` 来存储所有需要旅行的日子。

#####**初始化 DP 数组:**

 `dp[0] = 0`。

#####**遍历计算:** 从第 1 天开始，遍历到最后一天 `last_day`。

- 对于每一天 `i`：
  - 检查今天 `i` 是否需要旅行。
  - 如果不需要，则 `dp[i] = dp[i-1]`。
  - 如果需要，则根据状态转移方程计算 `dp[i]`：
    - `option1 = dp[i-1] + costs[0]`
    - `option2 = dp[max(0, i-7)] + costs[1]`
    - `option3 = dp[max(0, i-30)] + costs[2]`
    - `dp[i] = min(option1, option2, option3)`

##### **返回结果:** 

最终结果就是 `dp[last_day]`。

####实现代码

```java
class Solution {
    //
    public int mincostTickets(int[] days, int[] costs) {
        int n = days.length;
        int max = days[n-1];
        Set<Integer> daySet = new HashSet<>();
        for(int day : days){
            daySet.add(day);
        }
        int[] dp = new int[max+1];
        dp[0] = 0;
        for(int day = 1; day <= max; day++){
            if(!daySet.contains(day)){
                dp[day] = dp[day-1];
            }else{
                int option1Cost = dp[day-1] + costs[0];
                int option2Cost = dp[Math.max(0, day-7)] + costs[1];
                int option3Cost = dp[Math.max(0, day-30)] + costs[2];
                dp[day] = Math.min(option1Cost, Math.min(option2Cost,option3Cost)); 
            }
        }
        return dp[max];
    }
}
```

####注意事项

- **DP 数组的索引:** 要清楚 `dp[i]` 中的 `i` 代表的是日历上的“第 `i` 天”，而不是 `days` 数组的索引。这是一个常见的混淆点。

- **边界处理:** `i-7` 或 `i-30` 可能会小于 0，需要使用 `max(0, ...)` 来处理，确保索引不会越界。`dp[0]` 的花费是 0，这个逻辑是自洽的。

- **空间优化:** 观察状态转移方程，`dp[i]` 只依赖于 `dp[i-1]`, `dp[i-7]`, `dp[i-30]`。如果 `days` 数组跨度非常大（例如 `[1, 365]`），但旅行天数很少，那么 `dp` 数组会很大。但在这个解法中，我们必须计算所有中间天的 `dp` 值，所以空间复杂度是 `O(last_day)`。还有一种 DP 思路是基于 `days` 数组的索引进行状态定义，`dp[i]` 表示完成前 `i` 个旅行日所需的最低费用，可以优化空间，但逻辑稍复杂一些。不过，本题中 `last_day` 最大为 365，所以 `O(last_day)` 的空间复杂度是完全可以接受的。

- **数据结构选择:** 使用 `HashSet` 来存储旅行日，可以让我们以 `O(1)` 的时间复杂度判断某一天是否需要旅行，提高了整体效率。

####经验总结

- **识别 DP 是第一步:** 遇到求解最优值（最大/最小/最长等）的问题，且存在重叠子问题和最优子结构时，优先考虑动态规划。

- **定义状态是核心:** `dp` 数组的定义直接决定了状态转移方程的写法和解题的难易程度。选择一个清晰、易于递推的状态定义至关重要。将状态定义为“到第 `i` 天的最小花费”是一种非常直观和通用的方法。

- **从具体例子推导状态转移:** 如果对状态转移方程没有头绪，可以手动模拟一个简单的例子（比如 `days = [1, 2, 5]`, `costs = [2, 7, 15]`），看看在第 5 天时，你是如何做决策的。你会发现，你的决策依赖于第 4 天、第 1 天之前的花费情况，这自然而然就引出了状态转移方程。

- **清晰的逻辑和代码结构:** 即使思路正确，混乱的代码也容易出错。将问题分解为“初始化”、“循环递推”、“处理不同情况”等模块，能让代码更易读、更易调试。

- **多种 DP 实现方式:** 同一个 DP 问题可能有多种状态定义方式。例如，本题也可以定义 `dp[i]` 为“覆盖到 `days[i]` 这个旅行日所需的最低花费”。不同的定义方式会导致状态转移方程和实现细节的不同，可以尝试思考并实现，以加深理解。

### Leetcode 716: 爬楼梯的最小费用

注意是怕到最后一层楼梯的顶上，不是到达最后一层楼梯

#### 代码实现

```Java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n+1];

        dp[0] = 0;
        dp[1] = 0;

        for(int i = 2; i <= n; i++){
            //从i-1爬上来，得支付i-1的费用
            int option1 = dp[i-1] + cost[i-1];
            
            //从i-2爬上来，得支付i-2的费用
            int option2 = dp[i-2] + cost[i-2];

            dp[i] = Math.min(option1, option2);
        }
        //爬到楼梯的顶上，不是最后一层楼梯
        return dp[n];

    }
}
```



##打家劫舍模型

###场景和目标 - 选择不相邻的元素

**场景**：给定一个数组，代表一排房屋的财富。

**目标**：选择一些**不相邻**的元素，使其总和最大。这些包括：

- 线形排列- LC-198
- 环形排列 - LC 213
- 树形结构 - LC 337

###问题本质和分析 - 选择或者不选择

在每一个位置`i`，都需要做一个决策：偷或者不偷。

这个决策会影响到下一个位置`i+1`的决策（如果偷了`i`，就不能偷`i+1`）.

这是一个典型的**多阶段决策问题**。

###核心套路 - 动态规划

- `dp[i]` 的最优解依赖于 `dp[i-1]`（不偷当前家）和 `dp[i-2]`（偷当前家）的状态，符合线性 DP 的特征。

###原理和步骤 - 以线性打家劫舍为例

####定义状态： `dp[i]` 表示考虑到第 `i` 家房屋时能够偷到的最高金额

`dp[i]` 表示考虑到第 `i` 家房屋时（即前 `i+1` 家），能偷到的最高金额。

####确定选择 0 - 偷或者不偷

对于第 `i` 家房屋，可以选择**偷**或**不偷**。

####状态转移方程

- **不偷**第 `i` 家：那么最大金额就是偷前 `i-1` 家的最大金额，即 `dp[i-1]`。

- **偷**第 `i` 家：那么就不能偷第 `i-1` 家，最大金额是偷前 `i-2` 家的最大金额加上当前家的财富，即 `dp[i-2] + nums[i]`。

综合起来：`dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])`。

#####明确初始状态

**明确初始状态**：`dp[0] = nums[0]`，`dp[1] = Math.max(nums[0], nums[1])`。

**返回结果**：最终结果是 `dp[n-1]`。

###代码套路模板 - 线性打家劫舍

```java
public int rob(int[] nums){
  if(nums == null || nums.length == 0) return 0;
  if(nums.length == 1) return nums[0];
  
  int n = nums.length;
  int[] dp = new int[n];
  
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0],nums[1]);
  
  for(int i = 2; i < n; i++){
    dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
  }
  
  return dp[n-1];
}
```

###注意事项

- 环形排列（LC 213）可以分解为两个线性问题：偷 `[0, n-2]` 和偷 `[1, n-1]`，然后取两者最大值。
- 树形结构（LC 337）需要使用树形 DP，每个节点返回一个包含“偷”和“不偷”两种状态的数组。

###经验总结

- “打家劫舍”模型的核心在于“做与不做”的决策，并且这个决策会限制相邻的选择。这是 DP 中非常经典的一种状态转移模式。

###Leetcode 213 环形打家劫舍

#### 问题要点 - 围成一圈的房子

**环形排列**: 与标准版“打家劫舍”最大的不同是，这里的房屋是 **围成一圈** 的。这意味着第一家和最后一家是相邻的。

**相邻限制**: 盗贼不能偷窃 **相邻** 的两间房屋。

**目标**: 在满足上述条件下，计算一晚上能偷窃到的 **最高总金额**

这个“环形”的特点是解决本题的关键，也是唯一的**难点**。

#### 问题的本质和分析 - 序列决策问题

问题的本质依然是一个 **序列决策问题**：给定一个序列（房屋和其金额），你需要做出一个决策序列（偷或不偷），以在满足特定约束（不偷相邻房屋）的条件下，最大化收益。这种类型的问题通常是动态规划的用武之地。

与第一版（线性排列）相比，这里的约束变得更强了。因为第一家和最后一家相邻，所以你面临一个两难的抉择：

- **如果偷了第一家**，那么就绝对不能偷最后一家。
- **如果偷了最后一家**，那么就绝对不能偷第一家。

当然，也可能第一家和最后一家都不偷。

这个“环形”的依赖关系破坏了标准线性动态规划的子问题独立性。

直接在一个环上应用DP会很棘手，因为状态的定义和转移会变得复杂。

因此，我们需要想办法 **“破环为链”**，将这个环形问题转化为我们已经熟悉的线性问题。

#### 模式套路匹配

- **问题类型**: 序列动态规划 (Sequence DP)。
- **核心模式**: 最优子结构 (Optimal Substructure) 和 重叠子问题 (Overlapping Subproblems)。一个大问题的最优解可以由其子问题的最优解推导出来。
- **特定套路**: **环形DP问题 -> 拆解成线性DP问题**。
  - 处理环形数组/序列问题时，一个非常常见的技巧是将其分解为两个或多个独立的线性问题来解决，然后综合这些线性问题的结果。

#### 核心思想和套路 - 分类讨论

核心思想就是 **分类讨论**，将环形问题转化为两个独立的线性问题。

既然第一家和最后一家不能同时被偷，那么最终的最优解（能偷到的最大金额）必然来自以下两种情况之一：

##### 情况A: 不偷最后一家

- 那么问题就退化成了：在 `nums[0], nums[1], ..., nums[n-2]` 这个线性序列上，计算能偷到的最大金额。这正是标准的“打家劫舍 I”问题。

##### **情况B：不偷第一家 (`nums[0]`)**

那么问题就退化成了：在 `nums[1], nums[2], ..., nums[n-1]` 这个线性序列上，计算能偷到的最大金额。这也是标准的“打家劫舍 I”问题。

最终的答案，就是这两种情况得到的最大金额中的较大者：

```
max_robbery = max( rob_linear(nums[0...n-2]), rob_linear(nums[1...n-1]) )
```

这种“破环为链”的思路，通过巧妙地移除环的连接点（即首尾元素的约束），将一个复杂问题简化成了两个我们已经会解决的简单问题的组合。

##### 为什么这种分类是完备的？

- 最终的最优策略里，如果**不包含最后一家**，那么这个策略一定会在“情况A”中被考虑到。

- 最终的最优策略里，如果**不包含第一家**，那么这个策略一定会在“情况B”中被考虑到。

- 最终的最优策略里，如果**既不包含第一家，也不包含最后一家**，那么这个策略同时被“情况A”和“情况B”覆盖了，取最大值时不会遗漏。

- 唯一被排除的是**同时包含第一家和最后一家**的策略，而这恰恰是题目规则所禁止的。

因此，这种分类是 **不重不漏** 的，覆盖了所有有效的情况。

可以分解为两个线性问题：偷 `[0, n-2]` 和偷 `[1, n-1]`，然后取两者最大值。

#### 实现原理和步骤

##### 处理边界情况：空数组或者只有一个元素的情况

- 如果 `nums` 为空或 `null`，返回 0。
- 如果 `nums` 只有一个元素，小偷可以直接偷，返回 `nums[0]`。这是个特殊情况，因为下面的拆分逻辑要求数组长度至少为2。

##### 创建辅助函数

为了代码复用，创建一个辅助函数 `robRange(int[] nums, int start, int end)`，该函数用于计算在线性数组 `nums` 的 `[start, end]` 闭区间内能偷到的最大金额。

这个函数就是 LeetCode 198 的解法。

##### 实现辅助函数：`robRange(nums,int start, int end)`

- 使用两个变量 `rob` 和 `not_rob` 来优化空间。
- `rob`: 表示到当前房屋 `i`为止，并且 **偷了** 房屋 `i` 所能得到的最大金额。
- `not_rob`: 表示到当前房屋 `i`为止，并且 **没偷** 房屋 `i` 所能得到的最大金额。
- **状态转移方程**:
  - 当我们考虑房屋 `i` 时，如果偷了它，那么前一个房屋 `i-1` 肯定不能偷。所以 `rob` 的当前值等于 `not_rob` 在上一个状态的值加上 `nums[i]`。
  - 如果我们不偷房屋 `i`，那么前一个房屋 `i-1` 可偷可不偷，我们取其中的最大值。所以 `not_rob` 的当前值等于 `max(rob_{i-1}, not_rob_{i-1})`。
- **优化**: 可以用两个变量 `prev_max` (相当于 `rob_{i-1}`) 和 `curr_max` (相当于 `not_rob_{i-1}`)来滚动更新，进一步简化。更经典的优化是 `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`，用两个变量 `first` 和 `second` 滚动记录 `dp[i-2]` 和 `dp[i-1]`。

##### 主函数逻辑

调用 `robRange` 两次：

- 第一次，计算不偷最后一家的情况：`max1 = robRange(nums, 0, nums.length - 2)`。
- 第二次，计算不偷第一家的情况：`max2 = robRange(nums, 1, nums.length - 1)`。

返回 `Math.max(max1, max2)`。

###### 代码实现

```java
class Solution {
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        int n = nums.length;
        int profit1 = robByRange(nums, 0, n-2);
        int profit2 = robByRange(nums,1, n-1);
        return Math.max(profit1,profit2);
    }

    private int robByRange(int[] nums, int start, int end){
        int[] subArr = Arrays.copyOfRange(nums,start,end+1);
        int n = subArr.length;
        int[][] dp = new int[n+1][2];
        dp[1][1] = subArr[0];

        for(int i = 2; i <= n; i++){
            //不偷i-1
            dp[i][0] = Math.max(dp[i-1][1], dp[i-1][0]);
            //偷i-1
            dp[i][1] = dp[i-1][0] + subArr[i-1];
        }
        return Math.max(dp[n][0],dp[n][1]);
    }
}
```

#### 注意事项

**数组长度为1的特例**: 当 `nums.length == 1` 时，`robRange(nums, 0, -1)` 和 `robRange(nums, 1, 0)` 的结果可能会出错或不符合预期，具体取决于 `robRange` 的实现。因此，在主函数开头就单独处理这个边界情况是最稳妥、最清晰的做法。

**`robRange` 的实现细节**: 辅助函数的实现必须正确。无论是用 DP 数组还是用两个变量优化的版本，都要确保其逻辑是标准的“打家劫舍 I”解法。

**理解拆分的本质**: 拆分成两个子问题不是随便拆的，其根本原因是为了打破首尾元素的“相邻”约束。一定要想明白为什么这样拆分是完备的。

#### 经验总结

**遇到环形问题，先想“破环为链”**：这是解决环形DP、环形数组问题的一个非常通用的策略。通常可以通过复制数组、或者像本题一样通过分类讨论来打破环。

**分解问题**: 当一个问题包含一个额外的复杂约束时（本题的“环形”），尝试先移除这个约束，解决其简化版（线性版）。然后思考如何通过组合简化版问题的解来处理这个额外的约束。

**代码复用**: 将核心的、可重用的逻辑（如线性的打家劫舍算法）封装成一个独立的辅助函数，能让主逻辑更清晰，也减少了代码冗余。

**动态规划的空间优化**: 对于 `dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]` 的情况，通常可以用有限的几个变量（例如两个或三个）来代替整个 DP 数组，将空间复杂度从 O(N) 优化到 O(1)。这是DP问题中一个非常常见的优化技巧。

### Leetcode 337: 树形打家劫舍

这个问题属于**树形动态规划**的范畴，该死的我好像将树形动态规划的套路又忘记的一干二净了。

详细见二叉树部分的详细解释。

##股票买卖模型

###场景和目标

**场景**：给定一个数组 `prices`，代表每日股票价格。

**目标**：通过在不同规则下（如一次交易、多次交易、含冷冻期、含手续费、K次交易）买卖股票，获取最大利润。典型题目如 LC 121, 122, 309。

###问题本质和分析

这是一个**状态机模型**。在每一天，你都处于某个特定的状态（如：持有股票、不持有股票且可购买、不持有股票且在冷冻期）。

你的目标是通过在不同状态间转移（即“买入”、“卖出”或“不动”），使得最终的利润最大化。

###核心套路 - 多状态动态规划

二维 DP 数组来表示不同的状态。

例如 `dp[i][0]` 表示第 `i` 天不持有股票的最大利润，`dp[i][1]` 表示第 `i` 天持有股票的最大利润。

###实现原理和步骤 - 多次交易为例（LC 122）

####定义状态 - 第`i`天持有或者不持有股票

`dp[i][0]`：第 `i` 天结束时，**不持有**股票的最大利润。

`dp[i][1]`：第 `i` 天结束时，**持有**股票的最大利润。

####确定选择 - 买入、不动或者卖出

每天的决策是“买入”、“卖出”或“不动”。

####状态转移方程

#####**今天不持有`dp[i][0]`**

`dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0])`

#####**今天持有`dp[i][1]`**

`dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`

####明确初始状态

**第一天不持有**：`dp[0][0] = 0`

**第一天持有**：`dp[0][1] = -prices[0]`

####返回结果

最后一天不持有股票的利润肯定是最大的，所以返回 `dp[n-1][0]`。

##### 实现代码

```java
public int maxProfit(int[] prices){
  int n = prices.length;
  if (n == 0) return 0;
  
  int[][] dp = new dp[n][2];
  dp[0][0] = 0;
  dp[0][1] = -prices[0];
  
  for (int i = 1; i < n; i++){
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]);
  }
  
  return dp[n-1][0];
}
```

##### 注意事项

不同题目规则不同，状态转移方程也会变化。

- 含冷冻期（LC 309）需要增加一个“冷冻”状态。
- 含手续费（LC 714）则在卖出或买入时减去 `fee`。

##### 经验总结

股票买卖问题是 DP 状态机建模的典范。关键在于**划分出清晰、互斥且完备的状态**，然后根据规则写出状态之间的转移关系。

###Leetcode 121: 买卖股票的最佳时机-`dp[i]= i天的最大收益`

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

####代码实现-动态规划方法超出时间限制

```java
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length <=1) return 0;

        int n = prices.length;
        //第i天卖出股票时所获取的最大利润
        int[] dp = new int[n+1]; 
        int max = Integer.MIN_VALUE;
        Arrays.fill(dp, Integer.MIN_VALUE);
        dp[1]=0;
        for(int i=2; i<=n;i++){
            for (int j=1; j<i;j++){
                dp[i] = Math.max(dp[i], prices[i-1]-prices[j-1]);
                max = Math.max(dp[i], max);
            }
        }
        return max <= 0 ? 0 : max;
    }
```

#### 非动态规划实现 - 记录[0...i-1]的最小值

```Java
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int n = prices.length;
        int profit = 0;
        for(int i = 1; i < n; i++){
            min = Math.min(min, prices[i-1]);
            profit = Math.max(profit, prices[i] - min);
        }
        return profit;
    }
}
```

###Leetcode 122 买卖股票的最佳时机 II-`d[n][2]-i天持有或者不持有的最大收益`

你可以进行**任意次交易（买入+卖出）**，但**不能同时参与多笔交易**（即必须在再次购买前卖出）。
 目标是：在给定的股票价格序列中，**获取最大利润**。

##### 问题分析

你可以进行任意次交易（买入+卖出），但是不能够同时参与多笔交易（**必须在再次购买前卖出**）

目标是在给定股票价格中，获取最大利润。

这是一个**多阶段决策问题**。

每天你都有两个选择-持有股票和不持有股票。

每天的状态的转移都依赖于前一天的状态，符合动态规划的特点。

##### 核心思想

我们定义两个状态：

- `dp[i][0]`:第`i`天结束时不持有股票的最大收益
- `dp[i][1]`:第`i`天技术时持有股票的最大收益

##### 状态定义和初始化

###### 状态定义

- `dp[i][0]`:第`i`天结束时不持有股票的最大收益
- `dp[i][1]`:第`i`天技术时持有股票的最大收益

###### 初始化第一天的情况

- 第一天不持有股票`dp[0][0]=0`
- 第一天持有股票`dp[0][1]=-price[0]`

##### 遍历逻辑和状态转移方程

遍历逻辑`i=[0...n-1]`表示从第0天到第`n-1`天。

###### 第`i`天结束时不持有股票的最大收益`dp[i][0]`

取决于两种情况：

- 第`i-1`天不持有股票时

  第`i-1`天结束时不持有股票的最大收益为`dp[i-1][0]`，

  **今天不落袋的话，今天的收益为0**，

  因此``i-1`没有持有，`i`也没有持有的情况下，第`i`天的收益依然是`dp[i][0]=dp[i-1][0]`

- 第`i-1`天持有股票时的最大收益

  第`i-1`天持有股票时，最大收益是`dp[i-1][1]`,但是今天会卖掉股票，卖掉股票的收益就是`price[i]`

  因此，在`i-1`天持有股票，`i`不持有股票时（在第`i`天买掉）的情况下，总收益是`dp[i][0]=dp[i-1][1]+price[i]`

总和以上`dp[i][0] = max(dp[i-1][0],dp[i-1][1]+price[i])`

###### 第`i`天结束时持有股票的情况

同样取决两种情况：

- 第`i-1`天不持有股票

  第`i-1`天持有股票，但是`i`天持有股票，

  说明第`i`买入了股票，因此`dp[i][1]=dp[i-1][0]-price[i]`

- 第`i-1`天持有股票

  第`i-1`天持有股票，第`i`天也持有股票

  说明什么都没做，收益不变

  因此 `dp[i][1]=dp[i-1][1]`

总和以上`dp[i][1]=max(dp[i-1][0]-price,dp[i-1][1])`

##### 代码实现

```java
    public int maxProfit(int[] prices) {
        if (prices == null  || prices.length <=1 ) return 0;

        int n = prices.length;
        int[][] dp = new int[n][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i=1; i<n;i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
            dp[i][1] = Math.max(dp[i-1][0]-prices[i], dp[i-1][1]);
        }

        return Math.max(dp[n-1][0], dp[n-1][1]);
    }
```

##### 注意事项

1. 最后返回的是 `dp[n-1][0]`，即不持股状态下的收益；
2. `dp[i][1]` 表示当前还持股，因此不能作为最终答案；
3. 如果用滚动数组（空间优化）可以只用两个变量表示前一天的状态；
4. 注意股票价格数组可能为空，处理边界情况。

##### 经验总结

| 点           | 内容                                                         |
| ------------ | ------------------------------------------------------------ |
| 问题类型     | 多阶段决策，适合动态规划建模                                 |
| 核心思路     | 持股 vs 不持股，两种状态转移                                 |
| 状态数量     | 两个状态，适合空间优化                                       |
| 可否贪心？   | 是，可以用贪心遍历相邻两天价格差 `if (price[i] > price[i-1]) profit += price[i] - price[i-1];` |
| 动态规划优势 | 易扩展到含手续费、冷冻期、最多K次交易等变种问题              |

###Leetcode 309 买卖股票的最佳时机含冷冻期`dp[n][3]-i天持有/冷冻/非持有非冷冻的最大收益`

你可以多次买卖股票，但每次卖出后要有一天的**冷冻期**（cooldown），也就是**当天不能买股票**。目标是：**获得最大利润**。

####问题分析

相比 Leetcode 122（无限次买卖），**本题增加了一个约束条件：卖出后不能立即买入**。

这要求我们在设计状态时额外记录“**是否处于冷冻期**”的状态信息。

所以，我们必须精细追踪每一天处于哪种状态，并根据状态转移计算最优利润。

####问题本质

你可以多次买卖股票，但是每次卖出后，有一天的冷冻期，也就是当前不能够买股票，目标是获得最大利润。

相比Leetcode 122（无限次买卖）。本题增加了一个约束条件，**卖出后不能立即买入**。

这要求我们在设计状态时额外记录**是否处于冷冻期**的状态信息。

####核心思想-二维DP数组

#####**动态规划+状态机思想：**

将每一天的状态划分为三种：

- **持有状态**：当前持有股票

- **卖出状态**：今天刚卖出股票
- **冷冻状态**：处于非持有状态，可以选择买入

我们以每天不同状态下的最大收益作为状态定义，构建转移方程

#####状态定义与初始化

###### 状态定义

- `dp[i][0]`:当天持有股票
- `dp[i][1]`:当天处于冷冻期的最大利润
- `dp[i][2]`:处于非持有/非冷冻状态的最大利润

###### 状态初始化

```
dp[0][0] = -pricesp[0]
dp[0][1] = 0;
dp[0][2] = 0;
```

#####遍历逻辑与转移方程

###### 遍历逻辑

从`i=[1...n-1]`遍历，每天更新DP状态

###### 状态转移方程

- 第`i`天持有股票的最大收益

  - 如果`i-1`持有股票，最大收益为不变:`dp[i-1][0]`
  - 如果`i-1`天为冷冻期，最大收益为`dp[i-1][1]-prices[i]`
  - 如果`i-1`天为非冷冻非持有，不可能，直接去掉这个选项

  综合以上，第 `i`天持有股票的最大收益为`max(dp[i-1][0],dp[i-1[1]-prices[i]])`

- 第`i`天处于冷冻期的最大收益

  - 如果`i-1`天持有股票，最大收益为`dp[i-1][0]+prices[i]`
  - 如果`i-1`天处于冷冻期，不可能，直接去掉这个选项
  - 如果`i-1`天处于非持有非冷冻,不可能，直接去掉这个选项

  综合以上，第`i`处于冷冻期的最大收益为`dp[i][1]=max(dp[i-1][0],dp[i-1][2])`

- 第`i`天处于非冷冻非持有的最大收益

  - 如果第`i-1`天处于持有股票状态,这个不可能，直接去掉这个选项
  - 如果第`i-1`天处于冷冻状态，最大收益为`dp[i-1][1]`
  - 如果第`i-1`天处于非持有非冷冻状态,最大收益为`dp[i-1][2]`

  总和以上，第`i`天处于非持有非冷冻的最大收益为`dp[i][2]=max(dp[i-1][1],dp[i-1][2])`

##### 代码实现

```java
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length ==0){
            return 0;
        }
        int n = prices.length;
        
        int[][] dp = new int[n][3];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;

        for (int i=1;i<n;i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]-prices[i]);
            dp[i][1] = dp[i-1][0]+prices[i];
            dp[i][2] = Math.max(dp[i-1][1], dp[i-1][2]);
        }
        //最后一天肯定不持有的
        return Math.max(dp[n-1][1],dp[n-1][2]);

    }
```

##### 注意事项

1. **最终结果不是 `dp[n-1][0]`**，因为持有股票不能算收益，必须在卖出后计算利润；
2. **状态压缩优化**可以将空间降为 O(1)，不过为了清晰理解建议先写二维版本；
3. 状态[2] 表示冷冻期后的“可以选择买入”的状态，别误解为“卖出后”只能冷冻。

##### 经验总结

- 本题是典型的“状态机模型”的动态规划题，建议画出三种状态的转换图；
- 多状态动态规划核心在于设计**完整且互斥的状态划分**；
- 当问题涉及“操作的冷却期、延迟期”等规则时，一般需要引入额外状态来控制行为；
- 和122题（无限次交易）对比，会发现状态的限制极大影响转移关系的设计。

###Leetcode 714: 买卖股票的最佳时机-带手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

#### 关于什么时候缴纳费用的问题

##### Pay the fee when purchasing

There are three key points to consider:

- When initializing the DP array, you have to reduce the fee 

  ```
  dp[0][0] = -prices[0]-fee;
  ```

- When calculating  the profit when purchasing a stock, you have to reduce the fee

  ```
  dp[i][0] = Math.max(dp[i-1][1]-prices[i]-fee, dp[i-1][0]);
  ```

- When calculating  the profit when selling a stock, you should not reduce the fee

  ```
   dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+prices[i]);
  ```

  

##### Pay the fee when selling

There are three key points to consider:

- When initializing the DP array, you should not reduce the fee 

  ```
  dp[0][0] = -prices[0];
  ```

- When calculating  the profit when purchasing a stock, you should not reduce the fee

  ```
  dp[i][0] = Math.max(dp[i-1][1]-prices[i], dp[i-1][0]);
  ```

- When calculating  the profit when selling a stock, you have to reduce the fee

  ```
   dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+prices[i] - fee);
  ```

  

####代码实现

```java
    public int maxProfit(int[] prices, int fee) {
        if (prices == null || prices.length ==0) return 0;

        int n = prices.length;

        int[][] dp = new int[n][2];
        dp[0][0] = -prices[0]-fee;
        dp[0][1] = 0;

        for (int i=1; i<n;i++){
            dp[i][0] = Math.max(dp[i-1][1]-prices[i]-fee, dp[i-1][0]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }

        return dp[n-1][1];
        
    }
```

##最大子数组和模型 - Kdane算法

这个算法应当被记住。

###场景和目标 - 找出包含负数的数组的最大子数组和

- **场景**：给定一个整数数组，其中可能包含**正数、负数和零**。
- **目标**：找到一个具有最大和的**连续**子数组（子数组最少包含一个元素），并返回这个最大和。这是 LeetCode 的经典题目 LC 53。
- **经典LC问题：**53，918，1749

###问题本质和分析 - 加入还是重新发起子数组？

这是一个典型的最优子结构问题。

当我们遍历到数组的第 `i` 个位置时，我们面临一个决策：

- 是将 `nums[i]` 加入到前面那个以 `i-1` 结尾的最优子数组中？

- 还是让 `nums[i]` 自己独立成为一个新的子数组的起点？

  如果前面那段子数组的和已经是负数，那么它对 `nums[i]` 来说只会是“拖累”，不如从 `nums[i]` 重新开始。

###核心套路 - 丢弃负资产 ：只依赖于`dp[i-1]`和当前元素值

如果前面那段子数组的和已经是负数，那么它对 `nums[i]` 来说只会是“拖累”，不如从 `nums[i]` 重新开始。

问题的最优解具有清晰的递推关系。

**以 `i` 结尾的最大子数组和，只依赖于以 `i-1` 结尾的最大子数组和**。

这种线性的、单向的依赖关系，使其成为线性 DP 的完美应用场景。

###原理和步骤 

####状态定义  - `dp[i]`表示第`i`个元素结尾的最大子数组和

`dp[i]` 表示以数组中第 `i` 个元素 (`nums[i]`) **结尾**的**连续**子数组的最大和。

这是本题型状态定义中最关键的一点。

####确定选择 - DP[i-1] + nums[i]或者是nums[i]

- 将 `nums[i]` 接在以 `i-1` 结尾的最大子数组后面，形成更大的子数组。

  此时的和为 `dp[i-1] + nums[i]`。

- 从 `nums[i]` 重新开始一个新的子数组。

  此时的和为 `nums[i]`。

####状态转移方程 - `dp[i] = max(dp[i-1] + nums[i], nums[i])`

我们取上述两个选择的较大者:`dp[i] = max(dp[i-1] + nums[i], nums[i])`

####明确初始状态 - dp[0] = nums[0]

`dp[0] = nums[0]`。以第一个元素结尾的子数组只能是它自己。

####返回结果 - 返回dp中的最大值

最大子数组可能在任何位置结束，所以最终结果并不是 `dp[n-1]`，而是在整个计算过程中出现过的 `dp[i]` 的最大值。

因此，**需要一个额外的变量 `maxSum` 来实时记录全局最大值**。

###实现代码

```java
    public int maxSubArray(int[] nums) {
        int n = nums.length;

        //dp[i] 表示以i结尾的子数组的最大和
        int[] dp = new int[n];

        dp[0] = nums[0];
        int maxSum = nums[0];

        for (int i = 1; i < n; i++){
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            maxSum = Math.max(maxSum, dp[i]);
        }

        return maxSum;
    }
```

###注意事项

- 最常见的错误是直接返回 `dp[n-1]`。必须理解 `dp[i]` 的定义是“以 `i` 结尾”，而全局最优解的结尾位置不确定。
- 状态定义必须精准，是“以 `i` 结尾”，而不是“前 `i` 个元素中”。
- **空间优化**：由于 `dp[i]` 只依赖于 `dp[i-1]`，所以可以用一个滚动变量 `currentMax` 代替整个 `dp` 数组，将空间复杂度从 O(N) 优化到 O(1)。

###经验总结

- Kadane 算法是解决此问题的标准范式。其精髓在于“丢弃负资产”：如果延续前面的子数组会导致和变为负数，那还不如从当前元素重新开始。
- 这是一个看似简单但细节丰富的题目，能很好地考察对 DP 状态定义和最优子结构思想的理解。

###Leetcode 918: 环形子数组的最大和

妈的上次与到的环形数组相关的是什么？我一遇到环形数组就感觉完蛋了。

上次遇到的是环形数组的打家劫舍问题，主要的解决思路是分为两个策略：

- 按照典型打家劫舍计算`[0...n-2]`的结果`profit1`
- 按照典型打家劫舍计算`[1...n-1]`的结果`profit2`
- 然后取`max(profit1, profit2)`作为最终结果。

#### 问题要点 - 环形数组的子数组最大和

本质上是一个**最大子数组和问题**，但数组是环形的。

也就是说，子数组的元素可以从数组尾部"环绕"回数组头部。

因此，这个问题可以分成两类子问题：

1. 不跨越首尾的最大子数组（等价于 Leetcode 53）
2. 跨越首尾的最大子数组（可以转化为：总和 - 最小连续子数组）

####问题分析- max = total - min

#####计算数组的总和/最大值/最小值

如果我们设：

- `totalSum = 所有元素的和`
- `maxSubArraySum = 非环数组最大子数组和`
- `minSubArraySum = 非环数组的最小子数组和`

#####数组全部为负数的情况 - 最大子数组和为负数

如果`maxSubArraySum <0`，说明数组全部都是负数，返回`maxSubArraySum`

#####数组部分为整数部分为负数的情况

我们需要继续区分两种情况：

###### 最大子数组**不跨首尾连接处** ：最大值就是**非环数组的最大子数组** 

如果最大子数组**不跨首尾连接处**， 最大值就是**非环数组的最大子数组** 

######最大子数组**跨首尾连接处** ： **非环子数组的总和 - 非环数组的最小子数组**

如果最大子数组**跨首尾连接处**，最大值就是**非环子数组的总和 - 非环数组的最小子数组**

如果最大子数组跨越首尾交接出，那么最小子数组就不会跨越。

这是一个推导过程，需要记住这个规律。


原因是：

- `跨越的最大子数组 = totalSum - minSubArraySum`
- 不能把整个数组都当成**最小子数组（total - total =0 ,非法）**

####核心思想 - 同时计算最大和最小子数组

通过动态规划的方式，分别求出：

- 最大数组和使用`dpMax`
- 最小数组和使用`dpMin`

#####状态定义和初始化

###### 状态定义 - 最大子数组和最小子数组

- `dpMax[i]`: 以第`i` 个元素结尾的最大子数组和
- `dpMin[i]`: 以第`i` 个元素结尾的最小子数组和

###### 状态初始化

```java
dpMax[0] = nums[0];
dpMin[0] = nums[0];
totalSum = nums[0];
```

##### 状态转移方程 - 采用Kadane方法计算（丢弃负资产）

###### 状态转移过程

```java
dpMax[i] = Math.max(nums[i],dpMax[i-1]+nums[i]);
dpMin[i] = Math.min(nums[i],dpMin[i-1]+nums[i]);
```

解释：

- `dpMax[i]`表示当前最大要么是单独的`nums[i]`，要么是延续前一个最大和`dpMax[i-1] + nums[i]`
- `dpMin[i]`同理，用于计算最小和，从而间接得到子数组最大和

###### 计算最大值和最小值

- 最大值就是dpMax中的最大值
- 最小值就是dpMin中的最小值

##### 按照上述规则计算最大值

- 如果最大子数组和为负数，说明所有元素都是负数，返回最大子数组和即可
- 如果最大子数组和不为负数，返回`max(maxSubArraySum, TotalSum - minSubArraySum)`

####实现代码

```java
public int maxSubArraySumCircular(int[] nums){
  int n = nums.length;
  int[] dpMax = new int[n];
  int[] dpMin = new int[n];
  
  dpMax[0] = nums[0];
  dpMin[0] = nums[0];
  int totalSum = nums[i];
  
  for (int i=1; i < n; i++){
    dpMax[i] = Math.max(nums[i],dpMax[i-1]+nums[i]);
    dpMin[i] = Math.min(nums[i],dpMin[i-1]+nums[i]);
  }
  
  int maxSubArraySum = Arrays.stream(dpMax).max().getAsInt();
  int minSubArraySum = Arrays.stream(dpMin).min().getAsInt();
  
  if (maxSubArraySum < 0 ) return maxSubArraySum;
  
  return (maxSubArraySum, total - minSubArraySum);
}
```

####注意事项

- 不能选整个数组作为最小子数组
- 如果`maxSubArraySum < 0`, 说明数组全是负数，此时数组全是负数，此时应该只取最大的负数，而不是使用`total - minSubArraySum`
- 使用`Arrays.stream(dp).max().getAsInt()` 获取最大值的写法会有一定的性能开销，但是易读性高

####经验总结

- 本题是经典的`环形数组最大子数组和`的建模问题
- 将问题转化为两个字问题+总和处理，属于**构造+动态规划**组合性的问题
- 本题动态规划写法虽然空间复杂度为 O(n)，但**对理解最小/最大子数组和的转移过程非常直观**，适合教学和学习；
- 空间可以进一步优化为 O(1)，即采用滚动变量方式实现 **Kadane 算法**。

###Leetcode 1749: 任意子数组的绝对值最大值

给你一个整数数组 `nums` 。

一个子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` 的 **和的绝对值** 为 `abs(numsl + numsl+1 + ... + numsr-1 + numsr)` 。

请你找出 `nums` 中 **和的绝对值** 最大的任意子数组（**可能为空**），并返回该 **最大值** 。

`abs(x)` 定义如下：

- 如果 `x` 是负整数，那么 `abs(x) = -x` 。
- 如果 `x` 是非负整数，那么 `abs(x) = x` 。

####核心思想-同时计算dpMax和dpMin

- 最大值是**连续非负数**的子数组的最大值
- 最小只是**连续非正数**的子数组的最大值
- 比较**最大值**和**最小值**的**绝对值**之后就可以找到绝对值的最大值

####代码实现

```java
public int maxAbsoluteSum(int[] nums) {
    int maxEndingHere = 0, minEndingHere = 0;
    int maxSum = 0, minSum = 0;

    for (int num : nums) {
        maxEndingHere = Math.max(num, maxEndingHere + num);
        minEndingHere = Math.min(num, minEndingHere + num);
        maxSum = Math.max(maxSum, maxEndingHere);
        minSum = Math.min(minSum, minEndingHere);
    }

    return Math.max(maxSum, -minSum);
}
```

###Leetcode 53: 最大子数组和

给定一个整数数组 `nums`，找出一个**具有最大和的连续子数组**（至少包含一个元素），并返回其最大和。

📌 关键点：

- **子数组必须连续**。
- 至少包含一个元素。
- 要返回的是**子数组的最大和**。

##### 问题分析-一维数组上的动态规划问题

这是一个典型的一维数组上的动态规划问题，要在数组中找出某个连续子数组，使元素之和最大

本质上：

我们在每一个位置`i`上都面临一个决策，是否将`nums[i]`接到前一个子数组上，或者自己重新开始一个新的子

##### 状态定义与初始化-`dp[i]`表示前`i`个元素结尾的最大子数组和

`dp[i]=以第i个结尾的子数组的最大和`

###### 初始化

`dp[0] = nums[0]`(以第一个元素结尾的子数组只能是它自己)

##### 遍历逻辑和状态转移方程

```
dp[i] = Math.max(nums[i],dp[i-1]+nums[i])
```

含义：

- 要么当前元素`nums[i]`自己成为新的子数组
- 要么把它挂在之前的最大子数组`dp[i-1]`上

##### 代码实现

```java
public int maxArray(int[] nums){
  int n = nums.length;
  int[] dp = new int[n];
  dp[0] = nums[0];
  int maxSum = dp[0];
  
  // 外层循环每个元素
  for (int i = 1; i<n;i++){
    //内存循环比较dp[i-1]+nums[i]和nums[i]
    dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
    maxSum = Math.max(maxSum, dp[i]);
  }
  
  return maxSum;
}
```

##### 注意事项

- 初始化必须正确：`dp[0] = nums[0]`。
- 状态定义是“**以 i 结尾的最大和**”，不是“到 i 为止的全局最大和”。
- 遍历顺序是从左到右（因为子数组是连续的）。
- 可以用一个变量滚动记录而不需要整个数组。

##### 经验总结

| 点         | 内容                                                         |
| ---------- | ------------------------------------------------------------ |
| 🎯 问题类型 | 一维动态规划，子数组最大和                                   |
| 🧩 状态定义 | `dp[i]`: 以 `i` 结尾的最大子数组和                           |
| 🔁 转移逻辑 | `dp[i] = max(nums[i], dp[i-1] + nums[i])`                    |
| 🧠 思维关键 | 局部最优推导全局最优（贪心+DP思想）                          |
| 📉 空间优化 | 可以只用一个变量滚动记录 `dp[i-1]`                           |
| 📍 对比题目 | 可类比 Leetcode 918（环形最大子数组）、Leetcode 152（最大乘积子数组）等 |

##杨辉三角生成 - Leetcode 118

#### 问题要点

**输入**: 一个非负整数 `numRows`。

**输出**: 一个二维列表 `List<List<Integer>>`，代表杨辉三角的前 `numRows` 行。

**杨辉三角的规则**:

1. 第一行只有一个数字 1。
2. 从第二行开始，每一行的第一个和最后一个数字都是 1。
3. 中间的每个数字是它正上方两个数字的和。

**示例**: 输入: `numRows = 5` 输出:

```
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

**约束**: `1 <= numRows <= 30`。这个约束告诉我们，`O(numRows^2)` 的时间复杂度和空间复杂度都是完全可以接受的，不需要进行极致的优化。

#### 问题本质和分析

问题的本质是一个**递推构造**过程。

杨辉三角的每一行都依赖于它的前一行。具体来说，要生成第 `i` 行，你必须知道第 `i-1` 行的内容。

这种**下一状态依赖于前一状态**的特性，是**动态规划 (Dynamic Programming)** 的一个核心标志。

#### 模式匹配

当你看到这类问题时，应该能联想到以下几种常见的算法模式：

1. **动态规划 (Dynamic Programming)**: 这是最直接的模式。当前行的计算依赖于前一行的结果。我们将前一行的结果“缓存”下来（实际上就是 `result` 列表中的最后一个元素），用于计算当前行。这符合DP“最优子结构”和“重叠子问题”的特点。
2. **模拟/迭代 (Simulation/Iteration)**: 从更简单的角度看，我们只是在模拟人们手工绘制杨辉三角的过程。从第一行开始，一行一行地往下画，直到达到 `numRows`。
3. **数组/列表操作**: 这个问题也是对 `List` 或 `Array` 数据结构操作能力的一个很好的考察。你需要熟练地创建列表、向列表添加元素、以及从列表中读取元素。

#### 核心思想和套路 - 逐行生成

解决这个问题的核心思想是 **“逐行生成” (Row-by-Row Generation)**。

这个套路非常清晰和固定：

1. **初始化**: 创建一个最终的结果列表 `result` (即 `List<List<Integer>>`)。

2. **处理边界/基准情况 (Base Case)**: 如果 `numRows` 为 0，直接返回空的 `result`。

   如果 `numRows` 大于 0，手动创建并添加第一行 `[1]` 到 `result` 中。

3. **迭代**: 使用一个循环，从第二行 (索引 `i = 1`) 开始，一直循环到第 `numRows - 1` 行。

4. **在循环内部**: 

   a. **获取依赖**: 从 `result` 中获取前一行 (`prevRow = result.get(i-1)`)。 

   b. **创建新行**: 创建一个空列表 `currentRow` 来存放当前要生成的行。 

   c. **构造新行**:

   -  i.  添加第一个元素 `1`。 

   - ii. 循环计算中间的元素。

     对于 `currentRow` 的第 `j` 个位置（`1 <= j < i`），它的值等于 `prevRow.get(j-1) + prevRow.get(j)`。 

   - iii. 添加最后一个元素 `1`。

​      d. **存入结果**: 将构造好的 `currentRow` 添加到 `result` 中。

5. **返回**: 循环结束后，`result` 中就包含了所有 `numRows` 行，返回 `result`。

#### 实现原理和步骤

下面是将上述思想转化为具体代码实现的步骤：

1. 创建一个 `List<List<Integer>>` 类型的变量 `triangle` 作为最终返回值。

2. 检查 `numRows` 是否为 0。如果是，则直接返回空的 `triangle`。

3. 创建第一行。

   - `List<Integer> firstRow = new ArrayList<>();`
   - 然后 `firstRow.add(1);`
   - 最后 `triangle.add(firstRow);`。

4. 开始一个主循环，`for (int i = 1; i < numRows; i++)`。

   这个 `i` 代表的是我们即将要创建的行的索引（从0开始）。

5. 在循环内部，首先获取上一行：`List<Integer> prevRow = triangle.get(i - 1);`。

6. 创建一个表示当前行的列表：`List<Integer> currentRow = new ArrayList<>();`。

7. 添加当前行的第一个元素 `1`：`currentRow.add(1);`。

8. 开始一个内部循环，用于计算中间的元素：`for (int j = 1; j < i; j++)`。

   注意循环的边界。**第 `i` 行有 `i+1` 个元素**，索引从 `0` 到 `i`。

   我们已经处理了索引 `0`，接下来要处理**从 `1` 到 `i-1` 的中间元素**。

9. 在内循环中，计算值并添加：`int sum = prevRow.get(j - 1) + prevRow.get(j);`

   然后 `currentRow.add(sum);`。

10. 内循环结束后，添加当前行的最后一个元素 `1`：`currentRow.add(1);`。

11. 将完整的 `currentRow` 添加到 `triangle` 中：`triangle.add(currentRow);`。

12. 主循环结束后，返回 `triangle`。

#### 实现代码

```java
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        res.add(Arrays.asList(1));
        if(numRows >=2){
            res.add(Arrays.asList(1,1));
        }
        
        for(int i = 2; i < numRows; i++){
            List<Integer> row = new ArrayList<>();
            // row[0] = 1;
            row.add(1);
            // row[i-1] = 1;

            for(int j = 1; j < i; j++){
                int left = res.get(i-1).get(j-1);
                int right =res.get(i-1).get(j);
                row.add(left+right);
            }
            row.add(1);
            res.add(row);
        }
        return res;
    }
```



#### 注意事项

**索引管理**: 这是最容易出错的地方。要清楚地知道第 `i` 行有 `i+1` 个元素。当计算 `currentRow` 的第 `j` 个元素时，你需要的是 `prevRow` 的第 `j-1` 和第 `j` 个元素。画图辅助理解可以有效避免 off-by-one 错误。

**特殊情况**: `numRows = 1` 的情况需要特别注意。在我们的代码中，`for (int i = 1; i < numRows; i++)` 循环在 `numRows=1` 时不会执行，代码会正确地返回只包含第一行的列表。

**数据结构**: `ArrayList` 在这里是很好的选择，因为它支持动态扩容，我们不需要预先知道每行的大小。

**代码复用**: 在处理 LeetCode 119. Pascal's Triangle II 时，这个思想可以被复用，但需要优化空间复杂度，只保留上一行的信息即可，而不需要存储整个三角形。

#### 经验总结

**从简单到复杂**: 解决这类问题，总是从最简单的情况（第一行、第二行）入手，手动推演一遍，规律自然就会浮现。

**识别模式**: 识别出 "下一状态依赖于前一状态" 的特点，就能迅速将其归类到动态规划或迭代模拟的思路上，从而找到清晰的解题路径。

**将规律转化为代码**: 关键步骤是将 `T[i][j] = T[i-1][j-1] + T[i-1][j]` 这个规律，准确地用循环和数组（列表）索引来实现。

**练习基础**: 这道题是对编程语言基础（特别是列表操作）和算法思维（特别是迭代和DP）的综合考察。打好这个基础，对解决更复杂的问题大有裨益。它简单、经典，是面试中用来考察候选人基本代码功底的常见问题。

### 
