# 模式匹配

这类问题的核心是判断一个字符串 `s` 是否符合一个包含特殊字符（如 `.` `*` `?`）的模式 `p`。

字符串和模式的地位是**不对称**的。

### 核心思想和通用套路

####**DP数组定义**: `s[0..i-1]`) 是否能被 `p[0..j-1]` 成功匹配

`dp[i][j]` 通常是一个**布尔值**，表示 `s` 的前 `i` 个字符 (`s[0..i-1]`) 是否能被 `p` 的前 `j` 个字符 (`p[0..j-1]`) 成功匹配。

#### 状态转移方程：由`p[j-1]`驱动

##### **如果是普通字符**:

必须 `s.charAt(i - 1)` 与之相等，并且之前的子问题 `dp[i-1][j-1]` 也要为 `true`。

##### 如果是任意单字符通配符

可以匹配 `s` 中的任意一个字符，所以逻辑等同于普通字符匹配成功的情况，只需看 `dp[i-1][j-1]`。

##### 如果是 `*` - 最复杂的情况

###### `*`匹配0次

`*` 和它前面的字符被“无视”，匹配结果取决于 `dp[i][j-2]` (正则表达式) 或 `dp[i][j-1]` (通配符)。

###### `*`匹配1次或者多次

`*` 至少匹配了 `s` 中的一个字符 `s.charAt(i-1)`。这

要求 `s.charAt(i-1)` 必须能被 `*` 前面的那个模式字符匹配，并且 `s` 的前 `i-1` 个字符已经能被当前模式（`p` 的前 `j` 个字符）匹配，即依赖 `dp[i-1][j]`。

### 实现原理和步骤

####**创建 DP 数组**: `new boolean[m+1][n+1]`。

####初始化边界

- `dp[0][0] = true` (空字符串匹配空模式)。

- `dp[i][0]` 通常为 `false` (非空字符串无法匹配空模式)。

- `dp[0][j]` 较为复杂，需要判断模式的前 `j` 个字符是否能匹配空字符串（例如，`a*`, `a*b*`）。

#### 双层循环：分别遍历s和p

从 `i=0` 到 `m` (i可以从0开始，以处理空字符串s的情况)，`j=1` 到 `n`。

#### 状态转移：基于`p[j-1]`

在循环体内实现基于 `p.charAt(j-1)` 类型的多分支 `if-else` 逻辑。

#### 返回结果

`dp[m][n]`

###Leetcode 10. 正则表达式匹配

给你一个字符串 `s` 和一个字符模式 `p`，请你实现一个支持 **'.'** 和 **'\*'** 的正则表达式匹配。

- `'.'`：匹配任意单个字符
- `'*'`：匹配 **前一个字符** 0 次或多次

**要求：必须匹配整个字符串，而不是部分匹配。**

##### 核心思想与应对策略

本题是一个典型的**带有状态依赖关系**的问题，适合使用动态规划解决

###### 核心思想-`dp[i][j]`表示`s[0...i-1]`与`p[0...j-1]`是否匹配

构建二维DP数组，`dp[i][j]` 表示 **s[0...i-1] 与 p[0...j-1] 是否匹配**。

###### 应对策略

| 步骤     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 状态定义 | `dp[i][j] = true/false`，表示 `s[0...i-1]` 是否匹配 `p[0...j-1]` |
| 初始状态 | `dp[0][0] = true`（空串匹配空模式）                          |
| 状态转移 | 依据 `p[j-1]` 是否为 `*` 进行分类讨论                        |
| 返回结果 | `dp[s.length()][p.length()]`                                 |

##### 难点分析和应对

| 难点              | 说明                                      | 应对策略                                 |
| ----------------- | ----------------------------------------- | ---------------------------------------- |
| `*` 的多义性      | 表示匹配 **0 次或多次**，需要单独分类讨论 | 按是否使用 `*` 进行多分支状态转移        |
| 边界处理          | 如空串、空模式、`*` 前无字符等            | 仔细初始化 DP 表首行和首列，防止数组越界 |
| `dp[i][j]` 的推导 | 必须按依赖顺序从前往后填表                | 使用双重循环，确保依赖顺序正确           |

##### 实现原理和详细步骤

###### DP状态定义

`dp[i][j] 表示 s[0...i-1] 与 p[0...j-1] 是否匹配`

###### 状态初始化

- `dp[0][0] = true  // 空串和空模式匹配`

- 对于`p`中含有`*`的情况的初始化

  ```python
  for j from 2 to n:
    if p[j-1] == '*':
      dp[0][j] = dp[0][j-2];
  ```

###### 状态转移方程

如果说`p[j-1] == *`, 存在如下两种情况：

- 如果`s[0...i-1]`已经和`p[0...j-2]`匹配上了,因为`p[j-1] == '*'`， 所以`s[0...i-1]`和`p[0...j-1]`也可以匹配上（是怎么匹配上的，双重循环）
- 如果`s[0...i-2]`已经和`p[0...j-1]`匹配上了：
  - 如果`s[i-1]`和`p[j-2]`匹配，就说明**一个或者多个已经匹配上了**

```python
if p[j-1] == '*':
  dp[i][j] = dp[i][j-2]
  # 如果说 s[i-2]和p[j-1]匹配
  if match(s,p,i,j-1):
    dp[i][j] = dp[i][j] || dp[i-1][j]
```

##### 实现代码

```java
    //字符串匹配，动态规划解法
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        //dp[i][j] 表示s[0...i-1]匹配p[0...j-1]
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;

        for(int j = 2; j <= n; j++){
            if (p.charAt(j-1) == '*'){
                dp[0][j] = dp[0][j-2];
            }
        }

        for(int i = 1; i <= m;i++){
            for(int j = 1; j <= n; j++){
                if (p.charAt(j-1) == '*'){
                    dp[i][j] = dp[i][j-2];
                    //如果s[i-1]和p[j-2]匹配那么说明之前已经匹配了1次
                    //那么当s[0...i-2]和`p[0...j-1]`匹配时
                    if (matches(s,p, i, j-1)){
                        dp[i][j] = dp[i][j] || dp[i-1][j];
                    }
                }else{
                    if(matches(s,p,i,j)){
                        dp[i][j] = dp[i-1][j-1];
                    }
                }
            }
        }
        return dp[m][n];
    }

    private boolean matches(String s, String p, int i, int j){
        //为啥呢？难道P不会也是0吗
        if (i == 0) return false;
        if (p.charAt(j - 1) == '.') return true;
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
```

#####  注意事项

| 类型     | 说明                                                   |
| -------- | ------------------------------------------------------ |
| 边界控制 | 只有在 `i >= 1` 时，`match()` 才能取 `s.charAt(i - 1)` |
| 初始化   | `dp[0][j]` 只有在 `*` 能消掉前一个字符时才可能为 true  |
| 不要混淆 | `*` 是作用于 `p[j-2]`，不是 `p[j-1]`                   |
| 数据规模 | s 和 p 最长为 20，因此 DP 足够快速（O(mn)）            |

##### 经验总结

1. 正则匹配题目用动态规划是最稳定可控的方式。
2. 状态定义与初始化一旦确定，`*` 的处理就是重点。
3. 使用 `match(s, p, i, j)` 方法极大提升了逻辑清晰度与可维护性。
4. 本题也是面试经典题，掌握之后能应对其他类似字符串 DP 问题。

###Leetcode 44: 正则表达式匹配 - 问号和星号

##### 问题要点

给定一个字符串 `s` 和一个包含通配符的模式 `p`，实现一个函数来判断 `s` 是否能被 `p` 完全匹配。

- **输入**:
  - `s`: 一个可能为空的字符串，只包含小写字母 `a-z`。
  - `p`: 一个可能为空的字符串，包含小写字母 `a-z`，以及两个特殊的通配符 `?` 和 `*`。
- **通配符规则**:
  - `?`：可以匹配任何**单个**字符。
  - `*`：可以匹配**任意长度**的字符序列（包括空序列）。
- **匹配要求**:
  - 必须是**完全匹配**，即 `p` 必须匹配整个字符串 `s`，而不是 `s` 的一部分。

##### 示例

```
s = "aa", p = "a"` -> `false
s = "aa", p = "*"` -> `true
```

`s = "cb", p = "?a"` -> `false` (因为 'b' 不等于 'a')

`s = "adceb", p = "*a*b"` -> `true` (第一个 `*` 匹配 "dce"，第二个 `*` 匹配空序列)

```
s = "acdcb", p = "a*c?b"` -> `false
```

##### 问题本质和分析 - 动态规划

问题的本质是判断两个序列（字符串 `s` 和模式 `p`）在特定规则下是否能够匹配。

由于一个字符的匹配决策会影响后续所有字符的匹配，这暗示了问题具有**最优子结构**和**重叠子问题**的特性，这是动态规划的典型标志。

让我们来分析匹配过程中的决策点，特别是遇到通配符 `*` 时： 当 `p` 中的 `*` 出现时，我们面临选择：

1. **让 `\*` 匹配空序列**：我们跳过这个 `*`，用 `p` 剩下的部分去匹配 `s` 的当前位置。
2. **让 `\*` 匹配一个或多个字符**：我们用 `*` 匹配掉 `s` 的当前字符，然后用 `p` 的同一个 `*` 继续尝试匹配 `s` 的下一个字符。

这种选择性使得简单的线性扫描或贪心算法变得困难。

例如，对于 `s = "abceb"` 和 `p = "a*b"`，如果 `*` 贪心地匹配了 `bce`，那么 `p` 剩下的 `b` 就无法匹配 `s` 的结尾。

正确的做法是让 `*` 只匹配 `ce`，这样 `p` 的 `b` 才能匹配 `s` 的最后一个 `b`。

由于存在这些复杂的决策分支，我们需要一个系统性的方法来探索所有可能性，而动态规划正是解决这类问题的利器。

##### 模式匹配 - 双序列DP

这道题属于 **动态规划** 中的 **双序列 DP** 模型。它的结构与以下经典问题非常相似：

- **LeetCode 10. 正则表达式匹配 (Regular Expression Matching)**: 最直接的对比，但 `*` 的含义不同（在正则中 `*` 跟随前一个字符，表示 0 或多个前一个字符）。
- **LeetCode 72. 编辑距离 (Edit Distance)**: 同样是处理两个字符串，计算从一个转换到另一个所需的最小操作数。
- **LeetCode 1143. 最长公共子序列 (Longest Common Subsequence)**: 也是在两个序列上寻找最优解。

##### 核心思想和套路

定义 `dp[i][j]` 为一个布尔值，表示 `s` 的前 `i` 个字符 (`s[0...i-1]`) 是否能与 `p` 的前 `j` 个字符 (`p[0...j-1]`) 成功匹配。

我们的目标是求出 `dp[m][n]`，其中 `m` 是 `s` 的长度，`n` 是 `p` 的长度。

###### 状态转移方程

这是 DP 的灵魂。

为了计算 `dp[i][j]`，我们需要观察 `p` 的第 `j` 个字符 `p[j-1]` 是什么：

- **如果 `p[j-1]` 是一个小写字母**

  `dp[i][j]` 为 `true` 的前提是：`s` 的第 `i` 个字符 `s[i-1]` 必须与 `p[j-1]` 相同，**并且** `s` 的前 `i-1` 个字符与 `p` 的前 `j-1` 个字符已经匹配。

  $dp[i][j] = (s[i-1] == p[j-1]) \land dp[i-1][j-1] $

- **如果 `p[j-1]` 是 `?`**

  `?` 可以匹配任意单个字符。所以，`s[i-1]` 是什么不重要，只要 `s` 的前 `i-1` 个字符与 `p` 的前 `j-1` 个字符匹配即可。

  $dp[i][j] = dp[i-1][j-1] $

- **如果 `p[j-1]` 是 `*` (最关键的情况)**

  `*` 可以匹配空序列或任意字符序列。

  这里有两种可能性，只要满足其一，`dp[i][j]` 就为 `true`：

  - **`\*` 匹配空序列**: 我们“忽略”这个 `*`，相当于用 `p` 的前 `j-1` 个字符去匹配 `s` 的前 `i` 个字符。

    此时，`dp[i][j]` 的值取决于 `dp[i][j-1]`。

  - **`\*` 匹配一个或多个字符**

    如果 `*` 至少匹配一个字符，那么它必然匹配了 `s` 的第 `i` 个字符 `s[i-1]`。

    此时，我们需要看 `s` 的前 `i-1` 个字符是否能与 `p` 的前 `j` 个字符（包括这个 `*`）匹配。

    这意味着 `dp[i][j]` 的值取决于 `dp[i-1][j]`。

    为什么是 `dp[i-1][j]` 而不是 `dp[i-1][j-1]`？

    因为 `*` 可以继续匹配 `s` 中更多的字符，所以我们依赖于 `p` 的前 `j` 个字符（`*` 仍然在发挥作用）与 `s` 的更短前缀的匹配结果。

  综合上述两种情况，状态转移方程为：

  $dp[i][j] = dp[i][j-1] \or dp[i-1][j]$

###### 边界条件

- `dp[0][0] = true`: 空字符串 `s` 与空模式 `p` 匹配。

- `dp[i][0]` for `i > 0`: `false`。非空字符串 `s` 无法与空模式 `p` 匹配。

- `dp[0][j]` for `j > 0`: 空字符串 `s` 与非空模式 `p`。

  只有当 `p` 的前 `j` 个字符全部是 `*` 时，才能匹配成功。

  例如 `s=""`, `p="***"`。因此，`dp[0][j]` 取决于 `p[j-1]` 是否为 `*` 以及 `dp[0][j-1]` 是否为 `true`。

##### 实现原理和步骤

1. **获取长度**: 分别获取 `s` 和 `p` 的长度 `m` 和 `n`。

2. **创建 DP 表**: 初始化一个 `(m+1) x (n+1)` 大小的布尔二维数组 `dp`。`dp[i][j]` 对应 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符。

3. **初始化边界条件**:
   - 设置 `dp[0][0] = true`。
   - 处理第一行：`for j from 1 to n`，如果 `p[j-1]` 是 `*`，则 `dp[0][j] = dp[0][j-1]`。
   - 否则，中断循环，因为后续都不可能匹配。

4. **填充 DP 表**:
   - 使用嵌套循环遍历 `dp` 表，外层循环 `i` 从 `1` 到 `m`，内层循环 `j` 从 `1` 到 `n`。
   - 在循环内部，根据 `p.charAt(j-1)` 的值，应用上一节推导出的状态转移方程来计算 `dp[i][j]`。
5. **返回结果**: 最终结果就是 `dp[m][n]`。

##### 实现代码

```java
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        
        boolean[][] dp = new boolean[m+1][n+1];
        //初始化状态
        //空子串和空通配符串匹配
        dp[0][0] = true;
        //判断空字符串和通配符前缀是否匹配
        //如果p[j-1] == *, 那么dp[0][j] = dp[0][j-1]
        //否则中断处理过程
        for(int j = 1; j <= n; j++){
            if(p.charAt(j-1) == '*'){
                dp[0][j] = dp[0][j-1];
            }else{
                break;
            }
        }
        
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                char c = p.charAt(j-1);
                if(c != '?' && c != '*'){
                    dp[i][j] = s.charAt(i-1) == c && dp[i-1][j-1];
                } else if(c == '?'){
                    dp[i][j] = dp[i-1][j-1];
                } else if (c == '*'){
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
                }
            }
        }
        return dp[m][n];
    }
```

##### 注意事项

- **索引对应**: DP 表的大小是 `(m+1) x (n+1)`，这使得 `dp[i][j]` 可以自然地表示前 `i` 和前 `j` 个字符。访问字符串时，需要用 `s.charAt(i-1)` 和 `p.charAt(j-1)`，这是初学者常见的错误点。

- **`\*` 的状态转移理解**: `dp[i][j] = dp[i][j-1] || dp[i-1][j]` 是本题的核心和难点。

  - `dp[i][j-1]` (OR的左侧): 代表 `*` 不起作用（匹配空），所以 `s` 的前 `i` 个字符是否匹配 `p` 的前 `j` 个字符，完全取决于 `s` 的前 `i` 个字符是否能匹配 `p` 的前 `j-1` 个字符。

  - `dp[i-1][j]` (OR的右侧): 代表 `*` 至少匹配一个字符，即 `s[i-1]`。那么 `s` 的前 `i` 个字符要匹配 `p` 的前 `j` 个字符，就需要 `s` 的前 `i-1` 个字符能匹配 `p` 的前 `j` 个字符（这个 `*` 继续生效）。

- **空间复杂度优化**: 观察状态转移方程可以发现，`dp[i][j]` 的计算只依赖于 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]`，即只依赖于当前行和上一行的数据。因此，可以使用滚动数组或两个一维数组将空间复杂度从 O(mtimesn) 优化到 O(n)。但对于初次理解，完整的二维表更清晰。

##### 经验总结

- **识别问题模式**: 遇到涉及两个字符串/序列，并需要做出一系列决策来达到最终匹配/最优解的问题时，要立刻想到**动态规划**。

- **定义 DP 状态**: `dp[i][j]` 表示“s的前i个字符和p的前j个字符的匹配结果”是这类问题最标准、最通用的状态定义。

- **推导转移方程**: 仔细分析最后一步操作。对于 `dp[i][j]`，思考 `s[i-1]` 和 `p[j-1]` 的关系，特别是通配符如何影响决策。将所有情况（`?`, `*`, 普通字符）分类讨论，就能推导出完整的转移方程。

- **处理边界**: DP 的边界条件是正确性的基石。务必仔细考虑 `i=0` 和 `j=0` 的所有情况（空串对空串，空串对非空模式，非空串对空模式）。

- **从递归到递推**: 如果直接想递推（bottom-up DP）有困难，可以先尝试写出递归+记忆化（top-down）的解法。递归的思路往往更直观，`solve(i, j)` 直接对应 `dp[i][j]`，写出后可以很方便地翻译成递推形式。
