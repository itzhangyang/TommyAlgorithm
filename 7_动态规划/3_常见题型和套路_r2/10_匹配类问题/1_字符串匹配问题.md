##字符串匹配类

这类问题的核心是比较两个普通字符串，计算它们之间的某种“关系”，如相似度、差异或共同部分。两个字符串的地位是**对称**的。

###核心思想

字符串匹配类的动态规划问题，其核心思想是利用一个二维的 `dp` 数组（偶尔也会有一维的，但二维更普遍）在某个位置之前的匹配情况。

### 核心思想与通用套路

#### DP数组的定义

`dp[i][j]` 通常表示 `s1` 的前 `i` 个字符 (`s1[0..i-1]`) 与 `s2` 的前 `j` 个字符 (`s2[0..j-1]`) 之间的某种**最优值**（如最长长度、最小距离）或**总数量**。

#### 状态转移核心： `s1.charAt(i - 1)` 和 `s2.charAt(j - 1)` **是否相等**

转移的逻辑完全由 `s1.charAt(i - 1)` 和 `s2.charAt(j - 1)` **是否相等**来驱动：

##### 如果 `s1.charAt(i - 1) == s2.charAt(j - 1)`

当前两个字符匹配上了，通常意味着我们可以从 `dp[i-1][j-1]` 这个状态（即两个字符串都去掉最后一个字符后的状态）继承并进行更新。

##### 如果 `s1.charAt(i - 1) != s2.charAt(j - 1)`

- 当前两个字符不匹配，我们需要根据题目要求，从之前的状态中选择一个最优解。
- 这通常涉及到：
  -  `dp[i-1][j]` (忽略 `s1` 的当前字符),
  -  `dp[i][j-1]` (忽略 `s2` 的当前字符)，
  - 有时还包括 `dp[i-1][j-1]` (替换其中一个字符)。

**目标**: 求一个最优解（最大/最小）或一个计数值。

#### 基本原理与套路框架

##### 状态定义- `dp[i][j]` 表示字符串A的前i个字符和字符串B的前j个字符串中间存在某种关系

- 一般设`d[i][j]` 表示 字符串A的前`i` 个字符与字符串B的前j个字符之间的某种关系（是否匹配、最小编辑距离、最长公共子串的长度等）

##### 遍历逻辑

- 通常是双循环遍历两个字符串的所有组合

```
for (int i = 0; i <= m; i++) {
    for (int j = 0; j <= n; j++) {
        // 状态转移逻辑
    }
}
```

- 注意边界问题初始化`dp[0][*]`, `dp[*][0]`需要根据具体问题初始化

#### 状态转移方程

转移的逻辑完全由 `s1.charAt(i - 1)` 和 `s2.charAt(j - 1)` **是否相等**来驱动。

##### 如果 `s1.charAt(i - 1) == s2.charAt(j - 1)`

当前两个字符匹配上了，通常意味着我们可以从 `dp[i-1][j-1]` 这个状态（即两个字符串都去掉最后一个字符后的状态）继承并进行更新。

##### 如果 `s1.charAt(i - 1) != s2.charAt(j - 1)`

当前两个字符不匹配，我们需要根据题目要求，从之前的状态中选择一个最优解。

这通常涉及到：

-  `dp[i-1][j]` (忽略 `s1` 的当前字符)
-  `dp[i][j-1]` (忽略 `s2` 的当前字符)
- 有时还包括 `dp[i-1][j-1]` (替换其中一个字符)。

#####1. **编辑距离**

- 状态定义：

  - `dp[i][j]`: 将 word1 的前 `i` 个字符变成 word2 的前 `j` 个字符的最小编辑次数。

- 状态转移方程：

  ```
  if (word1[i-1] == word2[j-1])
      dp[i][j] = dp[i-1][j-1]
  else
      dp[i][j] = min(
          dp[i-1][j] + 1,    // 删除
          dp[i][j-1] + 1,    // 插入
          dp[i-1][j-1] + 1   // 替换
      )
  ```

##### 2. **最长公共子序列**

- 状态定义：

  - `dp[i][j]`: A的前`i`个字符与B的前`j`个字符的最长公共子序列长度。

- 状态转移方程：

  ```
  if (A[i-1] == B[j-1])
      dp[i][j] = dp[i-1][j-1] + 1
  else
      dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```

##### 3. **正则表达式匹配**

- 状态定义：
  - `dp[i][j]`: `s[0..i-1]` 与 `p[0..j-1]` 是否匹配。
- 转移较复杂（涉及 `*` 和 `.` 的处理）：
  - 详见 Leetcode 10 解法

### 实现原理和步骤

- **创建 DP 数组**: `new int[m+1][n+1]` 或 `new long[m+1][n+1]`。

- **初始化边界**: 处理一个字符串为空的情况。`dp[i][0]` 和 `dp[0][j]` 通常有直观的物理意义（例如，将一个非空字符串变为空串的代价）。

- **双层循环**: 从 `i=1` 到 `m`，`j=1` 到 `n`，填充整个 DP 表。

- **状态转移**: 在循环体内实现基于 `s1.charAt(i-1) == s2.charAt(j-1)` 的 `if-else` 逻辑。

- **返回结果**: 结果通常是 `dp[m][n]`。

### 代码套路模板

```Java
public class StringToStringDP {
    public int solve(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();

        // 1. 定义dp数组
        // dp[i][j] 表示 s1[0..i-1] 和 s2[0..j-1] 的某种结果
        int[][] dp = new int[m + 1][n + 1];

        // 2. 初始化边界条件
        // dp[0][0] 通常是0或1，取决于问题定义
        // 处理 s2 为空的情况
        for (int i = 1; i <= m; i++) {
            dp[i][0] = /* 根据问题定义初始化 */;
        }
        // 处理 s1 为空的情况
        for (int j = 1; j <= n; j++) {
            dp[0][j] = /* 根据问题定义初始化 */;
        }

        // 3. 状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // 字符相等，通常从左上角继承状态
                    dp[i][j] = /* 依赖于 dp[i-1][j-1] */;
                } else {
                    // 字符不相等，根据题目要求从左、上、左上角选择
                    dp[i][j] = /* 依赖于 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 的某种组合 */;
                }
            }
        }

        // 4. 返回结果
        return dp[m][n];
    }
}
```

###Leetcode 97: 交错字符串

给定三个字符串 `s1`、`s2`、`s3`，请判断 `s3` 是否由 `s1` 和 `s2` **交错组成**。

交错的定义是：`s3` 中的字符顺序保持 `s1` 和 `s2` 的相对顺序。例如：

- `s1 = "aabcc"`
- `s2 = "dbbca"`
- `s3 = "aadbbcbcac"` 返回 `true`，但 `s3 = "aadbbbaccc"` 返回 `false`。

##### 核心思想

判断`s3`是否可以由`s1`和`s2`的`前若干个字符`交错组成。

我们使用一个二维DP数组`dp[i][j]`来表示: `s1[0...i-1]`和`s2[0...j-1]`能否交错组成`s3[0...i+j-1]`。

##### 基本原理和状态定义

###### 状态定义-`dp[i][j]`表示s3的前`i+j`个字符是否可以由`s1`的前`i`个字符和字符串`s2`的前`j`个字符交错组成

- `dp[i][j]` 表示：`s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符能否交错组成 `s3` 的前 `i+j` 个字符。

###### 初始条件

- `dp[0][0] = true`，因为两个空串交错可以组成空串。
- `dp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1)`
- `dp[0][j] = dp[0][j-1] && s1.charAt(j-1) == s3.charAt(j-1) `

##### 状态转移方程

对于`dp[i][j]`,有两种可能：

###### S1的第`i`个字符和S3的第`i+j`个字符相同

这个时候，我们需要看看**S3是否可以由S1的第i-1个字符和S2的第j个字符交替组成**

- 如果可以，则`dp[i][j]=true`
- 如果不可以，则`dp[i][j]=false`

###### S2的第j个字符和S3的第i+j个字符相同

我们需要看**S3的前i+j-1个字符是否可以由S1的第i个字符和S2的第j-1个字符交替组成**

- 如果可以，则`dp[i][j]=true`
- 如果不可以，则`dp[i][j]=false`


因此可以推导出如下状态转移方程：

```
dp[i][j] = (s1.charAt(i - 1) == s3.charAt(i + j - 1) && dp[i - 1][j])
        || (s2.charAt(j - 1) == s3.charAt(i + j - 1) && dp[i][j - 1]);
```

##### 遍历逻辑

用两个嵌套循环遍历 `i` 和 `j`：

- `i` 遍历 `0 ~ s1.length()`
- `j` 遍历 `0 ~ s2.length()`

每次填充 `dp[i][j]`，判断是否能从上一步状态转移过来。

##### 代码实现

```java
 public boolean isInterleave(String s1, String s2, String s3) {
  int m=s1.length();
  int n = s2.length();
  if (m+n != s3.length()){
    return false;
  }
  
  boolean dp[][] = new boolean[m+1][n+1];
  dp[0][0]=true;
  
  for (int i=1;i<=m;i++){
    // s3[0...i-1] 是否是由s1[0...i-1]构成
    dp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1);
  }
  
  for(int j=1;j<=n;j++){
    //s3[0...j-1]是否由s2[0...j-1]组成
    dp[0][j] = dp[0][j-1] && s2.charAt(j-1)== s3.charAt(j-1);
  }
  
  // 填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (s1.charAt(i - 1) == s3.charAt(i + j - 1) && dp[i - 1][j])
                        || (s2.charAt(j - 1) == s3.charAt(i + j - 1) && dp[i][j - 1]);
            }
        }
  
  return dp[m][n];  
    }
```

