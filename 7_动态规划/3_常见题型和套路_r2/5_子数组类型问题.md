## 最长子数组问题 - 不同于子序列

在解题之前，必须清晰地辨别两个非常容易混淆的概念：

**子数组 (Subarray):** 必须是 **连续的**。例如，`[1,2,3,2,1]` 的子数组有 `[1,2,3]`, `[2,3,2]` 等。`[1,3,1]` 不是其子数组。

**子序列 (Subsequence):** 可以 **不连续**，但必须保持原有的相对顺序。例如，`[1,2,3,2,1]` 的子序列有 `[1,3,1]`, `[1,2,1]` 等。

本题要求的是 **子数组**，意味着元素必须是连续匹配的。这与 "最长公共子序列" (LeetCode 1143) 是完全不同的问题。

###单数组问题

在单个数组中寻找满足特定条件的、最长或者最大的连续子数组

#### 场景与目标 - 具有最优解的连续子数组

- **场景**: 给定一个数组 `nums`。
- **目标**: 找到一个 **连续子数组**，使其具有某种最优属性。
  - **经典案例**: [LeetCode 53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) (求子数组的最大和)。
  - **变种**: 最长的“湍流子数组”、最长的“等差子数组”等。

#### 核心思想和套路 - 以当前元素为终点的最优解

##### 到底应该使用动态规划还是滑动窗口？

###### 动态规划 - i位置的最优解可以通过`i-1`位置的最优解推导出来

当你需要计算的子数组的“最优属性”具有 **递归性质**，即 `i` 位置的最优解可以从 `i-1` 位置的最优解推导出来时，通常使用动态规划。它关注的是 **值的积累和传递**。

###### 滑动窗口 - 满足特定约束条件的最长、最短或者数量最多的子数组

当问题要求你找到一个 **满足特定约束条件** 的最长、最短或数量最多的子数组时，通常使用滑动窗口。它关注的是在一个 **可伸缩的区间** 内维护这个约束。

##### 状态数组的定义 - 以当前元素为终点的最优解

我们定义一个 DP 状态（可以是一个数组 `dp[]` 或一个变量），`dp[i]` 表示 **必须以 `nums[i]` 这个元素结尾的** 连续子数组所能达到的最优值。

注意**并没有说明以哪一个元素为起点**。

在计算`dp[]`的时候，我们通常有两个选择：

- **自立门户：**从`nums[i]`开始，形成一个新的数组
- **加入组织：**将`nums[i]`接入到以`nums[i-1]`结尾的最优子数组的末尾，形成一个更长的子数组

最终的全局最优解，**就是所有这些“以 `i` 结尾的最优解” (`dp[0], dp[1], ..., dp[n-1]`) 中的那个最大/最长的值**。

**注意全局最优解~~并非是`dp[n-1]`~~**

#### 实现原理和步骤 - `dp[i]` 代表以 `nums[i]` 结尾的连续子数组的最大和

1. **定义 DP 状态**: `dp[i]` 代表以 `nums[i]` 结尾的连续子数组的最大和。
2. **找出状态转移方程**:
   - 要计算 `dp[i]`，`nums[i]` 是**必须被包含**的。
   - 此时，我们看以 `nums[i-1]` 结尾的最大和 `dp[i-1]`：
     - 如果 **`dp[i-1]` 是一个正数**，那么 `dp[i-1] + nums[i]` 会比 `nums[i]` 单独作为子数组更大，所以我们选择**加入组织**：`dp[i] = dp[i-1] + nums[i]`。
     - 如果 **`dp[i-1]` 是一个负数或零**，那么它对 `nums[i]` 只会产生“拖累”，不如 `nums[i]` 自己**自立门户**来得大：`dp[i] = nums[i]`。
   - 综合起来就是：`dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0)`，或者更简洁的 `dp[i] = Math.max(nums[i], dp[i-1] + nums[i])`。

3. **初始化**: `dp[0] = nums[0]`。同时需要一个全局变量 `maxSum` 来记录 `dp` 数组中的最大值，`maxSum` 初始化为 `nums[0]`。
4. **遍历计算**: 从 `i = 1` 开始遍历数组，计算每个 `dp[i]` 的值，并**记录和随时更新 `maxSum`**。
5. **返回结果**: 返回 `maxSum`。

#### 代码套路模板

```java
public int maxSubArray(int[] nums){
  int n = nums.length;
  //dp[i]表示以元素`nums[i]结尾的子数组最大和`
  in[] dp = new int[n];
  dp[0] = nums[0];
  int maxSum = Integer.MIN_VALUE;
  
  for(int i = 1; i < n; i++){
    if(dp[i-1] >= 0){
      dp[i] = dp[i-1] + nums[i];
    }else{
      dp[i] = nums[i];
    }
    maxSum = Math.max(maxSum, dp[i]);
  }
  
  return maxSum;
}
```

#### 注意事项

- **最终结果**: 结果是全局最优值 (`globalMaxSum`)，而不是最后一个 `dp[i]` (`currentMaxSum`)。因为最大子数组可能在数组的任何位置结束。

- **初始化**: `currentMaxSum` 和 `globalMaxSum` 都需要初始化为第一个元素的值，以正确处理只有一个元素或所有元素都是负数的情况。

- **与前缀和的区别**: “子数组和等于K”这类问题，用“前缀和 + 哈希表”是更优的解法。DP 更适用于求解“最大/最长”这类最优化问题。

#### 经验总结

单数组 DP 问题的精髓在于 **局部最优与全局最优** 的关系。`dp[i]` 是一个局部最优解（必须以 `i` 结尾），而我们通过维护一个全局变量来寻找所有局部最优中的最终答案。这个“以 `i` 结尾”的定义方式是解决这类问题的破局点。

###双数组问题

在两个数组中，寻找一个公共的、最长的连续子数组。

#### 场景和目标 - 两个数组中的最长连续公共子数组

**场景**: 给定两个数组 `nums1` 和 `nums2`。

**目标**: 找到一个在 `nums1` 和 `nums2` 中都出现的、长度最长的 **连续子数组**。

- **经典案例**: [LeetCode 718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

#### 核心场景和套路

这类问题的核心思想是 **“以 `nums1[i]` 和 `nums2[j]` 为终点的公共长度”**。

由于涉及两个数组，我们需要一个二维的 DP 状态。`dp[i][j]` 表示 **必须以 `nums1[i-1]` 和 `nums2[j-1]` 这两个元素结尾的** 公共子数组的长度。

##### `nums1[i-1]`和`nums2[j-1]`相同的情况

如果 `nums1[i-1] == nums2[j-1]`，说明**公共长度可以在之前的基础上延续**。

这个**之前的基础**就是以 `nums1[i-2]` 和 `nums2[j-2]` 结尾的公共长度，即 `dp[i-1][j-1]`。所以 `dp[i][j] = dp[i-1][j-1] + 1`。

##### 元素不匹配的情况

如果 `nums1[i-1] != nums2[j-1]`，那么以这两个元素结尾的子数组无法构成公共部分，连续性被打破。因此，长度直接归零。`dp[i][j] = 0`。

**最终的全局最长长度，是所有 `dp[i][j]` 值中的最大值**

#### 实现原理和步骤

1. **定义 DP 状态**: `dp[i][j]` 代表以 `nums1[i-1]` 和 `nums2[j-1]` 结尾的最长公共子数组的长度。

2. **创建 DP 表**: 创建一个 `(m+1) x (n+1)` 的 `dp` 表，并初始化为 0。使用 `m+1` 和 `n+1` 的大小是为了方便处理边界情况（即 `i=0` 或 `j=0`）。
3. **初始化**: 一个全局变量 `maxLength` 初始化为 0。
4. **遍历计算**: 使用嵌套循环，`i` 从 1 到 `m`，`j` 从 1 到 `n`。
5. **状态转移**: 在循环内，判断 `nums1[i-1] == nums2[j-1]`，并根据结果更新 `dp[i][j]`。
6. **更新结果**: 每次计算完 `dp[i][j]`后，都要更新全局最大值：`maxLength = Math.max(maxLength, dp[i][j])`。
7. **返回结果**: 返回 `maxLength`。

#### 代码套路模板

```java
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int[][] dp = new int[m+1][n+1];
        int max = 0;
        for(int i = 1; i <= m ; i++){
            for(int j = 1; j <= n; j++){
                if(nums1[i-1] == nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = 0;
                }
                max = Math.max(dp[i][j], max);
            }
        }

        return max;
    }
```

#### 注意事项

- **与最长公共子序列（LCS）的关键区别**:
  - **最长公共子数组（本题）**: 不匹配时，`dp[i][j] = 0`，因为连续性被打破。
  - **最长公共子序列**: 不匹配时，`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`，因为子序列可以不连续，可以继承之前的最优结果。这是两类问题的根本区别。
- **结果位置**: 结果同样是 `dp` 表中的全局最大值，而不是右下角的 `dp[m][n]`。

#### 经验总结

双数组问题的 DP 状态通常是二维的，`dp[i][j]` 关联了两个数组中各自到 `i` 和 `j` 的状态。解题的关键在于**想清楚当 `nums1[i]` 和 `nums2[j]` 不匹配时，应该如何处理**。对于子数组问题，答案是“归零”；对于子序列问题，答案是“继承”。

## 子数组最优值问题

这类问题要求你找到一个子数组，使其某个指标最大或最小（例如，和最大、乘积最大等）。

### 场景和目标

**数据结构**: 一个一维数组 `int[] nums`。

**目标**: 找到一个连续子数组，使其和/乘积/或其他指标值最大或最小。

### 解决的一般套路

#### **状态定义**: 定义 `dp[i]` 为**必须以 `nums[i]` 元素结尾**的子数组的最优值

这个定义是解决此类问题的精髓，它保证了子数组的连续性。

#### 状态转移方程

思考 `dp[i]` 如何从 `dp[i-1]` 推导出来。对于以 `nums[i]` 结尾的子数组，我们通常有两种选择：

- 自成一派：子数组只包含 `nums[i]` 这一个元素。
- 与前面合并：将 `nums[i]` 加入到那个以 `nums[i-1]` 结尾的最优子数组中，形成一个新的、更长的子数组。 我们从这两种选择中取最优的作为 `dp[i]` 的值。

#### 最终结果

问题的最终解**不一定**是 `dp[n-1]`，因为最优子数组可能在数组的任何位置结束。因此，最终结果是所有 `dp[i]` (从 `i=0`到 `n-1`) 中的最优值。

### 实现套路

- 初始化两个变量：`global_max` 用于记录全局最优解，`local_max` 用于记录以当前元素结尾的最优解（即 `dp[i]`）。

- 将 `global_max` 和 `local_max` 都初始化为数组的第一个元素 `nums[0]`。

- 从数组的第二个元素开始遍历。

- 在循环中，更新 `local_max`：`local_max = max(nums[i], local_max + nums[i])` (以求最大和为例)。

- 然后，用更新后的 `local_max` 来挑战 `global_max`：`global_max = max(global_max, local_max)`。

- 循环结束后，`global_max` 就是最终答案。

### 代码模板套路

```Java
class Solution {
    public int solve(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // 或者根据题目要求抛出异常
        }
        // globalMax 存储全局最大值
        int globalMax = nums[0];
        // localMax 相当于 dp[i]，表示以 nums[i] 结尾的子数组的最大和
        int localMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            // 状态转移：选择是自成一派 `nums[i]` 还是与前面合并 `localMax + nums[i]`
            localMax = Math.max(nums[i], localMax + nums[i]);
            // 用当前局部最优解挑战全局最优解
            globalMax = Math.max(globalMax, localMax);
        }
        return globalMax;
    }
}
```

### Leetcode 152 : 最大子数组乘积

#### 问题要点

**输入**: 一个整数数组 `nums`。

**输出**: 数组中一个连续（contiguous）非空子数组的最大乘积。

**连续子数组**: 指的是数组中从一个索引到另一个索引的所有元素组成的序列，中间不能间断。例如，`[2, 3, -2, 4]` 的子数组可以是 `[2, 3]`、`[-2, 4]`，但不能是 `[2, 4]`。

**核心挑战**: 数组中包含正数、负数和零。负数的存在是这个问题的关键，因为两个负数的乘积会变成正数，这可能使得一个本来很小的负数，在与另一个负数相乘后，摇身一变成为最大乘积的一部分。零则会中断乘积的连续性，任何数乘以零都得零。

#### 问题本质和分析 - 负负得正！

问题的本质是，在一个序列中，找到一段连续的区间，使得这个区间内所有元素的乘积最大。

与“最大子数组和”不同，我们在这里不能简单地认为“如果当前乘积为负，就从下一个数重新开始”，因为这个负的乘积可能在后面遇到另一个负数，从而“负负得正”，得到一个巨大的正数。

**举例分析:**

- `nums = [2, 3, -2, 4]`
  - `[2, 3]` 的乘积是 6。
  - `[2, 3, -2]` 的乘积是 -12。
  - `[-2]` 的乘积是 -2。
  - `[4]` 的乘积是 4。
  - 最大乘积是 `[2, 3]` 的 `6`。
- `nums = [-2, 0, -1]`
  - 最大乘积是 `0`（子数组 `[0]`）。注意子数组 `[-2, -1]` 不是连续的。
- `nums = [-2, 3, -4]`
  - `[-2]` -> -2
  - `[-2, 3]` -> -6
  - `[-2, 3, -4]` -> 24
  - `[3]` -> 3
  - `[3, -4]` -> -12
  - `[-4]` -> -4
  - 最大乘积是 `[-2, 3, -4]` 的 `24`。这个例子完美地展示了负数的重要性。

从分析中我们得出结论：在遍历数组时，我们需要同时关注 **当前位置可能产生的最大乘积** 和 **最小乘积**。

为什么需要关注最小乘积？

因为一个当前的最小负值（例如 `-10`）如果乘以一个负数（例如 `-5`），就可能得到一个最大的正值（`50`）。

#### 规律观察和模式匹配

##### 规律观察

###### 当前数字为整数时： 希望乘以最大乘积

当遍历到一个正数 `x` 时，我们希望用它去乘以之前的最大乘积，以期望得到一个更大的正数。

同时，用它去乘以之前的最小乘积（如果为负），会得到一个更小的负数。

###### 当前数字为负数时：希望乘以最小乘积

当遍历到一个负数 `y` 时，情况反转了。我们希望用它去乘以之前的*最小*乘积（一个负数），来得到一个*最大*的正数。

而用它乘以之前的*最大*乘积，会得到一个*最小*的负数。

###### 当前数字为0时： 任何连续乘积都会被中断归零

当遍历到一个零 `0` 时，任何连续的乘积都会被“中断”归零。

这意味着新的子数组将从下一个元素开始。

##### 模式套路匹配

我们定义 `dp[i]` 为以 `nums[i]` *结尾*的子数组的最大乘积。

但是，正如我们上面分析的，只记录最大值是不够的。

比如 `nums = [-2, 3]`，到 `3` 的时候，以 `3` 结尾的最大乘积是 `3`。

但如果下一个数是 `-4`，那么 `3 * -4 = -12` 不是我们想要的。

我们反而需要前一步的最小乘积 `-2`，`(-2*3) * -4 = 24`。

因此，我们需要维护两个状态：

- `max_so_far[i]`: 以 `nums[i]` 结尾的子数组的 **最大** 乘积。
- `min_so_far[i]`: 以 `nums[i]` 结尾的子数组的 **最小** 乘积。

#### 核心思想和套路

##### 核心思想： 同时记录最大和最小乘积

使用动态规划，在遍历数组的每一步，同时追踪以当前元素结尾的“最大乘积”和“最小乘积”。

##### 状态转移方程

###### 计算最大乘积

当我们遍历到 `nums[i]` 时，以它结尾的最大乘积 `max_so_far[i]` 有三种可能：

1. 就是 `nums[i]` 本身。（例如 `[0.1, 0.2, 100]`，到 `100` 的时候，最大乘积就是 `100` 本身）
2. 是前一个最大乘积 `max_so_far[i-1]` 乘以 `nums[i]`。
3. 是前一个最小乘积 `min_so_far[i-1]` 乘以 `nums[i]`。（当 `nums[i]` 是负数时，这种情况可能产生最大值）

所以： `max_so_far[i] = max(nums[i], max_so_far[i-1] * nums[i], min_so_far[i-1] * nums[i])`

###### 计算最小乘积

同理，以 `nums[i]` 结尾的最小乘积 `min_so_far[i]` 也有三种可能：

```
min_so_far[i] = min(nums[i], max_so_far[i-1] * nums[i], min_so_far[i-1] * nums[i])
```

#### 实现原理和步骤

**处理边界情况**: 如果输入数组 `nums` 为 `null` 或长度为 0，返回 0。

**创建 DP 数组**:

- 创建 `maxDP` 数组，长度与 `nums` 相同。
- 创建 `minDP` 数组，长度与 `nums` 相同。

**初始化 DP 数组**:

- 设置基本情况：`maxDP[0] = nums[0]` 和 `minDP[0] = nums[0]`。

**初始化结果变量**:

- 创建一个变量 `result`，并初始化为 `maxDP[0]`，用来追踪整个 `maxDP` 数组中的最大值。

**循环计算**:

- 从 `i = 1` 开始遍历 `nums` 数组，直到结束。
- 在循环内部，根据状态转移方程计算 `maxDP[i]` 和 `minDP[i]`：
  - `maxDP[i] = Math.max(nums[i], Math.max(maxDP[i-1] * nums[i], minDP[i-1] * nums[i]));`
  - `minDP[i] = Math.min(nums[i], Math.min(maxDP[i-1] * nums[i], minDP[i-1] * nums[i]));`
- 每次计算出 `maxDP[i]` 后，更新 `result`：
  - `result = Math.max(result, maxDP[i]);`

**返回结果**: 循环结束后，`result` 中存储的就是全局最大乘积，返回 `result`。

#### 实现代码

```Java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0];
        }
        int n = nums.length;

        int[] minDp = new int[n];
        int[] maxDp = new int[n];

        minDp[0] = nums[0];
        maxDp[0] = nums[0];

        int ans = maxDp[0];

        for(int i = 1; i < n; i++){
            minDp[i] = Math.min(nums[i], Math.min(maxDp[i-1] * nums[i],minDp[i-1] * nums[i]));
            maxDp[i] = Math.max(nums[i], Math.max(maxDp[i-1] * nums[i],minDp[i-1] * nums[i]));
            ans = Math.max(maxDp[i], ans);
        }

        return ans;
    }
}
```



## 计数和存在性问题

这两类问题高度相关，通常可以使用相同的套路解决。

计数是问“有多少个”，存在性是问“有没有”（即数量是否大于0）。

因此，我们将它们合并讨论，核心思想是**前缀和 + 哈希表**。

### 场景和目标

**数据结构**: 一个一维数组 `int[] nums`，通常还有一个目标值 `k`。

**目标**: 统计满足特定条件（如和等于 `k`，和是 `k` 的倍数）的连续子数组的数量，或者判断是否存在这样的子数组。

### 解决的一般套路 - 前缀和 + 哈希表

####**核心思想**: `sum(nums[j+1...i]) = prefixSum[i] - prefixSum[j]` 

数组中从索引 `j+1` 到 `i` 的子数组之和为 `sum(nums[j+1...i])`。这个和可以通过前缀和 `prefixSum` 来计算，即 `prefixSum[i] - prefixSum[j]`。

####**问题转化**: `prefixSum[j] = prefixSum[i] - k`

我们要寻找 `prefixSum[i] - prefixSum[j] = k`。变形一下，就成了 `prefixSum[j] = prefixSum[i] - k`。

####**哈希表应用**: `counter.get(prefixSum[j])`

当我们遍历数组计算到索引 `i` 的前缀和 `prefixSum[i]` 时，我们只需要查询在 `i` 之前，有多少个 `j` 满足 `prefixSum[j] = prefixSum[i] - k`。

哈希表（HashMap）非常适合做这个“查询”工作。

####**哈希表设计**:<前缀和，前缀和出现的次数>

- `key`: 前缀和的值。
- `value`: 该前缀和出现的次数。

####**遍历与统计**:

- 初始化一个哈希表 `map`，并放入 `{0: 1}`。这非常重要，它处理了从数组开头到当前位置的子数组恰好满足条件的情况（即 `prefixSum[i] = k`）。
- 遍历数组，累加计算当前的前缀和 `currentSum`。
- 在 `map` 中查找 `currentSum - k` 这个键，如果存在，说明找到了符合条件的子数组，将其出现的次数累加到最终结果 `count` 中。
- 将当前的 `currentSum` 存入哈希表（或更新其出现次数）。

### 实现套路

1. 创建一个 HashMap，`map.put(0, 1)`。

2. 初始化 `count = 0`，`currentSum = 0`。

3. 遍历数组 `nums` 中的每个元素 `num`。

4. 更新 `currentSum += num`。

5. 检查 `map.containsKey(currentSum - k)`，如果存在，`count += map.get(currentSum - k)`。

6. 更新 `map` 中 `currentSum` 的频率：`map.put(currentSum, map.getOrDefault(currentSum, 0) + 1)`。

7. 循环结束后，`count` 就是答案。

8. 对于“是否存在”问题，只需在第5步找到后直接返回 `true` 即可，并且可以用 HashSet 代替 HashMap 简化逻辑。

### 代码实现套路模板

```Java
// 计数问题模板 (Counting)
class Solution {
    public int solve(int[] nums, int k) {
        int count = 0;
        int currentSum = 0;
        // Key: 前缀和, Value: 该前缀和出现的次数
        Map<Integer, Integer> prefixSumMap = new HashMap<>();
        // 初始化：和为0的前缀和出现了1次（代表空的前缀）
        prefixSumMap.put(0, 1);

        for (int num : nums) {
            currentSum += num;
            // 查找 target = currentSum - k 是否存在
            int target = currentSum - k;
            if (prefixSumMap.containsKey(target)) {
                count += prefixSumMap.get(target);
            }
            // 将当前的前缀和存入 map
            prefixSumMap.put(currentSum, prefixSumMap.getOrDefault(currentSum, 0) + 1);
        }
        return count;
    }
}

// 存在性问题模板 (Existence)
class Solution {
    public boolean solve(int[] nums, int k) {
        int currentSum = 0;
        // 只需要记录前缀和是否出现过
        Set<Integer> prefixSumSet = new HashSet<>();
        prefixSumSet.add(0);

        for (int num : nums) {
            currentSum += num;
            int target = currentSum - k;
            if (prefixSumSet.contains(target)) {
                return true;
            }
            prefixSumSet.add(currentSum);
        }
        return false;
    }
}
```

- - **[LeetCode 560. 和为 K 的子数组 (Subarray Sum Equals K)](https://leetcode.cn/problems/subarray-sum-equals-k/)**: 计数的经典模板题。
  - **[LeetCode 523. 连续的子数组和 (Continuous Subarray Sum)](https://leetcode.cn/problems/continuous-subarray-sum/)**: 存在性的经典题目。目标是子数组和是 `k` 的倍数。这需要利用同余定理：`(prefixSum[i] - prefixSum[j]) % k == 0` 等价于 `prefixSum[i] % k == prefixSum[j] % k`。所以哈希表中存的是**前缀和对 `k` 的余数**。
  - **[LeetCode 974. 和可被 K 整除的子数组 (Subarray Sums Divisible by K)](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)**: 523题的计数版本，同样使用同余定理和哈希表。