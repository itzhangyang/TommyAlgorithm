# 区间类问题

## High Level Summary

### 两种常见的数据结构场合：连续数组或者离散区间列表

#### 在连续的数组或者字符串上进行操作

问题给你一个数组或字符串，让你通过合并、删除、添加等操作求最优解。

解法通常是定义 `dp[i][j]` 为子数组 `arr[i...j]` 的最优解。

**这是最经典的区间DP**。

#### 在离散的区间列表上操作 - 先排序后DP

问题给你一堆 `[start, end]` 形式的区间，让你从中选择或组合以求最优解。

解法通常需要 **先排序**，然后DP。

### 灵魂 - `DP[i][j]`的定义

动规问题的核心是状态定义。对于区间DP，`dp[i][j]` 的含义清晰，题目就解了一半。

### 命脉 - 遍历顺序

区间DP的本质是“短区间”的解构成“长区间”的解。

因此，**先计算所有短区间，再计算长区间** 的遍历顺序是不可违背的铁律。

最经典、最不会出错的遍历方式就是 **按区间长度 `len` 递增**。

### 关键 -最后一步

思考 `dp[i][j]` 时，不要想“第一步怎么做”，而要思考“**形成 `[i, j]` 结果的最后一步是什么**”。

这一步通常涉及一个分割点 `k`，将问题分解为子问题。

##区间合并/分割问题-多个元素按照区间合并的最小代价

### 场景+目标

- **场景**：输入是一个线性数组 `nums` 或字符串 `s`。
- **目标**：通过在相邻元素间进行“合并”、“消除”或“配对”操作，求整个序列 `[0, n-1]` 上的最大/最小得分或代价。

### 问题的本质和分析

#### 问题的本质：对区间`[i...j]`的操作结果依赖于`[i,k]`和`[k+1,j]`的操作结果

这类问题的共性是，对一个大区间 `[i, j]` 的操作，其结果依赖于其内部子区间 `[i, k]` 和 `[k+1, j]` (或 `[i, k]` 和 `[k, j]`) 的操作结果。

最终形成 `[i, j]` 的解必然是源于某次在 `k` 点的分割或合并。

#### 问题分析 - 枚举所有的分割点K

我们需要枚举所有可能的分割点 `k`，找出那个能导出最优解的 `k`。根据“最后一步”的代价计算方式不同，又可细分为两种思维模式：

##### 正向合并（代价来自区间内）

如石子合并。最后一步合并 `[i, k]` 和 `[k+1, j]` 的代价是 `sum(i, j)`，这个代价取决于子区间的 **内部元素**。

##### 逆向合并（代价来自区间边界）

如戳气球。

思考`(i,j)`中最后一个被戳破的气球`k`，戳破它的代码是`nums[i]*nums[k]*nums[j]`，这个代价取决于子区间的外部边界。

当正向思考（先戳谁）导致子问题互相依赖时，逆向思考（最后剩谁）往往能解耦问题。

###核心思想-划分子区间并枚举中间的分割点

我们将一个较大的区间问题:

- **划分为多个更小的子区间**来解决，
- 并通过**枚举每个区间中间的分割点**`k=[i...k]`
- 合并子问题的解来构造整个区间的最优解。

假设设 `dp[i][j]` 表示区间 `[i, j]` 上问题的最优解。

对于每一个`k=[i...j]`，求`min(dp[i][k]+dp[k+1][j])`

找到`min(dp[i][k]+dp[k+1][j])`之后，`dp[i][j]=min(dp[i][k]+dp[k+1][j]+mergeCost(i,j))`

我们希望通过 `dp[i][k]` 和 `dp[k+1][j]` 来求出 `dp[i][j]`，公式一般为：

![image-20250409195650294](/Users/tommy/Library/Application Support/typora-user-images/image-20250409195650294.png)

- `mergeCost(i, j)`：表示将 `[i, j]` 区间合并成一个整体时的额外代价，视题目而定。
- `k` 是分割点，把 `[i, j]` 拆成 `[i, k]` 和 `[k+1, j]` 两个子问题。

#### **状态定义**：`dp[i][j]` 表示合并区间 `[i, j]` 的最小代价

最终我们求的是`dp[0,n-1]`

#### 遍历逻辑-按照区间长度从小到大遍历

- 按照区间长度遍历`len=[2,n]`
- 对于每一个长度为`len`的区间：
  - 找到起一个区间起点`firstStart`和最后一个区间起点`lastStart`
  - 对于`start=[firstStart...lastStart]`,`end = start+len-1`, 遍历区间`[start,end]`
  - 尝试通过分割区间来找到更小的代价，对于每一个`k=[start,end)`, 
    - 计算合并区间`[start...k]`和`[k+1,end]`的代价
    - 并找到上述合并代价的最小值

- 最后合并的最小代价`dp[start][end]=Math.min(dp[start][end],dp[start][k]+dp[k+1][end]+cost(start,end))`

```java
for (int len = 2; len <= n; len++) { // len：区间长度,从2开始
  int firstart = 0;
  int lastStart = n-len;
    for (int start = 0; i <= lastStart; start++) { // i：区间的起点
        int end = i + len - 1; // j：终点
        for (int k = i; k < j; k++) { // k：断点
            dp[start][end] = Math.min(dp[start][end], dp[start][k] + dp[k+1][end] + cost(start, end));
        }
    }
}
```

### 解决方法和套路

####**状态定义**：`dp[i][j]` 表示处理/合并/消除区间 `[i, j]` 的最优解

**状态定义**：`dp[i][j]` 表示处理/合并/消除区间 `[i, j]` 的最优解。

#### Base Case： 长度为1的区间 `dp[i][i]` 通常有初始值

长度为1的区间 `dp[i][i]` 通常有初始值（0或 `nums[i]`）。长度为2的区间有时也需要单独初始化。

#### 遍历过程 - 三层遍历：区间长度/区间/区间内部

##### 外层： 从小到大遍历区间的长度`[2....n]`

`for (int len = 2; len <= n; len++)`

##### 中层： 遍历当前长度的所有区间

```Java
for(int left = 0; left <= n - len; left++){
  int right = left + len  - 1;
  //...
}
```

##### 内层：遍历区间内的每一个切割点

```Java
for(int k = left; k < right; k++){
  ...
}
```

#### 状态转移过程

##### 正向合并

```
dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + cost(i,j));
```

##### 逆向思维

```
dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + cost(i, k, j))
```

##### 字符串配对

```Java
if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+C; else dp[i][j]=max(dp[i+1][j], dp[i][j-1])
```

### 代码套路模板

```Java
class Solution {
    public int solve(int[] nums) {
        int n = nums.length;
        // 根据题目可能需要padding，如戳气球
        // int[] points = new int[n + 2]; ...

        int[][] dp = new int[n][n];

        // len: 区间长度
        for (int len = 2; len <= n; len++) {
            // i: 区间起点
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1; // 区间终点
                dp[i][j] = Integer.MAX_VALUE; // or Integer.MIN_VALUE

                // k: 分割点
                for (int k = i; k < j; k++) {
                    // 【核心】根据具体问题定义代价和转移方程
                    // 例1：石子合并
                    // int cost = prefixSum[j+1] - prefixSum[i];
                    // dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + cost);

                    // 例2：戳气球 (注意dp数组和nums数组索引的转换)
                    // int score = points[i-1] * points[k] * points[j+1];
                    // dp[i][j] = Math.max(dp[i][j], dp[i][k-1] + dp[k+1][j] + score);
                }
            }
        }
        return dp[0][n - 1];
    }
}
```

### 注意事项

**开闭区间**：务必想清楚 `dp[i][j]`、分割点 `k` 定义的是开区间还是闭区间，这会影响循环的边界和状态转移的细节。

**预处理**：前缀和是计算区间内部代价的利器。padding数组是处理边界代价的常用技巧。

**返回值**：最终答案通常是 `dp[0][n-1]`，但有时 `n` 指的是padding后的长度，要注意区分。

### 子类型一：合并区间内的元素 - 自底向上

这是最直观的区间DP模型，思考方式是“正向”和“自底向上”的。

#### 场景+ 目标 - 合并数组内元素的最小代价

**场景**：通常输入是一个线性数组，数组中的每个元素代表一个独立的实体（如一堆石子、一个叶子节点）。

**目标**：通过不断地合并 **相邻** 的实体，最终将整个区间内的所有实体合并成一个。每一次合并都会产生一个“代价”，目标是求得完成所有合并后的 **最小或最大总代价**。

**典型例子**：石子合并 (LC 1000)、最小代价生成树 (LC 1130)。

#### 问题本质分析 - 寻找最优的合并顺序

**本质**：寻找一种最优的合并顺序，这种顺序可以被映射为一棵最优的二叉树。

#####最后一次合并：`[i,k]`和`[k+1,j]`

**分析**：考虑区间 `[i, j]`。无论内部的合并顺序多么复杂，这整个区间的合并过程中的 **最后一次合并**，一定是将两个已经合并好的“大实体”结合起来。

这两个“大实体”分别是由子区间 `[i, k]` 和 `[k+1, j]` (其中 `i <= k < j`) 里的所有小实体合并而成的。

**代价的来源**：这次最后合并的代价，通常取决于 **区间 `[i, j]` 的整体属性**。

例如，在石子合并中，代价是 `sum(stones[i]...stones[j])`。

##### 最后一次合并之前：分别合并过程也是最优子结构

**最优子结构**：要使 `[i, j]` 的总代价最优，其子问题 `[i, k]` 和 `[k+1, j]` 的合并过程也必须是各自最优的。这就构成了动态规划的基础。

#### 核心思想：前缀和 + 动态规划

##### **状态定义**：`dp[i][j]` - 将区间 `[i, j]` 内的所有实体合并成一个的最小/最大代价

`dp[i][j]` 表示将区间 `[i, j]` 内的所有实体合并成一个的最小/最大代价

#####**预处理**：构建前缀和数组

如果合并代价与区间和有关，预先计算一个 **前缀和数组** `prefixSum`，以便在O(1)时间内查询任意区间的和。

##### **Base Case**：`dp[i][i] = 0`。

单个实体无需合并，代价为0。

#####**遍历顺序**：区间长度/每个区间/区间内每个切割点

- 外层：区间长度 `len` 从 2 到 `n`。
- 中层：区间起点 `i` 从 0 到 `n-len`。
- 内层：分割点 `k` 从 `i` 到 `j-1`。

##### **状态转移方程**：$$dp[i][j] = optimal(dp[i][j], dp[i][k] + dp[k+1][j] + cost(i,j))$$

 `dp[i][j] = min/max ( dp[i][k] + dp[k+1][j] + cost_of_merging(i, j) )` 其中 `k` 在 `[i, j-1]` 的范围内枚举。



###Leetcode 1000:每次合并数组中K个元素 - 合并石头的最低成本（困难）

这是一道经典的区间动态规划 (Interval Dynamic Programming) 问题，并且带有一些独特的约束和优化，使其成为一道难度较高的题目。

#### 问题要点

给定 `n` 堆石头，排成一行，每堆的石头数量由数组 `stones` 表示。

游戏的目标是通过一系列的合并操作，将所有的石头堆合并成一堆。

合并操作的规则如下：

- **每次**合并，你必须选择 **连续的 `K` 堆** 石头。
- 将这 `K` 堆石头合并成**一堆**。
- 这次合并的**成本**等于这 `K` 堆石头的总数量。

你的任务是找到将所有石头合并成一堆的**最低总成本**。

如果无法完成合并，返回 `-1`。

**核心约束：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`
- `2 <= K <= 30`

#### 问题的本质和分析 - 每次必须连续合并`k`堆

这个问题的本质是在满足“每次必须合并连续 `K` 堆”的约束下，寻找一个最优的合并顺序，使得总成本最小。

#####**合并过程**：每次合并都会使石头的堆数减少 `K-1`

就是将`k`堆石头合并成了`1`堆，从总数量上来说，减少了`k-1`堆）。例如，合并 `K=3` 堆，堆数从 3 变成 1，减少了 2。

#####**最终状态**：最终目标是将 `N` 堆石头变成 1 堆。

#####怎样判断**合并可行性**？ - `(N-1) % (K-1) == 0`

从 `N` 堆开始，每次减少 `K-1` 堆，最终要变成 1 堆。

这意味着总共减少的堆数必须是 `N-1`。

因此，`N-1` 必须是 `K-1` 的整数倍。

如果 `(N - 1) % (K - 1) != 0`，那么无论如何也无法合并成一堆，可以直接返回 `-1`。

这是一个非常重要的**剪枝条件**。

##### 成本是怎么计算的？

假设我们合并区间 `[i, j]` 里的所有石头。

###### 最后一步的合并成本:`sum(i...j)`

无论我们怎么合并，最后一步一定是这样的场景：

> 在区间 `[i, j]` 内，已经形成了 `K` 堆临时的石头堆，然后我们“哗”地一下把这 `K` 堆合并成最终的那一堆。

这次合并的成本是多少？就是 `[i, j]` 区间内所有石头的总和。

为了快速计算这个总和，我们自然而然地想到了**前缀和**。

###### 前缀和

我们先创建一个 `prefixSum` 数组，`prefixSum[i]` 存的是前 `i` 个石头的总和。

这样 `stones[i]` 到 `stones[j]` 的和就可以用 `prefixSum[j+1] - prefixSum[i]` 在 O(1) 时间内算出来。

这是我们的计算器，非常方便。



#### 核心思想和套路

动态规划的核心就是**大问题化小，小问题求解**。

##### DP的定义： 将区间 `[i, j]` 的石头合并成 `k` 堆的最小成本

我们定义一个三维数组 `dp[i][j][k]`：

- `i`: 区间的起始索引。
- `j`: 区间的结束索引。
- `k`: 目标堆数。

我们的最终目标是 `dp[0][N-1][1]`，即把所有石头 `[0, N-1]` 合并成 `1` 堆的最小成本。

##### 前缀和辅助

为了快速计算任意区间 `[i, j]` 的石头总和（合并成本），我们预先计算一个前缀和数组 `prefixSum`。`sum(i, j)` 就可以通过 `prefixSum[j+1] - prefixSum[i]` 在 O(1) 时间内得到。

##### 状态转移方程

这是整个解法的核心，我们把它分成两种情况来分析：

###### 合成K堆（K > 1）

要将区间 `[i, j]` 合并成 `k` 堆，我们无法一步到位。

必须先将它分割成两个子区间 `[i, m]` 和 `[m+1, j]`。

一个自然的想法是：将左边 `[i, m]` 合并成 `1` 堆，右边 `[m+1, j]` 合并成 `k-1` 堆。

然后把这两部分的结果“拼接”在一起，就得到了 `k` 堆。 

在这个过程中，我们没有执行新的合并操作，所以成本就是两个子问题成本之和。 

我们需要遍历所有可能的分割点 `m` 来找到最小值。

`dp[i][j][k] = min(dp[i][m][1] + dp[m+1][j][k-1])`  (其中 `i <= m < j`)

###### 合成1堆（k=1）

这是唯一会产生**新成本**的步骤。

要将 `[i, j]` 合并成 `1` 堆，它的前一个状态必须是 `[i, j]` 区间内有 `K` 堆石头。

然后，我们执行最后一次合并操作，把这 `K` 堆合并成 `1` 堆。 

这次操作的成本就是区间 `[i, j]` 内所有石头的总和。

`dp[i][j][1] = dp[i][j][K] + sum(i, j)`

这个转移只在 `dp[i][j][K]` 是一个有效值（即 `[i,j]` 可以被合并成 `K` 堆）时才发生。

#### 实现原理和步骤

##### 检查是否能够完成合并过程

**可行性检查**: 如果 `(N - 1) % (K - 1) != 0`，直接返回 `-1`。

##### 构建前缀和数组

**预处理**: 创建并计算 `prefixSum` 数组。

#####构建和初始化DP数组

- **初始化DP数组**: 创建 `dp[N][N][K+1]` 数组，并用一个极大的值（代表无穷大）填充，表示状态不可达。

- **设置基本情况 (Base Case)**: `dp[i][i][1] = 0`。对于任意 `i`，将单堆石头 `[i]` "合并"成 `1` 堆的成本是 `0`，因为它本身就是一堆。

##### 遍历过程和状态转移

**迭代计算**: 按照区间DP的标准顺序进行循环：

- **外层循环**: 区间长度 `len`，从 `2` 到 `N`。
- **中层循环**: 区间起点 `i`，从 `0` 到 `N - len`。
- **计算区间终点**: `j = i + len - 1`。
- **内层循环**: 计算 `dp[i][j][k]`。
  - **计算 `k > 1` 的情况**: 遍历目标堆数 `k` (从 `2`到`K`)，再遍历分割点 `m` (从 `i`到`j-1`)，应用**情况1**的状态转移方程。
  - **计算 `k = 1` 的情况**: 在 `k` 的循环之后，检查 `dp[i][j][K]` 是否有效。如果有效，应用**情况2**的状态转移方程。

##### 返回结果

**返回结果**: `dp[0][N-1][1]`。如果该值仍为无穷大，说明出错了（理论上第一步检查后不会），否则返回该值。

#### 实现代码

```Java
import java.util.Arrays;

class Solution {
    public int mergeStones(int[] stones, int K) {
        int n = stones.length;

        // 1. 可行性检查
        if ((n - 1) % (K - 1) != 0) {
            return -1;
        }

        // 2. 预处理前缀和数组
        int[] prefixSum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + stones[i];
        }

        // 3. 初始化 DP 数组
        // dp[i][j][k] 表示将区间 [i, j] 的石头合并成 k 堆的最小成本
        int[][][] dp = new int[n][n][K + 1];
        int INF = Integer.MAX_VALUE / 2; // 用一个较大的值作为无穷大，防止计算时溢出
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(dp[i][j], INF);
            }
        }

        // 4. 设置基本情况 (Base Case)
        for (int i = 0; i < n; i++) {
            dp[i][i][1] = 0;
        }

        // 5. DP 迭代
        // 从小区间到大区间
        for (int len = 2; len <= n; len++) { // 区间长度
            for (int i = 0; i <= n - len; i++) { // 区间起点
                int j = i + len - 1; // 区间终点

                // --- 计算情况1: 合并成 k > 1 堆 ---
                for (int k = 2; k <= K; k++) { // 目标堆数
                    for (int m = i; m < j; m++) { // 分割点
                        // 将 [i,m] 合并成1堆，[m+1,j] 合并成 k-1 堆
                        if (dp[i][m][1] != INF && dp[m + 1][j][k - 1] != INF) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i][m][1] + dp[m + 1][j][k - 1]);
                        }
                    }
                }
                
                // --- 计算情况2: 合并成 1 堆 ---
                // 如果[i, j]能合并成K堆，那么就可以再花sum(i,j)的成本将它合并成1堆
                if (dp[i][j][K] != INF) {
                    int sum = prefixSum[j + 1] - prefixSum[i];
                    dp[i][j][1] = dp[i][j][K] + sum;
                }
            }
        }
        
        // 6. 返回结果
        return dp[0][n - 1][1];
    }
}
```

#### 注意事项

**态定义的精确性**: `dp[i][j][k]` 的 `k` 是合并**之后**的堆数，这是理解状态转移的关键。

**循环顺序**: 区间DP必须先算小区间，再算大区间。所以 `len` 是最外层循环。

**成本的产生**: 只有在 `K` 堆合并为 `1` 堆时才产生新的成本，即 `sum(i, j)`。合并成多堆（`k>1`）只是子问题成本的累加，不产生新成本。

**无穷大的选择**: 初始化 `dp` 数组时，`INF` 值不应是 `Integer.MAX_VALUE`，因为状态转移中有加法 `dp[...]+dp[...]`，可能会导致整数溢出。取 `MAX_VALUE / 2` 是个安全的选择。

#### 经验总结

**三维DP的适用场景**: 当二维区间DP `dp[i][j]` 无法完全描述一个子问题的状态时，就要考虑增加维度。本题中“合并后的堆数”就是必须记录的额外状态。

**分治思想**: DP的状态转移本质上是一种分治。我们将一个大问题（如合并成 `k` 堆）分解为两个更小的子问题（合并成 `1` 堆和 `k-1` 堆）。

**化整为零**: 将复杂的状态转移（合并成一堆）分解为两个清晰的步骤：先达成前置条件（凑成K堆），再执行最终操作（合并并加上成本）。这种思维方式能让复杂的DP逻辑变得清晰可控。

### Leetcode 1130 - 叶子节点值的最小代价生成树

#### 问题要点

给定一个正整数数组 `arr`，我们需要构建一棵二叉树，满足以下条件：

1. 每个叶子节点的值对应 `arr` 中的一个元素，且这棵树中序遍历的结果恰好是 `arr`。
2. 每一个非叶子节点的值等于其左子树和左子树的最大叶子节点。
3. 我们的目标是找到所有满足条件的二叉树中，**所有非叶子节点值的总和** 的**最小值**。

简单来说，就是用 `arr` 数组作为一排叶子节点。

不断地**将相邻的两个节点合并**成一个**新的父节点**，父节点的值是这**两个节点值的乘积**。

这个**新生成的父节点**会加入到序列中，**替换掉原来的两个节点**，直到最后只剩一个根节点。

我们要让这个过程中所有生成的父节点的值的总和最小。

**示例:** `arr = [6, 2, 4]` 一种可能的合并方式是：

- 先合并 `2` 和 `4`。新生成的非叶子节点值为 `2 * 4 = 8`。序列变为 `[6, 8]`。
- 再合并 `6` 和 `8`。新生成的非叶子节点值为 `6 * 8 = 48`。
- 总代价 = `8 + 48 = 56`。

另一种方式：

- 先合并 `6` 和 `2`。新生成的非叶子节点值为 `6 * 2 = 12`。序列变为 `[12, 4]`。
- 再合并 `12` 和 `4`。新生成的非叶子节点值为 `12 * 4 = 48`。
- 总代价 = `12 + 48 = 60`。

所以，最小代价是 `56`。

#### 问题的本质和分析 

##### [复习]相邻合并

###### 场景和目标

**场景**：通常输入是一个线性数组，数组中的每个元素代表一个独立的实体（如一堆石子、一个叶子节点）。

**目标**：通过不断地合并 **相邻** 的实体，最终将整个区间内的所有实体合并成一个。每一次合并都会产生一个“代价”，目标是求得完成所有合并后的 **最小或最大总代价**。

###### 问题本质分析

考虑区间 `[i, j]`。无论内部的合并顺序多么复杂，这整个区间的合并过程中的 **最后一次合并**，一定是将两个已经合并好的“大实体”结合起来。

这两个“大实体”分别是由子区间 `[i, k]` 和 `[k+1, j]` (其中 `i <= k < j`) 里的所有小实体合并而成的。

**代价的来源**：这次最后合并的代价，通常取决于 **区间 `[i, j]` 的整体属性**。

##### 问题分析 - 最优划分问题

这道题的本质是一个**最优组合/划分**问题。

`arr` 数组定义了叶子节点的顺序（中序遍历），我们不能打乱它。

每一次合并，我们实际上是在 `arr` 的一个连续子数组中选择一对相邻的数进行合并。

######操作的本质 - 不断的合并最终得到一个根节点

假设我们要计算 `arr[i...j]` 形成子树的最小代价。

我们必须选择一个分割点 `k` (其中 `i <= k < j`)，将数组分成 `arr[i...k]` (左子树) 和 `arr[k+1...j]` (右子树) 两部分。

当我们这样做时，会创建一个新的父节点，这个父节点的**代价**（也就是它的值）根据规则是：`max(arr[i...k]) * max(arr[k+1...j])`。



而总代价则是这三部分之和： `总代价 = (左子树的最小代价) + (右子树的最小代价) + (本次分割产生的父节点代价)`

###### 问题的转化

因此，问题转化为： **每次合并（相乘）一对数 `a` 和 `b`，都会产生 `a * b` 的代价，并将结果放回序列。为了使总代价最小，我们应该如何选择合并顺序？**

#### 模式套路匹配

##### 模式一：合并相邻元素的最小代价[动态规划]

基于上述分析，我们可以认为这属于一个合并相邻元素的最小代价的问题。

######状态定义 - `dp[i][j]`表示合并`[i...j]`所需要的最小代价

`dp[i][j]` 表示由 `arr[i...j]` 这个连续子数组（作为叶子）构成一棵树的最小代价。

我们的最终目标是求`dp[0][n-1]`

###### 状态转移方程

为了计算 `dp[i][j]`，我们可以枚举一个分割点 `k` (`i <= k < j`)，将 `arr[i...j]` 分成 `arr[i...k]` 和 `arr[k+1...j]` 左右两部分。

- 左子树 `arr[i...k]` 的最小代价是 `dp[i][k]`。

- 右子树 `arr[k+1...j]` 的最小代价是 `dp[k+1][j]`。

- 这两棵子树合并时，产生的新的父节点的代价是 `max(arr[i...k]) * max(arr[k+1...j])`。

  $$dp[i][j] = \min_{i \le k < j} \{ dp[i][k] + dp[k+1][j] + \max(arr[i..k]) \times \max(arr[k+1..j]) \}$$

  为了快速求 `max(arr[i...k])`，我们可以预处理一个 `max_val[i][j]` 数组。

###### 动态规划的复杂度

时间 $O(n^3)$，空间 $O(n^2)$。

##### 模式二： 单调栈

###### [复习]单调栈的作用 - prev/next greater/smaller

```Java
//利用单调栈为每一个元素寻找Next Greater
public int[] nextGreater(int[] arr){
  
}
```



###### 核心思想

按照题目的规则，父节点的值为左子树和右子树中最大值的乘积。

让我们换一个角度思考：代价是如何产生的？

每产生一个非叶子节点，就会产生一笔代价。

总共会产生 `n-1` 个非叶子节点。

这意味着每个叶子节点（除了全局最大的那个）都必须作为“较小的一方”参与一次乘法，然后被“消除”。

思考数组 `[A, x, B]` 中的最小元素 `x`。

为了让总代价最小，我们希望 `x` 参与的乘法尽可能小。

`x` 最终要么与左边的子树合并，要么与右边的子树合并。

当 `x` 被“消除”时，它所贡献的代价是 `x * partner`，其中 `partner`是另一边子树的最大叶子值。

为了让这个代价最小，`partner` 也应该尽可能小。

这个 `partner` 实际上就是 `x` **左右两边第一个比它大的数**中，那个更小的数。

#### 实现原理

##### 基于动态规划方法

1. 预处理一个 `maxVal[i][j]` 数组，存储 `arr[i...j]` 区间的最大值，方便 O(1) 查询。
2. 按区间长度 `len` 从 2 到 `n` 进行遍历。
3. 在每个长度下，遍历所有可能的起始点 `i`。
4. 对于每个区间 `[i, j]`，遍历所有可能的分割点 `k` (`i` 到 `j-1`)。
5. 使用状态转移方程计算通过 `k` 分割的代价，并更新 `dp[i][j]` 为最小值。
6. 最终返回 `dp[0][n-1]`。

#### 实现代码

##### 基于动态规划 - 合并相邻的最小代价

```Java
//给定一个由正整数组成的数组
//考虑所有的二叉树
//每一个节点有0个或者2个子节点
//数组元素按照中序遍历映射到二叉树
//每一个非叶子节点的值等于其左子树和左子树的最大叶子节点
//返回最小的非叶子节点值之和

class Solution {
    public int mctFromLeafValues(int[] arr) {
        int[][] max = getMax(arr);
        int n = arr.length;

        int[][] dp = new int[n][n];
        for(int len = 2; len <= n; len++){
            for(int start = 0; start <= n - len; start++){
                int end = start + len - 1;
                dp[start][end] = Integer.MAX_VALUE;
                for(int k = start; k < end; k++){
                    dp[start][end] = Math.min(dp[start][end], dp[start][k] + dp[k+1][end] + max[start][k] * max[k+1][end]);
                }
            }
        }
        return dp[0][n-1];
    }
    //寻找区间内的最大值
    private int[][] getMax(int[] arr){
        int n = arr.length;
        int[][] max = new int[n][n];
        for(int i = 0; i < n; i++){
            max[i][i] = arr[i];
            for(int j = i+1; j < n; j++){
                max[i][j] = Math.max(max[i][j-1], arr[j]);
            }
        }
        return max;
    }
}
```

### LC 1547. Minimum Cost to Cut a Stick (Hard)

#### 问题详解和要点

#####问题描述

给定一根长度为 `n` 的木棍，以及一个整数数组 `cuts`，其中 `cuts[i]` 表示需要进行切割的位置。

你可以按**任意顺序**进行切割。

每次切割的成本是当前被切割的木棍的长度。

例如，如果你在一根长度为 10 的木棍上，在位置 3 进行切割，这次切割的成本就是 10。

木棍被分成两段，长度分别为 3 和 7。

之后，如果你在长度为 7 的那段木棍（原始位置从 3 到 10）上，在位置 8 进行切割，这次切割的成本就是 7 (即 10 - 3)。



你的任务是找到一个切割顺序，使得总成本最小，并返回这个最小的总成本。



**示例:**

- `n = 7`, `cuts = [1, 3, 4, 5]`
- 一种可能的切割顺序是 `[3, 5, 1, 4]`。
  1. 在 `[0, 7]` 上切割 `3`，成本为 7。木棍变为 `[0, 3]` 和 `[3, 7]`。
  2. 在 `[3, 7]` 上切割 `5`，成本为 4 (7 - 3)。木棍变为 `[3, 5]` 和 `[5, 7]`。
  3. 在 `[0, 3]` 上切割 `1`，成本为 3 (3 - 0)。木棍变为 `[0, 1]` 和 `[1, 3]`。
  4. 在 `[3, 5]` 上切割 `4`，成本为 2 (5 - 3)。木棍变为 `[3, 4]` 和 `[4, 5]`。
- 总成本 = 7 + 4 + 3 + 2 = 16。
- 可以证明这是最小成本。

##### 问题要点

###### 成本依赖于当前木棍长度

切割成本不是固定的，它取决于执行该次切割时，所在木棍片段的长度。

###### 切割顺序影响总成本

不同的切割顺序会导致不同的总成本。一个“好”的切割（比如尽早切割中间位置）可以大大降低后续切割的成本。

###### 目标是求最优解

问题要求的是所有可能切割顺序中的“最小”总成本。

###### 所有的切割操作必须都执行

不能跳过任何一个切割点。



#### 问题本质和分析

这个问题的本质是一个优化问题。我们需要在一系列决策（切割顺序）中找到最优的一个。



##### 先切哪一个切点？

不论我们最后切割成什么样子，总成本是什么？ 

假设我们先在 `c1` 切，成本是 `n`。

木棍分为 `[0, c1]` 和 `[c1, n]`。

然后我们在 `[c1, n]` 上切 `c2`，成本是 `n - c1`。

总成本是 `n + (n - c1) + ...`。

这个思路很复杂，因为木棍在不断变化。



##### 换个思考方法？- 合并切割后的块

我们不考虑如何“切”木棍，而是想象木棍已经被所有 `cuts` 位置完全切开了，变成了一系列有序的小木棍片段。

例如，对于 `n = 7`, `cuts = [1, 3, 4, 5]`，木棍已经被切成了 `[0,1], [1,3], [3,4], [4,5], [5,7]` 这几个片段。

我们的新任务是：将这些相邻的小片段一步步合并起来，最终拼回成一根完整的 `[0, 7]` 的木棍。

###### 合并成本: merge_cost([a,b],[b,c]) = c - a

每当你合并两个相邻的木棍片段时，例如合并 `[a, b]` 和 `[b, c]`，你需要付出一定的成本。这个**成本等于合并后新生成的木棍的长度**，即 `c - a`。

######**目标：找到一个合并顺序使得合并总成本最小** 

找到一个合并顺序，使得将所有小片段合并成一根完整木棍的**总成本最小**



#### 核心思想和套路 - 转化为简化板的堆石头问题

##### 构建切割后的木棍数组

我们通过`n`和`cuts`构建切割后的木棍长度数组。

##### 合并切割后的木棍数组的最小代价

通过预处理，我们已经将问题的“外衣”（切木棍）剥去，露出了它的核心——一个标准的**石子合并 (Stone Merging)** 问题。

假设我们要计算合并子数组 `sticks[i...j]` 的最小成本。无论我们如何合并，必然存在**最后一次合并**。

这次合并将一个已经合并好的左半部分 `sticks[i...k]` 和一个已经合并好的右半部分 `sticks[k+1...j]` 合并在一起。

- **最后一次合并的成本**：是这两个合并后的大块的总长度，也就是 `sum(sticks[i...j])`。

- **总成本**：`min_cost(i...j) = min_cost(i...k) + min_cost(k+1...j) + sum(sticks[i...j])`。

##### 利用前缀和来减低计算区间和的复杂度

从上面的分析可以看出来，我们在计算过程中需要频繁的计算数组的某个区间的元素和。

利用前缀和，可以将该类计算过程的复杂度从$O(N)$ 降低到 $O(1)$

#### 实现原理和步骤

1. 根据 `n` 和 `cuts`，生成有序的 `points` 数组 `[0, ...cuts..., n]`。

2. 根据 `points` 数组，生成 `sticks` 长度数组。`sticks[i] = points[i+1] - points[i]`。设 `sticks` 数组长度为 `m`。

3. 创建 `sticks` 数组的前缀和数组 `prefixSum`，长度为 `m+1`。

4. 创建一个二维DP数组 `dp[m][m]`。

5. `dp` 数组天然初始化为0，满足 `dp[i][i]=0` 的基本情况。

6. 遍历区间长度 `len`，从 2 到 `m`。

7. 对于每个 `len`，遍历起始点 `i`，从 `0` 到 `m-len`。

8. 计算终点 `j = i + len - 1`。

9. 初始化 `dp[i][j]` 为极大值。

10. 遍历分割点 `k`，从 `i` 到 `j-1`。

11. 使用前缀和计算当前区间的总长度 `sum = prefixSum[j+1] - prefixSum[i]`。

12. 根据状态转移方程更新 `dp[i][j]`：`dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum)`。

13. 所有循环结束后，`dp[0][m-1]` 就是最终答案。

#### 实现代码

```Java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Solution {
    public int minCost(int n, int[] cuts) {
        // 优化点1：使用更简洁的方式生成初始 sticks 数组
        List<Integer> points = new ArrayList<>();
        points.add(0);
        points.add(n);
        for (int cut : cuts) {
            points.add(cut);
        }
        Collections.sort(points);

        int stickCount = points.size() - 1;
        int[] sticks = new int[stickCount];
        for (int i = 0; i < stickCount; i++) {
            sticks[i] = points.get(i + 1) - points.get(i);
        }

        // 关键修正1：prefixSum 数组大小基于 stickCount
        int[] prefixSum = new int[stickCount + 1];
        for (int i = 0; i < stickCount; i++) {
            prefixSum[i + 1] = prefixSum[i] + sticks[i];
        }

        // dp[i][j] 表示合并 sticks 数组中 [i..j] 区间所需最小代价
        // 关键修正2：dp 数组大小基于 stickCount
        int[][] dp = new int[stickCount][stickCount];
        // java 中 int 数组默认初始化为 0, dp[i][i]=0 的基本情况已满足

        // DP 核心逻辑 (您的这部分逻辑是完全正确的)
        for (int len = 2; len <= stickCount; len++) {
            for (int start = 0; start <= stickCount - len; start++) {
                int end = start + len - 1;
                dp[start][end] = Integer.MAX_VALUE;

                // 当前合并区间的总长度，作为本次合并的成本
                int cost = prefixSum[end + 1] - prefixSum[start];

                for (int k = start; k < end; k++) {
                    dp[start][end] = Math.min(dp[start][end], dp[start][k] + dp[k + 1][end] + cost);
                }
            }
        }

        return dp[0][stickCount - 1];
    }
}
```

#### 注意事项

**索引对齐**: `dp` 数组的索引 `i, j, k` 和 `sticks` 数组的索引是一致的。而前缀和数组 `prefixSum` 的索引有一个偏移，需要注意。

**DP状态的微小差异**: 在之前的 `points` 解法中，`dp[i][j]` 表示处理 `points[i]` 到 `points[j]` 的区间。在这里，`dp[i][j]` 表示处理 `sticks` 数组的子数组 `sticks[i...j]`。虽然最终结果等价，但理解其索引含义很重要。

**循环边界**: 区间DP的循环边界很容易出错。这里的 `len` 从2到`m`，`i` 从`0`到`m-len`，`j` 由`i, len`确定，`k` 从`i`到`j-1`，这是石子合并模型的标准写法。

#### 经验总结

**抽象的力量**: 您提出的这个思路是问题抽象能力的一个绝佳体现。它成功地将一个带有特定背景（切木棍）的问题，转化为了一个纯粹的、更具普适性的数学模型（石子合并）。在算法竞赛和工程中，这种能力至关重要。

**预处理的重要性**: 很多复杂问题的突破口在于第一步的预处理。通过对输入数据进行排序、转换或计算辅助数据（如前缀和），可以极大地简化后续核心算法的逻辑。

**识别核心模型**: 能够识别出问题的本质属于某个经典模型（如图论、背包、区间DP等），是经验积累的结果。一旦识别成功，就可以直接套用成熟的、最优的解决方案，事半功倍。您的思路正是这样一个识别过程。



### LC 375. Guess Number Higher or Lower II (Medium)

#### 问题要点

**游戏规则**: 从 1 到 n 中选择一个秘密数字。你来猜。

**反馈**: 每次你猜错，会告诉你秘密数字是比你猜的「大」还是「小」。

**代价**: 每当你猜错一个数字 `x`，你需要支付 `x` 元。猜对则游戏结束，不用付钱。

**目标**: 给定一个 `n`，你需要找到一种策略，无论对方选择 1 到 n 中的哪个数字作为秘密数字，你都能保证获胜，并且在这种保证获胜的前提下，你支付的**总金额的最大值**是所有策略中**最小**的。

**返回值**: 返回这个 "最小的最大金额"。

#### 问题本质和分析

让我们用小一点的 `n` 来推导：

- `n=1`: 不用猜，代价 $0。

- `n=2` (范围 `[1, 2]`): 只能猜 `1`。

  如果秘密是 `2`，支付 1，游戏结束。最大代价 1。=> $cost([1...2]) = 1$

- `n=3` (范围 `[1, 3]`):

  - 猜 `1`: 如果错了，数字是 `[2, 3]`。代价 $1+cost([2..3])=1+2=3$。
  - 猜 `2`: 如果错了，数字是 `1` 或 `3`。最坏情况是 $2+max(cost([1...1]),cost([3...3]))=2+max(0,0)=2$。
  - 猜 `3`: 对称于猜 `1`，代价很高。如果猜错了代价是: $3 + cost([1...2]) = 4$
  - 所以，最优策略是猜 `2`，最坏代价是 $2。

- `n=4`，范围`[1...4]`
  - 猜 `1`: 最坏代价 $1+cost([2...4])$。
  - 猜 `2`: 最坏代价 $2+max(cost([1...1]),cost([3..4]))=2+max(0,3)=5$。(cost([3,4])是3)
  - 猜 `3`: 最坏代价 $3+max(cost([1,2]),cost([4,4]))=3+max(1,0)=4$。
  - 猜 `4`: 最坏代价 $4+cost([1,3])=4+2=6$。
  - 比较所有选择，最小的最大代价是 4 (通过先猜 `3`)。

我们发现，计算一个大范围的代价，需要依赖于它所有子范围的代价。

例如，计算 `cost([1,4])` 需要 `cost([2,4])`, `cost([1,1])`, `cost([3,4])`, `cost([1,2])`, `cost([1,3])`。这具有明显的**最优子结构**和**重叠子问题**特性。

#### 模式和套路匹配 - 区间DP

##### **状态定义**: `dp[i][j]` - 数字范围 `[i, j]` 内保证获胜所需的最小花费

我们的最终目标是 `dp[1][n]`。

##### **状态转移方程**:

为了计算 `dp[i][j]`，我们可以尝试在 `[i, j]` 中选择任意一个数 `k` 作为第一次猜测。

- 猜测 `k` 的成本是 `k` (如果猜错)。

- 如果猜错，我们会进入两个子问题之一：`[i, k-1]` 或 `[k+1, j]`。

- 对手会让游戏进入代价更高的那个子问题，所以后续的代价是 `max(dp[i][k-1], dp[k+1][j])`。

- 因此，选择 `k` 的总代价是 `k + max(dp[i][k-1], dp[k+1][j])`。

- 我们需要在所有可能的 `k`（从 `i` 到 `j`）中选择一个，使得这个总代价最小。

- 所以状态转移方程为：

  $$dp[i][j] = min_{i\le k \lt j}(k + max(dp[i][k-1],dp[k+1][j]))$$

#####**基本情况 (Base Case)**:

- 当 `i >= j` 时，范围内没有数字或只有一个数字，无需猜测或第一次就猜中，代价为 `0`。所以 `dp[i][i] = 0`。

#### 实现原理和步骤

1. **初始化**: 创建一个 `(n+1) x (n+1)` 的二维数组 `dp`。所有值默认为 0。`dp[i][i]` 天然为 0，满足基本情况。

2. **遍历顺序**: DP的计算依赖于小区间的解。因此，我们必须按**区间长度**从小到大进行遍历。

   - 外层循环 `len` 从 2 到 `n` (区间长度)。
   - 中层循环 `i` 从 1 到 `n - len + 1` (区间起点)。
   - 通过 `len` 和 `i` 计算出区间终点 `j = i + len - 1`。

3. **状态转移**:

   - 对于每个区间 `[i, j]`，初始化 `dp[i][j]` 为一个极大值（例如 `Integer.MAX_VALUE`）。

   - 内层循环 `k` 从 `i` 到 `j` (遍历猜测的数字)。

   - 对于每个 `k`，计算代价 `costForK = k + Math.max(dp[i][k-1], dp[k+1][j])`。

     注意边界：如果 `k=i`，左边区间为空，`dp[i][i-1]` 应视为 0；如果 `k=j`，右边区间为空，`dp[j+1][j]` 也应视为 0。

   - 更新 `dp[i][j] = Math.min(dp[i][j], costForK)`。

4. **返回结果**: 循环结束后，`dp[1][n]` 就是我们要求的最终答案。

#### 实现代码

```Java
class Solution {
    public int getMoneyAmount(int n) {
        //dp[i][j] 合并区间[i,j]所需要最小成本
        int[][] dp = new int[n+1][n+1];

        for(int len = 2; len <= n; len++){
            for(int start = 1; start <= n - len + 1; start++){
                int end = start + len - 1;
                dp[start][end] = Integer.MAX_VALUE;
                for(int k = start; k <= end; k++){
                    int leftCost = (k > start)? dp[start][k-1] : 0;
                    int rightCost = (k < end) ? dp[k+1][end] : 0;
                    dp[start][end] = Math.min(dp[start][end], k+ Math.max(leftCost, rightCost));
                }
            }
        }

        return dp[1][n];
    }
}
```

#### 注意事项

**P 数组大小**: 注意数组大小要开到 `n+1`，因为数字范围是 `1` 到 `n`，这样数组下标可以直接对应数字。

**循环顺序**: 必须是先遍历长度 `len`，再遍历起点 `i`。这是区间DP的典型遍历方式，保证在计算 `dp[i][j]` 时，所有比它短的子区间 `dp[i][k-1]` 和 `dp[k+1][j]` 都已经被计算出来了。

**k 的选择**: 循环中 `k` 的范围是从 `i` 到 `j`。有些优化会尝试缩小 `k` 的范围（例如从 `(i+j)/2` 开始），因为最优解通常不会在区间的两端，但这会使代码变复杂，对于本题的数据范围，完整的 `i` 到 `j` 遍历是完全可以接受的。

**理解 Minimax**: 再次强调，`max` 是因为对手会把你逼到最坏的分支，`min` 是因为你要选择一个最好的猜测点来最小化这个最坏的代价。

#### 经验总结

**识别模式**: 遇到“保证获胜”、“最小化最大损失/成本”这类字眼，要立刻联想到 **Minimax** 思想。

**转化问题**: Minimax 问题通常可以通过**递归 + 记忆化搜索**或者**动态规划**来解决。如果问题可以被划分为重叠的子问题，DP 是一个非常高效的方法。

**区间 DP 套路**:

- 状态定义：`dp[i][j]` 通常代表处理区间 `[i, j]` 的最优解。
- 状态转移：通常涉及枚举区间 `[i, j]` 的一个分割点 `k`，然后结合子区间 `dp[i][k-1]` 和 `dp[k+1][j]` 的结果来更新 `dp[i][j]`。
- 遍历方式：总是按区间长度从小到大进行迭代。

###LC 546. Remove Boxes (Hard)[高频题目]

#### 问题要点

给定一个由数字（代表不同颜色的盒子）组成的数组 `boxes`。你可以分多轮移除盒子，每一轮的操作规则如下：

- 选择**连续**的 `k` (k >= 1) 个相同颜色的盒子。
- 移除它们，并获得 `k*k` 的分数。
- 移除后，左右两边的盒子（如果存在）会合并在一起。

你的目标是找到一个最优的移除顺序，使得最终获得的总分数最高。

**示例:** `boxes = [1, 3, 2, 2, 2, 3, 4, 3, 1]` 输出: `23`

**解释:** 一种最优的移除策略是：

1. `[1, 3, 2, 2, 2, 3, 4, 3, 1]` -> 移除中间的三个 `2`，得到 `3*3 = 9` 分。数组变为 `[1, 3, 3, 4, 3, 1]`。
2. `[1, 3, 3, 4, 3, 1]` -> 移除中间的一个 `4`，得到 `1*1 = 1` 分。数组变为 `[1, 3, 3, 3, 1]`。
3. `[1, 3, 3, 3, 1]` -> 移除三个 `3`，得到 `3*3 = 9` 分。数组变为 `[1, 1]`。
4. `[1, 1]` -> 移除两个 `1`，得到 `2*2 = 4` 分。数组变为空。

总分 = `9 + 1 + 9 + 4 = 23`。

#### 问题的本质和分析

##### 贪心算法可行吗？（每次从头开始移除颜色相同的盒子）

初看此题，可能会想到贪心策略，比如每次都移除最长的一段连续同色盒子。

但通过反例 `[1, 2, 1, 2, 1]` 我们可以轻易证伪。

如果先移除中间的 `1`，得 `1` 分，数组变为 `[1, 2, 2, 1]`，再移除两个 `2` 得 `4` 分，再移除两个 `1` 得 `4` 分，总分 `9`。

而如果先移除三个 `1`（通过先移除中间的 `2`），总分会更高。

##### 当前的最优决策依赖于未来的状态

这揭示了问题的核心难点：**当前的最优决策依赖于未来的状态**。

移除一段盒子后，可能会让原本不相邻的同色盒子变得相邻，从而在未来形成更长的可移除序列，获得更高的平方收益。

这种前后状态的依赖性，以及求解最优解的特性，强烈暗示了**动态规划 (Dynamic Programming)** 是解决此问题的正确方向。

#### 规律观察

这是一个典型的**区间DP (Interval DP)** 问题，因为我们通常需要求解一个子区间 `[i, j]` 的最优解。

然而，标准的区间DP `dp[i][j]`（表示移除区间 `[i, j]` 的最大得分）在这里是不够的。

因为子问题的解并非完全独立。



考虑 `boxes[i...j]`，我们移除 `boxes[j]` 时，其得分不仅取决于 `boxes[j]` 左侧有多少个连续的同色盒子，还可能取决于 `boxes[j]` 右侧的同色盒子。

但由于移除操作，`boxes[j]` 右侧的盒子在原数组中的位置是变化的，这使得状态难以定义。

为了解决这个问题，我们需要引入一个额外的维度来记录**与当前子问题相关的、未来可能合并的同色盒子数量**。

#### 核心思想和套路

##### 定义一个更强大的DP状态

我们定义一个三维DP状态（通常使用记忆化搜索实现），这也是解决本题的精髓所在：

```
dp[l][r][k]
```

- `l`: 子数组的左边界索引。
- `r`: 子数组的右边界索引。
- `k`: 在`boxes[r]`右侧，已经有多少个与`boxes[r]`颜色相同的盒子。

`dp[l][r][k]` 的含义是：**求解子数组 `boxes[l...r]`，加上其后紧跟着的 `k` 个与 `boxes[r]` 颜色相同的盒子，所能获得的最大分数**。

**在数组 `boxes` 的子区间 `[l, r]` 上，加上在 `boxes[r]` 这个元素的右边，还额外跟着 `k` 个与 `boxes[r]` 颜色相同的盒子时，我们能获得的最大分数。**

让我们逐个拆解这三个参数：

- **`l` (left)**: 你当前正在考虑的子数组的 **左边界** 索引。

- **`r` (right)**: 你当前正在考虑的子数组的 **右边界** 索引。

- **`k` (k-additional boxes)**: 一个至关重要的 **附加信息**。

  它代表在子数组 `boxes[l...r]` 的外部，紧挨着 `boxes[r]` 的右侧，有多少个盒子的颜色与 `boxes[r]` 相同。

  这些盒子是“虚拟”的，它们来自于原数组中其他位置，但在未来的某个时刻，通过移除它们之间的障碍，将会与 `boxes[r]` 合并。

###### 为什么需要第三个维度k?

如果只有 `dp[l][r]`，我们无法解决这个问题。因为 `boxes[l...r]` 这个子问题的最优解，会受到其外部环境的影响。

一个具体的例子来理解 `dp[l][r][k]`

假设 `boxes = [1, 3, 2, 2, 2, 3, 4, 3, 1]` 我们来分析 `dp[1][5][1]` 的含义：

- `l = 1`, `r = 5` -> 子数组是 `boxes[1...5]`，即 `[3, 2, 2, 2, 3]`。
- `k = 1` -> 在 `boxes[5]`（也就是那个值为3的盒子）的右边，还额外跟着 **1个** 颜色也是3的盒子。这个额外的盒子可能来自原数组的 `boxes[7]`。



例如，对于 `[1, 3, 2, 2, 2, 3, 4, 3, 1]`，如果我们要求解 `dp[2][5][2]`，其中 `boxes[2...5]` 是 `[2, 2, 2, 3]`，`boxes[5]` 是 `3`，那么 `k=2` 就意味着在 `boxes[5]` (即 `3`) 的右边还有2个 `3` 待合并。

##### 状态转移方程

对于 `solve(l, r, k)`，我们主要考虑如何处理 `boxes[r]` 和它后面跟着的 `k` 个同色盒子。

首先，我们可以先将 `boxes[r]` 左侧所有与之颜色相同的连续盒子合并，这样可以简化问题。

例如，如果 `boxes` 是 `[..., 3, 3, 3]` 且我们正在处理最右边的 `3`，那么我们可以直接将这三个 `3` 视为一个整体。假设处理后，`boxes[r]` 的右侧有 `k` 个，加上 `boxes[r]` 本身以及它左侧的连续同色部分，总共有 `count` 个。

此时： 我们面临两个选择：

###### 决策1：直接移除

- 我们直接移除 `boxes[r]` 和它后面跟着的 `k` 个同色盒子。这 `k+1` 个盒子（经过预处理后可能是更多）组成了一个连续段。
- 得分为 `(k+1) * (k+1)`。
- 剩下的问题是求解子问题 `solve(l, r-1, 0)`。注意，因为 `boxes[r]` 被移除了，所以对于子问题 `boxes[l...r-1]` 来说，`boxes[r-1]` 右侧已经没有同色盒子可以合并了，所以第三个参数是 `0`。
- **总分 = `solve(l, r-1, 0) + (k+1)\*(k+1)`**

###### 决策2：寻找合并机会

- 我们不立即移除 `boxes[r]`，而是尝试在 `boxes[l...r-1]` 区间内寻找一个 `boxes[m]` (其中 `l <= m < r`)，使得 `boxes[m] == boxes[r]`。
- 如果找到了这样的 `m`，我们可以先想办法**移除**中间的子数组 `boxes[m+1...r-1]`。
- 移除中间部分后，`boxes[m]` 就会和 `boxes[r]` 相邻。这样，原本跟在 `boxes[r]` 后面的 `k+1` 个同色盒子就可以和 `boxes[m]` 结合起来。
- 这个策略的得分可以分解为两个独立子问题的和：
  1. 移除 `boxes[m+1...r-1]` 的最大得分，即 `solve(m+1, r-1, 0)`。
  2. 处理 `boxes[l...m]`，此时 `boxes[m]` 的右侧跟了 `k+1` 个同色盒子（来自`boxes[r]`及其后续），所以问题变为 `solve(l, m, k+1)`。
- **总分 = `solve(l, m, k+1) + solve(m+1, r-1, 0)`**

我们需要遍历所有可能的 `m`，并在这所有可能的合并策略与“直接移除”策略中，取一个最大值作为 `dp[l][r][k]` 的最终结果。

#### 实现原理和步骤

使用**自顶向下 (Top-Down)** 的记忆化搜索来实现上述逻辑是最直观的。

1. **主函数 `removeBoxes(boxes)`**：
   - 获取数组长度 `n`。
   - 创建一个三维数组 `dp[n][n][n]` 并初始化为0（或-1），用于记忆化。
   - 调用核心递归函数 `solve(boxes, 0, n-1, 0, dp)` 并返回结果。
2. **递归函数 `solve(boxes, l, r, k, dp)`**：
   - **Base Case**: 如果 `l > r`，说明子数组为空，返回 `0`。
   - **Memoization Check**: 如果 `dp[l][r][k]` 已经计算过（不为初始值），直接返回结果。
   - **预处理**: 从 `r` 向左扫描，将所有与 `boxes[r]` 颜色相同的连续盒子都计入，更新 `r` 的位置和 `k` 的值。例如，`[...1, 2, 2, 2]` 处理 `r` 在末尾时，新的 `r` 会指向 `1`，`k` 会增加 `2`。
   - **计算决策1**: 计算直接移除 `boxes[r]` 及其同色序列的分数：`res = solve(boxes, l, r-1, 0, dp) + (k+1)*(k+1)`。
   - **计算决策2**: 遍历 `m` from `l` to `r-1`：
     - 如果 `boxes[m] == boxes[r]`，计算合并分数：`solve(boxes, l, m, k+1, dp) + solve(boxes, m+1, r-1, 0, dp)`。
     - 用这个分数更新 `res` 的最大值：`res = max(res, ...)`。
   - **存储并返回**: 将计算出的最大值 `res`存入 `dp[l][r][k]`，然后返回。

#### 实现代码

```Java
public class Solution {
    public int removeBoxes(int[] boxes) {
        int n = boxes.length;
        // dp[l][r][k] stores the max score for boxes[l...r] with k boxes of the same color as boxes[r] to its right
        int[][][] dp = new int[n][n][n];
        return solve(boxes, 0, n - 1, 0, dp);
    }

    private int solve(int[] boxes, int l, int r, int k, int[][][] dp) {
        // Base case: no boxes left
        if (l > r) {
            return 0;
        }

        // Check memoization table
        if (dp[l][r][k] != 0) {
            return dp[l][r][k];
        }

        // --- Pre-processing Step ---
        // Group boxes[r] with its left-side continuous same-colored boxes
        int original_r = r;
        int original_k = k;
        while (r > l && boxes[r] == boxes[r - 1]) {
            r--;
            k++;
        }

        // --- Decision 1: Remove the group ending at r ---
        // Score from removing boxes[r...original_r] and the k boxes that followed
        // The number of boxes in this group is (original_r - r + 1) + original_k = (r - 1 - r + 1) + k + 1 = k + 1
        int res = solve(boxes, l, r - 1, 0, dp) + (k + 1) * (k + 1);

        // --- Decision 2: Look for merge opportunities ---
        for (int m = l; m < r; m++) {
            // If we find a box with the same color, we can try to merge it
            if (boxes[m] == boxes[r]) {
                res = Math.max(res,
                        // First, solve for the middle part
                        solve(boxes, m + 1, r - 1, 0, dp) +
                        // Then, solve for the left part, now with more boxes to merge
                        solve(boxes, l, m, k + 1, dp));
            }
        }
        
        // Store the result in the memoization table.
        // Note: We use original_r and original_k as the key because the subproblem was defined by them.
        return dp[l][original_r][original_k] = res;
    }
}
```

#### 注意事项

- **状态定义的精确性**: `dp[l][r][k]` 中 `k` 的定义至关重要，它必须捕获到子问题之外但又与之相关的信息，这是解决此题的钥匙。
- **边界条件**: 确保递归的 base case (`l > r`) 正确处理。
- **记忆化**: 如果不使用记忆化，暴力递归的时间复杂度会是指数级的，无法通过。`dp` 数组是性能的关键。
- **空间复杂度**: `dp` 数组的大小是 O(n³)，对于 n <= 100 是可行的。
- **预处理的优化**: 在递归函数开始时，将 `r` 左边的连续同色盒子先进行合并计算，可以减少递归的深度和重复计算，是常见的优化手段。

#### 经验总结 (Lessons Learned)

- **识别动态规划的信号**: 当问题要求最优解，且当前选择会影响未来状态时，应高度怀疑是DP问题。
- **标准DP模型的扩展**: 不要局限于标准的 `dp[i]` 或 `dp[i][j]`。当子问题不完全独立时，思考需要添加哪些额外维度来“封装”子问题之间的依赖关系。
- **自顶向下 vs. 自底向上**: 对于状态转移比较复杂、依赖关系不那么线性的DP问题，记忆化搜索（自顶向下）往往比迭代法（自底向上）更容易思考和实现。
- **化繁为简**: 通过预处理（如合并连续同色块）可以简化状态转移的逻辑，让代码更清晰。

### 子类型二： 消除/选择区间中的元素 - 逆向思考

当正向思考（第一步做什么）会破坏子问题独立性时，就需要这种强大的逆向思维模式。

#### 场景 + 目标：数组中消除/选择元素的最优代价

- **场景**：输入也是一个线性数组。操作通常是“消除”或“选择”区间中的某个元素，该操作的得分/代价与它当前的“邻居”有关。
- **目标**：寻找一个最优的消除/选择顺序，使得总得分/总代价最大或最小。
- **典型例子**：戳气球 (LC 312)、奇怪的打印机 (LC 664)。

#### 问题本质和分析： 最后一个戳破的应该是哪个气球？

**本质**：正向思考的困境与逆向思考的突破。

##### 正向思考的问题 - 先戳破哪个气球？

以戳气球为例，如果我们思考在区间 `[i, j]` 中 **第一个** 戳破气球 `k`，那么 `k` 消失后，`k-1` 和 `k+1` 就变成了邻居。

这导致子问题 `[i, k-1]` 和 `[k+1, j]` 之间产生了新的关联，它们不再是**独立的子问题**，DP的前提被破坏。

##### **逆向突破**：最后戳破哪个气球？

我们换个角度，思考在 **开区间 `(i, j)`** 中 **最后一个** 被戳破的气球是 `k`。

当 `k` 是最后一个被戳时，它的邻居必然是 `i` 和 `j`（因为中间的都已消失）。

戳破它的代价就是 `nums[i] * nums[k] * nums[j]`。在 `k` 被戳破之前，`(i, k)` 和 `(k, j)` 这两个区间内的所有气球已经被戳完了，并且这两个过程是 **完全独立、互不干扰** 的。问题被完美地分解。

#### 核心思想和套路

##### **状态定义**：`dp[i][j]`表示戳破`i`和`j`之间的所有气球的最大获利

`dp[i][j]` 表示消除/处理 **开区间 `(i, j)`** 或闭区间 `[i, j]` 内所有元素的最优解。

使用开区间定义在某些问题中（如戳气球）更自然。

#####**预处理**：添加虚拟边界

通常需要在数组两端添加“哨兵”或“虚拟边界”，以方便处理边界情况下的代价计算。

##### **Base Case**：`dp[i][i+1] = 0`。

对于开区间 `(i, i+1)`，内部没有元素，代价为0。

##### **遍历顺序**：区间长度/每个区间/区间内的每个元素

与相邻合并模型完全相同，依然是按区间长度 `len` 递增。

#####**状态转移方程**：

 `dp[i][j] = min/max ( dp[i][k] + dp[k][j] + cost_of_last_operation(i, k, j) )` 其中 `k` 是 `(i, j)` 内的最后一个操作点。

###Leetcode 312:戳气球（困难）


 有 `n` 个气球，编号从 `0` 到 `n - 1`，每个气球上都标有一个数字。你可以选择一个气球戳破，获得的金币数量为 `nums[i - 1] * nums[i] * nums[i + 1]`，其中 `i` 是当前戳破气球的下标。**注意：气球戳破后会从数组中移除，左右相邻气球变为相邻。**

返回可以获得的最大金币数。

##### 问题分析和本质

这是一个**区间类动态规划问题**，核心难点在于：

- 戳破顺序影响积分
- 每次戳破气球都会改变剩下的结构，导致暴力解法时间复杂度非常高

###### 关键转化思路-谁是最后一个被戳破的？

不考虑第一个戳破谁，而是考虑**最后一个戳破谁**

即假设最后区间内只剩下了`[i,k,j]`三个气球时，戳破K得时候会获得多少金币？

这可以保证：当你戳最后一个气球时，其左右气球位置时固定的，从而可以准确计算贡献。

##### 核心思想

- 使用**区间动态规划**，枚举每个区间`[i...j]`，设定最后一个戳破的气球`k`.
- 求解子问题，`dp[i][j]`表示戳破区间`[i...j]`内的所有气球（**不包括i和j**）可以获得的最大金币

为了处理边界问题，在原来数组两侧增加虚拟气球：`nums = [1]+nums+1`

##### 状态定义与初始化

###### 状态定义

`dp[i][j]`表示戳破`（i...j）`之间的气球(**不包含`i`和`j`**)能获得多少金币

###### 初始化

`dp[i][i+1]=0`：因为`i`和`i+1`中间没有可以戳破的气球

##### 遍历逻辑和状态转移方程

###### 遍历逻辑

- 区间长度枚举:从小区间逐步扩展
- 区间枚举：`i~j`表示当前区间

###### 状态转移方程

选定`k`作为最后一个戳破的气球，那么戳破的顺序就变成了：

- 戳破`(i...k)`之间的气球（不包含i和k）, 获得金币数量为`dp[i][k]`
- 戳破`(k...j）`之间的气球（不包含k和j），获得的金币数量为`dp[k][j]`
- 戳破气球`k`,所获得的金币数量为`nums[i]*nums[k]*nums[j]`

因此获得如下的状态转移方程：

```java
dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
```

##### 实现代码

```java
    public int maxCoins(int[] nums) {
       int n = nums.length;
       int[] points = new int[n+2];
       points[0] = 1;
       points[n+1]=1;

       for (int i=0;i<n;i++){
        points[i+1] = nums[i];
       }

       int dp[][] = new int[n+2][n+2];
				
       //注意区间的长度是从3开始遍历的，这个跟合并石头的问题是不一样的
       for (int length=3; length <=n+2; length++){
        int firstStart=0;
        int lastStart = n+2-length;

        for (int start=firstStart;start <= lastStart; start++){
            int end = start+length-1;
            for (int k = start+1; k< end; k++){
                dp[start][end] = Math.max(dp[start][end], 
                dp[start][k]+dp[k][end]+points[start]*points[k]*points[end]);
            }
        }
       }
       return dp[0][n+1];
    }
```

##### 注意事项

1. **加边界虚拟气球**（值为 1）是简化处理边界的关键。
2. `dp[i][j]` 表示的是**不包含 i 和 j**之间的气球最大得分。
3. 枚举区间时，要确保内层循环 `k` 在 `(i, j)` 之间，不能包含边界。
4. 区间遍历时长度要从小到大，确保子问题已经计算完成。

##### 经验总结

| 要点         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 动态规划类型 | 区间 DP                                                      |
| 状态设计难点 | 考虑**最后戳谁**而非**先戳谁**                               |
| 通用技巧     | 添加边界虚拟元素简化处理                                     |
| 子问题拆解   | `dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])` |
| 时间复杂度   | `O(n^3)`                                                     |
| 空间复杂度   | `O(n^2)`                                                     |

### LC 664. Strange Printer (Hard)

#### 问题描述

1. **目标**: 计算打印给定字符串 `s` 所需的 **最少** 打印次数。
2. **操作**:
   - 每次打印可以印出由 **同一个字符** 组成的任意长度的序列。
   - 打印可以 **覆盖** 纸上已有的字符。
3. **核心**: "覆盖" 操作是解题的关键。它允许我们将不同位置的相同字符通过一次打印操作完成，从而减少总次数。

#### 问题本质和分析 - 区间动态规划问题

这道题的本质是一个 **区间动态规划 (Interval Dynamic Programming)** 问题。

- **最优子结构**: 求解整个字符串 `s` 的最优解（最少打印次数），依赖于其子串 `s[i...j]` 的最优解。
- **重叠子问题**: 在计算不同区间的解时，可能会反复遇到并求解同一个更小的子区间。

例如，要解决打印 "abacaba" 的问题，我们可能需要先知道如何打印 "bac"、"aca" 等子串。

问题的难点在于如何通过状态转移方程来体现 **“覆盖”** 这一操作带来的优化。

一个朴素的想法是将区间 `[i, j]` 分割成 `[i, k]` 和 `[k+1, j]`，然后将二者的结果相加。

但这忽略了 `s[i]` 和 `s[j]` 可能相同，从而可以合并打印操作的可能性。



正确的分析思路是，当我们考虑打印区间 `s[i...j]` 时，我们以 `s[i]` 这个字符为基准。

这次打印操作，除了打印位置 `i` 之外，还可以“免费”地将区间内所有其他 `s[k] == s[i]` 的位置也覆盖上。

#### 规律观察

#####**连续相同字符是冗余的** - 可以进行压缩预处理: 

考虑字符串 `"aaabbc"`。

打印它和打印 `"abc"` 的最少次数是一样的。

因为任何一次打印 `"a"` 的操作，都可以一次性覆盖所有连续的 `'a'`。

这启发我们，可以先对字符串进行 **预处理**，将连续相同的字符压缩成一个。

- `"aaabbc"` -> `"abc"`
- `"aabbaaccaa"` -> `"abaca"`

##### 合并打印操作

考虑压缩后的字符串 `"abaca"`。`s[0]` 和 `s[2]`，`s[4]` 都是 `'a'`。

这意味着，打印 `s[0]` 的那次操作，可以延伸得足够长，把 `s[2]` 和 `s[4]` 的位置也打上 `'a'` 的“底色”。

这样，原本需要为 `s[2]` 和 `s[4]` 开始的打印操作就可以节省下来。

#### 模式套路匹配

这个问题完美匹配 **区间DP** 的模式。

**DP状态定义**: `dp[i][j]` 表示打印 **压缩后** 字符串 `t` 的子串 `t[i...j]` 所需的最少次数。

**目标**: 求解 `dp[0][n-1]`，其中 `n` 是压缩后字符串的长度。

**迭代方式**: 由小区间向大区间扩展。标准的写法是外层循环遍历区间长度 `len` (从1到n)，内层循环遍历区间的起始点 `i`。

#### 核心思想和套路：分治+动态规划

核心思想是基于 **分治** 和动态规划，通过寻找**合并点**来优化解。

对于区间`t[i...j]`:

##### 基础策略 - 先打印第一个字符

我们至少要打印 `t[i]` 这个字符。

我们可以先用一次操作打印它，然后去解决子问题 `t[i+1...j]`。

这提供了一个基础解（但不一定最优）：`1 + dp[i+1][j]`。

##### 优化策略

我们在 `(i, j]` 范围内寻找一个分割点 `k`，使得 `t[k] == t[i]`。

如果找到了，就意味着打印 `t[i]` 和 `t[k]` 的操作可以 **合并**。

这次合并的打印操作覆盖了 `t[i]` 和 `t[k]`。

整个问题 `t[i...j]` 就被 `k` 分割成了两个 **完全独立** 的子问题：

- 打印 `t[i...k-1]`

- 打印 `t[k+1...j]` 由于 `t[k]` 的打印任务已经被 `t[i]` 的操作顺带完成了，所以总次数就是这两个独立子问题的次数之和: `dp[i][k-1] + dp[k+1][j]`。

我们将基础策略的结果和所有可能的优化策略结果进行比较，取最小值。

##### 状态转移方程

![image-20251011201840599](/Users/tommy/Library/Application Support/typora-user-images/image-20251011201840599.png)



#### 实现原理和步骤

##### 预处理 - 压缩字符串

- 如果字符串为空，返回0。

- 创建一个 `StringBuilder`，将原字符串 `s` 中连续的字符压缩。

  例如，`"aaabbc"` 变为 `"abc"`。得到压缩后的字符串 `t`。

##### 初始化DP数组

- 获取 `t` 的长度 `n`。

- 创建一个 `n x n` 的二维数组 `dp`。

##### 遍历逻辑和状态转移

###### 循环逻辑 - 子串长度/每一个当前长度的子串

- 外层循环：`for (int len = 1; len <= n; len++)`

- 内层循环：`for (int i = 0; i <= n - len; i++)`

- 计算区间终点：`int j = i + len - 1;`

- **Base Case**: 如果 `len == 1` (`i == j`)，`dp[i][j] = 1`。

###### 状态转移方程

- **Base Case**: 如果 `len == 1` (`i == j`)，`dp[i][j] = 1`。
- 初始化 `dp[i][j]` 为基础解：`dp[i][j] = 1 + dp[i+1][j]`。
- 遍历 `k` 从 `i+1` 到 `j`, 因为我们的目的是找一个`t[k] == t[i]`的k。
- 如果 `t.charAt(k) == t.charAt(i)`，则找到了一个可以合并的 `k`。
- 计算合并后的代价 `cost = dp[i][k-1] + (k + 1 > j ? 0 : dp[k+1][j])`。
- 更新 `dp[i][j] = Math.min(dp[i][j], cost)`。

##### 返回结果： `dp[0][n-1]`。

**返回结果**: `dp[0][n-1]`。

#### 实现代码

```Java
class Solution {
    public int strangePrinter(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        // 1. 预处理：压缩字符串
        // 例如 "aaabbb" -> "ab", "aabbaa" -> "aba"
        StringBuilder sb = new StringBuilder();
        sb.append(s.charAt(0));
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) != s.charAt(i - 1)) {
                sb.append(s.charAt(i));
            }
        }
        String t = sb.toString();
        int n = t.length();

        // 2. 初始化 DP 数组
        // dp[i][j] 表示打印压缩后字符串 t[i...j] 的最少次数
        int[][] dp = new int[n][n];

        // 3. 动态规划计算
        // len 是区间的长度
        for (int len = 1; len <= n; len++) {
            // i 是区间的起始点
            for (int i = 0; i <= n - len; i++) {
                // j 是区间的结束点
                int j = i + len - 1;

                // Base Case: len = 1, 区间只有一个字符
                if (len == 1) {
                    dp[i][j] = 1;
                    continue;
                }

                // 状态转移:
                // a. 基础解：先打印 t[i]，再解决 t[i+1...j]
                dp[i][j] = 1 + dp[i+1][j];

                // b. 寻找优化：寻找 k 使得 t[k] == t[i]
                for (int k = i + 1; k <= j; k++) {
                    if (t.charAt(k) == t.charAt(i)) {
                        // 如果 t[k] == t[i]，打印 t[i] 和 t[k] 的操作可以合并
                        // 问题分解为打印 t[i...k-1] 和 t[k+1...j]
                        int part1 = dp[i][k - 1];
                        int part2 = (k + 1 > j) ? 0 : dp[k + 1][j]; // 注意边界
                        dp[i][j] = Math.min(dp[i][j], part1 + part2);
                    }
                }
            }
        }

        // 4. 返回结果
        return dp[0][n - 1];
    }
}
```

#### 注意事项

##### 字符串压缩的重要性

预处理不仅是优化，更是对问题本质的简化。它消除了 `t[i] == t[i+1]` 这种平凡情况的干扰，让状态转移聚焦于核心难点。

##### DP循环顺序

区间DP必须保证在计算 `dp[i][j]` 时，所有比它更短的子区间（如 `dp[i+1][j]`, `dp[i][k-1]`）都已经计算完毕。因此，必须将区间长度 `len`作为最外层循环。

##### 边界条件

在 `dp[k+1][j]` 的状态转移中，当 `k` 等于 `j` 时，`k+1 > j`，此时右半部分为空串，其打印次数为0。需要妥善处理此边界。

#### 经验总结

**识别问题模式**: 遇到涉及子数组/子字符串的“最优解”问题，要立刻联想到动态规划，特别是区间DP。

**简化输入**: 在设计DP状态前，思考是否能对输入数据进行预处理或转换，以简化问题模型。本题的压缩字符串是典范。

**推导状态转移**: 这是DP问题的核心。可以从一个简单的基础解开始，然后思考问题的特殊性质（本题是“覆盖”）能带来哪些优化，从而找到更优的转移路径。

**用实例验证**: 对一个复杂的DP方程，用一个小例子（如"aba", "abac"）手动推演一遍DP表的填充过程，是验证其正确性的最佳方法。



### LC 1478. Allocate Mailboxes (Hard)

### LC 486. Predict the Winner

### LC 887. Super Egg Drop (Hard)

### 子题型三：字符串匹配/回文 (String Matching/Palindromes)

这是区间DP在字符串问题上的特化应用，其状态转移有非常鲜明的特征。

#### 场景 + 目标

- **场景**：输入是一个字符串 `s`。
- **目标**：通常是寻找与“回文”相关的最优属性。例如，计算最长回文子序列的长度、最少插入多少字符可以构成回文串等。
- **典型例子**：最长回文子序列 (LC 516)、最少插入次数 (LC 1312)。

#### 问题本质和分析 - 关注字符串中的首尾字符关系

**本质**：利用字符串问题中**首尾字符关系**的特性来分解问题。

**分析**：一个字符串区间 `s[i...j]` 是否具有某种性质（如回文），很大程度上取决于它的两个端点 `s[i]` 和 `s[j]`。

- **如果 `s[i] == s[j]`**：那么这两个字符就可以“配对”。

  问题通常可以化归为求解它们的内部子区间 `s[i+1...j-1]` 的性质。

  例如，`s[i...j]` 的最长回文子序列长度，就是 `s[i+1...j-1]` 的最长回文子序列长度 + 2。

- **如果 `s[i] != s[j]`**：那么这两个字符无法配对。

  问题的解通常来自于两个更小的子区间：要么放弃 `s[i]`，在 `s[i+1...j]` 中寻找解；

  要么放弃 `s[j]`，在 `s[i...j-1]` 中寻找解。我们从这两个子问题的解中取最优。

#### 核心思想和套路

##### **状态定义**：

`dp[i][j]` 表示字符串 `s` 的子串 `s[i...j]` 所具有的目标属性（如最长回文子序列长度）。

##### **Base Case**：`dp[i][i] = 1`

`dp[i][i] = 1`。单个字符是长度为1的回文。

##### **遍历顺序**：区间长度/当前长度的每个区间

```Java
for(int len = 2; lengths <= n; len++){
  for(int start = 0; start <= n - len; start ++){
    int end = start + len - 1;
    //...
  }
}
```



#####**状态转移方程**：

- `if (s.charAt(i) == s.charAt(j))`: `dp[i][j] = dp[i+1][j-1] + 2;`
- `else`: `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);`

#### 套路模板

```Java
//注意最长回文子序列，不是最长回文子串
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        //dp[i][j] 表示 s[i...j]之间的最长回文子序列长度
        int[][] dp = new int[n][n];
        for(int i = 0; i < n; i++){
            dp[i][i] = 1;
        }

        for(int len = 2; len <= n; len++){
            for(int start = 0; start <= n - len; start++){
                int end = start + len - 1;
                if(s.charAt(start) == s.charAt(end)){
                    dp[start][end] = 2 + dp[start+1][end-1];
                }else{
                    dp[start][end] = Math.max(dp[start+1][end], dp[start][end-1]);
                }
            }
        }

        return dp[0][n-1];
    }
}
```

###**LC 516. Longest Palindromic Subsequence (Medium)**

- **最经典的字符串区间DP**。`s[i] == s[j]` 时，长度加2并看内部；不等时，分别看 `[i+1, j]` 和 `[i, j-1]`。
- 详解看上面的解释

###**LC 1312. Minimum Insertion Steps to Make a String Palindrome (Hard)**

#### 核心思想： 总长度 - 最长回文子序列长度

所需要插入的字符的数量就是字符串本身的长度 - 最长回文子序列的长度，这一点应该尽量记住。

```Java
//给定一个字符串
//每一步你可以在任何一个位置插入一个字符
//观察规律
//找到最大子串，然后
class Solution {
    public int minInsertions(String s) {
        int maxPalindromeLen = longestPalindrome(s);
        return s.length() - maxPalindromeLen;
    }
    //使用最长回文子序列
    private int longestPalindrome(String s){
        int n = s.length();
        //dp[i][j]: whether s[i...j] is a palindrome
        int[][] dp = new int[n][n];
        for(int i = 0; i < n; i++){
            dp[i][i] = 1;
        }
        for(int len = 2; len <= n; len++){
            for(int start = 0; start <= n - len; start++){
                int end = start + len - 1;
                if(s.charAt(start) == s.charAt(end)){
                   dp[start][end] = dp[start+1][end-1] + 2;
                }else{
                  dp[start][end] = Math.max(dp[start+1][end], dp[start][end-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```



###**LC 5. Longest Palindromic Substring (Medium)**

- **DP是解法之一**。`dp[i][j]` 表示 `s[i...j]` 是否为回文串。虽然中心扩展法更优，但DP解法是区间DP的入门好题。

###**LC 647. Palindromic Substrings (Medium)**

- **与LC 5类似**。在计算 `dp[i][j]` 的过程中顺便计数即可。

  ```Java
  //给定一个字符串
  //返回其中回文串的数量
  //方法一：遍历所有的子串（暴力法）
  //方法二：动态规划
  //dp[i][j] 表示s[i...j]是否是一个回文串
  class Solution {
      public int countSubstrings(String s) {
          int count = 0;
          int n = s.length();
          //dp[i][j] s[i...j]是否是回文串
          boolean[][] dp = new boolean[n][n];
          //dp[i][j] 依赖于dp[i+1][j-1] && s[i] == s[j]
          //因此i需要倒序，j需要正序？
          for(int i = 0; i < n; i++){
              dp[i][i] = true;
              count++;
          }
  
          for(int len = 2; len <= n; len++){
              for(int start = 0; start <= n - len; start++){
                  int end = start + len - 1;
                  if(s.charAt(start) == s.charAt(end)){
                      //注意不要漏掉len==2情况
                      //这种情况下s[start] == s[end]就说明s[start...end]本身就是回文串
                      if(len == 2){
                          dp[start][end] = true;
                      }else{
                          //否则，如果s[start+1...end-1]也是回文串的话，则当前子串就是回文串
                          dp[start][end] = dp[start+1][end - 1];
                      }
                  }
                  if(dp[start][end]){
                      count++;
                  }
              }
          }
  
          return count;
      }
  }
  ```






###**LC 730. 统计不同的回文子序列数量 (Hard)**

- **LPS的计数难题**。状态转移变得复杂，需要根据 `s[i]` 和 `s[j]` 之间的字符情况进行精细的分类讨论和计数。

#### 问题要点

给定一个字符串 `S`，找出 `S` 中不同回文子序列的个数。

由于结果可能很大，需要对 $10^9+7$ 取模。

**核心约束:**

- 字符串 `S` 的长度在 1 到 1000 之间。
- `S` 只包含 'a', 'b', 'c', 'd' 四种小写字母。
- **"不同"** 的定义：只要子序列本身不相同就算不同。例如，对于 "aba"，子序列 "a" 可以由索引 0 或索引 2 得到，但它们只算作一个不同的回文子序列 "a"。

**例子:**

- **输入:** `S = "bccb"`
- **输出:** `6`
  - 回文子序列为: "b", "c", "bb", "cc", "bcb", "bccb"。
- **输入:** `S = "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"`
- **输出:** `104860361`
  - 说明结果会很大，必须使用模运算。

#### 问题的本质和分析 - 难点在于避免重复计数

这是一个 **计数类动态规划** 问题。

与最值问题不同，计数问题的核心难点在于 **如何避免重复计数**。

们自然会想到定义 `dp[i][j]` 为子串 `s[i...j]` 中不同回文子序列的数量。状态转移必须精确。

- 当 `s[i] != s[j]` 时，情况比较简单，可以使用容斥原理。

- 当 `s[i] == s[j]` 时，情况变得复杂。

  假设 `s[i] == s[j] == 'x'`。

  `s[i...j]` 中的回文子序列可以看作是基于 `s[i+1...j-1]` 中的回文子序列扩展而来的。

  扩展的方式是用 `s[i]` 和 `s[j]` (`'x'`) 将内部的回文包裹起来，形成 `x...x` 格式的新回文。

  但这种包裹会产生大量重复，比如 `s = "aaaa"`，简单的相加会重复计算 "a" 和 "aa"。

#### 规律观察和模式匹配

**区间动态规划:** 状态依然由区间 `[i, j]` 定义，依赖于更小的子区间，是标准的区间 DP。

**计数与去重:** 这是计数类 DP 的核心模式。

解决方案通常需要对导致重复的来源进行细致的分类讨论，并从总数中减去重复计算的部分。

#### 核心思想和套路

##### 状态定义：`dp[i][j]`:`s[i...j]`不同回文子序列的数量

`dp[i][j]` 表示子字符串 `s[i...j]` 中不同回文子序列的数量。

我们的目标是求`dp[0][n-1]`

##### 状态转移分析

###### 当`s[i] != s[j]`时：容斥原理

`s[i...j]` 中的回文要么来自 `s[i...j-1]`，要么来自 `s[i+1...j]`。

两者重叠的部分是 `s[i+1...j-1]`。

根据**容斥原理**： `dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]`



###### 当 `s[i] == s[j]` 时 - 需要分析`s[i+1...j-1]`中是否还有有`x`

我们假设`s[i] == s[j] == 'x'`。



**计算`s[i+1...j-1]`中的回文子序列数量的逻辑基础**

`s[i...j]` 中的回文子序列，源自于 `s[i+1...j-1]`，并额外增加了以 `'x'` 开头和结尾的新回文。

具体的说，这个时候`dp[i][j]`由三个部分组成：

- 原来`s[i+...j-1]`中的回文子序列数量，即`dp[i+1][j-1]`
- 原来的`s[i+1...j-1]`中的每个回文序列头尾加上`x`， 数量也是`dp[i+1][j-1]`
- `s[i]`和`s[j]`各自组成一个只有一个字符的回文序列
- `s[i]+s[j]`组成一个两个字符组成的回文序列

这样以来，来自`s[i+1...j-1]`的贡献就是$2\times {dp[i+1][j-1]}$。

但这样**可能会有重复**，我们需要根据内部 `s[i+1...j-1]` 中 `'x'` 的数量来修正。



**怎样排除重复计算的回文数量？**

我们令 `low = i + 1`, `high = j - 1`。

在 `s[low...high]` 中寻找 `'x'`：

- **情况 A: `s[low...high]` 中没有 `'x'`** 

  此时，`'x'` 和 `'xx'` 是全新的回文，不会与内部的任何回文重复。

   `dp[i][j] = 2 * dp[low][high] + 2`  (新增了 'x', 'xx')

- **情况 B: `s[low...high]` 中只有 1 个 `'x'`** 

  此时，`'x'` 已经在 `dp[low][high]` 中被计数。

  只有 `'xx'` 是全新的。

   `dp[i][j] = 2 * dp[low][high] + 1`  (只新增了 'xx')

- **情况 C: `s[low...high]` 中有 2 个或更多 `'x'`**

   此时，`'x'` 和 `'xx'` 都已经在 `dp[low][high]` 中被计数了。

   重复的部分源于：用最外层的 `s[i], s[j]` 包裹 `s[low...high]` 内部的一个回文 `p`，得到的 `"xpx"`，可能与 `dp[low][high]` 中已有的某个回文相同。 

  **这部分被重复计算的回文，恰好是夹在 `s[low...high]` 中最靠外侧的两个 `'x'` 之间的子串所能构成的回文数量**。

   我们假设 `s[low...high]` 中所发现的第一个 `'x'` 在 `next_i`，最后一个在 `prev_j`。 

  `dp[i][j] = 2 * dp[low][high] - dp[next_i + 1][prev_j - 1]`

#### 实现原理和步骤

##### **创建 DP 表:** 

初始化一个 `n x n` 的 `long` 类型二维数组 `dp`（防止中间计算溢出）。

##### **基础情况:** 

对所有 `i`，`dp[i][i] = 1`，因为单个字符是一个回文。

##### **确定遍历顺序:** 区间长度/每一个区间/区间内检查第一个和最后一个重复元素

同样按区间长度 `len` 从 2 到 `n` 遍历。

##### **填充 DP 表:** 

在循环内部，根据 `s[i]` 和 `s[j]` 是否相等，应用上面详细分析的状态转移方程。

如果相等，需要一个辅助循环或预处理来找到内部的 `next_i` 和 `prev_j`。

##### **处理模运算:** 

每一步加减法后都要进行模运算。对于减法，使用 `(a - b + mod) % mod` 来防止出现负数。

##### **返回结果:** 

返回 `(int)dp[0][n-1]`。

#### 实现代码

```Java
//统计不同的回文子序列的数量
//
//假设dp[i][j]表示s[i...j]有多少个回文子序列
//dp[i][j]和dp[]
class Solution {
    final int MOD = 1000000007;
    public int countPalindromicSubsequences(String s) {
        int n = s.length();
        long[][] dp = new long[n][n];
        Map<Character,List<Integer>> indexMap = new HashMap<>();

        for(int i = 0; i < n; i++){
            dp[i][i] = 1;
            char c = s.charAt(i);
            indexMap.putIfAbsent(c, new ArrayList<>());
            indexMap.get(c).add(i);
        }

        for(int len = 2; len <= n; len++){
            for(int start = 0; start <= n - len; start++){
                int end = start + len - 1;
                //当`s[i] != s[j]`时：容斥原理
                //`s[i...j]` 中的回文要么来自 `s[i...j-1]`，要么来自 `s[i+1...j]`。
                //者重叠的部分是 `s[i+1...j-1]`。
                //根据**容斥原理**： `dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]`
                if(s.charAt(start) != s.charAt(end)){
                    dp[start][end] = (dp[start + 1][end] + dp[start][end - 1] - dp[start+1][end-1] + MOD) % MOD;
                }else{
                    //在区间中寻找和头尾字符一样的字符的位置
                    char c = s.charAt(start);
                    List<Integer> indexes = new ArrayList<>();
                    for(int index: indexMap.get(c)){
                        if(index > start && index < end){
                            indexes.add(index);
                        }
                    }
                    //如果没有找到
                    //此时，`'x'` 和 `'xx'` 是全新的回文，不会与内部的任何回文重复。
                    if(indexes.isEmpty()){
                        dp[start][end] = (2 * dp[start+1][end-1] + 2) % MOD;
                    //如果只是找到一个
                    //此时，`'x'` 已经在 `dp[low][high]` 中被计数。
                    //只有 `'xx'` 是全新的
                    //dp[i][j] = 2 * dp[low][high] + 1
                    }else if(indexes.size() == 1){
                        dp[start][end] = (2 * dp[start+1][end - 1] + 1) % MOD;
                        // 此时，`'x'` 和 `'xx'` 都已经在 `dp[low][high]` 中被计数了。
                        // 重复的部分源于：用最外层的 `s[i], s[j]` 包裹 `s[low...high]` 内部的一个回文 `p`，得到的 `"xpx"`，可能与 `dp[low][high]` 中已有的某个回文相同。
                    }else{
                        //**这部分被重复计算的回文，恰好是夹在 `s[low...high]` 中最靠外侧的两个 `'x'` 之间的子串所能构成的回文数量**。
                        int first = indexes.get(0);
                        int last = indexes.get(indexes.size()-1);
                        dp[start][end] = (2 * dp[start+1][end-1] - dp[first+1][last-1] +MOD) % MOD;
                    }
                }
            }
        }
        return (int)(dp[0][n-1]);
    }

    
}
```

#### 注意事项

##### **模运算:** 

减法取模是最大的陷阱，务必使用 `(a - b + mod) % mod`。

##### **数据类型:** 

中间计算 `a+b` 可能超过 `Integer` 的范围，使用 `long` 数组是安全的做法。

##### **空子串:** 

当 `i+1 > j-1` 时，内部子串为空，其回文子序列数量为 0。代码中需要正确处理这种情况。

#### 经验总结

**计数 DP 的核心是去重:** 遇到计数类 DP，第一反应应该是“哪里会重复，如何去掉重复”。

**分类讨论是利器:** 当状态转移变得复杂时，根据问题的内在逻辑（本题是根据边界字符在内部的分布）进行精细的分类讨论，是化繁为简的有效手段。

**从实例中找规律:** 对于复杂的去重逻辑，可以手写几个关键例子（如 "aaaa", "abaca"）来推演，验证自己公式的正确性，并发现重复的来源。

**编码严谨性:** 计数类问题对细节要求极高，模运算、数据类型、边界条件等任何一个环节出错都可能导致结果错误。





## 区间调度型 - 不带容量限制

这是另一大族，输入是离散的区间集合。

代表题目有 **出租车的最大盈利(LC 2008)**、**最大盈利的职业规划(LC 1235)**。

### 场景 + 目标

- **场景**：输入是一个区间数组 `intervals`，每个区间有 `[start, end, value]`。
- **目标**：从中选择一个 **不重叠** 的子集，使得子集的总价值最大。

### 问题本质和分析 - 选择类动态规划问题

**本质**：对每一个区间，做“选”或“不选”的决策。

这是一个典型的选择类动态规划问题。

**分析**：为了让决策有序，避免复杂的依赖关系，必须 **排序**。

按 **结束时间 `end`** 排序是黄金法则。

当我们考虑第 `i` 个区间时，所有在它之前处理过的区间的 `end` 都小于等于它，这使得寻找“上一个可以兼容的区间”变得非常高效（可通过**二分查找**）。

### 解决方法和套路：排序 + 动态规划  + 二分查找

####将区间或者任务进行封装

**数据封装**：将 `start, end, value` 封装成一个对象或数组。

```Java
class Job {
    int startTime;
    int endTime;
    int profit;
    public Job(int startTime, int endTime, int profit){
        this.startTime = startTime;
        this.endTime = endTime;
        this.profit = profit;
    }
}
```

#### 将区间任务按照结束时间排序

**排序**：按 `end` 时间升序排序。

####**状态定义**：考虑前`i`个区间所能获得的最大值

`dp[i]` 表示考虑前 `i` 个区间（排序后）所能获得的最大价值。

####**遍历与转移**：选择或不选择当前任务

- `for (int i = 1; i <= n; i++)`

#####不选择当前任务：dp[i-1]

如果不选择任务，那么当前所有获得的最大价值就是`dp[i-1]`

- `// 决策1: 不选第 i 个区间`
- `profit1 = dp[i-1]`

#####选择当前任务: jobs[i-1].val + dp[j+1]

如果选择当前任务，那么我们就需要找到**上一个和当前任务不冲突的任务**，这个过程可以使用**二分查找实现**。

###### 利用二分查找寻找前一个不冲突的任务

找到第 i 个区间的 $start_i$ 之前，与之不冲突的最后一个区间 j:

```Java
    private int binarySearch(Job[] jobs, int i){
        int left = 0;
        int right = i - 1;
        int target = jobs[i].startTime;
        int ans = -1;

        while(left <= right){
            int mid = left + (right - left) / 2;
            if(jobs[mid].endTime <= target){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return ans;
    }
```



`j = binary_search(...)`

找到该前驱任务`j`之后，选择当前任务`jobs[i-1]`的最大利润就是 = 选择任务`j`的最大利润(`dp[j+1]`)+任务`jobs[i-1]`的利润(`jobs[i-1].profit`)

注意这里`dp[j+1]`并不代表一定是选择了任务`j`的最大利润，而是考虑前`j+1`个任务之后的最大利润。

#####选择获利较大的选项

- `dp[i] = max(profit1, profit2)`

**优化**：线性寻找 `j` 会使复杂度变为 $O(N^2)$，必须用 **二分查找** 优化到 O(N log N)。

### 代码套路模板

```Java
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n = profit.length;
        Job[] jobs = new Job[n];
        for(int i = 0; i < n; i++){
            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);
        }

        Arrays.sort(jobs,(job1,job2) -> job1.endTime - job2.endTime);
        //dp[i]表示考虑了前i个job之后的最大利润
        int[] dp = new int[n+1];

        for(int i = 1; i <= n; i++){
            //不考虑jobs[i-1]
            int profit1 = dp[i-1];
            //考虑jobs[i-1]
            int j = binarySearch(jobs, i-1);
            int profit2 = jobs[i-1].profit + (j == -1 ? 0 : dp[j+1]);

            dp[i] = Math.max(profit1, profit2);
        }

        return dp[n];
    }
```

### 注意事项

#### 排序标准 ： 按照`end`排序

务必理解为何按 `end` 排序。这是为了确保当我们决策 `i` 时，所有潜在的兼容区间 `j` 的DP值 `dp[j+1]` 已经是最优且最终的。

#### DP索引和数组索引的关系

`dp[i]` 对应 `jobs[i-1]`，二分查找和DP值获取时的索引转换要小心。

### Leetcode  1235: 最大盈利的兼职规划

见题目解释部分。

### Leetcode 646: 最长的对链

#### Key Points

You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.

A pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.

Return *the length longest chain which can be formed*.

You do not need to use up all the given intervals. You can select pairs in any order.

#### 核心思想和套路 - 标准套路

这个问题和题目中所描述的情况一致，属于标准套路的内容。

##### 区间按照终点排序

##### DP[i] - 考虑前i个区间的最大值

##### 状态转化方程

###### 选择区间`i-1`

###### 不选择区间`i-1`:利用二分查找查找上一个不冲突的区间

##### 最终结果

#### 代码实现

```Java
//给定n个区间 pair[i] = [left_i,right_i]
//如果p2.start > p1.end, 两个区间就可以形成一个链了
//返回所能够形成的最长的链
class Interval{
    int left;
    int right;
    public Interval(int left, int right){
        this.left = left;
        this.right = right;
    }
}
class Solution {
    public int findLongestChain(int[][] pairs) {
        int n = pairs.length;
        Interval[] intervals = new Interval[n];
        for(int i = 0; i < n; i++){
            intervals[i] = new Interval(pairs[i][0], pairs[i][1]);
        }

        Arrays.sort(intervals,(a,b) -> a.right - b.right);
        //dp[i] 表示前i个区间中所形成的最长的链的长度
        //对于当前的区间intervals[i-1]
        //不使用当前区间len1 = dp[i-1]
        //使用当前区间，就需要寻找上一个与当前区间不冲突的区间
        int[] dp = new int[n+1];
        Arrays.fill(dp, 1);
        dp[0] = 0;

        for(int i = 1; i <= n; i++){
            int len1 = dp[i-1];

            int j = binarySearch(intervals, i-1, intervals[i-1].left);
            int len2 = 1 + (j == -1 ? 0: dp[j+1]);

            dp[i] = Math.max(len1, len2);
        }

        return dp[n];
    }

    private int binarySearch(Interval[] intervals, int i, int target){
        int left = 0;
        int right = i - 1;
        int ans = -1;
        
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(intervals[mid].right < target){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return ans;
    }
}
```



### Leetcode 2008:出租车最大盈利

#### 问题要点

**输入**: 一个整数 `n` 代表一个从 1 到 `n` 的路径，以及一个二维数组 `rides`。

**`rides` 数组**: 每个元素 `rides[i] = [start_i, end_i, tip_i]` 代表一个乘车请求。

- `start_i`: 乘客上车点。
- `end_i`: 乘客下车点。
- `tip_i`: 这趟行程的小费。

**收益计算**: 一趟行程的收益为 `(end_i - start_i) + tip_i`。

**约束条件**:

- 司机从点 1 开始，并且初始没有乘客。
- 司机不能同时接两个重叠的行程。也就是说，如果司机接了 `[start, end, tip]` 的行程，他必须在 `end` 点之后才能开始新的行程。
- 司机可以空驶（不载客）。

**目标**: 计算司机从点 1 到点 `n` 所能获得的最大总收益。

#### 问题本质和分析 - 带选择的优化问题

##### 决策1:空驶

从点 `i-1` 空驶到点 `i`。这种情况下，在点 `i` 的收益等于在点 `i-1` 的最大收益。

##### 决策2: 完成一趟行车

如果在点 `i` 刚好有乘客下车，那么司机可以选择完成这趟行程。

假设这趟行程是从 `start` 开始的，那么在点 `i` 的收益就等于**在点 `start` 时的最大收益** 加上 **这趟行程本身的收益**。

由于在每个点的最优决策都依赖于它之前某些点的最优决策，这符合**动态规划 (Dynamic Programming, DP)** 的两个核心特征：**最优子结构** 和 **重叠子问题**。

- **最优子结构 (Optimal Substructure)**: 到达点 `i` 的最大收益，依赖于到达 `i` 之前所有点（如 `i-1` 和所有可能的 `start` 点）的最大收益。
- **重叠子问题 (Overlapping Subproblems)**: 在计算不同点的最大收益时，我们可能会多次需要查询同一个点的最大收益（例如，多个行程的起点都是同一个点）。

#### 规律观察

我们观察到，司机的状态只与他当前所在的位置有关。

我们可以定义一个状态 `dp[i]`，表示司机到达（或经过）点 `i` 时所能获得的最大收益。

为了计算 `dp[i]`，我们需要考虑所有可能到达点 `i` 的方式：

1. 从 `i-1` 空驶过来。此时收益为 `dp[i-1]`。

2. 完成了若干个以 `i` 为终点的行程。

   对于每一个终点为 `i`、起点为 `start` 的行程，其收益为 `dp[start] + (i - start + tip)`。

`dp[i]` 的值就是以上所有可能性中的最大值。这形成了一个清晰的状态转移关系。

#### 核心思想和套路

本题的核心思想是使用动态规划来构建从起点到终点的最优解。

##### 定义DP状态：`dp[i]` - 达点 `i` 时所能获得的最大累计收益。

`dp[i]` 表示司机到达点 `i` 时所能获得的最大累计收益。

##### 状态转移方程

对于每个位置 `i` (从 1 到 `n`)，我们有两种选择：

###### 不以`i`为终点结束行程

这种情况下，司机只是从 `i-1` 移动到 `i`，收益不变。

所以 `dp[i]` 的一个候选值是 `dp[i-1]`。

###### **以 `i` 为终点结束行程**：

我们检查所有终点为 `i` 的行程 `[start, i, tip]`。

对于每一个这样的行程，我们可以从 `start` 点接上乘客，然后在 `i` 点结束。

这样获得的收益是 `dp[start] + (i - start + tip)`。

结合这两种情况，`dp[i]` 的最终值是所有这些可能性的最大值：

$$dp[i]=max(dp[i−1],max(dp[start_j]+(end_j−start_j+tip_j))) \quad for\quad each\quad ride_j\quad ends\quad at\quad i$$

##### Base case 

`dp[0] = 0` (或者 `dp[1] = 0`，取决于你的数组索引，使用 `n+1` 大小的数组并从 `dp[1]` 开始计算会更直观)。

##### **最终答案 (Final Answer)**:

最终的答案是司机到达点 `n` 时的最大收益，即 `dp[n]`。

#### 实现原理和步骤

直接实现上述DP思路，如果每次计算 `dp[i]` 都遍历整个 `rides` 数组来查找终点为 `i` 的行程，效率会很低（`O(n * R)`，其中 `R` 是行程数量），可能会超时。

因此，需要一个**预处理**步骤来优化查找过程：

##### 将ride按照`end`分组

使用一个哈希表（`Map`）是理想的选择，其中 `key` 是终点，`value` 是一个列表，包含所有在该点结束的行程。

- `Map<Integer, List<int[]>> ridesByEnd = new HashMap<>();`
- 遍历 `rides` 数组，将每个 `ride` 放入其对应 `end` 点的列表中。

##### 初始化

创建一个 `long` 类型的 `dp` 数组，大小为 `n + 1`。使用 `long` 是为了防止收益总和溢出 `int` 的范围。

- `long[] dp = new long[n + 1];`

##### 动态规划计算

循环 `i` 从 1 到 `n`：

###### 继承前一个状态

首先假设在 `i` 点没有行程结束，那么最大收益就是从 `i-1` 过来的收益。

- `dp[i] = dp[i-1];`

###### 处理在`i`结束的行程

检查哈希表中是否存在以 `i` 为终点的行程列表。

`if (ridesByEnd.containsKey(i))`

###### 更新最大值

如果存在，遍历该列表中的每一个行程 `ride = [start, end, tip]`。

- 计算选择该行程的收益： `earnings = dp[start] + (end - start + tip);`
- 用这个新计算出的收益更新 `dp[i]`：`dp[i] = Math.max(dp[i], earnings);`

**返回结果**: 循环结束后，`dp[n]` 中存储的就是最终答案。

#### 实现代码

```Java
class Ride{
    int start;
    int end;
    int tip;
    public Ride(int start, int end, int tip){
        this.start = start;
        this.end = end;
        this.tip = tip;
    }
}
class Solution {
    public long maxTaxiEarnings(int n, int[][] rides) {
       Map<Integer, List<Ride>> ridesEndBy = new HashMap<>();
       for(int[] ride : rides){
        ridesEndBy.putIfAbsent(ride[1], new ArrayList<>());
        ridesEndBy.get(ride[1]).add(new Ride(ride[0], ride[1], ride[2]));
       }

       long[] dp = new long[n+1];

       for(int i = 1; i <= n; i++){
        dp[i] = dp[i-1];
        List<Ride> rideList = ridesEndBy.getOrDefault(i, new ArrayList<>());
        for(Ride ride : rideList){
            dp[i] = Math.max(dp[i], dp[ride.start] + ride.end - ride.start + ride.tip);
        }
       }
       return dp[n];
    }
}
```

#### 注意事项

**数据类型**: `n` 和 `rides` 的长度都可能达到 `10^5`，单次收益也可能很大。累加起来的总收益很容易超过 `Integer.MAX_VALUE`（约 `2 * 10^9`）。因此，`dp` 数组必须使用 `long` 类型，这是一个常见的陷阱。

**坐标与索引**: 题目的坐标是 1-based (从 1 到 `n`)。将 `dp` 数组大小设为 `n+1` 可以让 `dp[i]` 直接对应点 `i` 的状态，代码写起来更清晰，避免了繁琐的索引转换。

**时间复杂度**: 预处理 `rides` 数组需要 `O(R)` 时间，其中 `R` 是 `rides` 的数量。DP 计算的主循环是 `O(n)`，在循环内部，我们遍历所有以当前点 `i` 为终点的行程。由于每个行程只会被处理一次（在它的终点处），所以循环内部的总操作数是 `O(R)`。因此，总时间复杂度是 `O(n + R)`。

**空间复杂度**: `dp` 数组需要 `O(n)` 的空间。哈希表 `ridesByEnd` 需要存储所有行程的信息，所以需要 `O(R)` 的空间。总空间复杂度是 `O(n + R)`。

#### 经验总结

**识别DP模式**: 当问题要求在满足一定约束条件下的“最大/最小/总数”时，特别是当决策可以分解为一系列连续的步骤，且每一步的决策都依赖于之前的最优解时，应首先考虑动态规划。

**定义清晰的状态**: DP 问题的关键是定义一个能够完整描述子问题的状态。在本题中，`dp[i] = 到达点i的最大收益` 是一个非常自然且有效的状态定义。

**预处理的重要性**: 对于需要频繁查询特定条件的DP问题（例如本题中“查找所有在 `i` 点结束的行程”），通过预处理（如使用哈希表）将数据结构化，可以极大地优化状态转移的效率，是避免超时的关键。

**注意边界和数据范围**: 始终关注输入数据的范围，特别是可能导致整数溢出的情况，及时选择 `long` 等更大数据类型。同时处理好数组索引与问题坐标之间的对应关系。

## 区间调度问题 - 带容量限制

### 场景+目标：

- **场景**：输入是一个区间数组 `intervals`，每个区间有 `[start, end, value]`。
- **目标**：从中选择一个 **不重叠** 的子集，使得子集的总价值最大。
- **限制：**最多只能选择`k`个，这是与**不带容量限制的区间调度问题的核心区别**。

### 问题的本质 - 带限制的选择类动态规划问题

##### 加上限制以后同时具有0-1背包的特征

- 物品 ： 每一个事件
- 物品价值： 每一个事件的价值
- 物品重量：1
- 背包容量：k

和普通背包问题唯一的不同点是事件相互之间存在时间上的互斥关系。

选择了某个物品之后，其他有重叠的物品就不可选择。

##### 所保留的加权区间调度问题特征

对每一个区间，做“选”或“不选”的决策。

这是一个典型的选择类动态规划问题。

**分析**：为了让决策有序，避免复杂的依赖关系，必须 **排序**。

但是与不带限制的区间调度不同，这里需要按照**开始时间**进行排序。



### 解决方法和套路

#### 将事件按照开始事件进行排序

```Java
Arrays.sort(events,(eevent1,event2) -> event1[0] - event2[0]);
```

#### DP定义：`dp[i][j]`表示从`[i...n-1]`中选择`j`个事件的最大价值

- 一维表示物品`[0...n]`
- 二维表示选择的数量`[0...k]`

```Java
int[][] dp = new int[n+1][k+1]
```

#### 遍历逻辑和状态转移方程

##### 遍历逻辑：外层事件内层容量[0-1背包]

根据**0-1背包的逻辑**：

- 外层我们遍历每一个事件,但是我们需要逆序遍历`[n-1...0]`
- 内层遍历所有的容量,从`[0...k]`

##### 状态转移方程

按照0-1背包的逻辑，我们需要在循环内部分别计算选择和不选择当前事件的最大价值。

###### 不选择当前事件：`dp[i+1][j]`

如果我们不参加事件 `i`，那么问题就变成了“从第 `i+1` 个事件到最后一个事件，最多参加 `j` 个事件”的最大价值。

###### 选择当前事件:`events[i-1].val + dp[next][j-1]` 核心难点和逻辑

这部分是本体的关键核心。

如果选择了当前的事件，我们需要考虑**后续我们能够选择哪一个事件**。

即我们使用**二分查找**方法，找到**不早于当前事件的结束时间**的第一个事件。

这也就是为什么我们需要根据开始事件进行排序的原因。

我们假设我们找到了后续事件`events[next]`符合条件。

那么如果我们选择了`event[i-1]`，则最大价值为:

**当前事件的价值 + 从`[next...n-1]`选出`j-1`个事件所获的的最大价值**。

`events[i-1].val + dp[next][j-1]`

从上面的逻辑可以看出来我们的事件遍历顺序应当是从`n-1`遍历到`0`

##### 初始化DP

我们创建一个 `dp` 表，大小为 `(n+1) x (k+1)`，其中 `n` 是事件数量。

多出来的一行 `dp[n]` 可以看作是边界条件：当 `i=n` 时，表示没有事件可供选择，所以 `dp[n][j]` 对于所有的 `j` 都为 0。

我们将整个 `dp` 表初始化为 0 即可满足这个边界条件。

##### 最终答案：`dp[0][k]`

根据定义，我们要求的最终答案是“从第 0 个事件开始，最多参加 `k` 次”的最大价值，即 `dp[0][k]`。

### 代码套路模板

```Java
class Solution {
    public int maxValue(int[][] events, int k) {
      int n = events.length; 
      Arrays.sort(events,(event1,event2) -> event1[0] - event2[0]);
      //dp[i][j]表示从[i...n-1]选择出j个事件所获的的最大利润
      int[][] dp = new int[n+1][k+1];

      for(int i = n-1; i >= 0; i--){
        for(int j = 1; j <= k; j++){
            //不选择当前事件，则利润在dp[i+1][j]
            int profit1 = dp[i+1][j];

            //选择当前事件
            //找出下一个根当前事件不冲突的事件（开始时间大于等于当前事件的结束时间）
            int next = binarySearch(events, i);
            //其利润就是当前事件的价值 + dp[next][j-1]
            int profit2 = events[i][2] + (next == -1 ? 0 : dp[next][j-1]);

            dp[i][j] = Math.max(profit1, profit2);
        }
      }
      //根据定义，最终的结果是dp[0][k]
      return dp[0][k];

    }

    private int binarySearch(int[][] events, int i){
        int n = events.length;
        int left = i + 1;
        int right = n - 1;
        int ans = -1;
        int target = events[i][1];
        while(left <= right){
            int mid = left + (right - left) / 2;
            //如果找到了，继续尝试有没有更左边的
            if(events[mid][0] > target){
                ans = mid;
                right = mid -1;
            }else{
                left = mid + 1;
            }
        }
        return ans;
    }


}
```



### Leetcode 1751: 最多可以参加的会议数量 II - 结合背包问题

问题和区间调度的问题基本一致，但是多了一个限制条件，最多参加K个会议。

加上了这个限制以后，其就具备了0-1背包问题的特征。

详细解析见上述描述和0-1背包部分。

#### [复习]0-1背包问题的特性

##### 0-1背包问题的场景和目标

- 背包的重量限制是k
- 每一个物品的价值是Value
- 每一个物品的重量是1
- 每一个物品可以选或者不选

返回在背包容量限制下所能获得的最大价值。

##### 0-1背包问题的套路模板

```Java
class Item{
  int weight;
  int val;
  public Item(int weight, int val){
    this.weight = weight;
    this.val = val;
  }
}

class Solution{
  public int maxValue(Item[] items, int k){
    int n = items.length;
    
    int[][] dp = new int[n+1][k+1];
    //外层遍历物品
    for(int i = 1; i <= n; i++){
       Item item = items[i-1];
      //内层遍历容量
      for(int j = 0; j <= k; j++){
      	//不选择该物品的最大获利
      	int profit1 = dp[i-1][j];
        if(j >= item.weight){
          int profit2 = dp[i-1][j-item.weight] + item.val;
          dp[i][j] = Math.max(profit1, profit2);
        }
      }
    }
    return dp[n][k];
  }
}
```



## 区间调度类问题的应对套路对比

### 场景一：无容量/次数限制 (e.g., LeetCode 1235)

- **最佳策略**: **按 `终点` 排序 + 向前查找**
- **思维模式**: 自底向上 (Bottom-Up) DP。
- **DP状态**: `dp[i]` = 考虑按终点排序后的前 `i` 个任务，能获得的最大收益。
- **为何有效**:
  - 按 `终点` 排序后，当我们计算 `dp[i]` 时，所有它可能依赖的子问题（如 `dp[i-1]` 和 `dp[p]`，其中 `p<i`）都已经计算完毕。这种线性的、向前依赖的结构非常适合用一个简单的一维数组来迭代求解。
  - 整个逻辑非常紧凑和高效。

```
dp[i] = max(
    dp[i-1],                               // 不选第 i 个任务
    tasks[i].profit + dp[prev_compatible]  // 选第 i 个任务
)
```

### 场景二：有容量/次数限制 `k` (e.g., LeetCode 1751)

- **最佳策略**: **按 `起点` 排序 + 向后查找**
- **思维模式**: 自顶向下 (Top-Down) / 记忆化搜索 或 自底向上（倒序遍历）。
- **DP状态**: `dp(i, k_left)` = 从第 `i` 个事件开始考虑，还剩 `k_left` 次机会，能获得的最大价值。
- **为何有效**:
  - 当增加了 `k` 这个约束维度后，我们需要跟踪“剩余可用次数”。
  - 按 `起点` 排序，当我们站在事件 `i` 做决策时：
    1. **不选**：问题规模变为 `(i+1, k_left)`
    2. **选**：问题规模变为 `(next_compatible, k_left - 1)`
  - 这种将一个大问题，分解为几种不同参数的子问题的模式，天然地契合了递归（记忆化搜索）的思维方式。状态 `(i, k_left)` 的定义非常直观，状态转移也十分清晰。
  - 如果要写成自底向上的迭代，也需要按 `起点` 排序，然后倒序遍历 `i`，逻辑与递归的镜像一致。

```
dp(i, k) = max(
    dp(i+1, k),                               // 不选第 i 个事件
    events[i].value + dp(next_compatible, k-1) // 选第 i 个事件
)
```

这个逻辑可以帮助您在面对一个区间调度问题时，迅速根据**是否存在容量限制**来选择最合适的处理范式：

- **没有 `k` 限制？** -> 优先考虑**按终点排序**，构建一维 `dp` 数组，向前查找。
- **有 `k` 限制？** -> 优先考虑**按起点排序**，构建二维 `dp` 状态（或使用递归），向后查找。

从理论上讲，两种问题都可以用两种方法来解，只是其中一种会比另一种在思路上和实现上**自然得多、简单得多**。您提炼出的这个规律，正是区分这两种情况并选择最优解题路径的关键。





