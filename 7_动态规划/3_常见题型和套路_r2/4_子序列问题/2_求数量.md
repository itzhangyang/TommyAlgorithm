## 求数量： 计算满足特定条件的子序列一共有多少种

这类问题要求我们计算满足特定条件的子序列一共有**多少种**。

### 场景和目标

**场景**: 通常是处理单个或两个数组/字符串。

**目标**: 计算形成特定模式/结果的**方案数**或**路径数**。

### 核心思想和套路 - 到达所有前驱状态的方案数之和

核心思想是**累加所有可能来源的方案数**。

状态转移通常涉及 `+` (加法) 运算。

当我们考虑状态 `i` 时，我们会思考：

- 状态 `i` 可以由哪些合法的*前驱状态 `j1, j2, ...` 转移而来？
- 那么，到达状态 `i` 的总方案数，就是**到达所有这些前驱状态的方案数之和**。
- `$dp[i] = dp[j1] + dp[j2] + ...$

### 实现原理

#### DP 状态定义

`$dp[i]$` 或 `$dp[i][j]$` 的含义是“...的**数量**”或“...的**方案数**”。

#### 状态转移：核心是加法

1. 转移方程的核心是**加法**。例如，在“不同的子序列”问题中，给定源字符串 `s` 和目标字符串 `t`：

2. 我们定义`dp[i][j]`表示`s[0...i-1]`能中能够找到的组成`t[0...j-1]`的子序列的数量

3. 那么每次遇到字符`s[i-1]`和`s[j-1]`

   - 首先`dp[i][j]`应当继承`dp[i-1][j]`的数量(即上一个邻居状态的数量)

   - 其次，我们应该看看是否`s[i-1] == t[j-1]`，如果相等，我们又多了一个方案数

     `dp[i][j] += dp[i-1][j-1]`

### 代码套路模板 - 不同的子序列

```Java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        //t的前j个字符由s的前i个字符组成的数量
        int[][] dp = new int[m+1][n+1];

        //dp[0][...] = 1
        //dp[...][0] = 0
        for(int i = 0; i <= m; i++){
            dp[i][0] = 1;
        }

        for(int i = 1; i <=m; i++){
            for(int j = 1; j <= n; j++){
                //符合条件，则是两种方案数之和
                if(s.charAt(i-1) == t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
}
```

### 注意事项

**初始化是关键**：计数问题的初始条件通常比较微妙。例如，`dp[0]` 或 `dp[0][0]` 设置为 `1` 还是 `0` 对整个结果有决定性影响。`dp[0]=1` 通常意味着“空集”或“什么都不做”也是一种方案。

**防止重复计算**：要确保状态转移的划分是“不重不漏”的，避免同一个方案在不同的转移路径中被多次计算。

**结果溢出**：方案数可能非常大，注意题目是否要求对一个大数（如 109+7）取模，并在每次加法操作后都进行取模。

### 经验总结

计数问题的本质是**构建组合的递推关系**。`dp` 表记录了到达每个中间状态的路径数量。解题的关键在于正确定义状态，并找到能覆盖所有情况且互不重叠的加法转移规则。初始化，尤其是关于“空”情况的定义，是常见的难点。

### Leetcode 115: 不同的子序列

详细见上述分析

### Leetcode 940: 不同的子序列 II

#### 问题要点 - 不同是关键

1. **输入**: 一个字符串 `S`，只包含小写字母。
2. **输出**: `S` 的所有**非空**、**不同**的子序列的个数。
3. **约束**: 结果可能非常大，需要对 109+7 取模。

**核心挑战**: "不同"二字是这个问题的关键。如果只是计算所有子序列（允许重复），那么每个字符都有选和不选两种状态，总共有 2∣S∣ 种，减去空集就是 2∣S∣−1。但由于字符串中可能存在重复字符（如 "aba"），会导致某些子序列被重复计算（"a" 可以由第一个 'a' 构成，也可以由第三个 'a' 构成），我们需要精确地去重。

#### 问题本质和分析

这个问题的本质是一个**动态规划**计数问题。

我们需要设计一种方法，在从左到右遍历字符串构建子序列时，能够有效地统计新生成的子序列数量，并巧妙地减去因重复字符而产生的重复计数。

##### 暴力方法 - 用set保存所有子序列

直接使用集合（Set）来存储所有子序列并最后返回其大小，会因为子序列数量呈指数级增长（最多 $2^{2000}$）而导致时间和空间复杂度过高，不可行。

因此，我们必须寻找一种数学上或状态转移上的**递推关系**。

#### 规律观察

让我们通过一个例子来观察规律。假设我们从左到右处理字符串 `S`。

##### s = `a`

- 子序列: "a"

- 总数: 1

##### s = `ab`

- 我们已经有了 "a" 的结果 (1个: "a")。

- 现在新来了字符 'b'。'b' 可以：

  1. 自己独立构成一个子序列: "b"

  2. 追加到之前所有子序列的末尾: "a" + "b" -> "ab"

- 所以，新增的子序列是 {"b", "ab"}，共 2 个。

- 总数 = (之前的结果) + (新增的数量) = 1 + 2 = 3。

- 观察：新增的数量 = 之前的结果数 + 1。

递推关系似乎是：`dp[i] = dp[i-1] + (dp[i-1] + 1) = 2 * dp[i-1] + 1`。

##### s = `abc`

- 我们已经有了 "ab" 的结果 (3个: "a", "b", "ab")。

- 新来了字符 'c'。'c' 可以：

  1. 自己独立构成: "c"

  2. 追加到之前所有子序列末尾: "ac", "bc", "abc"

- 新增的子序列是 {"c", "ac", "bc", "abc"}，共 4 个。

- 总数 = (之前的结果) + (新增的数量) = 3 + 4 = 7。

- 观察：新增的数量 = 之前的结果数 + 1 (3+1=4)。

- 这验证了 `dp[i] = 2 * dp[i-1] + 1` 的猜想。

##### s = `aba`, 出问题了

- 处理到 "ab"，结果是 3 ("a", "b", "ab")。

- 新来了字符 'a'。我们尝试用同样的逻辑：

  1. 自己独立构成: "a"

  2. 追加到之前所有子序列末尾: "aa", "ba", "aba"

- 新增的似乎是 {"a", "aa", "ba", "aba"}，共 4 个。

- 总数 = (之前的结果) + (新增的数量) = 3 + 4 = 7？

- 但是我们来实际数一下 "aba" 的不同子序列: "a", "b", "ab", "aa", "ba", "aba"。总共只有 6 个！

##### 哪里出问题了？

因为新生成的 "a" 与第一个 'a' 构成的子序列 "a" 重复了。

##### **为什么会重复？** 

当我们用新的 'a' 去追加到 "空" 子序列上时，得到了 "a"。而这个 "a" 在处理第一个字符时已经被计算过了。

##### 总结一下为什么会出错？ - 追加一个已经存在的字符

当我们用新的字符 `c` 去追加到之前的子序列上时，如果之前的某个子序列 `sub` 已经是由更早出现的同一个字符 `c` 生成的，那么 `sub + c` 就会和现在新生成的子序列产生重复。

比如`aba`这个简单的例子：

出现`a`时，构成的子序列是`a`

出现`b`时：

- 首先将生成一个独立的子序列`b`
- 然后将b，追加到由`a`生成的子序列`ba`

- 再次出现`a`时，它又会生成一个只包含自己的子序列`a`，已经出现重复了



##### 我们需要减去重复的部分 - 上一次c出现时以它结尾的子序列的数量

我们需要减去这部分重复的计数。

重复的部分是多少呢？就是上一次 `c` 出现时，所有以它结尾的子序列的数量。



#### 模式套路匹配

这是一个典型的**序列动态规划**问题。

当处理到第 `i` 个元素时，其结果依赖于前 `i-1` 个元素的结果。

同时，由于存在重复元素，状态转移还需要考虑相同元素上一次出现的位置和贡献。

这种 "统计以某元素结尾的数量" 的思想，是解决此类去重计数问题的经典模式。

#### 核心思想和套路 - 维护以每个字符结尾的子序列的数量

##### 创建哈希表维护以每个字符为结尾的子序列的数量

我们可以维护一个数组（或哈希表）`ends_with`，其中 `ends_with[c]` 表示在处理过的字符串前缀中，以字符 `c` 结尾的不同子序列有多少个。

同时，我们用一个变量 `total_count` 记录当前已处理前缀的不同子序列的总数。

当我们遍历到字符串中的一个新字符的时候，执行如下操作：

##### 计算新增多少 - Total Count + 1

如果不考虑去重，新字符 `ch` 可以追加到之前所有 `total_count` 个子序列的末尾，再加上 `ch` 本身，总共可以形成 `total_count + 1` 个以 `ch` 结尾的新子序列。

##### 去除重复的计数 - `endsWith[ch]`

在这 `total_count + 1` 个新序列中，有多少是重复的呢？

重复的正是那些由 *上一个* `ch` 字符所构成的、以 `ch` 结尾的子序列。

这些重复序列的数量，恰好就是我们之前记录的 `ends_with[ch]`。

##### 计算真正的新增

所以，本次操作真正新增的、独一无二的子序列数量是 `(total_count + 1) - ends_with[ch]`。

##### 更新总数

所以，本次操作真正新增的、独一无二的子序列数量是 `(total_count + 1) - ends_with[ch]`。

##### 更新哈希表`endsWith[ch]`

经过本次操作后，新的以 `ch` 结尾的子序列总数是多少？就是我们第一步计算的 `total_count + 1`。所以，我们更新 `ends_with[ch] = total_count + 1`。

#### 实现原理和步骤

1. 定义模数 `MOD = 10^9 + 7`。

2. 创建一个大小为 26 的数组 `ends_with` (Java 中建议用 `long` 类型防止中间计算溢出)，并初始化所有元素为 0。`ends_with[i]` 存储以字符 `'a' + i` 结尾的子序列数量。

3. 创建一个变量 `total_count` (同样建议用 `long` 类型)，初始化为 0，表示当前不同子序列的总数。

4. 遍历输入字符串 `S` 的每一个字符 `ch`。

5. 对于每个字符 `ch`： 

   - a. 计算 `ch` 对应的索引 `idx = ch - 'a'`。 

   - b. 保存旧的以 `ch` 结尾的数量 `prev_ends_with_ch = ends_with[idx]`。

   - c. 更新 `ends_with[idx]`。新的以 `ch` 结尾的子序列数等于（旧的总数 + 1（代表空集））。

   所以 `ends_with[idx] = (total_count + 1) % MOD`。 

   - d. 计算本次真实增加的子序列数 `added = (ends_with[idx] - prev_ends_with_ch)`。注意处理负数取模，`added = (added + MOD) % MOD`。

   - e. 更新总数 `total_count = (total_count + added) % MOD`。

6. 循环结束后，`total_count` 就是最终答案，将其转换为 `int` 类型返回。

#### 实现代码

```Java
class Solution {
    public int distinctSubseqII(String s) {
        // 定义模数
        int MOD = 1_000_000_007;

        // endsWith[i] 存储以字符 ('a' + i) 结尾的不同子序列的数量
        // 使用 long 类型防止中间加法溢出
        long[] endsWith = new long[26];

        // totalCount 存储当前已处理前缀的不同子序列总数
        long totalCount = 0;

        for (char ch : s.toCharArray()) {
            int index = ch - 'a';

            // 记录在处理当前字符 ch 之前，以 ch 结尾的子序列数量
            long prevEndsWith = endsWith[index];

            // 计算如果本次新生成的以 ch 结尾的子序列数量
            // 它们是通过将 ch 追加到之前所有子序列（totalCount个）和空序列（1个）的末尾得到的
            long newEndsWith = (totalCount + 1);

            // 更新 endsWith 数组
            endsWith[index] = newEndsWith;

            // 本轮真实新增的子序列数量 = 新生成的以ch结尾的数量 - 之前就以ch结尾的数量 (去重)
            // (a - b + MOD) % MOD 是处理负数取模的标准方法
            long addedCount = (newEndsWith - prevEndsWith + MOD) % MOD;
            
            // 更新总数
            totalCount = (totalCount + addedCount) % MOD;
        }

        return (int) totalCount;
    }
}
```

#### 注意事项

1. **取模运算**: 在每一步加法和减法之后都要进行取模运算，防止数值溢出。
2. **负数取模**: `(a - b) % MOD` 在 Java 中如果 `a < b` 结果会是负数。正确的写法是 `(a - b + MOD) % MOD`，确保结果始终在 `[0, MOD-1]` 区间内。
3. **数据类型**: 尽管最终结果是 `int`，但中间计算过程（特别是 `totalCount + 1`）可能会超过 `Integer.MAX_VALUE`，所以使用 `long` 类型来存储 `totalCount` 和 `endsWith` 数组是更安全、更严谨的做法。
4. **空子序列**: 题目要求非空子序列。我们的算法 `totalCount + 1` 中 `+1` 的含义是“空子序列”，追加字符后变为了非空子序列。整个过程中 `totalCount` 始终统计的是非空子序列的数量，因此最终结果无需额外处理。

#### 经验总结

**问题转化**: 遇到带有 "不同"、"唯一" 等字样的计数问题，通常意味着需要去重。动态规划是解决这类问题的有力工具。

**DP状态设计**: 如果一个简单的 DP 状态（如 `dp[i]` 代表前 `i` 个字符的答案）导致状态转移非常复杂，可以尝试更细分的 DP 状态。本题中，将总数`dp[i]` 拆解为 "以每个字符结尾的子序列数量" `ends_with[c]`，极大地简化了去重逻辑。

**"结尾"思想**: "以...结尾" 或 "以...开头" 是序列 DP 中一种非常常见的状态定义技巧，特别适用于处理与元素本身值相关的约束或去重。

**代码鲁棒性**: 在处理计数和取模问题时，要时刻注意数据溢出和负数取模的陷阱，养成使用 `long` 和 `(a - b + MOD) % MOD` 的好习惯。

### Leetcode 2393: 严格递增子数组的个数

#### 问题要点

**輸入**: 一個只包含正整數的陣列 `nums`。

**輸出**: 陣列中「嚴格遞增子陣列」的總數量。

**子陣列 (Subarray)**: 必須是 **連續的** 序列。例如，`[1, 2, 3]` 中 `[1, 2]` 是子陣列，但 `[1, 3]` 不是。

**嚴格遞增 (Strictly Increasing)**: 子陣列中的每個元素都必須嚴格大於它前面的元素。例如 `[3, 5, 8]` 是嚴格遞增的，但 `[3, 5, 5]` 不是。

**單一元素**: 單個元素的子陣列 `[x]` 也被視為一個合格的嚴格遞增子陣列。

#### 问题本质和分析

這道題的本質是計數問題。一個最直觀但效率低下的想法是：

1. 找出所有的連續子陣列。
2. 對每一個子陣列，檢查它是否滿足「嚴格遞增」的條件。
3. 如果滿足，計數器加一。

這個暴力解法的時間複雜度至少是 O(n2)（枚舉所有子陣列的起點和終點）甚至 O(n3)（如果每次檢查都再遍歷一次子陣列），空間複雜度是 O(1)。對於 LeetCode 的數據規模（`n` 通常可達 105），O(n2) 的算法會超時（Time Limit Exceeded）。

你最初的 DP 方法，`dp[i][j]` 記錄 `nums[i...j]` 是否遞增，雖然邏輯上可行，但 O(n2) 的空間複雜度直接導致了內存溢出（Memory Limit Exceeded）。

因此，我們必須尋找一種更高效的方法，最好是只需要遍歷一次陣列的 O(n) 解法。

#### 方法一： `dp[i][j]`表示`nums[i...j]`为严格递增子数组

```Java
class Solution {
    public long countSubarrays(int[] nums) {
        int n = nums.length;
        //dp[i][j]表示nums[i...j]为严格递增子数组
        boolean[][] dp = new boolean[n][n];
        for(int i = 0; i < n; i++){
            dp[i][i] = true;
        }

        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                if(dp[i][j-1] && nums[j] > nums[j-1]){
                    dp[i][j] = true;
                }
            }
        }

        int count = 0;
        for(int i = 0; i < n; i++){
            for(int j = i; j < n; j++){
                if(dp[i][j]){
                    count++;
                }
            }
        }
        return count;


    }
}
```

##### 该方法存在的问题 - 内存溢出

你最初的 DP 方法，`dp[i][j]` 記錄 `nums[i...j]` 是否遞增，雖然邏輯上可行，但 O(n2) 的空間複雜度直接導致了內存溢出（Memory Limit Exceeded）。

#### 规律观察

高效解法的突破口往往來自於對問題規律的觀察。

我們不從「檢查每一個子陣列」的角度出發，而是從「**計算以每個元素結尾的貢獻**」這個角度來思考。

讓我們以 `nums = [1, 3, 5, 4, 6]` 為例：

##### 举个例子：`nums = [1, 3, 5, 4, 6]`

######**遍歷到 `nums[0] = 1`**:

- 以 `1` 結尾的嚴格遞增子陣列只有 `[1]`。
- 數量為 **1**。
- 當前總數 = 1。

######**遍歷到 `nums[1] = 3`**:

- 因為 `3 > 1`，遞增趨勢得以延續。
- 以 `3` 結尾的嚴格遞增子陣列有：`[3]` 和 `[1, 3]`。
- 數量為 **2**。
- 當前總數 = 1 + 2 = 3。

###### **遍歷到 `nums[2] = 5`**:

因為 `5 > 3`，遞增趨勢繼續延續。

以 `5` 結尾的嚴格遞增子陣列有：`[5]`, `[3, 5]`, 和 `[1, 3, 5]`。

數量為 **3**。

當前總數 = 3 + 3 = 6。

###### **遍歷到 `nums[3] = 4`**:

因為 `4 <= 5`，遞增趨勢**中斷**。

一個新的遞增序列從 `4` 開始。

以 `4` 結尾的嚴格遞增子陣列只有 `[4]`。

數量為 **1**。

當前總數 = 6 + 1 = 7。

###### **遍歷到 `nums[4] = 6`**:

- 因為 `6 > 4`，遞增趨勢得以延續。

- 以 `6` 結尾的嚴格遞增子陣列有：`[6]` 和 `[4, 6]`。
- 數量為 **2**。
- 當前總數 = 7 + 2 = 9。

##### 规律总结 - 以`nums[i]`结尾的递增子数组的数量以其结尾的最大递增子数组的长度

**規律**: 當我們遍歷到 `nums[i]` 時，以它為結尾的嚴格遞增子陣列的數量，正好等於**包含 `nums[i]` 在內的、向前延伸的連續遞增序列的長度**。

- 如果 `nums[i] > nums[i-1]`，這個長度就是前一個元素的長度加 1。
- 如果 `nums[i] <= nums[i-1]`，遞增序列中斷，新的長度重置為 1。

總的子陣列數量就是每一步計算出的貢獻數量之和。

#### 模式套路匹配 ： 贡献法 -  以`nums[i]`结尾的递增子数组有多少？

- **動態規劃（狀態壓縮）**: 傳統的 DP 需要 `dp[i]` 表示以 `i` 結尾的某種狀態。我們發現計算 `dp[i]` 只需要 `dp[i-1]` 的信息，而不需要 `dp[i-2]`, `dp[i-3]`...。因此，我們不需要一個完整的 DP 陣列，只需要一個變數來記錄前一個狀態即可。這就是從 O(n) 空間到 O(1) 空間的優化，也稱為「滾動陣列」或「狀態壓縮」。
- **貢獻法 (Contribution Method)**: 我們將總問題分解為計算每個元素 `nums[i]` 的「貢獻」——即有多少個符合條件的子陣列是以 `nums[i]` 結尾的。最後將所有貢獻相加。

#### 核心思想和套路 - 以`nums[i]`结尾的递增子数组有多少？

**核心思想**: 線性掃描，實時計算。

**套路**: 維護一個變數 `length`，記錄**當前連續嚴格遞增子陣列的長度**。

遍歷陣列，根據當前元素和前一個元素的關係來更新 `length`，並將更新後的 `length` 累加到最終結果 `count` 中。

#### 实现原理和步骤

- 初始化總數 `count = 0` (使用 `long` 型別以防溢出)。

- 初始化當前遞增長度 `length = 0`。

- 從頭到尾遍歷陣列 `nums`，索引為 `i`。

- 在循環中： 
  - a. 判斷是否為第一個元素 (`i == 0`) 或當前元素是否大於前一個元素 (`nums[i] > nums[i-1]`)。
  - b. **如果是**，說明遞增序列延續，`length` 自增 1。 
  - c. **如果不是**，說明遞增序列中斷，將 `length` 重置為 1。
  - d. 將當前的 `length` 值累加到 `count` 中。

循環結束後，返回 `count`。

#### 实现代码

```Java
class Solution {
    public long countSubarrays(int[] nums) {
        long count = 0;
        long length = 0;
        for(int i = 0; i < nums.length; i++){
            if(i == 0 || nums[i] > nums[i-1]){
                length += 1;
                
            }else{
                length = 1;
            }
            count += length;
        }

        return count;
    }
}
```

#### 注意事项

- **數據型別**: 總數 `count` 必須使用 `long`。考慮一個極端情況，如果 `nums` 的長度是 105 且完全遞增，總數將是 $1+2+3+...+10^5$，大约数$5×10^9$，這個值遠超 `int` 型別的最大值（約 $2.1×10^9$）。
- **邊界條件**: 處理好 `i = 0` 的情況。在我們的實現中，`else` 分支很巧妙地同時處理了序列中斷和 `i=0` 這兩種需要重置 `length` 為 1 的情況。
- **題目理解**: 務必分清「子陣列(Subarray)」和「子序列(Subsequence)」。本題要求連續，因此方法相對簡單。

#### 经验总结

1. **從暴力解到最優解**: 當遇到一個計數或最值問題時，可以先從最暴力的方法想起，然後分析其複雜度瓶頸（是時間還是空間），再尋找優化點。
2. **轉化思考角度**: 解決本題的關鍵是將思路從「枚舉並檢查所有子陣列」轉化為「計算每個元素的貢獻」。這種「貢獻法」思想在很多計數類題目中都非常有效。
3. **識別 DP 優化模式**: 當你發現一個 DP 問題的狀態轉移 `dp[i]` 只依賴於 `dp[i-1]`（或常數個前面的狀態）時，通常意味著空間複雜度可以從 O(n) 優化到 O(1)。
4. **大道至簡**: 很多看似複雜的問題，其最優解的核心邏輯往往非常簡潔。本題的 O(n) 解法就只用了一個循環和一個額外變數，體現了算法的優雅。

