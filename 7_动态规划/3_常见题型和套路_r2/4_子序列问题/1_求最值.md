## 求最值： 求满足特定条件的最大/最小长度/最大/最小和

### 场景和目标类型

#### 场景 - 通常是处理单个或者两个数组/字符串

#### 目标

- 求最大/最小**长度** (如：最长递增子序列 LIS, 最长公共子序列 LCS)

- 求最大/最小**和** (如：最大子数组和)
- 求最小**代价/距离** (如：最小编辑距离)
- 求最大**价值** (如：0/1背包问题)

###核心思路和套路 - 找到与i配对并产生最优结果的子问题解

核心思想是**从子问题的最优解中推导出当前问题的最优解**。

状态转移通常涉及 `max()` 或 `min()` 函数。

当我们考虑元素 `i` 时，我们会思考：

- **不包含 `i`**：最优解就是不考虑 `i` 时的最优解。

- **包含 `i`**：`i` 会作为子序列的**结尾**元素。

我们需要回顾 `i` 之前的所有元素 `j`，找到一个能够与 `i` **配对**并且能产生最优结果的子问题解，然后在此基础上加上 `i` 的贡献。

最终，`dp[i]` 的值就是综合所有这些可能性后得到的**最值**。

### 实现原理

#### DP状态定义 - 以`nums[i]`结尾的子序列最优值

**单序列**: `$dp[i]$` 通常定义为 “在 `0...i` 范围内，**必须以 `nums[i]` 结尾**的子序列的最优值”。

这个“结尾”的限定至关重要，它保证了状态转移的**无后效性**。

**双序列**: `$dp[i][j]$` 通常定义为 “对于 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符，其子序列的最优值”。

#### 状态转移方程 - 核心是比较

转移方程的核心是比较。例如，求 LIS 长度时：

$dp[i] = 1 + max_{j=0}^{i-1}(\{dp[j] \mid 0 \le j < i \text{ and } nums[i] > nums[j]\})$

求最小编辑距离时：

$dp[i][j] = 1 + min_{j=0}^{i-1}(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])$

### 代码套路模板（LIS）

```Java
public int maxLis(int[] nums){
  if(nums == null || nums.length == 0){
    return 0;
  }
  if(nums.length == 1){
    return 1;
  }
  
  int n = nums.length;
  //以nums[i]为最后一个元素的递增子序列的最大长度
  int[] dp = new int[n];
  Arrays.fill(dp,1);
  
  for(int i = 0; i < n; i++){
    for(int j = 0; j < i; j++){
      if(nums[j] < nums[i]){
        //核心是比较长度
        dp[i] = Math.max(dp[i],dp[j] + 1);//通用模版中应当是f(dp[j],nums[i])
      }
    }
  }
  
  int max = 1;
  for(int len : dp ){
    max = Math.max(max,len);
  }
  return max;
}
```

### 注意事项

####**DP定义要精准**：以nums[i]结尾的子序列的最大长度

特别是“是否必须以 `i` 结尾”会直接影响状态转移和最终结果的计算方式。

#### 最终结果的确定：注意DP的定义是全局还是局部

如果 `$dp[i]$` 定义为“以 `i` 结尾的最优值”，那么全局最优解通常是 `max(dp)`。

如果 `$dp[i]$` 定义为“前 `i` 个元素的最优值”，那么全局最优解通常是 `$dp[n-1]$`。

#### 初始化

初始值要确保不影响 `max/min` 的第一次比较。

例如，求最小值时可以初始化为正无穷，求最大值时可以初始化为负无穷或一个合法的初始值。

### 经验总结

求最值问题的本质是**寻找最优的决策路径**。

`dp` 表记录了在每一步的“局部最优解”，而整个DP过程就是通过这些局部最优解构建出“全局最优解”。

关键在于识别出子问题之间的依赖关系，并写出正确的状态转移方程。

### Leetcode 300: 最长公共子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

####状态定义

```
// dp[i] 表示以i结尾的最长递增子序列长度
int[] dp = new int[n];
//初始化状态数组
Arrays.fill(dp, 1); 
//初始化最大长度
int maxLength = 1;
```

####遍历逻辑和状态转移

```Java
for (int i=0;i<n;i++){
  for (int j=0;j<i;j++){
    if (nums[i]>nums[j]){
      dp[i] = Math.max(dp[i],dp[j]+1);
    }
  }
}
```

####查找最大结果

`maxLength = max(dp)`

```java
for (int length:dp){
            if (length>maxLength){
                maxLength = length;
            }
        }
        return maxLength;
```

###Leetcode 5 最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。

注意这里寻找的是**最长回文子串**，而不是**最长回文子序列**。

####核心思想 - 枚举所有子串是否是回文串

##### 暴力方法： 检查每一个子串是否是回文串

一个简单的想法是枚举所有的子串，并检查期是否是回文串：

```Java
for(int len = 1; len <= n; len++){
  for(int start = 0; start <= n - len; start++){
    int end = start + len -1;
    if(isPalindrome(s.substring(start,end+1))){
      maxLen = Math.max(maxLen,len);
    }
  }
}
```

##### 使用动态规划方法减少重复检查

我们的主要思路是，枚举所有可能的子串，判断其是否为回文，并记录最长的那一个。

但是我们需要需要避免重复的检查和遍历相同的子串是否是回文串。



我们定义`dp[i][j]`表示子串`s[i...j]`是否是回文串。

按照我们对于回文串的理解，如果`dp[i][j]`为`true`，那么`dp[i+1][j-1]`也一定为`true`.



换个角度，如果：

- `s[i] == s[j]`，并且
- `dp[i+1][j-1] == true`

那么就可以推导出`dp[i][j] = true`。



而如果按照子串长度`len`从小到大的遍历的话，那么在我们需要计算`dp[i][j]`的时候`dp[i+1][j-1]`应该是已经计算好了的。

这样我们就可以达到避免重复遍历整个子串的过程了。



####基本原理

回文的特征是

- 首尾字符相同
- 去掉首尾字符之后，剩下的子串也是回文

所以，可以使用`递归`或者`动态规划`思想来判定子串是否是回文。

##### 状态定义:`dp[i][j]`表示`s[i...j]`是否是回文串

`dp[i][j]`表示字符串从第`i`个字符到第`j`个字符s`[i....j]`是否是回文串。

- `dp[i][j]=true`表示`s[i....j]`是回文
- `dp[][j]=false`表示`s[i...j]`不是回文

##### 遍历逻辑-按照长度从小到大遍历所有的子串

**因为`dp[i][j]`依赖于`dp[i+1][j-1]`，所以我们要保证`dp[i][j]`之前，`dp[i+1][j-1]`已经被填过**

- 先计算计算每一个`dp[i+1,j-1]`的值
- 判断`s[i]`是否和`s[j]`相同
  - [Corner Case]如果子串长度小于等于2，则`dp[i][j]=true`;
  - 如果相同 并且 `dp[i+1][j-1]=true` ,则`dp[i][j]=true`
  - 否则则`dp[i][j]=false`

![image-20250410202155313](/Users/tommy/Library/Application Support/typora-user-images/image-20250410202155313.png)

```java
for (int length=1; length <= n;length++){
  int firsrtStart = 0;
  int lastStart = n-len;
  for (int start = firstStart;start<=lastStart;i++){
    int end = start+len-1;
    if (s.charAt(start) == s.charAt(end)){
      //需要注意这个corner case
     if (len <=2){
       dp[start][end]=true;
     }else{
       dp[start][end] = dp[start+1][end-1];
     }
    }
    
    if(dp[start][end] && len > maxLen){
      maxLen = len;
    }
  }
}
```

##### 状态转移方程

```
dp[i][j] = true  ⟺  s[i] == s[j] 且 (j - i <= 2 或 dp[i+1][j-1] == true)
```

**解释**

- 如果 `s[i]!=s[j]`,一定不是回文
- 如果`s[i]==s[j]`,那么要看中间的子串`s[i+1...j-1]`是否是回文
  - `j-1<=2`表示区间长度小于等于3，只要首尾相同就是回文

##### 初始状态

- 所有`i==j`的情况都是回文（长度为1的子串）：`dp[i][j]=true`

##### 代码实现

```java
    public String longestPalindrome(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    int maxLen = 1;
    int bestStart = 0;
		//遍历所有长度（从1到n）的子串
    for (int len = 1; len <= n; len++) {
        int firstStart = 0;
        int lastStart = n - len;
				//从左到右遍历所有长度为len的子串
        for (int start = firstStart; start <= lastStart; start++) {
            int end = start + len - 1;
						//如果子串的首尾相同
            if (s.charAt(start) == s.charAt(end)) {
              //如果子串长度<=2，子串为回文串
                if (len <= 2) {
                    dp[start][end] = true;
                  //否则看看s[start+1...end-1]是否是回文串
                } else {
                    dp[start][end] = dp[start + 1][end - 1];
                }
            }

            if (dp[start][end] && len > maxLen) {
                maxLen = len;
                bestStart = start;
            }
        }
    }

    return s.substring(bestStart, bestStart + maxLen);
}
```

###Leetcode 673 最长递增子序列的个数

####问题本质 & 问题分析

给定一个整数数组 `nums`，返回 **最长递增子序列的个数**。

注意，不仅要找出最长长度，还要数出有多少种不同的递增子序列达到这个长度。

####核心思想 - 增加一个计数器数组

这是**最长递增子序列**的基础上，加上了**计数维度**，定义下列两个**DP数组**：

- **length[i]: **每个位置`i`结尾的**LIS的最长长度**
- **count[i]:** 每个位置`i`结尾的并且长度为`length[i]`的LIS的数量

####状态定义与初始化

#####状态定义

- `length[i]`表示以`nums[i]`结尾的**最长子序列**的长度
- `count[i]`表示以`nums[i]`结尾的**最长（即长度为`length[i]`）子增长子序列的个数**

#####状态初始化

- 所有元素的`length[i]=1`：每个元素本身就是一个长度为1的递增子序列
- 所有元素的`count[1]=1`:每个元素可以至少构成一个子序列

####遍历逻辑与状态转移方程

#####遍历顺序 - 过程和LIS一样

- 外层循环每一个元素`nums[0...i]`
- 内层遍历`j=[0...i-1]`找到`nums[i]`之前小于`nums[i]`的元素`nums[j]`

#####状态转移方程

我们知道在目前已经知道：`length[i]`是以`i`结尾的最长递增子序列的长度。

现在我们在`[0...i)`中又新发现了一个比`nums[i]`小的元素。

这说明我们可能需要更新一下最大长度`length[i]`了。

在LIS中我们的做法是: `length[i] = max(length[j]+1, dp[i])`

现在我们得区分上面的两种情况了，因为我们得同时更新计数器。

######情况一： 找到了一个**更长的递增子序列**（`length[j]+1 > length[i]`）

也就是上面所说的`length[j]+1 > length[i]`的情况，

之前以`i`结尾的最长长度是`length[i]`。

现在追加上元素`j`，`length[j]+1`比原来的`length[i]`更长了。



那应该怎么办呢？

- 首先，我们还是按照LIS的套路，继续更新**以`i`结尾的最长递增子序列**：

  `length[i]=length[j]+1`(**求最长递增子序列的标准套路**)

- 其次，我们知道以`j`结尾的最大子增子序列的数量是`count[j]`，

  因此构成`length = length[j]+1`的子序列的数量是`count[j]`

  

######情况二：找到了一个**相同长度的递增子序列**（`length[j]+1 == length[i]`）

说明：

- 当前`length[i]`依然是最长递增子序列的长度
- 以`j`结尾的序列加上`nums[i]`，也可以**正好组成这个长度**
- 这是一种新的方式来表达这个长度的子序列

那应该怎么办？

- 首先根据LIS的逻辑，我们不需要更新`length[i]`，因为最长长度没变

- 其次，我们需要将`count[j]`累加到`count[i]`，因为这是另外一种以`nums[i]`结尾的方案

- 对上述两种情况的总结：

  | 条件                         | 意义                                | 操作                                         |
  | ---------------------------- | ----------------------------------- | -------------------------------------------- |
  | `length[j] + 1 > length[i]`  | 找到了**更长**的 LIS                | 更新 `length[i]`，重置 `count[i] = count[j]` |
  | `length[j] + 1 == length[i]` | 找到了**另一种**构造当前 LIS 的方式 | `count[i] += count[j]`                       |

```java
// 我找到了一个更长的递增子序列！
if (length[j] + 1 > length[i]) {
     //之前以 i 结尾的最长长度是 length[i]（初始为1）
    // 现在通过 j 接上来，length[j] + 1 比原来的 length[i] 更长
    // 更新 length[i] = length[j] + 1（从 j 扩展得到的更优解）
    length[i] = length[j] + 1;
    // 而能构成这个新解的方式就是 count[j] 种（因为以 j 结尾的 LIS 就有这么多种）
    count[i] = count[j];
// 我找到了另一条不同路径，也能构成相同长度的 LIS
} else if (length[j] + 1 == length[i]) {
  // 不需要更新 length[i]，因为长度没变
    //但是要把 count[j] 也加进来，因为这是另一组以 nums[i] 结尾的方案
    count[i] += count[j];
}
```

##### 记录当前全局最大长度

对于所有的`i = [0...n]`我们在计算每一个`dp[i]`的时候，同时维护比较和更新一个全局的最大长度`maxLen`

`maxLen = max(dp[i],maxLen)`

这样我们在最后在收集所有的符合`dp[i] == maxLen`的情况，就可以收集到长度为`maxLen`的子序列的数量了。

##### 收集所有长度为全局最大长度的子序列数量

我们在填充`dp`的时候同时维护和更新了全局最大长度`maxLen`。

现在我们只要遍历最大递增子序列长度数组`dp[0...n]`， 找出所有`dp[i] == maxLen`的索引`i`。

然后我们将所有的`count[i]`进行累加，就可以得到最终的结果。

####实现代码

```java
public int findNumberOfList(int[] nums){
  int n = nums.length;
  if (n == 0) return 0;
  
  int[] length = new int[n];
  int[] count = new int[n];
  int maxLen =1;
  
  Arrays.fill(length,1);
  Arrays.fill(count,1);
  
  for (int i=0; i < n; i++){
    for(int j=0;j<i;j++){
      if(nums[j] < nums[i]){
        if (length[j]+1 > length[i]){
          length[i] = length[j]+1;
          count[i] = count[j];
        }else if (length[j]+1 == length[i]){
          count[i] += count[j];
        }
      }
    }
    maxLen = Math.max(maxLen,dp[i]);
  }
  
  //后面逻辑，找出所有长度为maxlen的子序列
  int result =0;
  for (int i=0;i<n;i++){
    if (length[i] == maxLen){
      result += count[i];
    }
  }
  
  return result;
}
```

##### 注意事项

1. **状态更新时不能遗漏 `==`**：
   - `if (length[j] + 1 == length[i])` 是关键分支，不能写错为 `>=`
2. **避免只更新 count 却没更新 length**，两者应配套处理。
3. 题目要求的是“个数”，最终需要遍历所有位置的 `count[i]`，只要 `length[i] == maxLen`。

##### 经验总结

| 点         | 内容                                                   |
| ---------- | ------------------------------------------------------ |
| 🎯 问题本质 | 在 LIS 基础上统计组合数（动态规划 + 计数）             |
| 🏷️ 状态设计 | `length[i]` + `count[i]` 联合建模                      |
| 🔁 状态转移 | 如果是新的最大长度，重置 count；如果是等长，累加 count |
| 🧠 常见陷阱 | 忘记 count 初始化、未判断相等更新路径数                |

###Leetcode 516 最长回文子序列

注意这个题目是找最长**回文子序列**，而不是**最长回文子串**。

在面试过程中，需要和面试官澄清到底是子序列还是子串。

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

####问题本质-子序列不要求连续

给定一个字符串`s`,求其最长回文子序列的长度

- **子序列：**不要求连续，可以跳过字符
- **回文：**正着读和反着读一样
- 与**最长回文子串**不同，这里是子序列，位置可以跳跃

####问题分析 - 考虑`s[i...h]`区间中能够构成的最长回文子序列

核心是**在字符串中选出一组字符，使得他们正反一样，并且长度最大**

- 这是一个**区间最优解**问题，类似**两个指针夹逼**的形式
- 考虑字符串区间`[i...j]`，我们关注的是这个区间里能够构成的最长回文子序列

####核心思想和套路 - 关注两头的字符串

####核心思想 - 只需要比较区间的两头

想知道一个大区间的最优解，就看它的“两头”怎么处理。

我们要找子串 `s[i...j]` 的最长回文子序列。

我们的注意力只放在这个子串的**第一个字符 `s[i]`** 和**最后一个字符 `s[j]`** 上。

我们需要注意的是，如果在区间`s[i-1..j+1]`内如果找到一个回文序列，如果头上两个字符相等，`s[i...j]`内的最长回文序列长度就+2了。

#####情况一： 两头字符相等 (比如 `a...a`)

如果 `s[i]` 和 `s[j]` 正好相等，比如子串是 `abaca`。

- **太棒了！** 这两个 `a` 天生就是一对，我们可以把它们当作回文串的“外壳”。
- 这个“外壳”已经为我们的总长度贡献了 `2`。
- 接下来，我们只需要在**去掉这两头之后**的**更小**的子串 `bac` (`s[i+1...j-1]`) 里面，再去找最长的回文子序列就行了。
- 所以，`abaca` 的答案 = `2` + `bac` 的答案。

这就解释了为什么我们需要知道更小子串 `s[i+1...j-1]` 的解。

#####情况二：两头字符不相等 (比如 `b...a`)

如果 `s[i]` 和 `s[j]` 不相等，比如子串是 `banca`。

这意味着，我们构建的最长回文子序列，**不可能同时用上**开头的 `b` 和结尾的 `a`。

我们必须**丢掉一个**。

- 这就产生了两个选择：
  1. **丢掉开头的 `b`**：我们在剩下的 `anca` (`s[i+1...j]`) 里找最长回文子序列。
  2. **丢掉结尾的 `a`**：我们在剩下的 `banc` (`s[i...j-1]`) 里找最长回文子序列。
- 我们当然会选择能产生**更长**结果的那一个选择。
- 所以，`banca` 的答案 = `max` ( `anca` 的答案 , `banc` 的答案 )。

这就解释了为什么我们需要知道更小子串 `s[i+1...j]` 和 `s[i...j-1]` 的解。

#####总结问题

- 把问题拆成更小的子问题（子串），通过**递推**逐步解决
- 状态转移依赖于子区间`[i+1][j-1]`,`[i+1][j]`,`[i][j-1]`

#### 核心套路

##### 状态定义和初始化

###### 状态定义：`dp[i][j]` - `s[i...j]`最长回文子序列的长度

`dp[i][j]`表示在区间`[i...j]`中，最长回文子序列的长度

###### 状态初始化

- 当`i==j`，表示区间只有一个字符，本身就是回文,`dp[i][i]=1`
- 当`i>j`，区间非法，不需要处理

##### 遍历逻辑和状态转移方程

###### 遍历顺序

- 外层遍历`i=[n-1...0]`， 因为我们看到`dp[i][...]`会依赖于`dp[i+1][...]`
- 内层遍历`j=[i+1...n-1]`因为状态`dp[...][j]`依赖于`dp[i+1][j-1]`，`dp[i+1][j]`，`dp[i][j-1]`

###### 状态转移方程

根据上面的分析，知道：

- 当`s[i] == s[j]`时, `dp[i][j] = dp[i+1][j-1] + 2`
- 当`s[i] != s[j]`时，`dp[i][j] = max(dp[i-1][j],dp[i][j-1])`

```java
if(s.charAt(i) == s.charAt(j)){
  dp[i][j] = dp[i+1][j-1]+2;
}else{
  dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
}
```

- 如果首尾字符相同，则他们可以包在一个回文字符串两端，+2
- 如果不等，就去看左边或者右边哪一个可以获取更长的回文字符串

####实现代码

```java
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        //
        int[][] dp = new int[n][n];
        for (int i=0;i<n;i++){
            dp[i][i] =1;
        }

        for(int i= n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if (s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]+2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
```

###Leetcode 1143 最长公共子序列

#### 问题要点

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

#### 问题本质和分析

在所有满足“公共子序列”条件的解中，找到一个具有最大“长度”的解。

接的暴力解法是什么？

1. 找出 `text1` 的所有子序列。
2. 对每一个子序列，检查它是否也是 `text2` 的子序列。
3. 在所有满足条件的公共子序列中，记录下最长的长度。

这个方法为什么不可行？一个长度为 `m` 的字符串，其子序列的个数为 2m。这是一个指数级别的复杂度，对于典型的字符串长度（例如 1000），这是绝对无法接受的。

暴力法的问题在于进行了大量的重复计算。例如，在比较 `"abcde"` 和 `"ace"` 时，我们计算 `"abc"` 和 `"ac"` 的LCS时得到的信息，在后续计算 `"abcd"` 和 `"ace"` 的LCS时本可以被复用。

#### 规律观察

动态规划的核心是找到状态转移的规律。我们尝试从两个字符串的末尾开始分析，假设 `text1` 长度为 `m`，`text2` 长度为 `n`。

##### 情况一： 最后一个字符相等

如果 `text1[m-1] == text2[n-1]`，例如 `text1 = "abcde"` 和 `text2 = "bade"`。

 最后一个字符 `'e'` 相等。那么这个 `'e'` 必然可以作为最长公共子序列的一部分（并且放在末尾）。

为什么？如果LCS不包含这个`'e'`，我们总可以把这个`'e'`加上，得到一个更长的公共子序列，这与LCS的定义矛盾。 

因此，问题就转化为求 `LCS("abcd", "bad")` 的长度，然后再加上 1。

 即: `LCS(text1, text2) = 1 + LCS(text1[0...m-2], text2[0...n-2])`

##### 情况二： 最后一个字符不相等

如果 `text1[m-1] != text2[n-1]`，例如 `text1 = "abcde"` 和 `text2 = "axce"`。

 最后一个字符 `'e'` 和 `'f'` 不相等。

那么最长公共子序列**不可能**同时包含 `text1` 的最后一个字符和 `text2` 的最后一个字符。 

所以，最长公共子序列只能来源于以下两种情况之一，并且取其中较长者：

1. `text1` 去掉最后一个字符，和 `text2` 完整比较，即 `LCS(text1[0...m-2], text2)`。
2. `text2` 去掉最后一个字符，和 `text1` 完整比较，即 `LCS(text1, text2[0...n-2])`。

即: `LCS(text1, text2) = max(LCS(text1[0...m-2], text2), LCS(text1, text2[0...n-2]))`

通过以上观察，我们成功地将一个大问题分解为了规模更小的子问题，并且找到了它们之间的关系。这就是状态转移方程的基础。

#### 模式套路匹配

这个问题完美匹配**二维动态规划**的模式，特别是处理**两个序列（字符串、数组等）**相关的问题。

- **模式**: 当你需要比较两个序列 `A` 和 `B`，并且需要构建一个依赖于 `A` 的前缀 `A[0...i]` 和 `B` 的前缀 `B[0...j]` 的解时，通常会使用一个二维DP表 `dp[i][j]`。
- **经典同类问题**:
  - 编辑距离 (LeetCode 72)
  - 不同子序列 (LeetCode 115)
  - 正则表达式匹配 (LeetCode 10)

这些问题的共同点是，`dp[i][j]` 的状态依赖于 `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]` 这几个相邻的状态。

#### 核心思想和套路

根据上面的分析，我们可以定义出DP解法的核心三要素：

##### DP状态定义

`dp[i][j]` 表示 `text1` 的前 `i` 个字符（即 `text1[0...i-1]`）与 `text2` 的前 `j` 个字符（即 `text2[0...j-1]`）的**最长公共子序列的长度**。 

*注意*: `dp` 表的索引 `i` 和 `j` 通常从1开始，对应字符串的长度，这样 `dp[0][...]` 和 `dp[...][0]` 可以方便地表示空字符串的情况，作为边界条件。

##### 状态转移方程

根据我们观察到的规律：

- 如果 `text1.charAt(i-1) == text2.charAt(j-1)`:

$$dp[i][j] = dp[i-1][j-1] + 1$$

- 如果 `text1.charAt(i-1) != text2.charAt(j-1)`:

  $$dp[i][j] = max(dp[i-1][j], dp[i][j-1])$$

##### 状态初始化

创建一个 `(m+1) x (n+1)` 大小的DP表 `dp`。

- `dp[0][j] = 0` ( `text1` 为空字符串时，与任何字符串的LCS长度都是0)。
- `dp[i][0] = 0` ( `text2` 为空字符串时，与任何字符串的LCS长度都是0)。 在代码实现中，创建一个 `(m+1) x (n+1)` 的 `int` 数组，默认值就是0，所以初始化自然完成。

##### 最终答案

我们要求的 `text1` (长度 `m`) 和 `text2` (长度 `n`) 的LCS长度，根据定义，就是 `dp[m][n]`。

#### 实现原理和步骤

1. 获取 `text1` 和 `text2` 的长度，分别记为 `m` 和 `n`。

2. 创建一个二维数组 `dp`，大小为 `(m + 1) x (n + 1)`。

3. 使用两层嵌套循环来填充这个DP表。

   - 外层循环 `i` 从 1 到 `m`。

   - 内层循环 `j` 从 1 到 `n`。

4. 在循环内部，比较 `text1.charAt(i-1)` 和 `text2.charAt(j-1)`。

   - 如果相等，则执行 `dp[i][j] = 1 + dp[i-1][j-1]`。

   - 如果不相等，则执行 `dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`。

5. 循环结束后，DP表被完全填充。返回 `dp[m][n]` 作为最终结果。

####代码实现

```java
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text1.length()==0 || text2 == null || text2.length()==0) return 0;
        int m = text1.length();
        int n = text2.length();

        //dp[i][j] = s1[0...i-1] 和 s2[0...j-1]的公共子序列的最大长度
        int[][] dp = new int[m+1][n+1];
        
       // 从[1...m]遍历text1
        for(int i=1; i<=m; i++){
          //从[1...n]遍历text2
            for (int j=1; j<=n;j++){
              //如果s[i-1] == s[j-1]
                if (text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                  //如果text1[i-1] != text2[j-1] 
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }

        return dp[m][n];
        
    }
```

#### 注意事项

**索引对应关系**: 这是最容易出错的地方。`dp[i][j]` 对应的是 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符。在访问字符串时，需要用 `i-1` 和 `j-1` 作为索引。`dp` 表的 0 行和 0 列作为边界，极大地简化了代码逻辑，避免了在循环中处理 `i=0` 或 `j=0` 的边界判断。

**空间复杂度**: 上述解法的空间复杂度是 O(m×n)。在 `m` 和 `n` 非常大的情况下，可能会导致内存超限。

**空间优化**: 观察状态转移方程 `dp[i][j]` 只依赖于 `dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]`，即只依赖于**上一行**和**当前行**的状态。因此，可以用一个**滚动数组**的思想来优化空间。我们只需要两个一维数组（代表上一行和当前行）或者一个一维数组（如果更新顺序得当）就可以完成计算，将空间复杂度降为 O(min(m,n))。面试中可能会作为追问点。

#### 经验总结

**识别问题**: 当遇到涉及两个字符串/序列，并要求计算最优解（如最长、最短、最大、最小）时，应首先考虑动态规划。

**LCS是基石**: 最长公共子序列是DP问题中的一个经典模型，理解透彻它的解法，对于解决其他很多序列DP问题非常有帮助。它是很多更复杂问题的子问题。

**DP四步法**: 解决DP问题的标准流程是：

- 定义状态 `dp[i]` 或 `dp[i][j]` 的清晰含义。
- 推导出状态转移方程。
- 确定初始化或边界条件。
- 确定最终答案在 `dp` 表中的位置。

**画表示例**: 对于二维DP，在纸上画出DP表，并手动填充几个格子的值，是理解状态转移过程、检查逻辑正确性的最有效方法。

**思考优化**: 在写出标准DP解法后，主动思考是否可以进行空间优化。观察状态转移的依赖关系是优化的关键。如果 `dp[i]` 只依赖 `dp[i-1]`, `dp[i-2]` 等常数个之前的状态，空间就可以被优化。



### Leetcode 72: 编辑距离

#### 场景描述-字符串编辑距离

给定两个字符串 `word1` 和 `word2`，返回将 `word1` 转换为 `word2` 所使用的最少操作数。
 你可以对一个字符串进行以下三种操作之一：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

#### 核心思想+动态规划+双指针指向两个不同的word

这个题目最重要的关键点在于如何理解三个操作：

##### 插入一个字符： 将word[0..i-1]转化为word2[0...j-2]再插入word2[j-1]

这种情况下`dp[i][j]=dp[i][j-1]+1`

##### 删除一个字符：删除word1[i-1]，将word1[0...i-2]转化为word2[0...j-1]

就是将`word1[i-1]`从word1中删除，重新从word1[i-2]计算，这个时候就变成了dp`[i-1][j]`+1 (删除操作)

##### 替换字符：将word1[i-1]替换成word2[j-1]，然后将word1[0..i-2]转化为word2[0..j-2]

将 `word1[i-1]` 替换为 `word2[j-1]`, 剩余的转换次数就是`dp[i-1][j-1]`

将大问题（两个字符串的编辑距离）分解为多个小问题（两个`前缀`的`编辑距离`），使用**递推**或**记忆化搜索**记录子问题的解，避免重复计算。

#### 基本原理

将原问题转化为求解两个字符串前缀之间的最短编辑路径，用二维数组保存中间结果，逐步构造完整解。

#### 状态定义 -`dp[i][j]` 表示将 `word1[0..i-1]` 转换为 `word2[0..j-1]` 的**最小操作数**

令 `dp[i][j]` 表示将 `word1[0..i-1]` 转换为 `word2[0..j-1]` 的**最小操作数**。

####状态转移方程

考虑当前两个字符 `word1[i-1]` 和 `word2[j-1]`：

- **若相等**：无需操作
  `dp[i][j] = dp[i-1][j-1]`
- **若不等**：选择三种操作中最小的一个 + 1

```
dp[i][j] = min(
    dp[i-1][j] + 1,     // 删除 word1[i-1]，删除掉之后，编辑距离就变成了dp[i-1][j]=>word1[0...i-2]和word2[0...j-1] 之间的编辑距离+删除操作本身
    dp[i][j-1] + 1,     // 将word1[0...i-1]转换成word2[0...j-2](操作次数dp[i][j-1])，再在末尾追加字符word[j-1](操作次数1)
    dp[i-1][j-1] + 1    // 替换 word1[i-1] -> word2[j-1]
)
```

##### 删除：删除字符word1[i-1]

就是将`word1[i-1]`从word1中删除，重新从word1[i-2]计算，这个时候就变成了dp`[i-1][j]`+1 (删除操作)

##### 插入：将word[0...i-1]转化为word2[0...j-2]，再追加word[j-1]

这种情况下`dp[i][j]=dp[i][j-1]+1`

##### 替换：将word1[i-1]替换为word2[j-1]

**目标**：将 `word1[i-1]` 替换为 `word2[j-1]`

- 示例：

  - `word1 = "hi"`, `word2 = "ho"`
  - 将 `i` 替换为 `o`，`word1` 变为 `"ho"`，就对齐了

- 状态转移：

  ```
  CopyEdit
  dp[i][j] = dp[i-1][j-1] + 1
  ```

- 解释：这一步我们把两个字符匹配上了（虽然是强行替换的），所以 `i` 和 `j` 都往前推进。



#####  状态转移方程详细解析

为了方便理解，我们假设变化后的字符串是`temp`, `temp[0...m]`和`word2[0...m]`具有相同的值。

在`word1[i-1]`和`word2[j-1]`不同的情况下，需要注意只能通过三种情况来使得`word1[i-1]`上的字符串根`word1[0...i-1]` 变成`word2[0...j-1]`

- 删除`word1[i-1]`, 退回重新从`word1[i-2]` 开始计算，这个时候操作次数就是`dp[i-1][j]`+删除操作
  - 然后将`word1[i-2]`转化成`word2[0...j-1]`,操作数是`dp[i-1][j]`;
  - 删掉原来的`word1[i-1]`, 操作数为`1`;

- 在`word1[0...i-1]`的末尾，插入一个字符`word2[j-1]`,这样它更接近目标字符串`word2[0...j-2]`
  - 我们先把`word1[0...i-1]` 变成`word2[0...j-2]`，这个操作次数是`dp[i][j-1]`
  - 然后再插入一个`word2[j-1]`，得到`word2[0....j-1]`, 操作次数为`1`

- 我们同时回退
  - 然后将`word1[0...i-2]`变成`word2[0...j-2]`,操作次数为`dp[i-1][j-1]`
  - 然后再将`word2[j-1]`插入到`变化后`的`word1[0...i-2]`的最后， 操作数为`1`

####初始化（边界条件）

- `dp[0][j] = j`：空字符串变成 word2 前 j 个字符 → 插入 j 次

- `dp[i][0] = i`：word1 前 i 个字符变成空字符串 → 删除 i 次

#### 推荐学习路径

1. ✅ 先记模板（**真的可以记，别有心理负担**）
2. ✅ 记住含义：`dp[i][j] = word1[0..i-1]` 变成 `word2[0..j-1]` 的最小操作数
3. ✅ 然后对照小例子（比如 "abc" → "ac"）
4. ✅ 最后再去搞懂“为什么是插入、删除、替换”



#### 遍历逻辑

从小到大遍历 `i` 和 `j`（bottom-up），即从 `dp[0][0]` 一直到 `dp[m][n]`，逐步构建完整解。

#### 代码实现

```java
public int minDistance(String word1, String word2){
  int m = word1.length;
  int n = word2.length;
  
  //定义dp数组
  int[][] dp = new int[m+1][n+1];
  
  //初始化边界
  //对于任意i,dp[i][0]=i
  //要么在word1中删掉全部字符（i个字符，操作i次）
  //要么在word2中插入word1中的所有字符(i个字符，操作i次)
  for(int i=0;i<=m;i++) dp[i][0]=i;
  //对于任意i,dp[0][j]=j
  for(int j=0;j<=n;j++) dp[0][j]=j;
  
  //遍历逻辑
  //外层遍历word1
        for (int i = 1; i <= m; i++) {
            char c1 = word1.charAt(i - 1);
          //内层遍历word2
            for (int j = 1; j <= n; j++) {
                char c2 = word2.charAt(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1];  // 无需操作
                } else {
                    dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1,     // 删除
                                 dp[i][j - 1] + 1),    // 插入
                                 dp[i - 1][j - 1] + 1  // 替换
                    );
                }
            }
        }
}
```

### Leetcode 646: 最长对数链

### Leetcode 491: 递增子序列[适用于回溯]

#### 问题要点

**输入**: 一个整数数组 `nums`。

**输出**: 数组中所有不同的、长度至少为 2 的 **非递减** 子序列。

**子序列 (Subsequence)**: 可以通过从原始数组中删除一些（也可以不删除）元素而不改变其余元素的顺序得到。例如 `[4, 7]` 是 `[4, 6, 7, 7]` 的一个子序列。

**非递减 (Non-decreasing)**: 子序列中的后一个元素必须大于或等于前一个元素。例如 `[4, 6, 7, 7]` 是非递减的，但 `[4, 7, 6]` 不是。

**长度至少为 2**: 结果中不能包含单个元素的子序列。

**结果唯一**: 输出中不能包含重复的子序列。例如对于 `[4, 6, 7, 7]`，子序列 `[4, 7]` 只能在结果中出现一次，即使它可以由 `nums[0]` 和 `nums[2]` 构成，也可以由 `nums[0]` 和 `nums[3]` 构成。

#### 问题的本质和分析 - 找到满足特定条件的子集

#####问题的匹配模式 - 回溯算法

这个问题的本质是 **在集合的所有子集中，找到满足特定条件的子集**。

这里的“集合”就是输入数组 `nums`，而“特定条件”就是“非递减”和“长度不小于2”。

当我们看到“所有可能”、“所有组合”、“所有子集”这类字眼时，通常要联想到 **搜索算法**，特别是 **深度优先搜索 (DFS)** 或 **回溯 (Backtracking)**。

##### 问题的挑战 - 如何处理重复子集

这个问题的关键难点在于如何处理重复：

- **数组中元素可能重复**: 例如 `[4, 6, 7, 7]`。

- **最终结果集不能重复**: 不同的选择路径可能产生相同的子序列，例如上面提到的 `[4, 7]`。

一个常见的去重思路是先对数组排序，然后在搜索时跳过相邻的重复元素。

但 **这个问题不能对原数组排序**！因为排序会改变元素的相对顺序，而子序列必须保持原始的相对顺序。

例如，对于 `[4, 7, 6]`，排序后变成 `[4, 6, 7]`，你可能会找到 `[4, 6]`，但这在原数组中是不合法的，因为 6 在 7 之后。

因此，去重操作必须在搜索过程中完成，或者在收集结果后完成。

#### 规律观察 - 决策树

我们可以将寻找子序列的过程想象成一棵决策树。

从数组的第一个元素开始，对于每个元素，我们都有两个选择：

1. 将当前元素加入到正在构建的子序列中。
2. 不将当前元素加入。

这种结构天然适合用递归（回溯）来解决。

##### 如何去重？

去重的关键在于，在递归的 **同一层**，我们**不应该使用相同的元素来开始新的搜索分支**。 

举个例子：`nums = [4, 7, 7]` 我们的搜索过程如下：

```
dfs(startIndex=0, path=[])
|
|--- 选择 nums[0]=4, path=[4]
|    |
|    |--- dfs(startIndex=1, path=[4])
|         |
|         |--- 选择 nums[1]=7, path=[4, 7] -> 收集结果, 继续 dfs(startIndex=2, path=[4, 7])
|         |
|         |--- 选择 nums[2]=7, path=[4, 7] -> 又得到一个 [4, 7]，这是重复的！
|
|--- 不选择 nums[0]=4 (跳过)
|    |
|    |--- ...
```

问题出在 `dfs(startIndex=1, path=[4])` 这一层。

它在索引 1 处选择了 7，又在索引 2 处选择了 7。

对于 `path=[4]` 来说，下一个要添加的元素，无论是第一个 7 还是第二个 7，最终构成的子序列都是 `[4, 7]`。

因此，在这一层递归中，值为 7 的元素只应该被选择一次。

这启发我们：在每一层递归调用中，需要一个机制来记录 **本层已经使用过** 的元素值，防止在同一层再次使用。

#### 模式和套路匹配 - 回溯

这个问题完美匹配 **回溯算法** 的“子集/组合”模型。

- **路径 (Path)**: 当前已经构建的非递减子序列。
- **选择列表 (Choices)**: 从 `startIndex` 到数组末尾的所有元素。
- **结束条件 (End Condition)**: 搜索到数组末尾。
- **剪枝/约束 (Pruning/Constraints)**:
  1. 要加入的元素 `nums[i]` 必须大于或等于 `path` 的最后一个元素。
  2. 在当前递归层级，一个元素值如果已经被用过，就不能再用了（去重关键）。

#### 核心思想和套路

采用回溯算法 (Backtracking) + 剪枝 (Pruning) 来解决。

##### 回溯函数的设计：`dfs(int startIndex, LinkedList<Integer> path)`

定义一个 `dfs(int startIndex, LinkedList<Integer> path)` 函数。

- `startIndex`: 本次搜索的起始索引，确保我们只向后查找，避免产生重复的排列。
- `path`: 从根节点到当前节点的路径，即当前构建的子序列。

##### 结果收集： path.size >= 2

在递归的每一步，只要 `path` 的长度大于等于 2，就将它的一份拷贝加入最终结果集。

##### 去重机制： 核心

这是本题的核心。在 `dfs` 函数的 **每一层循环中**，使用一个 `Set` 或者一个布尔数组来记录当前层已经选择过的元素值。

- 由于 `nums[i]` 的范围是 `[-100, 100]`，我们可以用一个大小为 201 的布尔数组 `used` 来高效地记录。`used[nums[i] + 100]` 即可映射到数组索引。

#### 实现原理和步骤

##### 函数定义和变量初始化

1. 初始化一个全局的 `List<List<Integer>> result` 用于存放最终结果。

2. 初始化一个 `LinkedList<Integer> path` 用于存放当前的子序列。

3. 编写主函数 `findSubsequences`，在其中调用回溯辅助函数 `backtrack(nums, 0, path, result)`。

#####**`backtrack` 函数实现**:

###### **收集结果**: 

如果 `path.size() >= 2`，说明找到了一个合法的子序列，将其 `new ArrayList<>(path)` 加入 `result`。

**注意**：这里必须是 `new` 一个，否则加入的是 `path` 的引用，后续 `path` 的改变会影响 `result` 中的内容。

###### **去重集合**

创建一个只在当前层有效的 `used` 集合/数组。例如 `Set<Integer> visited = new HashSet<>();`。

###### **遍历选择**:

- **剪枝条件1 (非递减)**: 如果 `path` 不为空，且当前元素 `nums[i]` 小于 `path` 的最后一个元素，则跳过 `continue`。
- **剪枝条件2 (同层去重)**: 如果 `visited.contains(nums[i])` 为 `true`，说明当前层已经处理过这个数值了，跳过 `continue`。

###### 做出选择

- 将 `nums[i]` 标记为本层已使用: `visited.add(nums[i]);` 

- 将 `nums[i]` 加入 `path`。 

######**进入下一层递归**: 

调用 `backtrack(nums, i + 1, path, result)`。

注意，下一个起始索引是 `i + 1`。

 ###### **撤销选择 (回溯)**: 

将 `path` 的最后一个元素移除，`path.removeLast()`。

##### 另外一种去重的方法 - `HashSet<List<Integer>>`

如果不想在递归中处理去重，也可以将所有找到的合法子序列（包括重复的）都加入一个 `HashSet<List<Integer>>`，利用 `Set` 的特性自动去重，最后再将 `Set` 转换为 `List`。

这种方法代码更简洁，但可能会因为哈希计算和存储所有中间结果而导致时空开销稍大。

对于本题的数据规模，两种方法都可通过。

#### 实现代码

```Java
//回溯
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtrack(nums,0);
        return res;
    }

    private void backtrack(int[] nums, int start){
        if(path.size() >= 2){
            res.add(new ArrayList<>(path));
        }

        if(start >= nums.length){
            return;
        }

        Set<Integer> visited = new HashSet<>();
        //我们从start - nums.length 中选择每一个元素
        for(int i = start; i < nums.length; i++){
            //如果该元素已经被选择了，剪枝
            if(visited.contains(nums[i])) continue;
            //如果该元素 小于当前路径的最新元素（即子序列的最大元素），剪枝
            if(!path.isEmpty() && nums[i] < path.getLast()){
                continue;
            }

            path.add(nums[i]);
            visited.add(nums[i]);
            backtrack(nums, i+1);
            path.remove(path.size() - 1);
        }
    }

}
```

#### 注意事项

##### **不能排序**: 

再次强调，绝对不能对原数组 `nums` 进行排序。

##### **去重的实现**: 

“层级去重”是本题最优美的解法。

`used` 数组必须在 `backtrack` 函数的循环之前定义，这样它只对当前层有效。如果定义成全局变量，就会导致不同层级的相同数值也被错误地去重。

##### **结果的收集时机**: 

与常规的求所有子集问题不同（通常在叶子节点收集结果），本题只要路径长度 `>= 2` 就要收集一次。收集操作应放在递归函数的入口处。

##### **深拷贝路径**: 

`result.add(new ArrayList<>(path))` 必须是深拷贝，不能直接 `add(path)`。

##### **数据结构选择**: 

使用 `LinkedList` 作为 `path`，因为它的 `addLast` 和 `removeLast` 操作是 O(1) 时间复杂度，比 `ArrayList` 在尾部增删更高效。

#### 经验总结

eetCode 491 是一道非常经典的回溯算法题，它融合了子集问题和去重问题，并且增加了一个关键的“不可排序”的限制。

**掌握“层级去重”模式**：当遇到输入包含重复元素且不能排序的组合/子集问题时，“在递归的每一层维护一个 `used` 集合”是一个标准的、可复用的套路。这个套路也适用于 LeetCode 90 (Subsets II)，只不过那题可以排序，解法会稍有不同但思想相通。

**识别回溯信号**: “寻找所有解”、“所有组合/子集”是使用回溯的强烈信号。

**剪枝是优化的关键**: 仔细分析题目约束（如“非递减”），并将其转化为回溯过程中的剪枝条件，可以大大减少不必要的搜索，提高算法效率。

**数据范围的妙用**: 注意到 `nums[i]` 的范围是 `[-100, 100]`，这提示我们可以用数组代替哈希表来进行去重，实现常数时间的查找和插入，性能更优。这在算法竞赛中是一个常见的优化技巧。

### Leetcode 674: 最长连续递增子序列

#### 问题要点

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

####核心思想 - dp[i]表示以nums[i]结尾的最大递增子序列的长度

##### 怎么映射到这个模式的？

我们需要计算每一个元素所在的最长子序列的长度，并且最终找到一个最长的子序列，这个场景比较明显，在所有的候选元素中选择出符合条件的。

##### DP定义和初始化

定义一个`int dp[n]`: `dp[i]`表示以`nums[i]`结尾的最大递增子序列的长度

因为每一个元素都可以是一个独立的子序列，因此我们初始化DP的所有值为`1`:

`Arrays.fill(dp,1)`

 ##### 遍历和状态转移过程

- 从1到`n-1`遍历每一个元素

- 对于每一个元素，对比其和前一个元素的大小

  - 如果大于前一个元素，则更新其对应的dp值

    `dp[i] = dp[i-1] + 1`

  - 如果不大于，则什么都不做（保持为1）

#### 代码实现

```Java
//最长连续递增子序列
//方法一：动态规划？
//dp[i]表示以nums[i]结尾的最长连续递增子序列的长度
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);

        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i-1]){
                dp[i] = dp[i-1] + 1;
            }
        }

        int max = 0;
        for(int len : dp){
            if(len > max){
                max = len;
            }
        }

        return max;
    }
}
```



### Leetcode 1062: 最长重复子串

#### 问题要点

1. **输入**: 一个字符串 `S`。
2. **输出**: 一个整数，代表最长重复子串的长度。
3. **"重复"的定义**: 子串在原字符串中出现了至少两次。
4. **重叠(Overlap)**: 允许重叠。例如，在 `"aaaaa"` 中，`"aaaa"` 是一个重复子串，它在索引0和索引1处分别开始。
5. **空结果**: 如果没有任何子串重复，则返回 `0`。

**示例:**

- `S = "abcd"` -> `0` (没有重复的子串)
- `S = "abbaba"` -> `2` (子串 `"ab"` 和 `"ba"` 都重复了，最长的是2)
- `S = "aabcaabdaab"` -> `3` (子串 `"aab"` 重复了)

#### 问题的本质和分析 - 如何找出重复的子串？

问题的本质是在一个字符串中寻找两个完全相同的子串 `S[i:i+L]` 和 `S[j:j+L]`（其中 `i != j`），并使得它们的长度 `L` 最大。

##### 朴素的暴力方法

一个最直观的想法是，枚举所有可能的子串，然后检查每个子串是否在字符串的其他位置出现。

- 生成所有子串：两层循环，$O(N^2)$。
- 对于每个子串，检查它是否在字符串的其余部分再次出现：$O(N)$。
- 总时间复杂度：$O(N^3)$。

对于 LeetCode 通常 `N` 在几千的范围，$O(N^3)$ 的算法会超时。

因此，我们需要更高效的算法。

这个问题引导我们去思考更经典的算法模式。



#### 规律观察 

两个字符串 `S1` 和 `S2` 的最长公共后缀的长度，与 `S1` 去掉最后一个字符和 `S2` 去掉最后一个字符后的最长公共后缀有关。

如果 `S1` 和 `S2` 的最后一个字符相同，则长度加一；否则为零。

这暗示了**动态规划**的可能性。



#### 模式套路匹配 (Pattern/Template Matching)

问题可以分解为重叠的子问题，并且具有最优子结构。

特别是在处理序列和字符串的 "最长公共..." 问题时非常常见。



此问题可以转化为 "字符串与其自身的最长公共子串" 问题，但要**排除掉公共子串在同一位置**的情况。

我们可以定义一个 `dp[i][j]` 来表示以 `S[i-1]` 和 `S[j-1]` 结尾的公共子串的长度。

#### 核心思想和套路 - 字符串和自身的最长公共子串问题

这个问题可以看作是字符串 `S` 和它自身的 "最长公共子串" (Longest Common Substring) 问题的一个变种。

我们定义 `dp[i][j]` 为：**必须以 `S[i-1]` 结尾**的子串和**必须以 `S[j-1]` 结尾**的子串的最长公共后缀的长度。

**状态转移方程**:

- 如果 `S[i-1] == S[j-1]`，那么我们可以将这个相同的字符续到之前的公共后缀上，所以 `dp[i][j] = dp[i-1][j-1] + 1`。
- 如果 `S[i-1] != S[j-1]`，那么以它们结尾的公共后缀不存在，长度为 `0`，所以 `dp[i][j] = 0`。

##### 关键约束 - 起始位置不能够相同

题目要求是 "重复" 子串，意味着子串的起始位置必须不同。

当我们计算 `dp[i][j]` 时，它代表的两个子串分别结束于 `i-1` 和 `j-1`。

为了确保它们不是同一个子串，我们只需要保证 `i != j`。

在遍历 `dp` 表时，我们可以让内层循环 `j` 的范围小于 `i`（例如 `j` from 1 to `i-1`），这样自然就保证了 `i` 和 `j` 不相等。

##### 最终答案

在填充整个 `dp` 表的过程中，所有 `dp[i][j]` (其中 `i != j`) 的最大值就是我们要求的答案。



#### 实现原理和步骤

获取字符串长度 `N`。

创建一个二维数组 `dp[N+1][N+1]`。

初始化最大长度 `maxLength = 0`。

使用两层嵌套循环遍历 `dp` 表：

- 外层循环 `i` 从 `1` 到 `N`。
- 内层循环 `j` 从 `1` 到 `i-1`。（**注意**：`j` 的上界是 `i-1`，这巧妙地保证了我们总是在比较两个不同位置的子串）。

在内层循环中：

- 检查 `S.charAt(i-1) == S.charAt(j-1)`。
- 如果相等，`dp[i][j] = dp[i-1][j-1] + 1`。
- 更新 `maxLength = Math.max(maxLength, dp[i][j])`。

循环结束后，返回 `maxLength`。

#### 实现代码

```Java
public class Solution {
    public int longestRepeatingSubstring(String S) {
        int n = S.length();
        if (n == 0) {
            return 0;
        }

        // dp[i][j] 表示以 S[i-1] 和 S[j-1] 结尾的最长重复子串的长度
        int[][] dp = new int[n + 1][n + 1];
        int maxLength = 0;

        for (int i = 1; i <= n; i++) {
            // j < i 确保了我们比较的是两个不同的子串
            for (int j = 1; j < i; j++) {
                if (S.charAt(i - 1) == S.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    maxLength = Math.max(maxLength, dp[i][j]);
                }
                // 如果字符不相等，dp[i][j] 默认为 0，无需操作
            }
        }
        return maxLength;
    }
}
```

#### 注意事项

#####**DP 循环边界**: 

在 DP 解法中，`for (int j = 1; j < i; j++)` 是代码的核心。

它保证了比较的两个子串的结束位置 `i-1` 和 `j-1` 是不同的，从而避免了子串与自身的比较。

#### 经验总结

**识别问题模式**: 这个题目是检验对基本算法模式识别能力的好例子。看到 "最长/最大" 且答案有单调性，优先考虑**二分查找答案**。看到 "子串/序列/公共部分"，优先考虑**动态规划**。

**权衡不同解法**:

- **DP 解法 (O(N2))**: 思路相对直接，代码简洁，对于 `N` 不超过几千的情况是标准且足够高效的解法。
- **二分查找解法 (O(N2logN) 或优化后 O(NlogN))**: 当 `N` 非常大时，经过优化的二分查找会更快。它将问题分解为更简单的判定问题，是解决 "求最大/最小" 问题的一个非常强大的通用框架。

**最优解法**: 理论上，此问题可以通过**后缀数组** (Suffix Array) 或**后缀树** (Suffix Tree) 在 O(NlogN) 或 O(N) 的时间内解决。

但这两种数据结构实现复杂，在常规算法面试中不常要求现场写出，但了解其思想可以作为加分项。对于此题，DP 解法通常是面试官期望看到的满意答案。



### Leetcode 2008: 出租车的最大盈利[区间调度问题]

#### 问题要点

**输入**: 一个整数 `n` 代表一个从 1 到 `n` 的路径，以及一个二维数组 `rides`。

**`rides` 数组**: 每个元素 `rides[i] = [start_i, end_i, tip_i]` 代表一个乘车请求。

- `start_i`: 乘客上车点。
- `end_i`: 乘客下车点。
- `tip_i`: 这趟行程的小费。

**收益计算**: 一趟行程的收益为 `(end_i - start_i) + tip_i`。

**约束条件**:

- 司机从点 1 开始，并且初始没有乘客。
- 司机不能同时接两个重叠的行程。也就是说，如果司机接了 `[start, end, tip]` 的行程，他必须在 `end` 点之后才能开始新的行程。
- 司机可以空驶（不载客）。

**目标**: 计算司机从点 1 到点 `n`

#### 问题的本质和分析 - 带有选择的优化问题

这个问题的本质是一个**带有选择的优化问题**。

在路径上的每一个点，司机都需要做出决策：

##### 决策1：空驶

从点 `i-1` 空驶到点 `i`。这种情况下，在点 `i` 的收益等于在点 `i-1` 的最大收益。

##### 决策2：完成一趟行程

如果在点 `i` 刚好有乘客下车，那么司机可以选择完成这趟行程。假设这趟行程是从 `start` 开始的，那么在点 `i` 的收益就等于**在点 `start` 时的最大收益** 加上 **这趟行程本身的收益**。

#### 规律观察



### Leetcode 718: 最长重复子数组

###Leetcode 1537: 最大得分

### Leetcode 2361: 乘坐火车的最少费用

### Leetcode 956: 最高的广告牌

