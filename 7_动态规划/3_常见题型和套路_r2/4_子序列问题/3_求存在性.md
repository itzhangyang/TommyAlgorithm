## 求存在性： 判断是否存在某种满足特定条件的字符串

这类问题不关心具体值或数量，只关心**“是否可能”**，通常返回 `true` 或 `false`。

### 场景和目标

- **场景**: 通常是处理单个或两个数组/字符串。
- **目标**: 判断是否存在一个子序列满足特定属性（例如，和为 `target`，能拼成某个单词等）。

### 核心思想和套路 - 逻辑或

核心思想是**逻辑或 (OR)**。

如果一个状态可以从任何一个可达的（`true`）前驱状态转移而来，那么这个状态也变为可达（`true`）。

当我们考虑状态 `i` 时，我们会思考：

- 状态 `i` 能否实现？
- 这取决于是否存在**至少一个**前驱状态 `j` 是 `true`，并且从 `j` 到 `i` 的转移是合法的。
- `$dp[i] = dp[j1] || dp[j2] || ...$` (其中 `j1, j2` 是合法的前驱状态)

### 实现原理

#### DP状态的定义 - Boolean类型数组

`$dp[i]$` 或 `$dp[i][j]$` 是一个**布尔值**，表示“...的可能性是否存在”。

#### 转移方程

转移方程的核心是**逻辑或 `||`**。例如，在“分割等和子集”问题中（可以转化为0/1背包问题）：

`$dp[i][j]$` = 是否可以用前 `i` 个数凑出和为 `j`。

要凑出 `j`，可以不使用 `nums[i-1]`，也可以使用 `nums[i-1]`：

- 不使用 `nums[i-1]`：可能性取决于 `$dp[i-1][j]$`
- 使用 `nums[i-1]`：可能性取决于 `$dp[i-1][j - nums[i-1]]$`

只要两者之一为 `true`，`$dp[i][j]` 就为 `true`。

```
$dp[i][j] = dp[i-1][j] || dp[i-1][j - nums[i-1]]$
```

### 代码套路模板 - 分割等和子集

```Python
def check_existence(nums):
    target_sum = sum(nums) / 2 # 假设已处理总和奇偶等情况
    n = len(nums)

    # 1. 定义: dp[j] 是能否凑出和为 j
    # (使用空间优化后的1D DP)
    dp = [False] * (int(target_sum) + 1)

    # 3. 初始化: 凑出和为 0 是永远可以的 (什么都不选)
    dp[0] = True

    # 2. 遍历所有物品 (状态)
    for num in nums:
        # 从后往前遍历，防止物品被重复使用
        for j in range(int(target_sum), num - 1, -1):
            # 4. 状态转移: 逻辑或
            dp[j] = dp[j] or dp[j - num]

    # 5. 返回最终结果
    return dp[int(target_sum)]
```

### 注意事项

1. **基准情况 (Base Case)**：必须有一个初始的 `true` 状态作为所有推导的起点。通常是 `$dp[0]` 或 `$dp[0][0]`，表示一个“空”或“平凡”的初始条件是可达的。
2. **转移条件的严谨性**：确保状态转移的逻辑判断无误。例如，在背包问题中，`j >= item_weight` 这个条件必须满足才能进行转移。
3. **空间优化**：许多存在性问题（特别是背包类）的DP可以从二维优化到一维，此时要注意内层循环的遍历方向（正向或反向）。

### 经验总结

存在性问题的本质是**在状态空间中进行可达性分析**。`dp` 表就像一张地图，标记了哪些状态点是可以到达的。解题的关键是找到初始的出发点（`true`），并根据规则（转移方程）将可达性传播出去。

### Leetcode 10：正则表达式匹配[热门题目]

给你一个字符串 `s` 和一个字符模式 `p`，请你实现一个支持 **'.'** 和 **'\*'** 的正则表达式匹配。

- `'.'`：匹配任意单个字符
- `'*'`：匹配 **前一个字符** 0 次或多次

**要求：必须匹配整个字符串，而不是部分匹配。**

- `isMatch("aa", "a")` → `false` (模式 `a` 只能匹配一个 'a')
- `isMatch("aa", "a*")` → `true` (`*` 匹配了两个 'a')
- `isMatch("ab", ".*")` → `true` (`.` 匹配 'a', `*` 匹配了前面的 `.` 一次，所以 `.` 匹配了 'b')
- `isMatch("aab", "c*a*b")` → `true` (`c*` 匹配零个 'c', `a*` 匹配两个 'a', `b` 匹配 'b')

#### 问题本质和分析

这个问题的本质是一个**状态匹配**问题。

我们需要判断在字符串 `s` 的某个位置 `i` 和模式 `p` 的某个位置 `j`，之前的子串是否能够成功匹配。

问题的难点在于 `*` 的存在，它引入了**不确定性**：

##### 问题的不确定性 - * 代表几个字符 - 跳过/一次/多次

1. `x*` 可以匹配 0 次 `x`，相当于 `x*` 这部分在模式中被“跳过”了。
2. `x*` 可以匹配 1 次或多次 `x`，这要求字符串 `s` 中的当前字符必须是 `x`（或者 `.`），然后继续用 `x*` 匹配 `s` 的下一个字符。

这种不确定性和选择性（匹配0次还是多次）使得**简单的双指针线性扫描法无法解决**。

因为当我们在 `s` 中匹配了一个字符后，我们不知道模式 `p` 的指针是否应该前进。

例如，对于 `s = "aaa"` 和 `p = "a*"`，当 `s` 的第一个 `a` 匹配后，`p` 的指针应该停留在 `a*` 这里，继续用来匹配 `s` 的第二个 `a`。

这种**一个状态的决策依赖于之前多个子问题的结**的特性，强烈地指向了**动态规划 (Dynamic Programming)** 或 **记忆化搜索 (Memoization)**。

#### 规律观察

我们从后往前（或者从前往后）考虑匹配过程。

定义一个状态 `dp[i][j]` 表示 `s` 的前 `i` 个字符 (`s[0...i-1]`) 能否被 `p` 的前 `j` 个字符 (`p[0...j-1]`) 成功匹配。

在推导状态转移时，我们需要观察 `p` 的第 `j` 个字符 `p[j-1]`：

##### 如果`p[j-1]`不是`*`

这是最简单的情况。

要使`dp[i][j]`为`true`，必须满足两个条件：

- `s`的第`i`个字符`s[i-1]`和`p`的第`j`个字符`p[j-1]`必须匹配，即
  - `s[i-1] == p[j-1]`， 或者
  - `p[j-1] == '.'`
- 并且，他们前面的子串也必须是匹配的，即`dp[i-1][j-1]`为`true`

##### 如果`p[j-1]`是`*` - 最核心的复杂情况

`*` 不能独立存在，它必须和它前面的字符 `p[j-2]` 结合起来看，例如 `a*` 或 `.*`。

此时我们有两种选择来处理 `p[j-2]*` 这个组合：

###### Option 1: `*` 匹配0次: `dp[i][j-2] == true`

我们让 `p[j-2]*` 这个组合匹配 0 个字符，相当于直接“无视”或“跳过”它。

那么 `s` 的前 `i` 个字符能否被 `p` 的前 `j` 个字符匹配，就完全取决于 `s` 的前 `i` 个字符能否被 `p` 的前 `j-2` 个字符匹配（即跳过了 `p[j-2]*`）。

所以，此时 `dp[i][j]` 的一个可能来源是 `dp[i][j-2]`。

###### Option 2: `*`匹配一次或者多次

- 要让`p[j-2]*`至少匹配一个字符，前提是`s`的当前字符`s[i-1]`和`p[j-2]`匹配，即

  - `s[i-1] == p[j-2]`， 或者
  - `p[j-2] == '.'`

- 如果这个前提满足，那么我们消耗掉了 `s` 的一个字符 `s[i-1]`。

  问题就转化为：`s` 的前 `i-1` 个字符 (`s[0...i-2]`) 能否被 `p` 的前 `j` 个字符 (`p[0...j-1]`) 匹配。

  注意，这里是**  `p` 的前 `j` 个字符 **，而不是 `j-1` 或 `j-2`。

  因为 `p[j-2]*` 这个组合可以继续用来匹配 `s` 中更多的字符。

  所以，此时 `dp[i][j]` 的另一个可能来源是 `dp[i-1][j]` (前提是 `s[i-1]` 和 `p[j-2]` 匹配)。

###### 总结 `*` 的情况

只要上述两种选择 (a 或 b) 中有一种能成功，`dp[i][j]` 就为 `true`。

- `dp[i][j] = dp[i][j-2]` (匹配0次) `||` (`s[i-1]` 匹配 `p[j-2]` `&&` `dp[i-1][j]`) (匹配1次或多次)。

#### 模式套路匹配

此问题完全符合**二维动态规划**的模式，特别是用于解决涉及两个字符串（或序列）的匹配问题。

**套路**: 定义 `dp[i][j]` 为两个输入的前缀 `s[0...i-1]` 和 `p[0...j-1]` 之间的关系。

**经典同类问题**:

- 最长公共子序列 (Longest Common Subsequence)

- 编辑距离 (Edit Distance)

- 通配符匹配 (Wildcard Matching - LeetCode 44)

这个套路的核心是构建一个二维表格，通过解决小规模的子问题（短前缀的匹配）来逐步构建出最终问题的解。

#### 核心思想和套路 - 填表

##### 状态定义

`dp[i][j]` 是一个布尔值，表示 `s` 的前 `i` 个字符 (`s.substring(0, i)`) 是否能与 `p` 的前 `j` 个字符 (`p.substring(0, j)`) 匹配。

##### DP的大小

`boolean dp[s.length() + 1][p.length() + 1]`。 

- 一维的长度是`s.length()+1`， 表示s的前`i`个字符
- 一维的长度是`p.length()+1`，表示`p`的前`j`个字符

##### 状态转移方程

基于上述规律得出：

```Java
// Case 1: p的第j个字符 p[j-1] 不是 '*'
if (p.charAt(j-1) != '*') {
    if (matches(s, p, i, j)) { // s[i-1]与p[j-1]匹配
        dp[i][j] = dp[i-1][j-1];
    }
}
// Case 2: p的第j个字符 p[j-1] 是 '*'
else { // p.charAt(j-1) == '*'
    // 选择 a: '*' 匹配 0 次，直接忽略 p[j-2]*
    dp[i][j] = dp[i][j-2];

    // 选择 b: '*' 匹配 1 次或多次
    if (matches(s, p, i, j-1)) { // s[i-1]与p[j-2]匹配
        dp[i][j] = dp[i][j] || dp[i-1][j];
    }
}
```

`matches(s, p, i, j)` 是一个辅助函数，用于判断 `s[i-1]` 和 `p[j-1]` 是否匹配（考虑 `.` 的情况）。

增加一行一列是为了方便处理边界情况，例如空字符串。`dp[0][0]` 代表空字符串 `s` 与空模式 `p` 的匹配。

##### 初始化

`dp[0][0] = true`: 空字符串 `s` 与空模式 `p` 是匹配的。

处理第一行 `dp[0][j]`：空字符串 `s` 与模式 `p` 的匹配。只有当 `p` 是 `a*`，`a*b*`，`a*b*c*` 这类形式时才可能匹配。

- 所以 `dp[0][j]` 为 `true` 的条件是 `p[j-1]` 是 `*` 并且 `dp[0][j-2]` 为 `true` (即 `*` 前面的模式也能匹配空串)。

#### 实现原理和步骤

获取字符串 `s` 和模式 `p` 的长度 `m` 和 `n`。

创建一个 `(m+1) x (n+1)` 的布尔型二维数组 `dp`。

**初始化**:

- `dp[0][0] = true`。
- 遍历 `p`，初始化第一行 `dp[0][j]`。如果 `p[j-1] == '*'`，则 `dp[0][j] = dp[0][j-2]`。

**填表**:

- 使用两层嵌套循环，外层 `i` 从 `1` 到 `m`，内层 `j` 从 `1` 到 `n`。
- 在循环内部，根据 `p.charAt(j-1)` 的值，应用上面推导出的状态转移方程。
- 可以写一个 `matches` 辅助函数来提高代码可读性，判断 `s.charAt(i-1)` 和 `p.charAt(j-1)` 是否匹配。当 `p` 的字符是 `.` 时，也返回 `true`。

**返回结果**:

- 整个表格填写完毕后，最终的答案就是 `dp[m][n]`。

#### 实现代码

```Java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] dp = new boolean[m+1][n+1];

        //dp[0][j] = true when p[j-1] == * && dp[0][j-1]
        dp[0][0] = true;
        for(int j = 1; j <= n; j++){
            //注意题目的前提，*不会出现在第一个字符位置
            if (p.charAt(j - 1) == '*') {
                // 如果 p[j-1] 是 '*'，它可以匹配0次前面的元素
                // 所以 dp[0][j] 的状态取决于 dp[0][j-2]
                if (j >= 2) {
                    dp[0][j] = dp[0][j - 2];
                }
            }
        }

        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(p.charAt(j-1) != '*'){
                    dp[i][j] = matches(s, p, i, j) && dp[i-1][j-1];
                }else{
                    //匹配0个的情况，直接忽略p[j-2],基于p[j-3]基础即可
                    dp[i][j] = dp[i][j-2];
                    //匹配1个或者多个
                    //s[i-1]和p[j-2]匹配，并且前i-1个和前j个字符已经匹配？
                    if(matches(s, p, i, j-1)){
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }

    private boolean matches(String s, String p, int i, int j){
        char sc = s.charAt(i-1);
        char pc = p.charAt(j-1);
        if(pc == '.'){
            return true;
        }else{
            return sc == pc;
        }
    }
}
```

#### 注意事项 (Important Notes)

#####**索引对应**: 前`i/j`个字符而不是以第`i/j`个字符结尾 

DP 数组中的索引 `i` 和 `j` 分别对应字符串中的第 `i` 个和第 `j` 个字符，即 `s.charAt(i-1)` 和 `p.charAt(j-1)`。这是一个常见的易错点。

##### **`*` 的位置的保证**:

 题目保证 `*` 不会是模式 `p` 的第一个字符。这简化了我们的逻辑，因为当我们遇到 `*` (在 `p[j-1]`) 时，总能安全地访问它前面的字符 `p[j-2]`（只要 `j >= 2`）。

#####**空字符串**:

 DP 表格 `+1` 的大小对于优雅地处理空字符串（`i=0` 或 `j=0`）至关重要。

##### **两种选择的逻辑或**: 

对于 `*` 的情况，是 “匹配0次” **或者** “匹配1次或多次”，所以状态转移是 `dp[i][j-2] || (...)`，使用逻辑或 `||` 连接两种可能性。

#### 经验总结 (Experience Summary)

**识别 DP 信号**: 当问题涉及到字符串（或数组）匹配，且存在不确定性的选择（如 `*` 带来的“匹配0次还是多次”），导致需要回溯或考虑多种可能时，通常是动态规划的强信号。

**定义清晰的状态**: `dp[i][j]` 的定义是解决问题的基石。定义“`s` 的前 `i` 个字符和 `p` 的前 `j` 个字符是否匹配”是最直观和有效的。

**分类讨论**: 解决 DP 问题的关键是推导出状态转移方程。通过对问题中的关键元素（此题中的 `*`）进行全面的分类讨论，可以帮助你理清逻辑。

- `p[j-1]` 不是 `*` (简单情况)
- `p[j-1]` 是 `*` (复杂情况)
  - `*` 匹配 0 次
  - `*` 匹配 1+ 次

**处理边界/初始条件**: 初始值（如 `dp[0][0]`）和边界行/列（如 `dp[0][j]`）的正确设置是 DP 成功的保障。思考“当一个字符串为空时，另一个字符串/模式应该是什么样才能匹配？”。

**自顶向下 vs 自底向上**: 本题解采用了自底向上（填表法）的 DP。同样也可以用自顶向下（递归 + 记忆化）的方式实现，代码可能更贴近人的直观思考过程，但两者在本质和时间复杂度上是等价的。对于面试，两种方法都应该掌握。

### Leetcode 44: 通配符匹配

给定一个字符串 `s` 和一个包含通配符的模式 `p`，实现一个函数来判断 `s` 是否能被 `p` 完全匹配。

通配符包含两个：

- `?`：可以匹配任何**单个**字符。
- `*`：可以匹配**任意序列**的字符（包括空序列）。

要求是**完全匹配**，即整个字符串 `s` 都需要被模式 `p` 覆盖。

示例：

- `s = "aa"`, `p = "a"` → `false` (模式 `p` 没有覆盖整个 `s`)
- `s = "aa"`, `p = "*"` → `true` (`*` 匹配了整个 "aa")
- `s = "cb"`, `p = "?a"` → `false` (`?` 匹配了 'c'，但 'a' 不匹配 'b')
- `s = "adceb"`, `p = "*a*b"` → `true` (第一个 `*` 匹配空序列，第二个 `*` 匹配 "dce")
- `s = "acdcb"`, `p = "a*c?b"` → `false`

#### 问题本质和分析

这个问题的本质是**带有状态的序列匹配**。

传统的字符串匹配算法（如 KMP）在这里不适用，因为通配符，尤其是 `*`，引入了不确定性。

`*` 的存在使得匹配关系不再是简单的一对一。

一个 `*` 可以匹配0个、1个或多个字符，这导致了匹配可能性的爆炸式增长。

当我们从左到右进行匹配时，如果遇到 `*`，我们面临一个选择：

1. 让这个 `*` 匹配空序列，然后用 `p` 中 `*` 后面的部分去匹配 `s` 的当前位置。
2. 让这个 `*` 匹配 `s` 中的一个字符，然后继续用这个 `*` 去匹配 `s` 后面的字符（因为它能匹配多个）。

这种选择和依赖于子问题结果的特性，强烈暗示了**动态规划（Dynamic Programming）**或**带备忘录的递归（Memoization）**是解决此问题的经典方法。

题目和Leetcode差不多，但是缺少了一个重要的约束：`*`号不会出现在第一个位置。

#### 规律观察和核心思想

让我们定义一个二维状态来解决这个问题。

 使用一个二维布尔数组 `dp[i][j]`，其中 `dp[i][j]` 表示字符串 `s` 的前 `i` 个字符 (`s[0...i-1]`) 是否能与模式 `p` 的前 `j` 个字符 (`p[0...j-1]`) 成功匹配。

我们的目标就是求出 `dp[s.length()][p.length()]`。

为了构建 `dp` 表，我们需要推导出状态转移方程，即 `dp[i][j]` 如何由之前的状态（如 `dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]`）计算出来。

我们考察 `p` 的第 `j` 个字符 `p[j-1]`（因为字符串索引从0开始）：

##### `p[j-1]`是普通字符的情况

要想 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符匹配，那么 `s` 的第 `i` 个字符 `s[i-1]` 必须与 `p` 的第 `j` 个字符 `p[j-1]` 相同。

此外，`s` 的前 `i-1` 个字符也必须和 `p` 的前 `j-1` 个字符匹配。 

所以：`dp[i][j] = (s[i-1] == p[j-1]) && dp[i-1][j-1]`

#####`p[j-1]`是`?`的情况

`?` 可以匹配任何单个字符。

所以，我们不关心 `s[i-1]` 是什么，只要 `s` 的前 `i-1` 个字符和 `p` 的前 `j-1` 个字符匹配即可。

 所以：`dp[i][j] = dp[i-1][j-1]`

##### `p[j-1]`是`*`的情况

###### 匹配空子串的情况

`*` 不匹配任何字符。

在这种情况下，`p` 的前 `j` 个字符要想匹配 `s` 的前 `i` 个字符，就等同于 `p` 的前 `j-1` 个字符（即去掉这个 `*`）要匹配 `s` 的前 `i` 个字符。

 状态转移：`dp[i][j]` 取决于 `dp[i][j-1]`。

###### 匹配一个或者多个字符的情况

`*` 至少匹配 `s` 中的一个字符 `s[i-1]`。

在这种情况下，`p` 的前 `j` 个字符要想匹配 `s` 的前 `i` 个字符，就等同于 `p` 的前 `j` 个字符（`*` 可以继续使用）要匹配 `s` 的前 `i-1` 个字符。

 状态转移：`dp[i][j]` 取决于 `dp[i-1][j]`。

因为 `*` 只要满足以上两种情况之一即可，所以我们将它们用“或”(`||`)连接起来。 所以：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`

##### 边界情况的考虑

- `dp[0][0] = true`：空字符串 `s` 和空模式 `p` 是匹配的。

- `dp[i][0]` (当 `i > 0`)：`false`。因为非空字符串 `s` 无法与空模式 `p` 匹配。

- `dp[0][j]` (当 `j > 0`)：空字符串 `s` 与非空模式 `p` 的匹配情况。

  只有当 `p` 的前 `j` 个字符都是 `*` 时才可能匹配。例如 `s=""`, `p="***"`。

  所以：`dp[0][j] = (p[j-1] == '*') && dp[0][j-1]`

#### 实现原理和步骤

##### 初始化：创建DP数组

创建一个 `(s.length() + 1) x (p.length() + 1)` 的二维布尔数组 `dp`。

##### 设置边界条件

- `dp[0][0] = true`。

- 初始化第一行 `dp[0][j]`：遍历 `p`，如果 `p[j-1]` 是 `*`，则 `dp[0][j]` 继承自 `dp[0][j-1]`。

##### 状态DP填充过程

使用两层循环，外层遍历 `s`（从 `i = 1` 到 `s.length()`），内层遍历 `p`（从 `j = 1` 到 `p.length()`）。

##### 状态转移方程

在循环内部，根据 `p.charAt(j-1)` 的值，应用前面分析的三种状态转移规则来计算 `dp[i][j]`。

- 如果`p[j-1]`是普通字符

  ```Java
  dp[i][j] = p[j-1] == s[i-1] && dp[i-1][j-1];
  ```

- 如果`p[j-1]`是`?`

  ```Java
  dp[i][j] = dp[i-1][j-1];
  ```

- 如果`p[j-1]`是`*`

  ```Java
  dp[i][j] = dp[i-1][j] || dp[i][j-1]
  ```

#### 实现代码

```Java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        // dp[i][j]: s的前i个字符是否能与p的前j个字符匹配
        boolean[][] dp = new boolean[m + 1][n + 1];

        // 1. 初始化边界条件
        // dp[0][0] = true: 空s和空p匹配
        dp[0][0] = true;

        // dp[i][0] (i > 0) 默认为 false: 非空s和空p不匹配

        // dp[0][j]: 空s和非空p的匹配
        // 只有当p的前缀都是'*'时才可能为true
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 1];
            }
        }

        // 2. 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char sChar = s.charAt(i - 1);
                char pChar = p.charAt(j - 1);

                if (pChar == '*') {
                    // '*' 的情况:
                    // dp[i][j-1]: '*' 匹配空序列
                    // dp[i-1][j]: '*' 匹配一个或多个字符
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else if (pChar == '?' || sChar == pChar) {
                    // '?' 或 字符匹配 的情况:
                    // 当前字符匹配，结果取决于之前的子串是否匹配
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // else: pChar是普通字符且与sChar不匹配，dp[i][j] 默认为 false
            }
        }

        // 3. 返回最终结果
        return dp[m][n];
    }
}
```

#### 注意事项

- **索引对应**：DP表的大小是 `(m+1) x (n+1)`，`dp[i][j]` 对应 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符。因此，在代码中访问字符串时，需要用 `s.charAt(i-1)` 和 `p.charAt(j-1)`。
- **空间优化**：注意到 `dp[i][j]` 的计算只依赖于第 `i` 行和第 `i-1` 行的数据。因此，可以使用滚动数组或一维数组将空间复杂度从 O(m×n) 优化到 O(n)。但对于理解算法核心思想，二维数组更清晰。
- **贪心算法**：此题也可以用贪心+回溯的思路解决，但逻辑更复杂，容易出错。当遇到 `*` 时，记录下当前 `*` 的位置和 `s` 的匹配位置，然后继续匹配。如果后续匹配失败，则回溯到 `*` 的位置，让 `*` 多匹配一个 `s` 中的字符，再继续尝试。DP方法更通用且不易出错。

#### 经验总结

**识别DP信号**：当问题涉及到两个序列（字符串/数组）的匹配，并且存在复杂的、可分支的匹配规则（如 `*`），这通常是应用动态规划的强烈信号。

**定义状态是关键**：`dp[i][j]` 的定义是解决问题的基石。清晰地定义状态（例如，`s`的前`i`个字符和`p`的前`j`个字符是否匹配）使得后续的状态转移推导变得顺理成章。

**处理 `\*` 是核心**：本题与 LeetCode 10. 正则表达式匹配 非常相似，但 `*` 的含义不同。理解 `*` 的两种核心功能——“匹配空”和“匹配非空”——并将其转化为 `dp[i][j-1]` 和 `dp[i-1][j]` 的逻辑，是解题的重中之重。

**不要忽略边界**：动态规划的正确性严重依赖于正确的边界条件初始化。`dp[0][0]`，第一行 `dp[0][j]` 和第一列 `dp[i][0]` 的处理必须准确无误。

**从二维到一维**：在掌握了二维DP解法后，思考如何进行空间优化是一个很好的进阶练习，这能加深对DP状态依赖关系的理解。

### Leetcode 10 与 Leetcode 44的比较

#### 两题的关键区别：`*`的定义

##### Leetcode 44: 与前一个字符无关

在Leetcode 44中，`*`匹配**任意序列**的字符（包括空序列）。

**它是一个独立的通配符，与它前面的字符无关**。

##### Leetcode 10: 依赖于前一个字符

在Leetcode 10 中，`*`表示匹配它前面的字符0次或者多次。

**它不是一个独立的通配符，必须和她前面的`p[j-2]`配合使用。**

#### 两个题目解决方法上的的相同点

##### 核心解法相同 - 动态规划

两者最经典、最通用的解法都是**动态规划 (Dynamic Programming)**。

##### 状态的定义相同

DP状态的定义完全一致。

我们都使用一个二维数组 `dp[i][j]`，它表示**字符串 `s` 的前 `i` 个字符** 是否能与 **模式 `p` 的前 `j` 个字符** 成功匹配。

##### 最终的目标答案相同

最终的答案都是 `dp[s.length()][p.length()]`。

##### 普通字符的匹配过程相同

当模式中的字符是普通字母时，逻辑相同：`p[j-1]` 必须等于 `s[i-1]`，并且 `s` 的前 `i-1` 个字符必须匹配 `p` 的前 `j-1` 个字符。

即 `dp[i][j] = (s[i-1] == p[j-1]) && dp[i-1][j-1]`。

##### 单字符通配符匹配过程相同

LeetCode 44 的 `?` 和 LeetCode 10 的 `.` 功能完全一样，都可以匹配任意单个字符。

它们的转移方程也一样：`dp[i][j] = dp[i-1][j-1]`。

#### 两个题目解决方案上的不同点

##### Leetcode 44: 通配符匹配

###### `*`的定义：独立通配符 - 匹配任意序列的字符

匹配**任意序列**的字符（包括空序列）。它是一个独立的通配符，与它前面的字符无关。

###### `*`的状态转移

当`p[j-1] == '*'`时，`dp[i][j]`有两种可能性，满足其一即可

- **匹配空序列 - 直接跳过星号**

  此时的结果取决于`s[0...i-1]`是否匹配`p[0....j-2]`即去掉`*`的之后的`p`,这个时候对应的状态为`dp[i][j-1]`

- **匹配一个或者多个字符 - 至少匹配一个字符**

  我们让 `*` 至少匹配 `s[i-1]` 这个字符。

  如果 `*` 要匹配 `s[i-1]`，那么`p[0...j-1]`就必须匹配`s[0...i-2]`。

  对应的状态就是`dp[i-1][j]`

##### Leetcode 10: 正则表达式匹配

###### `*`的定义 - 匹配前面的字符0次或者多次

匹配它**前面那个字符**的**零次或多次**。

它不是一个独立的通配符，必须和它前面的 `p[j-2]` 结合使用。

###### `*` 的状态转移

当 `p[j-1] == '*'` 时，我们需要考察它前面的字符 `p[j-2]`。

- **0次匹配**

  我们让 `p[j-2]` 和 `*` 这个组合整体失效。

  此时的匹配结果取决于 `s` 的前 `i` 个字符能否匹配 `p` 的前 `j-2` 个字符（即跳过 `p[j-2]*` 这个组合）。

  - 对应状态：`dp[i][j-2]`

- **一次或者多次匹配**

  注意这里有个和Leetcode 44本质上不一样的限制。

  **前提是当前 `s` 中的字符 `s[i-1]` 必须能和 `*` 前面的字符 `p[j-2]` 匹配**（`s[i-1] == p[j-2]` 或 `p[j-2] == '.'`）。

  如果能匹配，那么就相当于我们用 `p[j-2]*` 这个组合匹配了 `s[i-1]`，接下来 `p[j-2]*` 仍然可以继续匹配 `s` 中更早的字符。

  所以结果取决于 `s` 的前 `i-1` 个字符能否匹配 `p` 的前 `j` 个字符。

|                        | Leetcode 44                                                  | Leetcode 10                                                  |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `*`的含义              | 匹配**任意序列**的字符（包括空序列）                         | 表示匹配**它前面的字符**0次或者多次                          |
| 是否独立               | 是，与前一字符无关                                           | 否，与前一字符有关                                           |
| DP状态初始化           | 我们遍历 `p` 来填充 `dp[0][j]`。 `dp[0][j]` 为 `true` 的条件是 `p[j-1]` 必须是 `*`，并且它前面的模式 (`p` 的前 `j-1` 个字符) 也必须能匹配空字符串。 所以，状态转移是： `dp[0][j] = (p.charAt(j-1) == '*') && dp[0][j-1]` | 我们遍历 `p` 来填充 `dp[0][j]`。 如果 `p[j-1]` 是 `*`，它能否匹配空字符串，完全取决于**跳过 `p[j-2]\*` 这个组合**之后，前面的模式 (`p` 的前 `j-2` 个字符) 能否匹配空字符串。 所以，状态转移是： `dp[0][j] = dp[0][j-2]` |
| `*`匹配空序列的情况    | 匹配结果取决于 `s[0....i-1]`能否匹配 `p[0....j-2]`（即去掉 `*` 的模式,）**注意这里仅仅是去掉星号**，即`dp[i][j-1]` | 匹配结果取决于`s[0...i-1]`能否匹配 `p[0...j-3]`（即去掉 `p[j-2]*` 这个组合），**注意这里需要去掉前缀+星号**，即`dp[i][j-2]` |
| 匹配一次或者多次的情况 | `dp[i-1][j]`                                                 | 对应状态：`s[i-1]` 匹配 `p[j-2]` **并且** `dp[i-1][j]`       |
| 最终状态转移方程       | **`dp[i][j] = dp[i][j-1] || dp[i-1][j]`**                    | **`dp[i][j] = dp[i][j-2] || (matches(s[i-1], p[j-2]) && dp[i-1][j])`** |

##### 状态初始化内容对比

| 初始化部分              | LeetCode 44 (Wildcard Matching)              | LeetCode 10 (Regular Expression Matching)           |
| ----------------------- | -------------------------------------------- | --------------------------------------------------- |
| **`dp[0][0]`**          | `true` (空 vs 空)                            | `true` (空 vs 空)                                   |
| **`dp[0][j]` 逻辑**     | 只有当 `p` 的前缀全是 `*` 时，才能匹配空 `s` | 只有当 `p` 的前缀是 `x*y*z*` 形式时，才能匹配空 `s` |
| **`dp[0][j]` 状态依赖** | `dp[0][j]` 依赖于 `dp[0][j-1]`               | `dp[0][j]` 依赖于 `dp[0][j-2]`                      |
| **核心原因**            | `*` 是独立字符，可自身代表空序列             | `*` 依赖前一个字符，通过 `x*` 组合代表空序列        |

这个初始化的不同，完美地体现了两种 `*` 在语义上的根本差异

### Leetcode 392: 判断子序列

#### 实现代码

```Java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length();
        int n = t.length();
        int i = 0;
        int j = 0;
        while( i < m){
            if(j >= n) return false;
            if(s.charAt(i) == t.charAt(j)){
                i++;
            }
            j++;
        }
        return true;
    }
}
```

## 前i个元素与以第i个元素结尾的定义

###“前 i 个元素” - 不关心是否包含第`i`个元素

这种定义通常是 `dp[i]` 表示对**前 `i` 个元素组成的子数组/子串 `A[0...i-1]`** 所求得的解。

这种定义将问题看作是在一个不断扩大的**范围**或**前缀**内求解。

`dp[i]` 代表的是在 `nums[0...i-1]` 这个前缀子数组上问题的最优解。

这个解**不一定**包含 `nums[i-1]`。

最终的答案通常就是 `dp[n]`。

#### **核心思想**:关注的是一个**范围**

`dp[i]` 的值是针对 `A[0...i-1]` 这个**整体**的最优解，它并不关心这个最优解是否一定包含了第 `i` 个元素 `A[i-1]`。

```
dp[i] = f(dp[i-1], nums[i-1])
```

#### **状态转移**:**从相邻的上一个状态 `dp[i-1]` 推导而来**

`dp[i]` 的计算通常只依赖于相邻的前一个或前几个状态，如 `dp[i-1]`、`dp[i-2]` 等，而不需要遍历 `i` 之前的所有状态。

计算 `dp[i]` 时，通常考虑 `A[i-1]` 这个元素“加”或“不加”进来会对 `dp[i-1]` (即 `A[0...i-2]` 的解) 产生什么影响。

状态转移通常是**从相邻的上一个状态 `dp[i-1]` 推导而来**。

- `dp[i]` 可能等于 `dp[i-1]` (当 `A[i-1]` 不对最优解产生贡献时)。
- `dp[i]` 可能等于一个结合了 `A[i-1]` 的新值。

#### **最终结果**: 通常就是dp[n]

最终问题的解通常就是 **`dp[n]`** (其中 `n` 是数组/字符串的总长度)，因为 `dp[n]` 代表了对整个输入 `A[0...n-1]` 的求解。

####使用场景 - 最右子结构不依赖于结尾元素

当你发现，在计算位置 `i` 的状态时，你的决策是关于**是否使用 `nums[i-1]` 这个元素**，并且这个决策只依赖于前 `i-1` 个元素范围内的解 (`dp[i-1]`) 时，通常采用“范围”视角。

当问题的最优子结构不依赖于子序列的“结尾”是什么时，这种定义非常有效。

换句话说，当我们可以从一个前缀 `[0...i-2]` 的最优解，通过简单地考虑 `A[i-1]` 这一个新元素，就能推导出前缀 `[0...i-1]` 的最优解时，就使用此模式。

####经典例子： 最长公共子序列

**状态定义**: `dp[i][j]` 表示 `text1` 的**前 `i` 个字符** (`text1[0...i-1]`) 与 `text2` 的**前 `j` 个字符** (`text2[0...j-1]`) 的最长公共子序列的长度。

**为什么适用**: 我们在计算 `dp[i][j]` 时，只需要 `dp[i-1][j]`, `dp[i][j-1]`, 和 `dp[i-1][j-1]` 的信息。我们根本不关心 `text1[0...i-2]` 的最长公共子序列具体是以哪个字符结尾的，我们只需要那个最优的“长度”值即可。问题的“整体性”很强，不依赖于“结尾”这个局部特征。



###"以第 i 个元素结尾"  - 必须包含第`i`个元素

这种定义是 `dp[i]` 表示在所有**必须包含第 `i` 个元素 `A[i]` 并且以 `A[i]` 结尾**的子序列/子数组中，所求得的解。

最终的全局最优解，**往往是所有 `dp[i]` (从 `i=0` 到 `n-1`) 中的最大值/总和**。

#### **核心思想**: 子序列的终点必须是A[i]

它计算的是所有“必须包含 `nums[i]` 并且以它作为结尾”的子序列/子数组的属性

 这种定义施加了一个**强约束**——子序列的终点必须是 `A[i]`。它关注的是一个**端点**。

#### **状态转移**: **通常需要遍历从 `0` 到 `i-1`**

为了计算 `dp[i]`，因为我们必须选用 `A[i]`，所以我们需要向前看，遍历所有 `j < i` 的位置，找到一个最优的 `dp[j]`，使得 `A[i]` 可以“接在”以 `A[j]` 结尾的子序列后面，形成一个新的、更优的、以 `A[i]` 结尾的解。

简单来说，`dp[i]` 的计算通常需要遍历 `i` 之前的所有位置 `j` (从 `0` 到 `i-1`)，然后根据 `nums[i]` 和 `nums[j]` 的关系，来更新 `dp[i]`。

状态转移**通常需要遍历 `j` 从 `0` 到 `i-1`**。

- `dp[i] = f(A[i], dp[j])` for `j < i` (其中 `f` 是某种结合函数)。

#### **最终结果**: **`max/min(dp[0], dp[1], ..., dp[n-1])`**

由于最优解的子序列可能在**任何位置结尾**，所以最终问题的解**不是 `dp[n-1]`**，而是 **`max(dp[0], dp[1], ..., dp[n-1])`**。

####使用场景 - 状态转移依赖于子序列中的已经存在的元素

当你发现，在计算位置 `i` 的状态时，你需要**直接比较 `nums[i]` 和它之前的某个元素 `nums[j]` (其中 `j < i`) 的值**，并且 `i` 的状态需要**依赖于一个以 `nums[j]` 结尾的子问题的解**时，通常采用“结尾”视角。

简单来说，**当 `nums[i]` 的加入，需要“继承”或“扩展”一个在 `j` 位置结尾的状态时**，这种定义最有效。

当问题的状态转移**强依赖于子序列中相邻元素（非原始数组中的相邻）的关系**时，这种定义是必须的。

特别是当 `A[i]` 能否加入子序列，取决于子序列的**前一个元素**是谁时。

####经典例子 - 最长递增子序列

**状态定义**: `dp[i]` 表示所有以 `nums[i]` 这个元素**结尾**的最长递增子序列的**长度**。

**为什么适用**: 

我们要构建一个以 `nums[i]` 结尾的递增子序列，就必须在它前面找一个比它小的元素 `nums[j]` (`j < i`)。

这意味着，`nums[i]`能否“接上”去，完全取决于前面那个子序列的**结尾元素** `nums[j]`。

我们无法从一个“前 `i-1` 个元素的最长递增子序列”的**长度**（`dp[i-1]` 按定义一）直接推导出包含 `nums[i]` 的情况，因为我们不知道那个子序列的结尾是什么。

而“以 `j` 结尾”的定义恰好保留了这个至关重要的结尾信息。

###总结和对比

| 特性                | 定义一 ("前 i 个")                        | 定义二 ("以 i 结尾")                                 |
| ------------------- | ----------------------------------------- | ---------------------------------------------------- |
| **关注点**          | 一个**范围 (Prefix)** 的最优解            | 一个**端点 (Endpoint)** 的最优解                     |
| **`A[i-1]` 的角色** | 可选，可能包含也可能不包含                | **必须包含**，且作为结尾                             |
| **状态转移依赖**    | 通常只依赖 `dp[i-1]` 等**相邻**的几个状态 | 通常需要遍历 `dp[0]` 到 `dp[i-1]` **所有**之前的状态 |
| **最终答案**        | 通常是 `dp[n]`                            | 通常是 `max(dp)`                                     |
| **核心问题**        | “对于前 i 个元素，最优解是什么？”         | “如果我必须以第 i 个元素结尾，最优解是什么？”        |
| **典型应用**        | 最长公共子序列 (LCS), 编辑距离            | 最长递增子序列 (LIS), 最大子数组和                   |

