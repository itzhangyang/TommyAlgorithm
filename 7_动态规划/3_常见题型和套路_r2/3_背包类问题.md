# 背包类问题 - 容量限定下的目标值为特定值或者最大化

| 对比维度                      | **0-1 背包问题**                                             | **完全背包问题**                                             |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 💡 **问题本质**                | 每个物品只能选一次                                           | 每个物品可以选多次（无限次）                                 |
| 📦 **物品使用限制**            | 每个物品最多选 1 次                                          | 每个物品可以选 0~k 次（只要容量允许）                        |
| 🧠 **状态定义**                | `dp[i][j]`: 前 `i` 个物品、容量为 `j`，可获得的最大价值（每个物品只能用一次） | `dp[i][j]`: 前 `i` 个物品、容量为 `j`，最大价值（每个物品可用多次） |
| 🧩 **初始值**                  | `dp[0][*] = 0`, `dp[*][0] = 0`                               | 相同：`dp[0][*] = 0`, `dp[*][0] = 0`                         |
| 🔁 **状态转移方程**            | `dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1])`   | `dp[i][j] = max(dp[i-1][j], dp[i][j - w[i-1]] + v[i-1])`     |
| 🔄 **转移解释-不选择当前物品** | - 不选当前物品：`dp[i-1][j]`                                 | - 不选当前物品：`dp[i-1][j]`                                 |
| 🔄 **转移解释-选择当前物品**   | - 选一次当前物品：`dp[i-1][j - w[i-1]] + v[i-1]`             | - 重复选当前物品：`dp[i][j - w[i-1]] + v[i-1]`               |
| 🔁 **容量遍历顺序**            | 容量 `j=[w[i]....C]` 可任意顺序遍历，二维写法不影响          | 容量 `j=[C...w[i]]` **必须从小到大正序遍历**（保证能重复使用当前物品） |
| 🔂 **可重复选择物品**          | ❌ 不可重复使用同一物品                                       | ✅ 可重复使用同一物品                                         |
| 🧭 **每个状态的意义**          | **只能由前一个物品**的状态推导而来                           | 可以在**当前物品**的状态基础上继续叠加                       |
| 🧪 **例子说明**                | w=2, v=3, j=6 → 最多选1次 → 最大值 3                         | w=2, v=3, j=6 → 可选3次 → 最大值 9                           |
| 🧷 **典型 Leetcode**           | `416` 分割等和子集`474` 一和零`494` 目标和                   | `322` 零钱兑换（最少个数）`518` 零钱兑换 II（组合数）`377` 组合总和 IV（排列数） |

背包问题是 DP 中的一个大家族，其核心是在**容量限制**下，对一组物品进行**选择**，

- 达到价值最大化（比如价值最大化）
- 或满足特定条件（比如子集和为目标值）

##0-1背包问题- 每个物品只能选或者不选一次

**场景**：有一组物品，每个物品有自己的**重量和价值**。有一个容量有限的背包。

**目标**：选择一些物品放入背包，要求总重量不超过背包容量，且总价值最大。

关键约束是：**每个物品最多只能选择一次**。典型题目如 LC 416, 494。

###问题本质 - 每个物品只能选或者不选一次

在0-1背包问题中，每一个物品**只有一个**，在面临选择的时候，只能选择**要或者不要该物品**

0-1背包问题最常见的实现方法是**动态规划 (Dynamic Programming)**。

其基本原理是构建一个二维表格（通常称为`dp`表），用于存储在不同背包容量和物品子集下的最大价值。

####状态定义- `dp[i][j]`表示前i个物品在容量为j时的最大值

按照题目定义，我们定义`dp[i][j]`为前`i-1`个物品在背包容量为`j`的时候的最大价值，其中：

- `i` 代表考虑前 `i` 件物品。
- `j` 代表当前背包的容量。

采用一维动态规划数组的方式性能更高，但是可理解性没有这么高。

####**遍历方式**-双层循环遍历-确定`dp[i][c...w[i]]`的值

#####外层每一个物品i-确定`dp[i][c...w[i]]`的值

遍历每一个物品时为了确定前`i`个物品在特定背包容量的情况下的最大价值

#####内从遍历背包容量`[c...w[i]]`

- 内层循环容量，从大`背包最大容量` 到 小`当前物品容量`，依次**递减**

```java
int[i][j] dp = new int[i+1][C + 1]; // 初始化为 0
for (int i = 0; i < n; i++) { // i 表示第 i 个物品
    for (int j = C; j >= w[i]; j--) { // j 表示当前背包容量，从大到小
        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);
    }
}
```

####物品的选择与状态方程转移

#####选择物品`i` 时的最大价值-`dp[i-1][j-w[i]]+v[i]`

在之前的循环(`[0...i-1]`)当中我们已经知道:

- 前`i-1`个物品在容量为`j-w[i]`的情况下最大值`dp[i-1][j-w[i]]`

那么选择物品`i`的情况下，就相当于在上述情况基础上再选择物品`i`,那么：

`dp[i][j]=dp[i-1][j-w[i]]+v[i]`

#####不选择物品`i`时的最大值-`dp[i-1][j]`

不选择物品`i`时的最大值，就是前`i-1`个物品在背包容量为`j`的情况下的最大价值`dp[i-1][j]`

####权衡选择：选上述两种情况的最大值

```java
dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]); 
```

### 0-1背包问题适用于哪些问题和场景？

#### 数组中和不超过target的最大子集

**数据结构:** 一个正数数组 `nums[]`。数组中的每个数字可以同时被看作是其“重量”和“价值”。

**约束 (W):** 一个整数上限 `W`。

**目标:** 从 `nums[]` 中挑选出一个子集，使得子集中所有元素的和 `sum` 是所有可能子集中最大的，但同时要满足 `sum <= W`。

**应用场景举例:**

- **预算内购物:** 你有一个购物清单，上面列有不同商品的价格（`nums[]`），和一笔固定的预算（`W`）。你希望购买的商品总价尽可能接近预算，但不超出。目标是最大化已花费的金额。

#### 最大化/最小化某一属性的和

这是标准的0-1背包问题模型，每个元素包含多个属性。

- **数据结构:** 一个对象或元组的数组 `items[]`，每个元素 `item[i]` 至少包含两个属性，例如 `(weight, value)`。
- **约束 (W):** 一个整数，代表对 `weight` 属性总和的限制。
- **目标:** 选择一个 `items[]` 的子集，在子集的 `weight` 属性之和不超过 `W` 的前提下，使得子集的 `value` 属性之和最大化。

**应用场景举例:**

- **资源分配:** `items[]` 代表一系列项目，每个项目有其 `(所需资源, 预计回报)`。你拥有总量为 `W` 的资源，目标是选择一部分项目进行投资，以最大化总回报。
- **装载问题:** `items[]` 代表一堆货物，每件货物有其 `(重量, 价值)`。你的卡车载重为 `W`，目标是装载一组货物，使得总价值最高。

#### 判断数组中是否存在和为target的子集

这个问题是0-1背包问题的一个变种，被称为**子集和问题 (Subset Sum Problem)**。其目标不是最大化，而是判断可行性。

- **数据结构:** 一个正数数组 `nums[]`。
- **约束 (W):** 一个目标整数 `W`。
- **目标:** 判断是否存在 `nums[]` 的一个子集，使得子集中所有元素的和恰好等于 `W`。

在动态规划的解法中，`dp[i][j]` 的含义会从“最大价值”变为一个布尔值：`true` 或 `false`，表示用前 `i` 个数，能否凑成和为 `j`。

**应用场景举例:**

- **凑单问题:** 你有一堆不同面值的优惠券 (`nums[]`)，需要判断能否恰好凑出某个需要满足的金额 `W` 来享受优惠。
- **两堆相等分割:** 给定一个数组，判断是否能将其分为两个和相等的子集。这可以转化为一个子集和问题：计算整个数组的总和 `total_sum`，如果 `total_sum` 是奇数则无解；如果是偶数，则问题等价于判断是否存在一个子集，其和恰好等于 `total_sum / 2`。

#### 将数组划分为K个和相等的子集

这是子集和问题的进一步扩展，即**划分为k个相等的子集 (Partition to k Equal Sum Subsets)**。

- **数据结构:** 一个正数数组 `nums[]`。
- **约束 (W):** 隐式约束，即 `total_sum / k`。
- **目标:** 判断是否能将 `nums[]` 划分为 `k` 个非空子集，且每个子集的元素之和都相等。

这个问题通常使用回溯（深度优先搜索）并结合剪枝策略来解决，但其核心思想与背包问题的“选择与否”一脉相承。可以看作是需要**重复执行k次**的、寻找和为 `total_sum / k` 的子集和问题。

**应用场景举例:**

- **任务公平分配:** 有一组任务，每个任务有其预估的耗时 (`nums[]`)。需要将这些任务分配给 `k` 个员工，能否做到让每个员工分配到的任务总耗时完全相等。

###带有双重限制的0-1背包问题

#### 两个都是最大限制

```Java
class Item{
  int weight;
  int volume;
  public Item(int weight, int volume){
    this.weight = weight;
    this.volume = volume;
  }
}
public int maxValue(Item[] items, int m, int n){
  int len = items.length;
  int[][][] dp = new dp[len+1][m+1][n+1];
  
  for(int k = 1; k <= len; k++){
    Item item = items[k-1];
    for(int i = 0; i <= m; i++){
      for(int j = 0; j <= n; j++){
        dp[k][i][j] = dp[k-1][i][j];
        
        if(i >= item.weight && j >= item.volume){
          dp[k][i][j] = Math.max(dp[k][i][j], dp[k-1][i - item.weight][j - item.volume] + 1);
        }
      }
    }
  }
  
  return dp[len][m][n];
}
```



#### 一个最大限制一个最小限制

##### 问题抽象 

**給定**:

- `N` 個物品。
- 一個背包，其最大**容量 (capacity)** 為 `C`。

**物品屬性**: 每個物品 `i` 都有兩個屬性：

- **重量 (weight)** `weight[i]`
- **價值 (value)** `value[i]`

**雙重約束**:

1. **上限約束**: 所選物品的總重量**不得超過**背包容量 `C`。
2. **下限約束**: 所選物品的總價值**不得低於**最小價值 `V_min`。

**目標**:

- 計算有多少種**物品的組合（子集）能夠同時滿足這兩個約束條件。這是一個計數問題**。

##### 核心挑战和技巧 - 价值封顶技巧

這個範式的核心挑戰在於如何優雅地處理“價值不低於 `V_min`” 這個下限約束。

直接在DP狀態中表示一個**無限的價值範圍**是不可行的。

這裡的關鍵解決方案就是我們之前討論過的**狀態壓縮—價值封頂 (State Compression via Capping)** 技巧。

###### 什么是价值封顶技巧？

用一句话解释就是：**我們將所有計算後 `> V_min` 的價值，全部視為 `V_min`。**

例如，如果 `V_min = 100`，那麼一個價值為101的方案和一個價值為200的方案，都被歸類到價值`100`這個狀態點上。

###### 价值封顶怎么实现？

首先计算当前总价值+下一个前物品价值： `currentValue + itemValue`

- 我们比较累加之后的总价值和`minValue`
- 取其中较小者为`newValue`，然后更新`dp[][][newValue]`

`newValue = Math.min(V_min, currentValue + itemValue)`

###### 价值封顶的作用效果 - 从恰好到至少

這使得 `dp[...][V_min]` 這個狀態點的含義從“價值恰好為 `V_min` 的方案數”轉變為“價值**至少**為 `V_min` 的方案數”，從而巧妙地解決了下限約束問題，並將DP數組的維度控制在有限範圍內。

##### DP状态数组的定义

這是本次分析的核心。我們定義一個三維 `dp` 陣列：

`dp[k][i][j]` 代表：**從前 `k` 個物品中進行選擇，恰好使用 `i` 的容量（總重量），達成價值總和（經過封頂後）恰好為 `j` 的方案總數。**

- `k`: 第 `k` 個維度，代表我們已經**考慮完**了前 `k` 個物品。範圍從 `0` 到 `N`。
- `i`: 第二個維度，代表已用重量，範圍從 `0` 到 `capacity`。
- `j`: 第三個維度，代表已達價值，範圍從 `0` 到 `minValues`。

##### 状态转移方程 - 推的技巧

###### 什么叫做推式技巧 ->用当前状态推导下一个状态

為了邏輯清晰，我們採用“推”式DP（Push DP）的思路。

也就是說，我們根據 `dp[k]` 層的每一個狀態，來計算它對 `dp[k+1]` 層的貢獻。

###### 状态转移方程的推导过程

**決策一：不選擇第 `k+1` 個物品**

那麼 `dp[k][i][j]` 所代表的所有方案，會原封不動地繼承到下一層。

貢獻路徑：`dp[k][i][j]` -> `dp[k+1][i][j]`

**決策二：選擇第 `k+1` 個物品**（必须有足够的剩余容量）

**前提**: 必須有足夠的剩餘容量，即 `i + w <= capacity`。

**結果**: `dp[k][i][j]` 所代表的所有方案，在加入了物品 `k+1` 後，會形成新的方案。

- 新方案的重量: `i + w`
- 新方案的價值 (封頂後): `min(minValues, j + v)`

貢獻路徑：`dp[k][i][j]` -> `dp[k+1][i + w][min(minValues, j + v)]`

綜合起來，`dp[k+1]` 層的每個狀態值，都是由 `dp[k]` 層通過這兩種決策貢獻的方案數累加而來。



##### 代码套路模板

```Java
/**
 * 混合約束 (上限重量, 下限價值) 0/1 背包問題模板 - 三維DP實現
 * 目標：計算滿足條件的方案總數
 *
 * @param capacity  背包最大容量 (上限約束)
 * @param minValues 要求的最小總價值 (下限約束)
 * @param weights   物品重量數組
 * @param values    物品價值數組
 * @return 滿足條件的方案總數
 */
public int solveMixedConstraintCount3D(int capacity, int minValues, int[] weights, int[] values) {
    int MOD = 1_000_000_007;
    int numItems = weights.length;

    // DP狀態定義: dp[k][i][j]
    // k: 已考慮的物品數
    // i: 已用容量（重量）
    // j: 已達價值（經過封頂）
    // dp[k][i][j] 的值: 方案總數
    long[][][] dp = new long[numItems + 1][capacity + 1][minValues + 1];

    // Base Case: 考慮0個物品，用0容量，達成0價值的方案有1種（即空集方案）。
    dp[0][0][0] = 1;

    // 遍歷每一個物品 k (從第0個到第 numItems-1 個)
    for (int k = 0; k < numItems; k++) {
        int w = weights[k];
        int v = values[k];

        // 遍歷 dp[k] 層的所有可能狀態
        for (int i = 0; i <= capacity; i++) {
            for (int j = 0; j <= minValues; j++) {
                
                // 如果來源狀態 dp[k][i][j] 為0，則無法貢獻新方案，跳過
                if (dp[k][i][j] == 0) {
                    continue;
                }

                // --- "推"式更新 dp[k+1] 層 ---

                // 決策1: 不選擇物品 k
                // 將方案數貢獻給下一層的相同狀態
                dp[k + 1][i][j] = (dp[k + 1][i][j] + dp[k][i][j]) % MOD;

                // 決策2: 選擇物品 k
                // 檢查容量是否足夠
                if (i + w <= capacity) {
                    // 應用“價值封頂”技巧計算新價值的狀態索引
                    int newValueIndex = Math.min(minValues, j + v);
                    
                    // 將方案數貢獻給下一層的新狀態
                    dp[k + 1][i + w][newValueIndex] = (dp[k + 1][i + w][newValueIndex] + dp[k][i][j]) % MOD;
                }
            }
        }
    }

    // 匯總最終結果
    // 結果位於最後一層 dp[numItems]，即考慮完所有物品後
    // 我們需要的是所有“總重量不超過 capacity”且“總價值不低於 minValues”的方案。
    // 這些方案的數量被記錄在 dp[numItems][i][minValues] 中 (i 代表任意合法重量)
    long totalSchemes = 0;
    for (int i = 0; i <= capacity; i++) {
        totalSchemes = (totalSchemes + dp[numItems][i][minValues]) % MOD;
    }

    return (int) totalSchemes;
}
```





###和为目标值的子集 - Leetcode 416: 

给你一个 **只包含正整数** 的非空数组 `nums`，判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

- 典型的「**是否存在一个子集，其和为目标值**」的问题
- 背包问题（0/1 Knapsack）
- 使用一维 DP 数组优化空间

##### 如何将问题转化为一个0-1背包问题？

- **背包 (Knapsack):** 我们的背包容量是 `target`。
- **物品 (Items):** 数组 `nums` 中的每一个数字 `num` 都是一个物品。
- **物品的“重量”和“价值”:** 对于每个物品 `num`，它的重量是 `num`，它的价值也是 `num`。
- **目标:** 我们需要选择一些物品放入背包，问是否存在一种方案：
  - 使得背包刚好被装满（即所选物品的总重量恰好等于背包容量 `target`）。
  - 我们不追求价值最大化，只关心“能否恰好装满”。

##### 如何将问题场景转化为dp状态模型问题？

我们希望找到一个子集，使得它的和为`sum(nums)/2`。

- 如果数组的总和`sum(nums)`是**奇数**，直接返回false。

- 令`Target=sum(nums)/2`,问题就转化为：

> 是否存在一个子集，使得这些数的和为 `target`

##### 状态数组定义

`dp[i][j]` 表示：**从数组 `nums` 的前 `i` 个元素（下标从 0 到 `i-1`）中任意选取，是否存在一种组合，使得它们的和恰好等于 `j`。**

如果 `dp[i][j]` 为 `true`，则表示存在这样的组合；如果为 `false`，则表示不存在。

我们的最终目标是求解 `dp[n][target]`，其中 `n` 是数组 `nums` 的长度。

##### 状态转移方程

当我们考虑第`i`个元素（`nums[i-1]`），因为`i`和目标和`j`的时候，存在两种情况：

###### 不选择`nums[i-1]`

如果我们决定不把`nums[i]`放入背包，那么问题就变成：**能否从前`i-1`个元素中凑出和为`j`**? 答案就是`dp[i-1][j]`

###### 选择`nums[i-1]`

如果我们决定把`nums[i-1]`放入背包，**这个选择存在一个前提条件：当前的背包容量`j`必须大于或者等于`nums[i-1]`**

如果满足这个条件，那么问题就变成**能否从前`i-1`个元素中凑出`j-nums[i-1]`**?  - 答案就是`dp[i-1][j-nums[i-1]]`

由于我们只需要一种方案存在即可，所以`dp[i][j]`是上述两种情况的**OR**关系。

因此，最后的状态转化方程为：

- 当 `j >= nums[i-1]`时： $dp[i][j]=dp[i−1][j]∣∣dp[i−1][j−nums[i−1]]$ 

- 如果 `j < nums[i-1]`时，那么第`i`个元素`nums[i]`肯定不能选择，因为它本身的值**已经超过了背包的容量**：

  $dp[i][j]=dp[i−1][j]$

##### 状态初始化

- **`dp[0][j]`**: `dp[0][j]` 表示从前 0 个元素（即一个数都不选）中凑出和为 `j`。
  - `dp[0][0] = true`：不选择任何数，它们的和是 0。这是成立的。
  - `dp[0][j] = false` (当 `j > 0` 时)：不选择任何数，不可能凑出大于 0 的和。
- **`dp[i][0]`**: `dp[i][0]` 表示从前 `i` 个元素中凑出和为 0。
  - `dp[i][0] = true` (对于所有 `i`)：我们总可以通过一个数都不选的方式，使得和为 0。

所以，我们的 DP 表（大小为 `(n+1) x (target+1)`）初始化后，`dp[0][0]` 为 `true`，第 0 行其他都为 `false`。在遍历时，`dp[i][0]` 会自然地被 `dp[i-1][0]` 更新为 `true`。

##### 最终结果

根据我们的定义，最终的结果就是 `dp[n][target]`。

##### 代码实现

```java
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        int max = 0;
        for(int num : nums){
            sum += num;
            max = Math.max(max, num);
        }

        if (sum % 2 != 0) return false;
        if (max > sum /2) return false;

        int target = sum / 2;

        boolean[][] dp = new boolean[n+1][target+1];

        for (int i = 0; i <= n; i++){
            dp[i][0] = true;
        }

        for (int j = 1; j <= target; j++){
            dp[0][j] = false;
        }

        for (int i = 1; i <= n; i++){
            for (int j = 0; j <= target; j++){
                dp[i][j] = dp[i-1][j];
                if(j >= nums[i-1]){
                    dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        
        return dp[n][target];
    }
```

##### 复杂度分析

**时间复杂度:** $O(ntimestexttarget)$ 我们填充了一个大小为 `(n+1) x (target+1)` 的 DP 表，其中 `n` 是数组中元素的个数，`target` 是数组总和的一半。填充每个单元格的时间是 O(1)。

**空间复杂度:** $O(ntimestexttarget)$ 我们需要一个二维 DP 数组来存储所有子问题的解。

##### 经验总结

二维 DP 数组的解法非常直观，它清晰地展示了每个子问题的求解过程。`dp[i][j]` 的含义明确，状态转移方程也直接反映了“选”与“不选”这两种决策。虽然在空间上可以被优化为一维 DP（滚动数组），但二维 DP 的版本是理解这个问题的 foundational step，对于初学者来说更容易掌握 0/1 背包问题的核心思想。

###给每个数字加+或者-， 让整个数组的和为目标值 - Leetcode 494

给定一个整数数组 `nums` 和一个目标值 `target`。你需要为数组中的每个整数前添加 `+` 或 `-` 符号，然后计算所有数的和。问：有多少种不同的符号分配方式，可以使得最终的和等于 `target`？

##### 怎样将问题转化为0-1背包问题

- 将`nums`数组转化为两个集合：

  - 集合`P`包含所有带`+`的数字
  - 集合`N`包含所有的带`-`的数字

  那么原来的问题就转化为`sum(p) - sum(n) = target`

- 我们还知道另外一个隐藏的等式：`sum(p)+sum(n) = totalSum`

- 现在我们将两个等式加起来有：

  `2 * sum(p) = totalSum + target`

  `sum(p) = (target + totalSum)/2`

- 这个公式告诉我们，原问题等价于另外一个新问题：**在nums数组中，能否存在一个子集，其元素之和恰好等于`(target + totalSum)/2`**

##### 将转换后的问题转化为0-1背包模型：

| 0/1 背包模型术语        | LeetCode 494 问题的映射               | 解释                                                         |
| ----------------------- | ------------------------------------- | ------------------------------------------------------------ |
| **背包容量 (Capacity)** | `newTarget = (totalSum + target) / 2` | 我们要用物品“恰好装满”的目标和就是背包的容量。               |
| **物品 (Items)**        | 数组 `nums` 中的每一个数字 `num`      | 每一个数字都是一个可供选择的“物品”。                         |
| **物品的重量 (Weight)** | 数字 `num` 的值本身                   | 每个物品的“重量”就是它自身的数值。                           |
| **0/1 选择**            | 每个数字只能用一次                    | 对于 `nums` 中的每个数字，我们只能选择“放入子集P”或“不放入”，完全符合 0/1 背包的约束。 |
| **求解目标**            | **装满背包的方案数**                  | 不同于求最大价值，这是一个**计数型**的背包问题：求恰好装满容量为 `newTarget` 的背包，有多少种不同的装法。 |

##### 实现代码

```java
    public int findTargetSumWays(int[] nums, int target) {
      int n = nums.length;
      int totalSum = 0;
      int max = 0;
      for(int num: nums){
        totalSum += num;
        max = Math.max(max, num);
      }

      if ((totalSum + target) % 2 != 0) return 0;
      target = (totalSum + target) / 2;
      //数组中的元素之和不可能为负数，如果新的target是负数，则直接返回0
      if(target < 0) return 0;
		
      int[][] dp = new int[n+1][target+1];

      dp[0][0] = 1;
      //前0个元素，dp[0][1...target]都是0
      for(int j = 1; j <= target; j++){
        dp[0][j] = 0;
      }
      //对于所有的元素dp[1...n][0]都是1，就是空集
      for(int i = 1; i <=n; i++){
        dp[i][0] = 1;
      }
			
      //遍历过程
      for (int i = 1; i <= n; i++){
        for(int j = 0; j <= target; j++){
          //先拿到dp[i-1][j]
            dp[i][j] = dp[i-1][j];
          //如果j >= num, 将dp[i-1][j-num]也累加上
            if(j >= nums[i-1]){
                dp[i][j] += dp[i-1][j-nums[i-1]];
            }
        }
      }

      return dp[n][target];
      
    }
```

###Leetcode 474: 一和零-求最大子集的长度

给定一个字符串数组 `strs`，每个字符串只包含 `'0'` 和 `'1'`。

再给定两个整数 `m` 和 `n`，表示最多可以使用的 0 和 1 的数量。

问**最多**能从 `strs` 中选出多少个字符串，使得这些字符串中总共包含的 `0` 的数量 ≤ `m`，`1` 的数量 ≤ `n`。

####问题分析-多维度约束下的子集选择最大数量的问题

问的是符合条件的字符串的最大数量是多少？

##### 复习0-1背包问题

###### 场景和限制条件

- 背包能够装载的容量固定
- 每一个物品有两个属性
  - 物品的重量`w[i]`
  - 物品的价值`v[i]`
- 每一个物品只有一个
  - 只能选择装或者不装
  - 不能够切割

######目标 - 求背包能够装下的最大价值

目标是求在上述条件下，背包能够装下的物品的最大价值和。

###### 解决方法

- **DP定义：**`dp[i][j]`表示在容量前`i`个物品在容量`j`的限制下，能装入的最大价值

- **DP状态转移方程：**

  对于每一个物品`item[i]`，有两个选项：

  - **选择该物品：**`dp[i][j] = dp[i-1][j-w[i]] + v[i]`
  - **不选择该物品：**`dp[i][j] = dp[i-1][j]`

  选择上述两个选项中的较大者:`dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) `

- **DP的初始化状态：**

  前0个物品，不管容量如何，最大价值都是0:

  `dp[0][0...c] = 0`

##### 回到现在的问题当中

###### 如果背包问题增加一个维度 - 扩展版本0-1背包问题

首先我们是求最多的字符串的数量，假设每一个字符串都是一个物品，那么**物品的价值**就是1。

其次我们看物品的重量怎么限制，物品的重量就变成了两个维度了，也许我们可以认为是体积和重量。

对于这种情况下，我们可以认为背包有两个限制，一个是重量的限制`m`，一个体积的限制`n`。

那么我们就需要使用一个三维DP数组`dp[k][i][j]`来保存状态:

- 背包的重量限制是`m`
- 背包的体积限制是`n`
- 前`k`个字符串中，最多可以有装多少价值（字符串的个数）

那么我们的实现代码就相当于：

```Java
class Item{
  int weight;
  int volume;
  public Item(int weight, int volume){
    this.weight = weight;
    this.volume = volume;
  }
}
public int maxValue(Item[] items, int m, int n){
  int len = items.length;
  int[][][] dp = new dp[len+1][m+1][n+1];
  
  for(int k = 1; k <= len; k++){
    Item item = items[k-1];
    for(int i = 0; i <= m; i++){
      for(int j = 0; j <= n; j++){
        dp[k][i][j] = dp[k-1][i][j];
        
        if(i >= item.weight && j >= item.volume){
          dp[k][i][j] = Math.max(dp[k][i][j], dp[k-1][i - item.weight][j - item.volume] + 1);
        }
      }
    }
  }
  
  return dp[len][m][n];
}
```

###### 注意题目中要求是总的1和0的数量限制

不是对于每个字符串的限制，而是所有收集到的字符串的总的1和0的数量之和的限制。

这个问题就跟上面我们所扩展的扩展版0-1背包问题完全契合了。

该问题类似于**0-1**背包问题，**两个容量限制**分别是：

- 最多有`m`个`0`
- 最多有`n`个`1`

最终的目的是问最多有多少个字符串满足这样的条件，这相当于每一个字符串的价值为1。

###### 如何转化为0-1背包问题？

每一个字符像是一个物品：

- 有**两个权重**(0的数量，1的数量)
- 价值为`1`，每次选一个字符串就+1



####核心思想-三维动态规划

经过上面的分析，我们认为这个问题就是标准的扩展版0-1背包问题：

- 背包的重量限制就是字符串中的0的总数量
- 背包的体积限制就是字符串中的1的总数量
- 物品的价值就是1

那么我们就可以定义一个DP数组`dp[k][i][j]`

> 在前 `k` 个字符串中，使用了最多 `i` 个 0 和 `j` 个 1 的前提下，最多可以选多少个字符串。

##### 状态定义和初始化

**`dp[k][i][j]`:**表示在前`k`个字符中，最多使用`i`个`0`和`j`个1的前提下，最多可以选择多少个字符串。

`dp[0][i][j]`表示在`0`个字符的情况下，无论多少容量都只能选择0个。

##### 状态选择方程和遍历逻辑

参照扩展版的0-1背包问题，我们可以定义如下的循环和状态转移方程。

#####遍历每一个字符串

###### 统计字符串中的0和1的数量

我们可以认为0的数量就是**物品的重量**， 1的数量就是**物品的体积**。

对于每一个字符串`k in [1,strs.length]`, 统计其包含0和1的数量：`zero`,`one`

```Java
for(int k = 1; i <= len; k++){
  String s = strs[k-1];
	int zeros = 0;
  int ones = 0;
  for(char c : s.toCharArray()){
    if(c == '0'){
      zeros++;
    }else{
      ones++;
    }
  }
  //容量和体积循环和状态转移逻辑
}
```



###### 重量和体积限制的遍历逻辑

如同上面的扩展版0-1背包问题，我们在物品循环内，对于每一个字符串，统计了0和1数量之后。

对重量和体积限制进行一个循环。

```Java
for(int i = 0; i <= m; i++){
  for(int j = 0; j <= n; j++){
    //状态转移方程
    //..
  }
}
```

###### 状态转移方程

每次的选择有两个方案：

- 不选第`k`个字符串
- 在剩余容量足够的情况下，选择第`k`个字符串

```java
if (i >= zero && j >=0){ //剩余的容量足以容下当前字符串中所有的1和0
  dp[k][i][j] = Math.max(dp[k-1][i][j],//不选择当前字符串的情况
                        dp[k-1][i-zero][j-one]+1);//选择当前字符串的情况
}else{
  dp[k][i][j] = dp[k-1][i][j];
}
```

####实现代码

```java
class Solution {
  public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][][] dp = new int[len + 1][m + 1][n + 1];

        for (int k = 1; k <= len; k++) {
            int zero = 0, one = 0;
            for (char c : strs[k - 1].toCharArray()) {
                if (c == '0') zero++;
                else one++;
            }

            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= n; j++) {
                    // 不选当前字符串
                    dp[k][i][j] = dp[k - 1][i][j];
                    
                    // 选当前字符串（如果容量够）
                    if (i >= zero && j >= one) {
                        dp[k][i][j] = Math.max(dp[k][i][j], dp[k - 1][i - zero][j - one] + 1);
                    }
                }
            }
        }

        return dp[len][m][n];
    }
}
```

####注意事项

1. **空间复杂度是 O(L × m × n)**，当 `strs` 数量较大时可能会爆内存。
2. **索引要小心**：第 `k` 个字符串是 `strs[k - 1]`。
3. **易于理解但非最优**：这是教学用的理想选择，但可通过压缩为二维实现以减少内存占用。

####经验总结

- **初学者建议先用三维 dp 理解状态定义与转移**。
- 然后逐步「压缩维度」优化到二维 dp。
- 理解压缩过程中倒序遍历的**必要性与含义**（避免重复使用物品）。

###Leecode 1049 最后一块石头的重量

- 给定一堆石头的重量数组 `stones[]`，每次可以选两块石头碰撞，若重量相同则两块都消失，若不同则留下 `abs(x - y)` 的一块。
- **目标**：最后剩下石头的最小可能重量是多少？

这其实是一个 **将数组划分为两个子集，使得两个子集的和尽量接近** 的问题 —— **典型的「子集和接近一半」的 0-1 背包问题变形**。

即可以匹配上**求最大容量不超过target得最大子集。**

####问题分析

- 设所有石头的总重量为 `sum`，我们想把这些石头分为两组 `A` 和 `B`，碰撞的本质是 `|sum(A) - sum(B)|`。
- 所以目标是使这个差值尽可能小，即找到一个子集 A，使 `sum(A)` 尽量接近 `sum / 2`，使差值最小。
- 转化为 **0-1 背包问题**：选一些石头装入背包，背包容量为 `sum/2`，最大化装入的重量。

####核心思想-0/1背包问题

#####0-1背包思想

- 物品不能够重用
- 目标是从石头中选择若干个:
  - 使得总重量不超过`sum/2`
  - 并且总重量最大

最终答案为：`sum-2*maxSubArraySums`，`maxSubArray`是不超过`sum/2`的**最大子集和**

##### 状态定义和初始化：`dp[i][j]`表示前`i`个石头在容量为`j`的情况下的最大子集和

###### 状态定义

`dp[i][j]` 表示前 `i` 块石头中，选择一些石头，放入容量为 `j` 的背包中，**能达到的最大重量**。

###### 状态初始化

- `dp[0][*] = 0`：不选择任何石头，重量为 0。
- `dp[*][0] = 0`：背包容量为 0，最大重量只能是 0。

##### 遍历逻辑和状态转移方程

```java
dp[i][j] = dp[i-1][j];

if (j >= stones[i-1]){
  dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i-1]]+stones[i-1]);
}
```

###### 遍历顺序

- 外层遍历`i=[1...n]`
- 内层遍历容量`j=[0...target]`

####代码实现

```java
public int lastStoneWeightII(int[] stones) {
        int total = 0;
        for (int stone: stones){
            total += stone;
        }
        int n = stones.length;
        int target = total/2;

        // 前i个石头，在容量为j的情况下最大值
        int[][] dp = new int[n+1][target+1];

        for (int i=1; i <= n; i++){
            for (int j=0;j<=target;j++){
                dp[i][j] = dp[i-1][j];
                if (stones[i-1] <= j){
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-stones[i-1]]+stones[i-1]);
                }
            }
        }

        return total - 2* dp[n][target];
        
    }
```

####注意事项

1. **避免重复使用石头**：由于是 0-1 背包，内层必须 **倒序遍历** 背包容量。
2. **整数除法注意丢失精度**：`target = sum / 2` 是整型除法，自动向下取整，是符合预期的。
3. **石头总数不多**：`1 <= stones.length <= 30`，所以二维/一维 DP 都可接受。

####经验总结

- 本题是一个典型的**转化型动态规划问题**，从石头碰撞模拟题转化为**背包问题**。

- 本质上是一个**最小差值划分问题**（Subset Sum Partition）。

- 动态规划中，遇到“找最小差值”常常转化为“子集和最接近一半”的问题。

- 滚动数组优化非常实用，能把二维降成一维节省空间。

- 本题可以类比：

  - Leetcode 494. 目标和

  - Leetcode 416. 分割等和子集

  - Leetcode 698. 划分为k个相等子集（更复杂的划分问题）

###Leetcode 1751 最多可以参加的会议数量II

####问题要点

**输入**: 

- 一个二维整数数组 `events`，其中 `events[i] = [startTime_i, endTime_i, value_i]` 代表一个事件的开始时间、结束时间（包含）和价值。
- 一个整数 `k`，代表你最多可以参加的事件数量。

**目标**: 从这些事件中选择一部分参加，使得总价值最大。

**约束**:

- 你最多只能参加 `k` 个事件。
- 你不能同时参加两个时间上有重叠的事件。
- 如果一个事件在 `t` 时刻结束，你可以参加另一个在 `t + 1` 时刻开始的事件。

####问题的本质和分析 - 带有互斥关系的0-1背包问题

这个问题的本质是一个**带有约束的组合优化问题**。

我们需要在一系列“物品”（事件）中做出选择，以最大化总“价值”。

与经典的 0/1 背包问题不同，这里的“物品”之间存在**相互排斥**的关系（时间重叠）。



选择一个事件，不仅会消耗一个名额（`k` 减一），还会使得所有与它时间重叠的事件都无法被选择。

为了做出有序的决策，一个自然的想法是**按照时间的先后顺序**来考虑每个事件。

因此，**首先对事件按开始时间进行排序**是至关重要的第一步。

这使得我们的决策过程可以线性地、沿着时间轴向前推进。



排序后，对于每一个事件 `i`，我们都面临一个决策：

- **选择不参加事件 `i`**: 我们保留了 `k` 个名额，然后继续考虑从 `i+1` 开始的后续事件，能获得的最大价值。

- **选择参加事件 `i`**: 我们获得 `events[i]` 的价值，同时消耗一个名额（剩下 `k-1` 个）。

  接下来，我们只能从那些 **开始时间晚于事件 `i` 结束时间** 的事件中继续选择。

这清晰地揭示了一个递归结构，并且包含了重叠子问题（例如，从事件 `j` 开始、剩余 `m` 个名额的最优解可能被多次计算），因此非常适合使用动态规划来解决。

####模式匹配： 排序 + 动态规划 + 二分查找

这个问题可以匹配到以下经典算法模式：

#####**带约束的 0/1 背包问题**: 

每个事件可以看作一个物品，有其价值。

但“重量”或“成本”不是固定的，而是**机会成本**——即放弃了哪些其他事件。

`k` 是背包的容量。

##### **区间调度问题 (Interval Scheduling)**: 

尤其是带权重的区间调度（Weighted Interval Scheduling）。

经典区间调度问题是寻找最多数量的不重叠区间，而这里是寻找总价值最大的不重叠区间子集，并且有数量上限 `k`。

##### 二分查找边界

核心模式是 **“排序 + 动态规划”**，在 DP 的状态转移中，为了高效地找到下一个可以参加的事件，需要用到 **二分搜索** 进行优化。



####核心思想和套路：排序 + 动态规划 + 二分查找

#####**核心思想**：我们**从后向前**构建解决方案。

我们计算从最后一个事件开始能获得的最大价值，然后逐步向前推进，直到计算出从第一个事件开始能获得的最大价值。

#####核心套路

######**预处理 (Preprocessing)**: 对所有事件（区间）按 **开始时间** 升序排序。

选择一个事件，不仅会消耗一个名额（`k` 减一），还会使得所有与它时间重叠的事件都无法被选择。

为了做出有序的决策，一个自然的想法是**按照时间的先后顺序**来考虑每个事件。

因此，**首先对事件按开始时间进行排序**是至关重要的第一步。

这使得我们的决策过程可以线性地、沿着时间轴向前推进。

说明白一点，这个排序就是为了后面**二分查找**做准备的。

######**定义 DP 状态**:  `dp[0...n][0....k]`

设计一个DP数组来表示子问题的解。

这里的状态需要包含两个维度：

- `dp[i][j]` 表示：**从第 `i` 个事件到第`n`的范围内（`events[i-1...n-1]`），选择参加 `j` 个事件所能获得的最大价值**。
  - `i`表示数组的索引，范围是`[0...n]`,其中`n`表示**没有任何可以选择的事件**
  - `j`表示选择的数量，范围是`[0...k]`

- 我们的目标是求解 `dp[0][k]`。

###### DP表的初始化

- 我们创建一个 `(n+1) x (k+1)` 的 DP 表，`n` 是事件数量。

- `dp[n][j]` 对于所有的 `j` 都为 0，因为当 `i=n` 时，表示**没有任何事件可供选择**，所以最大价值为 0。

  这个 `n+1` 的维度可以巧妙地处理边界情况。

###### 状态转移方程

我们需要**从后向前**填充 `dp` 表。

这样，当我们计算 `dp[i][j]` 时，所有 `dp[i+1][...]` 的值（即后续事件的最优解）都已经是已知的。

**外层循环**: `i` 从 `n-1` 遍历到 `0`。

**内层循环**: `j` 从 `1` 遍历到 `k`。

对于 `dp[i][j]`，我们同样面临两个选择：

- **不参加事件 `i`**: 

  如果放弃事件 `i`，那么问题就变成了“从第 `i+1` 个事件开始，参加 `j` 个事件的最大价值”。

  这个值我们已经计算过了，就是 `dp[i+1][j]`。

- **参加事件 `i`**:。

  我们获得 `events[i]` 的价值。

  然后，我们需要从 **不与事件 `i` 重叠** 的后续事件中，再选择 `j-1` 个。

  为此，我们必须找到第一个开始时间在 `events[i]` 结束时间之后的事件，设其索引为 `nextIndex`。

  这里我们需要借助二分查找，寻找**大于当前时间的会议的最小的索引**。

  参加事件 `i` 的总价值就是 `events[i][value] + dp[nextIndex][j-1]`。

   `dp[nextIndex][j-1]` 的值也是已知的，因为 `nextIndex > i`，我们**在之前的迭代中已经计算过它**了。

- **最终决策**: 

  `dp(index, k) = max(不参加的价值, 参加的价值)`
  
  $dp[i][j] = \max(dp[i+1][j], \quad \text{events}[i]\_{\text{value}} + dp[\text{nextIndex}][j-1]) $

###### 优化查找 - 利用二分查找大于当前事件结束时间的事件的最小索引

在计算“参加”分支时，线性地从 `index + 1` 开始查找 `nextIndex` 会导致时间复杂度过高。

由于事件已经按 `startTime` 排序，我们可以使用 **二分搜索** 在 $O(logN)$ 时间内高效地找到 `nextIndex`。

###### 边界条件

如果 `k == 0`（没有机会了），或者 `index >= n`（没有事件了），能获得的价值为 0。

####实现原理和步骤

###### 初始化： 排序 + DP定义

- **排序**: 将 `events` 数组按 `startTime` 升序排序。

- **初始化 DP 表**

   创建一个 `int[][] dp = new int[n + 1][k + 1]` 的二维数组。

  所有元素默认为 0，这正好符合我们的边界条件（当 `i=n` 或 `j=0` 时，价值为0）。

###### 迭代填充

- **外层循环**: `for (int i = n - 1; i >= 0; i--)`
- **内层循环**: `for (int j = 1; j <= k; j++)`

- **计算状态**

  在循环内部，执行以下操作来计算`dp[i][j]`

  - **计算不参加events[i]的价值**

    `valSkip = dp[i+1][j]`

  - **计算参加event[i]的价值**

    - 获取当前事件`events[i]`的结束时间和价值
    - 使用二分搜索找到`nextIndex`
    - 计算价值:`valAttend = events[i][2] + dp[nextIndex][j-1]`

  - **更新DP表**

    `dp[i][j] = Math.max(valSkip, valAttend)`

- **返回结果**

  所有循环结束后，`dp[0][k]`就是我们要求的最终答案，它代表**从第0个事件开始，最多参加k个事件**的最大价值。

#### 实现代码

```Java
class Solution {
    //区间类问题
    //能够参加的会议数量
    
    public int maxValue(int[][] events, int k) {
        int n = events.length;
        Arrays.sort(events,(a,b) -> a[0] - b[0]);
        //1. 定义DP状态：                                                       
        //dp[i][j]表示从events[i...n-1]中选择j个事件的最大价值
        //i的范围是0 到 n-1
        int[][] dp = new int[n+1][k+1];

        //2. DP 状态初始化
        //dp[n][j]对于所有的j都是0，因为i=n时没有任何事件可以选择，所以最大价值为0

        //遍历和状态转移
        //外层遍历events
        for(int i = n-1; i >=0; i--){
            //内层遍历限制
            for(int j = 1; j <=k; j++){
               int valSkip = dp[i+1][j];
               
               int next = getNext(events, i);
               int valAttend = events[i][2] + dp[next][j-1];

               dp[i][j] = Math.max(valSkip, valAttend);
            }
        }

        return dp[0][k];
    }
    //利用二分查找，找到大于events[idx]的最小值
    //属于寻找做边界，查找 >= target的最小索引
    private int getNext(int[][] events, int index){
        int left = index + 1;
        int right = events.length - 1;
        //end time作为target
        int target = events[index][1];
        int ans = events.length;
        //注意寻找边界的时候的while条件是left <= right
        while (left <= right) {
            int mid = left + (right - left) / 2;
            //找到一个可能的答案
            if(events[mid][0] > target){
                //保存可能的答案
                ans = mid;
                //继续向左收缩查找范围
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        return ans;
    }
}
```

### Leetcode 879:双重混合限制 -  犯罪计划问题[重点题目，需要多次理解加深]

#### 问题要点

- 给定一个犯罪集团，一共n个人

- 以及一组犯罪活动

- 第i个犯罪活动生成的利益为profit[i],需要的犯罪份子的人数为group[i]

- 如果一个犯罪份子参加了一个犯罪活动，那么他就不能参加其他的犯罪活动

- 我们定义一个犯罪计划是由一组犯罪活动和一个最小盈利minProfit组成，参与计划的犯罪分子人数不能超过n

- 返回可以选择犯罪计划的数量

- 因为答案可能会比较大，返回的结果应该 % 10^9 +7

#### 问题本质和分析 - 具有双重限制的0-1背包问题

首先这是一个计数问题。

犯罪集团的目的可能是从众多的犯罪计划中选择一个最好的。

但是现在他们的目的是首先计算出所有的获利不小于`minProfit`的犯罪计划的数量。

##### 问题如何转化为背包问题？

| 背包项目 | 映射项目           | 说明                                                         |
| -------- | ------------------ | ------------------------------------------------------------ |
| 物品     | 犯罪活动           | `i`                                                          |
| 物品重量 | 犯罪活动所需要人数 | `group[i]`                                                   |
| 物品价值 | 犯罪活动的获利     | `profit[i]`，总价值不小于`minProfit`                         |
| 容器容量 | 犯罪集团人数       | 不大于`n`                                                    |
| 子集映射 | 犯罪计划           | 一个犯罪计划包含多个犯罪活动`crimes[i=0...n-1]`，一个犯罪活动需要`group[i]`个犯罪份子，一个犯罪活动获利是`profit` |

从上面的映射分析过程中，我们可以看到这个问题应该是一个0-1背包问题。

并且这个背包问题有两个限制：

- 总容量不大于`n`
- 总价值不小于`minProfit`

找出符合上述条件的犯罪或总的子集的总数。

#### 核心思想和套路

我们将使用动态规划来解决。关键在于定义 DP 状态、找出状态转移方程、确定基本情况和最终的答案计算。

##### DP的定义

为了清晰地展示逻辑，我们使用三维 `dp` 数组。 `dp[k][i][j]` 表示：**考虑前 `k` 个犯罪活动，恰好使用 `i` 名成员，恰好产生 `j` 点利润的方案数。**

- `k`: 第一个维度，表示我们正在考虑第 `k` 个犯罪活动（物品）。范围从 `0` 到 `group.length`。
- `i`: 第二个维度，表示已使用的人数。范围从 `0` 到 `n`。
- `j`: 第三个维度，表示已产生的利润。范围从 `0` 到 `minProfit`。

##### “至少” 与 “恰好” 的转换技巧 - 利润封顶技巧

题目要求利润**至少**为 `minProfit`。

如果我们让 `j` 的维度无限增长，DP数组会过大。

这里的核心技巧是**利润封顶（Profit Capping）**：

- 对于我们来说，产生 `minProfit` 的利润、`minProfit + 1` 的利润，或者 `minProfit + 100` 的利润，在“是否满足条件”这一点上是等价的。
- **因此，我们可以把所有**大于等于** `minProfit` 的利润都“压缩”或“视为” `minProfit`。**
- 这样，`dp[k][i][minProfit]` 的含义就变成了：**考虑前 `k` 个犯罪活动，使用 `i` 名成员，产生**至少** `minProfit` 利润的方案数。**

##### 状态转移方程

对于第 `k` 个犯罪活动（设其需要 `g = group[k-1]` 人，产生 `p = profit[k-1]` 的利润），当我们计算 `dp[k][i][j]` 时，它依赖于考虑前 `k-1` 个犯罪活动时的状态。我们有两种决策：

######**不选择第 `k` 个犯罪活动**:

那么，构成 `(i, j)` 状态的方案数，就完全等于只考虑前 `k-1` 个犯罪活动时的方案数。

即 `dp[k-1][i][j]`。

###### **选择第 `k` 个犯罪活动** - 考虑利润封顶策略

当当前人数`i`足够多，即`i >= group[k-1]`时，我们可以选择第`k`个犯罪活动。

在选择第`k`个活动之前，我们必须已经是使用了`i-group[k-1]`个人，产生了`j-profit[k-1]`的状态

因此这部分贡献的方案数是`dp[k-1][i-group[k-1]][j-profit[k-1]]`。



###### 综合两种情况的方案数

综合起来，状态转移方程就是：

$$dp[k][i][j] = dp[k-1][i][j](不选) + dp[k-1][i-group[k-1]][j-profit[k-1]](选择，但是需要i \ge group[k-1] 并且 j \ge profit[k-1])$$

##### Base Case: 0个犯罪活动0利润

在考虑0个犯罪活动时，使用0个人、获得0利润的方案有且仅有1种，那就是“什么都不做”这个方案。这是所有计数DP的起点。

`dp[0][0][0] = 1`

####  实现原理和步骤

#####初始化状态数组

定义 `MOD = 1_000_000_007`。

创建一个三维数组 `dp[group.length + 1][n + 1][minProfit + 1]`。

设置基本情况 `dp[0][0][0] = 1`。

#####循环迭代过程

- 外层循环遍历所有犯罪活动 `k` 从 `1` 到 `group.length`。
- 在循环内部，获取当前犯罪活动的人数 `g = group[k-1]` 和利润 `p = profit[k-1]`。
- 中层循环遍历所有可能的人数 `i` 从 `0` 到 `n`。
- 内层循环遍历所有可能的利润 `j` 从 `0` 到 `minProfit`。

#####状态转移过程

对于每个状态 `dp[k-1][i][j]`，如果其值大于0，说明存在这样的方案。

######**决策1（不选）**: 

将 `dp[k-1][i][j]` 的方案数累加到 `dp[k][i][j]`。 `dp[k][i][j] = (dp[k][i][j] + dp[k-1][i][j]) % MOD;`

######**决策2（选）**: - 利润封顶技巧

- 检查是否满足人数要求：`if (i + g <= n)`。

- 考虑当前的情况利润是`j`，计算新的利润：`j + profit[k-1]`

  - 如果新的利润超过`minProfit`，我们将它归功于`minProfit`
  - 如果新的利润不超过`minProfit`，我们将它归功于新的利润

  这样的情况下，**`dp[k][j][minProfit]`所代表的就是所有利润大于等于`minProfit`的计划的数量了**。

  - 计算新的利润（应用利润封顶技巧）：`int newProfit = Math.min(minProfit, j + p);`

  - 将 `dp[k-1][i][j]` 的方案数累加到新的状态 `dp[k][i + g][newProfit]`。

    `dp[k][i + g][newProfit] = (dp[k][i + g][newProfit] + dp[k-1][i][j]) % MOD;`

##### 计算最终结果

当所有犯罪活动都考虑完毕后（即 `k = group.length`），我们需要统计所有满足条件的方案。

条件是：利润至少为 `minProfit`。由于我们的利润封顶技巧，这些方案都累加在了 `dp[group.length][i][minProfit]` 中（对于任意 `i`）。

所以，最终答案是 `dp[group.length][0][minProfit] + dp[group.length][1][minProfit] + ... + dp[group.length][n][minProfit]` 的总和。

遍历 `i` 从 `0` 到 `n`，将 `dp[group.length][i][minProfit]` 累加起来，每次累加后取模。

#### 实现代码

```Java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int MOD = 1_000_000_007;
        int numCrimes = group.length;

        // DP状态定义: dp[k][i][j]
        // k: 已经考虑过的犯罪活动数量 (从 0 到 numCrimes)
        // i: 已经使用的成员人数 (从 0 到 n)
        // j: 已经产生的利润 (从 0 到 minProfit, j=minProfit 代表利润 >= minProfit)
        // dp[k][i][j] 的值: 达成该状态的方案总数
        // 使用 long 类型防止中间计算溢出
        long[][][] dp = new long[numCrimes + 1][n + 1][minProfit + 1];

        // Base Case: 在考虑0个犯罪活动时，使用0个人、获得0利润的方案有1种（即“什么都不做”）。
        dp[0][0][0] = 1;

        // 遍历每一个犯罪活动
        for (int k = 0; k < numCrimes; k++) {
            int currentGroup = group[k];    // 当前犯罪所需人数
            int currentProfit = profit[k];  // 当前犯罪产生利润

            // 遍历所有可能的前置状态 (在考虑了k个犯罪之后)
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= minProfit; j++) {
                    // 如果 dp[k][i][j] 是 0，说明无法达到这个状态，
                    // 它不能作为任何后续状态的基础，直接跳过可以优化性能。
                    if (dp[k][i][j] == 0) {
                        continue;
                    }

                    // --- 决策分支 ---
                    
                    // 决策 1: 不实施第 k+1 个犯罪活动
                    // 那么 dp[k][i][j] 的方案数会直接延续到 dp[k+1][i][j]
                    dp[k + 1][i][j] = (dp[k + 1][i][j] + dp[k][i][j]) % MOD;

                    // 决策 2: 实施第 k+1 个犯罪活动
                    // 检查是否满足人数限制
                    if (i + currentGroup <= n) {
                        // 计算新的利润，并应用“利润封顶”技巧
                        // 所有超过 minProfit 的利润都归入 minProfit 类别
                        int newProfit = Math.min(minProfit, j + currentProfit);
                        
                        // dp[k][i][j] 的方案数会贡献给新的状态 dp[k+1][i + currentGroup][newProfit]
                        dp[k + 1][i + currentGroup][newProfit] = (dp[k + 1][i + currentGroup][newProfit] + dp[k][i][j]) % MOD;
                    }
                }
            }
        }

        // 统计最终结果
        // 当所有犯罪活动都考虑完毕后 (k = numCrimes)，
        // 所有利润 >= minProfit 的方案都记录在 dp[numCrimes][i][minProfit] 中。
        // 我们需要把所有人数情况 (i从0到n) 下的这些方案数加起来。
        long totalSchemes = 0;
        for (int i = 0; i <= n; i++) {
            totalSchemes = (totalSchemes + dp[numCrimes][i][minProfit]) % MOD;
        }

        return (int) totalSchemes;
    }
}
```

#### 注意事项

**数据类型**: 中间累加过程可能会超出 `int` 的范围，即使最终结果在 `int` 范围内。使用 `long` 来定义 `dp` 数组或进行中间计算是更安全的做法，最后再强制类型转换为 `int`。

**数组维度**: DP 数组的大小通常是 `容量+1`。比如人数是 `n`，那么数组维度需要到 `n`，所以大小是 `n+1` (索引从0到n)。犯罪活动数量 `k` 也是同理。

**Base Case 的重要性**: `dp[0][0][0] = 1` 是计数的根基。没有它，所有结果都将是0。

**取模运算**: 取模运算 (`% MOD`) 必须在**每次加法操作后**进行，以防止溢出。

#### 经验总结

- **识别模式**: 当遇到“从一组物品中选择子集”、“计算方案数”、“满足多个约束条件”等关键词时，要立刻联想到**多维计数背包DP**。

- **处理约束**: “不超过N”的约束（如人数）直接映射为DP数组的维度（容量）。“不小于M”的约束（如利润）通常通过**利润封顶/状态压缩**或**最终求和**来处理。

- **从繁到简**: 三维DP是理解背包问题原理的绝佳方式，它明确展示了“物品”这一维度。在完全理解后，可以应用标准的空间优化技巧（通常是使用倒序循环）将其降至二维，从而在面试和比赛中写出更优的代码。

##### 技巧一：分层递推

您指出的 “在每一輪計算 `dp[k+1][i][j]` 而不是 `dp[k][i][j]`” 是動態規劃最原始、最符合其數學定義的實現方式。

**核心思想**: `dp[k]` 這一整個“層”的數據，代表了“只考慮前 `k` 個物品”能達成的所有狀態。

`dp[k+1]` 層的計算，**完全且僅僅依賴於** `dp[k]` 層的數據。兩層之間涇渭分明，互不干擾。

##### 技巧二： 利润封顶 - 解决背包问题最小约束的技巧

這是解決“**至少(>=)**”型約束的“神來之筆”，是本題從“看似不可解”到“巧妙可解”的轉折點。

###### 核心思想

將一個開放區間的約束（`利潤 >= minProfit`）轉化為一個封閉的、有限的DP狀態。

所有計算結果超出 `minProfit` 的利潤，我們都將其“摺疊”或“壓縮”到 `minProfit` 這個狀態點上。- 将大于`minProfit`的都归功于`minProfit`头上。

實現方式為 `newProfit = Math.min(minProfit, j + p)`。

- **控制狀態空間**: 如果沒有這個技巧，DP數組的“利潤”維度需要開到所有物品利潤的總和，這在大多數情況下會導致內存超限（MLE）。“利潤封頂”將這一維度的大小鎖定在 `minProfit + 1`，使得狀態空間變得可控。
- **簡化問題模型**: 它將一個複雜的“範圍約束”問題，簡化成了一個“點約束”問題。我們不再需要關心實際利潤是 `minProfit+1` 還是 `minProfit+100`，因為它們對於“是否滿足條件”是等價的。這使得 `dp[...][minProfit]` 這個狀態點擁有了新的含義：“利潤至少為 `minProfit` 的方案數”。
- **簡化最終計算**: 計算最終答案時，我們不再需要遍歷一個利潤範圍（`for j from minProfit to MAX_PROFIT`），而只需精確地累加所有 `dp[...][minProfit]` 的值即可，極大地簡化了匯總步驟。

##### 这个问题可以总结为同时带最大和最小限制的背包问题的套路

我们假设物品有两个属性，重量和价值，我们找出价值总和不低于minValues, 背包限制是capacity。



### Leetcode 871: 最少经停的加油站数量

#### 问题要点

- **目標:** 計算從起點到達目標位置所需的**最小**加油次數。
- **輸入:**
  - `target`: 目標距離。
  - `startFuel`: 初始油量。
  - `stations`: 二維數組 `[[position_i, fuel_i], ...]`，代表加油站的位置和油量。
- **約束:**
  - 油箱容量無限，每行駛 1 英里消耗 1 升油。
  - 加油站按位置升序排列。
  - 無法到達則返回 -1。

#### 问题的本质和分析 - 0/1背包问题

此問題的本質可以被視為一個**帶有條件約束的價值最大化問題**，這正是背包問題的核心。

想像一下，你有一個“背包”，這個背包的“容量”是你可以接受的加油次數。

沿途的每個加油站都是一件“物品”。

將一個“物品”（加油站）“放入背包”（選擇加油）會佔用 `1` 單位“容量”（加油次數），同時會為你帶來一定的“價值”（增加的可行駛距離）。



你的目標是：**用盡可能小的“背包容量”（最少的加油次數），使得獲得的總“價值”（總行駛距離）能夠達到 `target`**。



這個視角將問題從一個直觀的行程規劃，轉化為一個抽象但結構清晰的組合優化問題，完美地契合了 0/1 背包模型。



#### 模式匹配 - 根据价值限制求最小容量

| 0/1 背包問題元素        | LeetCode 871 問題元素            | 說明                                                         |
| ----------------------- | -------------------------------- | ------------------------------------------------------------ |
| **背包 (Knapsack)**     | 汽車的行程潛力                   | 我們要優化的載體。                                           |
| **物品 (Items)**        | **加油站 `i`**                   | 每一個加油站都是一個可供選擇的決策點，即一件物品。           |
| **物品重量 (Weight)**   | **1 次加油**                     | 每選擇一個加油站加油（放入物品），都會消耗固定的“重量” 1。   |
| **物品價值 (Value)**    | **加油站的油量 `fuel`**          | 選擇一個加油站加油（放入物品），會獲得`fuel`的價值，即增加的續航里程。 |
| **背包容量 (Capacity)** | **加油次數 `j`**                 | 我們限制自己最多只能加油 `j` 次。                            |
| **約束條件**            | **可達性** (`reach >= position`) | 這是與標準背包問題最大的不同點。你不能隨意將物品放入背包，必須先滿足**能開到這個加油站**的前提條件。 |

#### 核心思想 - 根据价值限制求最小容量的背包问题

标准的背包问题是**根据容量限制求最大价值**。

但是根据我们这里的分析，现在的问题变成了根据价值限制求最小容量。

这里的最小容量就是经停的加油站数量。

##### DP状态定义

`dp[i][j]`：一個長整型 `long`，表示在**考慮前 `i` 個加油站**（物品）的情況下，使用**`j` 次加油**（背包容量）所能到達的**最遠距離**（最大價值）。

##### DP状态转移方程

當我們遍歷到第 `i` 個加油站 `stations[i-1]` 時，對於 `j` 次加油，我們面臨一個典型的 0/1 選擇：

###### 不在加油站`i`加油（不选择i物品）

- 在這種情況下，能到達的最遠距離和只考慮前 `i-1` 個加油站、加油 `j` 次時是相同的。
- `dp[i][j]` 的一個可能值是 `dp[i-1][j]`。

######在加油站`i`加油（选择i物品）

**前提 (約束):** 必須能夠到達第 `i` 個加油站。

這意味著，使用 `j-1` 次加油、考慮前 `i-1` 個加油站所能達到的最遠距離 `dp[i-1][j-1]` 必須大於等於 `stations[i-1][0]`。

**決策**： 

根据标准的0-1背包, 在满足容量条件`j >= w[i-1]`的条件下，`dp[i][j] = dp[i-1][j-w[i-1] + value[i]] `

对于现在的问题而言，

满足的条件就是当前车内的油是否足以到达`station[i-1]`。

`dp[i-1][j-1] >= station[i-1]`。

物品的重量是1，物品的价值就是提供的公里数`stations[i-1][1]`。

如果滿足前提，我們就可以在這次加油，獲得的總距離是 `dp[i-1][j-1] + stations[i-1][1]`。

###### 状态转移方程

$$ dp[i][j]=\left\{
\begin{array}{rcl}
dp[i-1][j]       &      & \quad 不在加油站i加油\\
max(dp[i-1][j], dp[i-1][j-1]+stations[i-1][1])     &      & if\quad dp[i-1][j-1] \ge stations[0]
\end{array} \right. $$



#### 实现原理和步骤

##### 初始化： 

- 創建一個 `(n+1) x (n+1)` 的二維數組 `dp`，其中 `n` 是加油站的數量。
- `dp[0][0] = startFuel`。
- 對於 `i` 從 1 到 `n`，初始化 `dp[i][0] = startFuel`。這表示**考慮前 `i` 個加油站，但不加油（容量為0）**，最遠距離永遠是初始油量。

##### 遍历和更新DP

- 外層循環 `i` 從 1 到 `n`，代表遍歷每一個加油站（物品）。
- 內層循環 `j` 從 1 到 `i`，代表遍歷不同的加油次數（背包容量）。
- 在循環體內，應用我們上面推導出的狀態轉移方程來計算 `dp[i][j]` 的值。

##### 寻找结果

- 填完整個 DP 表後，遍歷 `j` 從 0 到 `n`。

- 對於每一個 `j`，檢查 `dp[n][j]` (即考慮了所有加油站，加油 `j` 次) 是否大於等於 `target`。

- 第一個滿足條件的 `j` 就是我們要求的最小加油次數。

- 如果遍歷完所有 `j` 都無法滿足條件，則返回 -1。

#### 实现代码

```Java
class Solution {
    public int minRefuelStops(int target, int startFuel, int[][] stations) {
        int n = stations.length;
        //dp[i][j]表示行驶在经过第i个加油站，经停j个加油站的时候，能够行驶的公里数
        //我们的结果就是求最小公里数大于等于target的最小的j
        if(startFuel >= target){
            return 0;
        }

        int[][] dp = new int[n+1][n+1];
        //dp[0][0] = 0;
        // dp[..][0] = startFuel;
        //如果不经停任何一个加油站，那么不管在哪里，能够行驶的最远距离都是startFuel;
        for(int i = 0; i <= n; i++){
            dp[i][0] = startFuel;
        }

        for(int i = 1; i <= n; i++){
            int[] station = stations[i-1];
            for(int j = 1; j <= i; j++){
                dp[i][j] = dp[i-1][j];
                if(dp[i-1][j-1] >= station[0]){
                    dp[i][j] = Math.max(dp[i][j],
                    dp[i-1][j-1] + station[1]);
                }
            }
        }

        for(int j = 0; j <= n; j++){
            if(dp[n][j] >= target){
                return j;
            }
        }
        return -1;
    }
}
```

#### 注意事项

1. **數據類型:** `target` 和油量可能很大，計算最遠距離時會累加，務必使用 `long` 類型來存儲 DP 數組的值，防止溢出。
2. **數組維度:** `dp` 數組的大小是 `(n+1) x (n+1)`，因為要考慮 "前0個" 加油站和 "加油0次" 的情況。
3. **索引對應:** `dp[i]` 對應的是 `stations[i-1]`，在編寫代碼時需要注意索引的轉換。
4. **複雜度:** 這種解法的時間複雜度和空間複雜度都是 O(N²)，其中 N 是加油站的數量。

#### 经验总结

**範式識別的力量:** 將問題成功映射到 0/1 背包範式，可以提供一個非常清晰和結構化的解決路徑，即使問題本身看起來很複雜。狀態定義和轉移方程的推導都變得有章可循。

**理解變體:** 這個問題展示了標準 DP 範式是如何在實際中產生變體的。核心的“0/1決策”結構不變，但增加了“可達性”這一動態約束，這是解決問題的關鍵。

**權衡與優化:** 雖然二維 DP 解法在邏輯上最貼近背包範式的原型，便於理解，但其 O(N²) 的空間複雜度在 N 很大時可能成為瓶頸。這也解釋了為何需要空間優化，從而推導出更精簡的一維 DP 解法。理解二維版本是掌握一維優化版本的基礎。

这个题目的最优解是贪心算法 + 优先队列，应当注意加强练习。

##完全背包问题-每个物品都不限制选择次数

| Item          | Value-二维数组                                               | 一维dp数组 | Comments                                                     |
| ------------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| 数据结构      | 数组                                                         |            |                                                              |
| 场景          | 完全背包问题，求最大价值                                     |            |                                                              |
| 状态定义      | `dp[i][j]`:前`i`个物品，容量为`j`的最大值                    |            | 一维dp数组定义？                                             |
| 状态初始化    | `dp[0][*] = 0`                                               |            |                                                              |
| 遍历逻辑      | 外层按照元素索引`i`遍历`i=[1...n]`，内层按照容量`j`遍历`j=[0...C]` |            | 1. 一般情况下，**先遍历物品，再遍历容量**。 2.**如果是排列问题，必须先遍历容量，再遍历物品** |
| 状态转移方程  | `dp[i][j] = max(dp[i-1][j],dp[i][j-w[i]]+v[i]) `             |            | 1. 0-1背包问题的状态转移方程是`max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])`2.  需要注意检查**是否具备使用`dp[i][j-w[i]]`的条件**：a: 基本条件`j >= w[i]`,b.需要检查具体业务场景所决定的条件 3. 求排列的情况下`dp[i][j] += dp[i][j - nums[i - 1]]`; |
| 常见目标      | 最大值                                                       |            |                                                              |
| 核心思想      | 选或者不选                                                   |            |                                                              |
| 注意事项      |                                                              |            |                                                              |
| LeetCode 题目 | 322, 518, 377, 139, 70                                       |            |                                                              |

###问题本质-每个物品都不限制选择次数

**场景**：与 0/1 背包类似，但关键区别在于：**每个物品可以无限次选择**。

**目标**：在容量限制内，求最大价值（或最少数量、组合数等）。

典型题目如 LC 322 (零钱兑换), 518 (零钱兑换 II)。

####**状态定义**-  `dp[i][j]`表示前`i-1`个物品在容量为`j`的情况下的最大价值

- **n+1 行**，表示：`0, 1, ..., n`（第 0 行代表“没有物品”）
- **W+1 列**，表示：`0, 1, ..., W`（第 0 列代表“容量为 0”）

####**遍历方式 **- 外层物品内层容量 - 不讲究顺序（组合）

所谓不讲究顺序，是指组合的方式，**不管顺序如何，都被视为相同的解**。

这个过程是为了计算对于每前`i`种物品`[0...i-1]`容量为`[w[i]...c]`的时候的最大容量分别是多少

#####外层遍历物品`i = [1....n-1]`

#####内层遍历容量`j = [w[i]....c]`

- 内层遍历容量，从小(`当前物品重量`)到大(`背包最大容量`)，依次`递加`

```java
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        if (j < w[i - 1]) {
            dp[i][j] = dp[i - 1][j];  // 装不下，不能选
        } else {
            // 注意：这里是 dp[i][j - w[i - 1]] + v[i - 1]
            // 而不是 dp[i - 1][j - w[i - 1]] + v[i - 1]
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - w[i - 1]] + v[i - 1]);
        }
    }
}
```

####遍历方式-外容量内物品 - 讲究顺序（排列）

#####外层遍历容量`j=[0...target]`

#####内层遍历物品`i=[0...n-1]`

```java
for (int j=0; j<= target; j++){
  for (int i=1; i<=n; i++){
    //...
  }
}
```

####状态转移方程的推导 - 和 0-1背包的不同点是当前物品可重选

在每一轮中，我们已知的状态为

- **前`i-1`个物品在背包容量为`j`的情况下的最大价值：**`dp[i-1][j]`
- **前`i`物品在背包容量为`j-w[i]`的情况下的最大价值:**`dp[i][j-w[i]]`， 因为允许`i-1`已经选择的情况下再次选择。

#####选择当前物品

如果选择了当前的物品， 那么前i个物品在背包容量为`j`的情况下的最大价值就是：

注意这里因为物品是可以重复选择的，并不是`dp[i-1][j-w[i]] + v[i]`

`dp[i][j-w[i]]+v[i]`

**前i个物品在背包容量为j的情况下的最大价值=前i-1个物品在背包容量为j-w[i]的情况下的最大价值+v[i]**``dp[i][j-w[i]]+v[i]``

`dp[i][j]=dp[i-1][j-w[i]]+v[i]`

#### 不选择当前物品

不选择当前物品的情况下，则表达式和0-1背包问题是一样的：

`dp[i-1][j]`

####为什么从小到大意味着`dp[i][...]`可能已经包含了物品`i`的价值？

🌟 关键就在：我们当前是计算 `dp[i][j]`，而 `dp[i][j - w[i-1]]` 是在同一行！

这就意味着：

- 你已经在 `dp[i][j - w[i-1]]` 中，**考虑过 i 号物品**；
- 所以你正在基于“选了一次 i” 的状态，再**接着选一次 i**；
- 从而实现了：**物品 i 的重复选择**

以下二者的最大值/最小值

- 不选择当前物品：`dp[j]`
- 选择当前物品：`dp[j-w[i]]+v[i]`

```java
 dp[i][j] = Math.max(dp[i-1][j], dp[i][j - w[i]] + v[i]);
```

1. **不使用**第 `i` 种物品：方案数与使用前 `i-1` 种物品凑成容量 `j` 的方案数相同，即 `dp[j]` (旧)。
2. **使用**第 `i` 种物品（至少一次）：这个方案必然包含至少一个物品 `i`。那么，这个方案可以看作是“在已经凑成 `j - c[i]` 的方案基础上，再多加一个物品 `i`”。因此，方案数来自于 `dp[j - c[i]]`。

### 用完全背包解决组合问题 - 不关心顺序

组合问题的思想是求凑成`target`的方案总数，不关心顺序。

#### 核心思想 - 固定物品的遍历顺序

为了不重复计算，我们必须为方案定义一个唯一的、固定的顺序。

通常的做法是**固定物品的遍历顺序**。

为了确保不重复计算（例如，`{1, 2}` 和 `{2, 1}` 只算一种），我们必须为决策过程建立一个固定的、不可逆的顺序。

最经典的方法就是**按顺序考虑每一种物品**。

我们的思考路径是：对于第 `i` 个物品，我们可以选择用它几次（0次，1次，2次...）来凑成目标容量 `j`。

####DP数组的定义 - 用前 `i` 种物品，恰好凑成容量为 `j` 的方案总数

当我们考虑第 `i` 种物品时，对于容量 `j`，它可以由两种情况转化而来：

##### 完全不使用第`i`种物品

那么，凑成容量 `j` 的所有组合都必须来自前 `i-1` 种物品。方案数直接继承自 `dp[i-1][j]`。

##### 至少使用一次第`i`个物品

一个包含物品 `i` 的组合，可以看作是“一个凑成 `j - coin` 的组合”再添加一个物品 `i` 构成的。

因为我们只使用前 `i` 种物品，所以这个“凑成 `j - coin` 的组合”也必须是只使用前 `i` 种物品得到的。

因此，这部分的方案数来自于 `dp[i][j - coin]`。

##### 状态转移方程

我们将上述两种情况相加，得到状态转移方程：

$dp[i][j] = dp[i-1][j]\quad (不使用第i种物品) + dp[i][j-coin] \quad (使用第i种物品)$

这个方程清晰地体现了决策过程，并且由于我们是按物品顺序 `i` 递增进行计算，保证了方案都是组合。

#### 代码模板套路

```Java
public int combinationSum(int[] coins, int amount){
  int n = coins.length;
  
  int[][] dp = new int[n+1][amount+1];
  
  //无论哪一种情况凑成0的方案数都是1
  for(int i = 0; i <= amount; i++){
    dp[i][0] = 1;
  }
  
  for(int i = 1; i <= 0; i++){
    int coin = coins[i-1];
    for(int j = 1; i <= amount; j++){
      dp[i][j] = dp[i-1][j];
      if(j >= coin){
        dp[i][j] += dp[i][j-coin];
      }
    }
  }
  
  return dp[n][amount];
}
```

#### 注意事项

**DP数组尺寸**：`dp[n+1][amount+1]` 是为了方便处理索引，让 `dp[i]` 直接对应第 `i` 种物品。

**Base Case**：`dp[i][0] = 1` 是递推的起点，其含义是“凑成0元有一种方案”，这至关重要。

**循环顺序**：必须是**先遍历物品，再遍历背包**。这个顺序是保证结果为“组合”的根本。它规定了我们决策时，物品池是逐步扩大的（先只用物品1，再只用物品1和2...）。

### 使用完全背包问题解决排列问题 - 关心顺序

解决的是“凑成总数”的方案数，并且**关心物品放入的顺序**。

#### 核心思想 - 聚焦于“构成当前总和的最后一步”

当我们思考如何凑成一个目标总和 `j` 时，我们不关心前面的组合是什么，只关心它是如何通过“最后添加一个物品”来实现的。

例如，要凑成 `j=10`，可能是由一个凑好了 `8` 的排列，最后加上物品 `2` 得到的；

也可能是由一个凑好了 `7` 的排列，最后加上物品 `3` 得到的。

因此，凑成目标 `j` 的**总排列数**，等于**所有**这些可能的前置状态（`j-物品大小`）的排列数之和。

我们的二维数组，就是要以一种结构化的方式，严谨地计算出这个累加的过程。

#### DP的定义： 

`dp[i][j]`：表示凑成**目标总和为 `j`**，当内层循环**已考虑完前 `i` 个物品**作为“最后一步”的可能性后，所得到的当前累积排列总数。

- `j` (row index): 代表我们正在计算的目标总和。

- `i` (column index): 代表我们内层循环推进到了第 `i` 个物品。`dp[j][nums.length]` 将是凑成 `j` 的最终答案。

#### 状态转移过程

我们以**容量**为主导，按照容量从1 到 `target`进行计算（外层循环遍历容量 `j`）。

在计算 **容量为j**，我们从左到右填充（内层循环遍历物品 `i`）。

对于 `dp[i][j]`，它的值由两部分构成：

##### **继承前一列的结果**：考虑第i个物品之前

在考虑第 `i` 个物品之前，我们已经计算出了“考虑完前 `i-1` 个物品”后的排列数。

这个值是 `dp[i-1][j]`，我们首先要把它继承过来。 `dp[i][j] = dp[i-1][j];`

##### 加上新增的可能性：考虑第i个物品作为最后一步

现在我们考虑把第 `i` 个物品（设其值为 `num`）作为最后一步。

如果想这么做，背包的容量必须先被凑成 `j - num`。

而凑成 `j - num` 的总方法数是多少呢？

在我们这个二维表格里，这个值已经被完整地计算出来并储存在上一行的最终结果列，**即 `dp[n][j - num]`**。

`dp[i][j] += dp[n][j - num];` (当 `j >= num` 时)

将两者合并，就是完整的状态转移方程：

$$ dp[i][j]=\left\{
\begin{array}{rcl}
dp[i-1][j]       &      & if\quad j < num\\
dp[i-1][j] + dp[n][j-num]     &      & if\quad j \ge num
\end{array} \right. $$

#### Base condition

`dp[0][i] = 1` 对于所有 `i` 成立。

它的含义是：凑成总和为 `0` 的方法永远只有 `1` 种（即什么都不选的“空排列”），无论我们考虑多少个物品，这个事实不变。这是所有递推计算的基石。

#### 代码套路模板

```Java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;

        int[][] dp = new int[n+1][target + 1];
        
        //dp[i][0] = 1
        for(int i = 0; i <= n; i++){
            dp[i][0] = 1;
        }

        for(int j = 1; j <= target; j++){
            for(int i = 1; i <= n; i++){
                int num = nums[i-1];
                dp[i][j] = dp[i-1][j];

                if(j >= num){
                  //这一点十分重要，注意和组合的情况进行区别
                    dp[i][j] += dp[n][j-num];
                }
            }
        }

        return dp[n][target];
    }
}
```

这种实现方式虽然使用了更多的空间，但它有一个巨大的优点：**可追溯性**。

你可以随时打印出整个 `dp` 表格，清晰地看到对于任何一个容量 `j`，在依次考虑每个物品后，排列数是如何一步步累加上去的，这对于学习和调试来说非常有帮助。

### 使用完全背包求排列和求组合的实现方案的比较

#### 相同点

##### 基本初始条件 (Base Case)相同

两者的计算起点是相同的。`dp[0][...]` 通常被初始化为 `1`，代表凑成总和为 `0` 的方案只有一种（即“空集”或“什么都不选”），这是所有递推计算的基石。

##### 最终结果的位置是相同的

在我们定义的二维数组中，最终的答案都存储在同一个位置，即 `dp[target][nums.length]`。

#### 不同点

这部分是关键，两者在实现上的差异直接源于其核心思想的根本不同。

| 特性             | 组合问题 (Combination)                                       | 排列问题 (Permutation)                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心逻辑**     | **以「物品」为核心**：逐个将物品加入“可选池”，考虑每个物品“用”或“不用”。 | **以「容量」为核心**：逐个攻克每个容量目标，考虑每个目标由“哪个物品”作为最后一步达成。 |
| **DP状态定义**   | `dp[i][j]`：使用**前 `i` 种物品**，凑成容量 `j` 的**组合**数。 | `dp[j][i]`：凑成容量 `j` 时，**已考虑完前 `i` 种物品**作为最后一步后的**排列**总数。 |
| **循环嵌套顺序** | **`外层遍历物品`**，`内层遍历容量`。 `for (item : items) { for (j=1...) }` | **`外层遍历容量`**，`内层遍历物品`。 `for (j=1...) { for (item : items) }` |
| **状态转移方程** | `dp[i][j] = dp[i-1][j] + dp[i][j-num]`                       | `dp[j][i] = dp[j][i-1] + dp[j-num][n]`                       |
| **转移依赖关系** | 当前状态 `dp[i][j]` 依赖于： 1. **正上方** (`dp[i-1][j]`) 2. **当前行左方** (`dp[i][j-num]`) | 当前状态 `dp[j][i]` 依赖于： 1. **正左方** (`dp[j][i-1]`) 2. **上方某行的最终列** (`dp[j-num][n]`) |

##### 最核心的要素不同

###### 组合问题以物品为中心

逐个将物品加入“可选池”，考虑每个物品“用”或“不用”。

即遍历每一个物品，检查物品是否可以加入可选池。

###### 排列问题以容量为中心

逐个攻克每个容量目标，考虑每个目标由“哪个物品”作为最后一步达成。

##### DP状态的含义有差别

- 组合问题： `dp[i][j]`：使用**前 `i` 种物品**，凑成容量 `j` 的**组合**数。
- 排列问题： 凑成容量 `j` 时，**已考虑完前 `i` 种物品**作为最后一步后的**排列**总数。

##### 嵌套循环顺序不同

###### 组合问题： 外层物品内层容量

**`外层遍历物品`**，`内层遍历容量`。 `for (item : items) { for (j=1...) }`

###### 排列问题：外层容量内层物品

**`外层遍历容量`**，`内层遍历物品`。 `for (j=1...) { for (item : items) }`

##### 转移方程不同

###### 组合问题

```
dp[i][j] = dp[i-1][j] + dp[i][j-num]
```

###### 排列问题

```
dp[j][i] = dp[j][i-1] + dp[j-num][n]
```

##### 转移依赖关系不同

###### 组合问题： 正上方和正左方

当前状态 `dp[i][j]` 依赖于：

1. **正上方** (`dp[i-1][j]`) 
2. **当前行左方** (`dp[i][j-num]`)

###### 排列问题

当前状态 `dp[j][i]` 依赖于： 

1. **正左方** (`dp[j][i-1]`) 
2. **上方某行的最终列** (`dp[j-num][n]`)



###无顺序的完全背包 - Leetcode 322 兑零钱

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

##### 问题本质

给定一个整数数组 `coins` 表示不同面额的硬币，以及一个整数 `amount`，求凑出总金额 `amount` 所需的**最少硬币个数**。如果无法凑出，返回 `-1`。

这道题是一个**完全背包问题的变形**：

- 每种硬币**可以使用无限次**
- 目标是用最少数量的硬币凑出给定金额

##### 问题分析

- 每种硬币可以无限取 ->完全背包问题
- 求最少个数 ->求最小值
- 背包容量`amount`
  - 物品重量是硬币面值
  - 物品价值是货币数量
  - 目标是凑出刚好为`amount`的最小硬币数量

##### 核心思想-完全背包问题

利用动态规划求解最小硬币数量：

- 以金额为维度构建状态数组
- 每次尝试加入一个硬币，看看是否能够更新为更少的硬币数量

##### 状态定义和初始化

###### 状态定义-`dp[i][j]`表示前`i`种硬币组成金额`j`所需要的最少硬币数量

```
dp[i][j] 表示使用前 i 种硬币，凑出金额 j 所需的最小硬币数
```

- `i`：第 i 种硬币（1-based，下标从 1 开始）

- `j`：目标金额

- `dp[0][j]` 表示不能使用任何硬币时，凑出金额 j

###### 状态初始化

- 所有 `dp[i][0] = 0`：凑出金额 0，不需要任何硬币。
- 所有 `dp[0][j] = ∞`：**没有硬币时无法凑出正金额，设为 `Integer.MAX_VALUE`**

#####  遍历逻辑和状态转移方程

###### 遍历逻辑

```java
for i from 1 to n:       // 第i种硬币
    for j from 1 to amount:   // 凑出金额j
        进行状态转移
```

###### 状态转移方程

```java
if (j < coins[i - 1])
    dp[i][j] = dp[i - 1][j]; // 当前硬币用不了
else {
    // 不用当前硬币 vs 用当前硬币一次（注意：仍然可以继续用）
    if (dp[i][j - coins[i - 1]] != Integer.MAX_VALUE) {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);
    } else {
        dp[i][j] = dp[i - 1][j];
    }
}
```

##### 实现代码

```java
public int coinChange(int[] coins, int amount) {
    int n = coins.length;
    int[][] dp = new int[n + 1][amount + 1];

    // 初始化：dp[0][...] = ∞，无法构造
    for (int j = 1; j <= amount; j++) {
        dp[0][j] = Integer.MAX_VALUE;
    }

    // 初始化：dp[...][0] = 0，构造金额0不需要硬币
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 0;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++) {
            // 不选当前硬币
            dp[i][j] = dp[i - 1][j];

            // 选当前硬币（完全背包，可多次使用）
            if (j >= coins[i - 1] && dp[i][j - coins[i - 1]] != Integer.MAX_VALUE) {
                dp[i][j] = Math.min(dp[i][j], dp[i][j - coins[i - 1]] + 1);
            }
        }
    }

    return dp[n][amount] == Integer.MAX_VALUE ? -1 : dp[n][amount];
}
```

###有顺序的完全背包 - Leetcode 377 组合数量IV

给定一个数组 `nums`，数组中的数字可以被**无限次使用**，求能够**按顺序排列组成目标和 `target` 的排列个数**。

####✳️ 关键点-求排列数

- 数组中的元素**可以重复使用**；
- 顺序不同的组合算作不同的解；
- 是一个**排列计数问题**（而非组合）；
- 有无限物品，但顺序敏感 ⇒ **有顺序的完全背包**。

####问题分析 - 顺序敏感的完全背包问题

这个问题和**完全背包**问题相似，但是区别在于：

- **完全背包+顺序敏感 ->先枚举容量，再枚举物品**
- 若是**组合（顺序无关）**，我们通常是**先枚举物品，再枚举容量**

```
nums = [1, 2], target = 4
输出应为 5：
[1,1,1,1]
[1,1,2]
[1,2,1]
[2,1,1]
[2,2]

```

这属于排列问题，因此在看题目的时候，一定要详细看一下**题目中所给出的例子**

####核心思想-先遍历容量，再遍历物品

使用动态规划记录从`0`到`target`每个整数的**排列组合数**，逐步构造答案。

> 不同于传统的**先物品后容量**，排列问题必须**先容量后物品**，从而枚举所有的不同的排列路径

#####状态定义和初始化 - `表示使用前`i`个数字，组成和为`j`的排列个数

状态定义-`dp[i][j]`表示使用前`i`个数字，组成和为`j`的排列个数

**由于是排列，所以最终结果要累加**。

#####状态初始化

- `dp[0][0] = 1`：使用0个数字组成和为0的方法只有1种（空集）
- `dp[0][j] = 0` for `j > 0`：使用0个数字无法构造正数
- `dp[i][0] = 1` for all i：凑成0的排列只有1种（空序列）

#####遍历逻辑和状态转移方程

对于每一个容量`j`，遍历第`i`个元素

按照上述关于求排列的逻辑：

###### 即成当前元素之前的数量

`dp[i][j] = dp[i-1][j]`

###### 累加新增的方案数量

`dp[i][j] += dp[n][j-num]`



当 **当前容量大于等于当前元素的值**的时候：

```
for (int j = 1; j <= target; j++) {         // 容量在外层
    for (int i = 1; i <= n; i++) {          // 数组下标（物品）在内层
    		dp[i][j] = dp[i-1][j];
        if (j >= nums[i - 1]) {
            dp[i][j] += dp[n][j - nums[i - 1]];
        }
    }
}
```

**注意状态转移方程也和普通完全背包不同**

```
 dp[i][j] += dp[n][j - nums[i - 1]];   // 选择当前数，累加已有排列方式
```

####代码实现

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;

        int[][] dp = new int[n+1][target + 1];
        
        //dp[i][0] = 1
        for(int i = 0; i <= n; i++){
            dp[i][0] = 1;
        }

        for(int j = 1; j <= target; j++){
            for(int i = 1; i <= n; i++){
                int num = nums[i-1];
                dp[i][j] = dp[i-1][j];

                if(j >= num){
                    dp[i][j] += dp[n][j-num];
                }
            }
        }

        return dp[n][target];
    }
}
```

###Leetcode 139:单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。

如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

####问题本质-类似完全背包

##### 我们先复习一下什么是完全背包问题？

###### 完全背包问题的场景

有N种物品和一个容量为V的背包，每种物品都有无限件可用。

第i种物品的体积（或重量）是 `weight[i]`，价值是 `value[i]`。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

###### 完全背包问题的核心要素有哪些？

1. **背包容量 (Capacity):** 一个需要被“填充”的上限，比如重量或体积。
2. **物品 (Items):** 一系列可选的物件。
3. **物品属性:** 每个物品至少有两个属性：**体积/重量 (Weight)** 和 **价值 (Value)**。
4. **物品数量:** 每种物品可以无限次使用（这是“完全”的含义）。
5. **目标:** 通常是**最大化总价值**。

将字符串`s`拆分成若干个词典中的单词，判断是否可以完整拆分：

属于**变种的完全背包问题：**

| 项目             | 对应                               |
| ---------------- | ---------------------------------- |
| 背包容量         | 字符串总长度 `n`                   |
| 物品             | 字典中每一个单词（长度作为“重量”） |
| 是否可以重复使用 | ✅ 可以重复使用（无限次）           |
| 是否可以放入     | 当前子串是否能被字典命中           |

##### 状态定义和初始化-`dp[i]`表示前i个字符是否可以被拆分成词典中的单词组合

###### 状态定义

```
dp[i] 表示 s[0..i-1] 是否可以被字典中的单词完全拆分
```

###### 状态初始化

```
dp[0] = true
```

##### 遍历逻辑与状态转移方程

```java
for (int i=1; i<=s.length;i++){
  for (int j=0; j< i;j++){
    if (dp[j] && wordDict.contains(s.substring(j,i))){
      dp[i] = true;
      break;
    }
  }
}
```

###### 状态转移方程

```java
dp[i] = dp[j] && wordDict.contains(s.substring(j, i))
```

只要找到一个 `j`，使得前缀可达且后缀是字典中的单词，则当前状态成立。

##### 代码实现

```java
public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> wordSet = new HashSet<>(wordDict);
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && wordSet.contains(s.substring(j, i))) {
                dp[i] = true;
                break; // 剪枝：找到一组拆分即可
            }
        }
    }

    return dp[n];
}
```

##### 注意事项

| 项                                                           | 注意点                                   |
| ------------------------------------------------------------ | ---------------------------------------- |
| ✅ `dp[0] = true`                                             | 表示空串是可拆分的                       |
| ✅ 子串索引                                                   | `s.substring(j, i)` 表示 s[j..i-1]       |
| ✅ 使用 HashSet                                               | 提高字典查找效率，避免超时               |
| ✅ 剪枝                                                       | 找到一个可拆分路径就可以提前退出内层循环 |
| ✅ 字典中单词可重复使用                                       | 所以是完全背包模型                       |
| ❌ 不要写成 dp[i] = dp[i - len] && s.substring(i - len, i) unless fixed-length | 要枚举所有 j，而不是假设固定单词长度     |

##### 经验总结

| 项目       | 内容                                                         |
| ---------- | ------------------------------------------------------------ |
| 问题类型   | 前缀判断 + 完全背包                                          |
| 状态设计   | `dp[i]` 表示 s[0..i-1] 可否拆分                              |
| 初始化     | `dp[0] = true`，其他为 false                                 |
| 状态转移   | 从所有 j ∈ [0, i) 找一个使 `dp[j] && s[j..i-1] ∈ dict` 成立  |
| 时间复杂度 | O(n²)（n 为字符串长度，外层循环 * 内层 substring + HashSet 查找） |
| 空间复杂度 | O(n)（状态数组）                                             |

### Leetcode 279 完全平方数

#### 问题要点

- **输入**: 一个正整数 `n`。
- **输出**: 和为 `n` 的**最少**完全平方数的数量。
- **完全平方数**: 指的是 1, 4, 9, 16, 25, ... 这些可以表示为某个整数平方的数。
- **核心要求**: "最少数量"，这是一个典型的优化问题。

- `n = 12`
  - `12 = 4 + 4 + 4` (3个)
  - `12 = 9 + 1 + 1 + 1` (4个)
  - 最优解是 3。
- `n = 13`
  - `13 = 9 + 4` (2个)
  - 最优解是 2。

#### 问题本质和分析

这道题的本质是**寻找最优解**。当我们看到“最少”、“最短”、“最小”等字眼时，通常可以考虑以下几种思路：

##### 贪心算法

每次都做出局部最优选择。

例如，对于 `n=12`，我们先取最大的完全平方数 `9`，剩下 `3`。`3 = 1 + 1 + 1`。

总共需要 `9+1+1+1` 四个数。

但这并非最优解（`4+4+4` 是3个）。因此，**贪心算法不适用**。

##### 动态规划 - 完全背包问题

如果问题可以分解为重叠的子问题，并且具有最优子结构，那么 DP 是一个很好的选择。

######**最优子结构是什么？** 

`n` 的最优解，可以由 `n - k` (其中 `k` 是一个完全平方数) 的最优解推导出来。

例如，`numSquares(n) = min(numSquares(n - j*j)) + 1`。

######**重叠子问题是什么？**: 

在计算 `numSquares(12)` 时，我们可能会计算 `numSquares(11)`, `numSquares(8)`, `numSquares(3)`。

在计算 `numSquares(11)` 时，可能又会去计算 `numSquares(10)`, `numSquares(7)`, `numSquares(2)`。

这其中有很多子问题会被重复计算。

###### 广度优先搜索

如果把问题看作一个图论问题，也可以找到答案。

**图模型**: 将 `0` 到 `n` 的每个数看作一个节点。

如果两个数 `u` 和 `v` 的差是一个完全平方数，则它们之间有一条边。

**问题转化**: 这个问题就变成了，从节点 `n` 出发，到达节点 `0` 的**最短路径**是多少？

因为图中每条边的权重都是 1（代表增加了一个完全平方数），所以求最短路径的最佳算法就是 **BFS**。

#### 模式匹配

#####完全背包问题

**背包容量**: `n`

**物品**: 所有的完全平方数 (1, 4, 9, ...)。每种物品的数量是无限的。

**目标**: 装满背包（使得总和恰好为 `n`）所需要的**最少物品数量**。

这与经典的“凑零钱”（Coin Change, LeetCode 322）问题几乎一模一样，只是把“硬币面额”换成了“完全平方数”。

##### 无权图的最短路径问题

**状态**: 当前的数字。

**转移**: 从数字 `i` 减去一个完全平方数 `j*j`，就转移到了下一个状态 `i - j*j`。

**目标**: 从 `n` 开始，经过最少的转移次数到达 `0`。

这类“最少步数”、“最少操作”问题，都可以抽象为图的 BFS 问题。

#### 核心思想和套路 - 基于动态规划完全背包问题

##### 定义状态

`dp[i][j]` 表示：从前 `i` 个物品（即从 `1*1, 2*2, ..., i*i` 这 `i` 个完全平方数）中任意选择，组成和为 `j` 时，所需要的**最少**数字个数。

- **第一维 `i`**: 代表我们当前可以使用的物品范围（即考虑前 `i` 个完全平方数）。
- **第二维 `j`**: 代表当前的背包容量（即要凑成的数字）。

我们的最终目标是求 `dp[m][n]`，其中 `m` 是小于等于 `n` 的完全平方数的总个数（即 `m = floor(sqrt(n))`）。

##### 状态转移方程

当我们考虑 `dp[i][j]` 时，也就是当我们面对第 `i` 个物品（值为 `i*i`）和容量为 `j` 的背包时，我们有两种选择：

######**不使用第 `i` 个物品**:

- 如果我们决定不使用 `i*i` 这个数，那么问题就退化为：用前 `i-1` 个物品来凑成 `j`。
- 此时，所需的数量就是 `dp[i-1][j]`。

######**使用第 `i` 个物品**:

- 前提是 `j >= i*i` (背包容量足够大，能装下这个物品)。
- 因为是**完全背包**，我们可以使用任意多次第 `i` 个物品。当我们决定至少使用一个 `i*i` 时，我们先放进去一个，背包的剩余容量就变成了 `j - i*i`。
- 接下来，我们需要用**前 `i` 个物品**（注意，因为可以重复使用，所以还是 `i` 个物品，而不是 `i-1`）去填满 `j - i*i` 的容量。
- 此时，所需的数量就是 `dp[i][j - i*i] + 1` (这里的 `+1` 代表我们刚刚放进去的那个 `i*i`)。

总和以上两种情况，我们需要取其中的最小值：

$dp[i][j]=min(dp[i−1][j],dp[i][j−i∗i]+1)$

##### 初始化

**`dp` 数组**: 创建一个 `dp[m+1][n+1]` 的数组，其中 $m = \lfloor {\sqrt{n}}\rfloor$。

**第一行 `dp[0][j]`**:

- `dp[0][j]` 表示用前 0 个物品来凑成 `j`。
- 这是不可能的（除了 `j=0`），所以应该初始化为一个极大值，表示此路不通。
- 我们通常用 `Integer.MAX_VALUE` 来表示。

**第一列 `dp[i][0]`**:

 `dp[i][0]` 表示凑成和为 0。

这不需要任何物品，所以 `dp[i][0] = 0` 对所有 `i` 都成立。

综合起来：

- `dp[0][0] = 0`
- `dp[0][j]` (j > 0) = `Integer.MAX_VALUE`
- `dp[i][0]` = `0`

为了方便编码，我们可以将整个 `dp` 数组（除了 `dp[0][0]`）都**初始化为极大值（因为我们要求的是最小值）**，然后在循环中自然地处理 `dp[i][0]`。

#### 实现原理和步骤 - 基于完全背包问题

1. 计算出物品数量 $m = \lfloor {\sqrt{n}}\rfloor$
2. 创建二维dp数组`dp[m+1][n+1]`
3. 初始化dp数组：
   - 将所有元素默认值设置为`Integer.MAX_VALUE`(**因为要求最小值**)
   - `dp[0][0] = 0` ->平方和为0的子集没有？//Tobe confirmed
4. 外层遍历物品`for(int i = 1; i<=m; i++)`
5. 内层遍历容量`for(int j = 0; j <= n; j++)`
6. 在循环内部，做状态转移操作
   - `dp[i][j] = dp[i-1][j]`
   - `if(j >= i*i){dp[i][j] = Math.min(dp[i][j], dp[i][j-i*i]+1)}`
7. 所有循环结束以后，`dp[m][n]`就是结果

#### 实现代码

```java
    public int numSquares(int n) {
        //dp[i][j] 前i个元素中，和为j^2的最短子序列长度
        int m = (int)Math.sqrt(n);
        //dp[i][j]表示前i个物品中，平方和为j的最小子集大小
        int[][] dp = new int[m+1][n+1];
        for(int i =0 ; i<= m; i++){
            Arrays.fill(dp[i],Integer.MAX_VALUE);
        }
        //前0个元素中组成平方和为0的子集数为0
        dp[0][0] = 0;
        for(int i = 1; i <= m;i++){
            dp[i][0] = 0;
        }

        for(int i = 1; i <= m; i++){
            for(int j = 0; j <= n; j++){
                dp[i][j] = dp[i-1][j];
                if(j >= i*i){
                    dp[i][j] = Math.min(dp[i][j], dp[i][j-i*i]+1);
                }
            }
        }
        return dp[m][n];
    }
```

#### 使用一维dp数组进行逻辑优化 - 完全背包问题的一维数组解法

观察状态转移方程 `dp[i][j] = min(dp[i-1][j], dp[i][j - i*i] + 1)`。

我们发现，计算第 `i` 行的状态时，**只依赖于第 `i-1` 行和第 `i` 行的旧值**。

这提示我们**可以把二维数组优化成一维数组**。

`dp[j]` 表示凑成和为 `j` 的最少数量。

转移方程变为：`dp[j] = min(dp[j], dp[j - i*i] + 1)`。

为了保证 `dp[j - i*i]` 是利用了第 `i` 个物品更新过的值（即 `dp[i][...]` 而不是 `dp[i-1][...]`），内层循环（`j`）必须**正序**遍历。

这正是我们在第一个回答中使用的方法。

```java
    public int numSquares(int n) {
            int[] dp = new int[n + 1];
    Arrays.fill(dp, n + 1);
    dp[0] = 0;

    for (int i = 1; i * i <= n; i++) { // 遍历物品
        int square = i * i;
        for (int j = square; j <= n; j++) { // 正序遍历背包，从当前物品大小到总容量
            dp[j] = Math.min(dp[j], dp[j - square] + 1);
        }
    }
    return dp[n];

    }
```

#### 注意事项

**数组大小**: DP 数组的大小必须是 `n + 1`，因为我们需要索引从 `0` 到 `n`。

**初始化**: `dp[0]=0` 是递推的基础，千万不能忘。将其他值设为极大值是 `min` 操作的常见技巧。

**循环边界**: 内层循环的条件是 `j * j <= i`，而不是 `j <= i`。这既保证了 `i - j*j` 不会是负数，也大大减少了不必要的计算。

**时间复杂度**: 外层循环 `n` 次，内层循环 `sqrt(i)` 次。总时间复杂度约为 $O(n\sqrt{n})$。

**空间复杂度**: 我们使用了一个大小为 `n+1` 的数组，所以空间复杂度是 O(n)。

**其他解法**:

- **BFS**: 时间和空间复杂度与DP类似，但思路更像图搜索。

#### 经验总结

**识别问题模式**: "求最值"（最大/最小/最长/最短）是动态规划和图搜索算法的强烈信号。

**由简入繁**: 先思考贪心，如果贪心不行（可以举出反例），再转向 DP 或 BFS。

**DP 四部曲**: 练习并熟练掌握“定义状态 -> 状态转移 -> 初始化 -> 遍历顺序”这套标准流程，可以解决大部分 DP 问题。

**一题多解**: LeetCode 279 是一个典型的可以从不同角度切入的问题。

理解 DP（背包）、BFS（图）、数学（数论）这三种解法，能极大地加深对算法本质的理解。

在面试中，能够讨论不同方法的优劣是一个很大的加分项。

**套路迁移**: “完全背包求最少物品数”这个模型可以应用到很多问题上，例如 LeetCode 322 (Coin Change)。掌握一个，就能触类旁通。