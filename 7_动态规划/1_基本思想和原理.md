# 7. **动态规划**

## 动态规划究竟解决了什么问题？

动态规划（DP）本质上**解决的是「`多阶段决策`中的`最优问题`或`计数问题`」，尤其是`子问题有重叠`的情形。**

### **最优解问题**

目标是找到一组`操作序列`，使得`总成本最小`或`总价值`最大。

例如：

- **背包问题**：如何在容量限制内选物品获得最大价值？
- **最长上升子序列**：找出一个序列中最长的上升子序列。
- **最短路径问题**：从起点到终点，路径代价最小是多少？

👉 这些问题本质上都是：

- **每一步都有多个选择（决策）**
- **决策之间存在依赖**（后一步依赖前一步）
- **子问题重复出现，可以复用之前的解**

### 计数问题

问的是「总共有多少种方式/方案」。

如：

- **爬楼梯**：每次可以爬1阶或2阶，一共有多少种爬法？
- **走迷宫**：从左上角走到右下角，有多少种路径？
- **分割整数**：一个数可以拆成多少种加法形式？

👉 这些问题不关注最优解，而是`所有可能解`的总数，也是`动态规划擅长`的场景。

### 是否存在问题（判定类）

判断是否能达到目标。

- **是否能用数组中元素加出目标和**（子集和问题）
- **是否能分成两个和相等的子集**（0/1背包变种）

这种问题不是求最大/最小/总数，而是只判断「可不可行」——也可以用 DP。

## 动态规划的核心思想是什么？

| 步骤                 | 作用                                 |
| -------------------- | ------------------------------------ |
| **1. 状态定义**      | 用变量（或数组）表示每个子问题的状态 |
| **2. 状态转移方程**  | 用`之前的状态`表达`当前状态`         |
| **3. 初始条件**      | 定义`边界`和`起点`                   |
| **4. 迭代/递归求解** | `自底向上`或`自顶向下`求解           |

###关键术语

####**最优子结构**：

`原问题的最优解`可以由`子问题的最优解`推导出来。

####**状态转移方程**：

描述如何从子问题的解构造原问题的解。

#### **重叠子问题**：

多个子问题在求解过程中会重复出现，可以使用`记忆化或表格`方式避免重复计算。

#### **状态表示**：

用一个或多个维度的数组表示状态（如 `dp[i]`、`dp[i][j]`）。

#### **初始条件**

定义边界条件，确保状态转移从某个已知值开始。

## 动态规划通用套路模板：五步法

### 第一步：定义「状态」数组

用一个或多个变量（通常是数组的索引）表示问题到某一阶段时的局部情况。

```
// 定义 dp[i] 表示：前 i 个元素/位置，能达到的最优解/方案数/是否可行...
```



> “我站在第 `i` 步，我想知道什么？”

- `dp[i]` 表示前 i 个元素的最优值

- `dp[i][j]` 表示前 i 个物品、容量为 j 的背包的最优解

### 第二步：确定「选择」哪几步？

明确每一步有哪些选择会影响状态。

> 通常和题目的“操作”、“转移路径”有关。

```
// 可以选择：选 or 不选、走一步 or 两步、合并 or 拆分等
```



- 是否选择第 i 个元素

- 上一步走的是 1 阶还是 2 阶

### 第三步：写出「状态转移方程」

用代码或公式表示当前状态和之前状态的关系。
 这是核心！

```java
// dp[i] = f(dp[i-1], dp[i-2], ...)
// 举例：dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
dp[i] = fun(dp[i-1,dp[i-2],...])
```

### 第四步：**明确初始状态和边界条件**

确保状态递推有起点。

```
// dp[0] = ...;
// dp[1] = ...;
```

### 第五步：**返回最终结果**

是 `dp[n]`、`dp[n][m]`、还是在 dp 数组中找`最大值`、`总和`等，要根据问题而定。

```java
return dp[n]; // 或 Arrays.stream(dp).max().getAsInt();
```

## 算法类型与套路模板

| 问题类型    | 特征关键词            | 示例题目                 | DP维度        |
| ----------- | --------------------- | ------------------------ | ------------- |
| 数列、路径  | 最大/最小、多少种方式 | 爬楼梯、斐波那契、走格子 | 一维 / 二维   |
| 子序列/子串 | 最长、是否存在        | 最长公共子序列、回文子串 | 二维          |
| 背包类      | 选择物品、容量限制    | 01背包、多重背包         | 一维 / 二维   |
| 区间问题    | 合并、分段            | 石子合并、戳气球         | 区间 DP       |
| 博弈问题    | 当前选手、先后手      | 石子游戏、Nim博弈        | 二维 / 记忆化 |

### 动态规划的两个难点

#### 如何定义状态数组`dp`?

##### 常见的各类场景下`dp`数组的含义分别是什么？

#### 如何推导状态转换方程？

## 递归动态规划 - **自顶向下的带记忆化的动态规划**

###什么时候使用？ - 父问题需要先知道子问题的答案！

简单来说，**当你发现一个问题可以被自然地分解成“为了解决当前问题，我需要先知道它的几个子问题的答案”时，递归动态规划就是一个绝佳的选择。**

递归动态规划还有一个名字：**自顶向下的带记忆化的动态规划**。

### 核心思想 ：“聪明的暴力枚举” 或 “带备忘录的递归”。

它结合了两种思想：

#### **递归 (Recursion)**:

 将一个大问题分解成若干个规模更小的相同类型的子问题来求解。这种“自顶向下”的分解方式非常符合人类的直观思考。

#### **记忆化 (Memoization)**: 

在递归的过程中，会遇到大量的 **重叠子问题**。

为了避免重复计算，我们用一个数据结构（通常是数组或哈希表）来“记忆”每个子问题的解。

当再次遇到同一个子问题时，直接从“备忘录”中读取答案，而不是重新计算。

#### 基本套路

#####**找到问题的“状态”**: 哪些参数可以唯一的识别一个子问题？

识别出哪些参数可以唯一地定义一个子问题。

##### **写出纯粹的递归函数**: 最初的暴力递归

先不考虑重复计算，根据问题的逻辑，写出一个能够解决问题的暴力递归函数。

这个函数能够正确运行，但可能会因为超时而无法通过。

##### **加入“备忘录”**: 将暴力递归升级成动态规划

在暴力递归的基础上，增加一个缓存（备忘录/记忆化表），在函数开头检查是否已计算过，在函数末尾存入计算结果。

这就将暴力递归“升级”为了动态规划。

### 重要的要素和概念

#### 状态： 一组可以标识一个子问题的参数

唯一标识一个子问题的一组参数。这是DP的基石。

例如，在斐波那契数列 `fib(n)` 中，状态就是 `n`；在石子游戏II `solve(i, M)` 中，状态是 `(i, M)` 的组合。

#### 递归关系：从子问题的解推导出当前问题的解

如何从一个或多个子问题的解，推导出当前问题的解的公式。

它描述了状态之间的转移关系。

**示例**: `fib(n) = fib(n-1) + fib(n-2)` 就是斐波那契数列的递推关系。

#### 基本情况（Base Case）：递归的终止条件

 递归的终止条件。

它是一个或多个最简单的、不需要再进行递归就能直接求解的子问题。

**作用**: 防止无限递归，是整个递归链条的起点。

**示例**: `fib(0) = 0`, `fib(1) = 1`。

#### 记忆化表 - 用于存储子问题解的缓存结构

- 状态参数是一维或二维整数时，通常使用 **数组** (如 `int[] memo` 或 `int[][] memo`)。

- 状态参数是其他类型（如字符串）或不连续时，通常使用 **哈希表** (如 `Map<String, Integer> memo`)。

需要一个特殊值（如 `null`, `-1`, `0`）来标记某个状态“尚未计算”。

使用包装类（如 `Integer`）的 `null` 是最安全的选择，因为它不会与任何合法的计算结果冲突。

#### 重叠子问题 (Overlapping Subproblems)

在递归求解的过程中，同一个子问题被多次计算。

这是动态规划能够优化的根本原因。如果不存在重叠子问题（例如归并排序），那么动态规划就没有用武之地。

#### 最优子结构 (Optimal Substructure)

一个问题的最优解包含其子问题的最优解。

这意味着我们可以放心地使用子问题的最优解来构建当前问题的最优解，而不用担心这会导致全局非最优。

### 实现原理和步骤 (Implementation Principle and Steps)

#### 第一步：定义递归函数

- 确定问题的 **状态**，并将其作为递归函数的**参数**。
- 确定函数的**返回值**，它应代表该状态下的解。
- 例如: `private int solve(int[] piles, int i, int M)`

#### 第二步：实现基本情况 (Base Case)

- 在函数的入口处，首先判断是否满足递归的终止条件。

- 如果满足，直接返回已知的简单解。

- 例如: `if (i >= piles.length) { return 0; }`

#### 第三步：检查是否已经计算过

- 在函数入口、**基本情况之后**，检查记忆化表中是否已经存在当前状态的解。
- 如果存在，直接返回该解，避免重复计算。
- 例如: `if (memo[i][M] != null) { return memo[i][M]; }`

#### 第四步：实现递推关系

- 如果前两步都没有返回，说明这是一个需要计算的新问题。

- 根据递推关系，进行计算。这通常涉及循环或多种选择。

- 在计算中，通过 **递归调用自身** 来解决子问题。

- 在函数返回之前，务必将计算出的 **结果存入记忆化表**。

```Java
// ... loop through choices ...
int result = ... solve(..., new_param1, new_param2);
// ... update max/min result ...

// Store result before returning
memo[i][M] = final_result;
return final_result;
```



### 代码套路模板

```Java
public class DpSolution {

    // 1. 记忆化表：用于存储子问题的解
    // 使用包装类（如 Integer）是最佳实践，因为 null 是一个完美的“未计算”标记
    private Integer[][] memo; 
    // 其他可能需要的全局变量
    private int n;

    /**
     * 这是用户调用的主函数
     */
    public int mainFunction(int[] inputArray) {
        this.n = inputArray.length;
        if (n == 0) {
            return 0; // 或者其他初始情况
        }
        
        // 2. 初始化记忆化表
        // 维度和大小根据“状态”参数的数量和范围决定
        this.memo = new Integer[n][n + 1]; // 示例大小

        // 3. 调用递归辅助函数，从初始状态开始
        // 初始状态通常是 (0, 0), (0, 1) 或 (n-1) 等
        return solve(inputArray, 0, 1); // 示例初始状态
    }

    /**
     * 这是实现核心DP逻辑的递归辅助函数
     * @param params 描述问题状态的参数
     * @return 返回该状态下的解
     */
    private int solve(/* state parameters, e.g., int[] input, int i, int M */) {
        
        // --- 步骤 2: 实现基本情况 (Base Case) ---
        // 这是递归的终止条件
        if (/* is a base case */) {
            return /* base case value */;
        }

        // --- 步骤 3: 加入记忆化读取 ---
        // 检查备忘录，如果已计算过，直接返回
        if (memo[/* state indices */] != null) {
            return memo[/* state indices */];
        }

        // --- 步骤 4: 实现递推关系 ---
        // 初始化一个变量来存储当前状态要计算的结果
        int result = /* initial value, e.g., 0 for sum, Integer.MIN_VALUE for max */;

        // 遍历所有可能的“选择”或“决策”
        for (/* each possible choice */) {
            
            // 进行决策，然后递归调用 solve() 来解决子问题
            int subProblemResult = solve(/* next state parameters */);
            
            // 根据子问题的解，更新当前状态的结果
            // 例如: result = Math.max(result, ...);
            // 或者: result += subProblemResult;
        }

        // --- 步骤 4 (续): 加入记忆化写入 ---
        // 在返回结果之前，将其存入备忘录
        memo[/* state indices */] = result;
        
        return result;
    }
}
```

### 总结

任何能够用迭代（自底向上）方式实现的动态规划过程，都可以被转化为递归（自顶向下带记忆化）的形式。

它们本质上是同一枚硬币的两面，都是在解决相同的**递推关系 (Recurrence Relation)**，只是计算的顺序不同。

- **迭代 (Bottom-Up)**: 像是在盖楼。从地基（Base Cases）开始，一层一层地向上盖（通过循环），直到楼顶（我们想要的最终答案）。它保证了在计算第 `i` 层时，所有 `i` 层以下的楼层都已经被盖好了。
- **递归 (Top-Down)**: 像是一个总工程师。他接到盖楼顶（最终答案）的任务，然后他把任务分解给下一层的工头：“要想盖楼顶，你们先把第 `n-1` 层盖好”。工头又把任务分解下去，直到最底层的工人接到任务：“盖地基”。地基盖好后，结果一层层地汇报上来，最终楼顶也盖好了。
