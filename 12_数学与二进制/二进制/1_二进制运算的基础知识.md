# 二进制运算基础

## 常见的二进制运算

这是所有二进制技巧的基石。

| **运算符** | **名称**       | 运算逻辑                                                     | **核心思想 (套路)**                                          | **典型应用 (例：n = 10110)**      |
| ---------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------- |
| `&`        | **与 (AND)**   | **`&` (与):** 两个位都为1时，结果才为1。                     | **掩码 (Masking)**：用于“检查”或“清零”特定位。               | `n & (1 << 2)` 检查第2位是否为1。 |
| `|`        | **或 (OR)**    | 两个位都为0时，结果才为0。                                   | **置位 (Setting)**：用于将特定位“强行设为1”。                | `n | (1 << 1)` 将第1位设为1。     |
| `^`        | **异或 (XOR)** | 两个位不同时，结果为1。                                      | **翻转/求异 (Flipping/Finding Difference)**：用于“翻转”特定位，或利用其特性求差。 | `n ^ (1 << 3)` 翻转第3位。        |
| `~`        | **非 (NOT)**   | 按位取反，0变1，1变0。                                       | **反转 (Inverting)**：反转所有位。                           | `~n` (注意符号位)。               |
| `<<`       | **左移**       | 所有位向左移动指定的位数，右侧补0。相当于乘以 2k。           | **乘以2的k次方**：`n << k` 等价于 $n \times 2^k$。           | `n << 1` (乘以2)。                |
| `>>`       | **右移**       | 所有位向右移动指定的位数。对于正数，左侧补0；对于负数，行为取决于编译器（通常补1）。相当于除以 2k。 | **除以2的k次方**：`n >> k` 等价于 $n \div 2^k$ (向下取整)。  | `n >> 1` (除以2)。                |
| `>>>`      | **无符号右移** |                                                              | **逻辑右移**：不考虑符号位，总是补0。                        | (Java特有，处理负数时有用)。      |

## 怎样将十进制转化为二进制？

将十进制转化为二进制的基本算法是通过**不断除以2并记录余数**

```Java
public static String decimalToBinary(int decimal) {
        StringBuilder binary = new StringBuilder();
        
        // 除2直到商为0
        while (decimal > 0) {
            binary.append(decimal % 2); // 记录余数
            decimal /= 2;  // 更新商
        }
        
        // 逆序输出
        return binary.reverse().toString();
    }
```



##异或 (XOR) 的核心性质

XOR (`^`) 是二进制题的“神器”，因为它有三个独一无二的性质：

### 异或运算的核心性质

####**自反性 (Self-Inverse):** $A \oplus A = 0$

- *推论：* 任何偶数个相同的数异或，结果为 0。

####**幺元 (Identity):** $A \oplus 0 = A$

- *推论：* 0 和任何数异或，结果是那个数本身。

####**交换律与结合律:** $A \oplus B = B \oplus A$, $(A \oplus B) \oplus C = A \oplus (B \oplus C)$

- *推论：* 一堆数异或，顺序不重要。

###异或运算的常见应用 (套路)

####寻找单个不同的数： (LC 136: 只出现一次的数字)

- *描述：* 数组中只有一个数出现1次，其他都出现2次。
- *套路：* 将数组中所有数全部异或起来。出现2次的数两两抵消 (性质1)，最后只剩下那个出现1次的数 (性质2)。

```Java
public int singleNumber(int[] nums) {
    int res = 0;
    // a ^ a = 0
    // a ^ 0 = a
    for (int num : nums){
        res ^= num;
    }
    return res;
}
```

####寻找两个不同的数： (LC 260: 只出现一次的数字 III)

- *描述：* 数组中有两个数出现1次，其他都出现2次。
- *套路：*
  1. 将所有数异或，得到 `diff = A ^ B` (A, B 是那两个不同的数)。
  2. `diff` 必定不为0。找到 `diff` 中任意一个为 '1' 的位（例如 `lowbit = diff & (-diff)`）。
  3. 这个 `lowbit` 意味着 A 和 B 在这一位上必定不同 (一个是0，一个是1)。
  4. 根据这一位是0还是1，将原数组分为两组，A 和 B 必然在不同组。
  5. 问题转化为在两个子数组中分别找单个不同的数。

#### 寻找丢失的数字：（LC 268:丢失的数字）

数组 `nums` 包含 `[0, n]` 中 n 个数，找出缺失的那个数。

1. 期望的结果是 $0 \oplus 1 \oplus \dots \oplus n$。
2. 实际的结果是 `nums[0] ^ nums[1] ^ ...`。
3. 将“期望结果”与“实际结果”异或，相同的数两两抵消，剩下的就是缺失的数。

#### 交换两个数字：不使用临时变量

```
a = a ^ b;
b = a ^ b; //(a ^ b ^ b) = a
a = a ^ b; // a ^ b ^ a = b;
```



## 常用的位运算技巧 

### 清除二进制数末尾的1:$n \& (n - 1)$

- **核心思想：** **清除 `n` 的二进制表示中最低(最右)的那个 '1'。**

- *原理：* `n = ...1000...`，`n-1 = ...0111...`。两者相 `&` 后，`...1000...` 这一段变为 `...0000...`。

####[Leetcode 191]统计 '1' 的个数 (Hamming Weight):

(LC 191: 位1的个数) 不断执行 `n = n & (n - 1)` 直到 `n` 变为 0，循环的次数就是 '1' 的个数。

####[Leetcode 231]判断是否为2的幂： 

如果 `n > 0` 且 `(n & (n - 1)) == 0`，则 `n` 是2的幂 (因为它只有一个 '1')。

### 获取最右边的1所代表的数值： $n \& (-n)$

- **核心思想：** **获取 `n` 的二进制表示中最低(最右)的那个 '1' 所代表的数值。**

- *原理：* 负数在计算机中用补码表示 (`~n + 1`)。

  例如 `n = 0110` (6)，`-n = 1010` (-6)，`n & -n = 0010` (2)。

#### [Leetcode 260]分组异或：

 在 `LC 260` 中用于找到 `diff` 的 `lowbit`。

####树状数组 (Fenwick Tree)： 

这是树状数组更新和查询的核心操作。

#### [Leetcode 751]IP地址对齐：

 (LC 751: IP到CIDR) 你提供的文件中用 `start & -start` 来找到IP地址能覆盖的最大块。

### 判断数字的奇偶性：$x \& 1$

判断奇偶: `x & 1 == 1` 为奇数，`x & 1 == 0` 为偶数。

本质上来说它是在判断数字的二进制最后一位是否为1.

### 交换两个数字的数值

交换两个数 (无需额外空间): `a ^= b; b ^= a; a ^= b;`

### 检查第K位的值：` n & (1 << k)`

#### 目标： 检查第n的二进制第k位的数值

#### 核心思想： 

创建一个只在第k位为1的掩码 `(1 << k)`，与 `n` 相`&`。

- 如果结果不为0，则第k位为1。
- 如果结果是0，则第k位是0

注意这里**结果不为0， 并不是说结果一定是1**。

#### **LC 1342 (将数字变成0的步骤数)**：用 `& 1` 判断奇偶。

###设置第 k 位为 1： `n = n | (1 << k)`

#### 将数字$n$的二进制第$k$为修改为1

**或 (OR) 置位**：创建一个第k位为1的掩码，与 `n` 相`|`。

1. 创建一个只有第$k$位是1 的数字： `int offset = 1 << k`
2. 将$n$更新为 `n = n | offset`

上述过程就完成了**将数字$n$的第$k$修改为1**的操作。

#### 常见于状态压缩中修改标记位

### 反转数字$n$的第$k$位数字：`n = n ^ (1 << k)`

#### [复习]异或运算的性质

- 相同为0
- 不同为1

#### 实现原理 - 异或

1. 创建一个第$k$位是1的数字$offset$
2. 我们已经知道$offset$的第$k$位是1， 根据抑或运算的特性
   1. 当$n$的第$k$位是1, 和$offset$的第$k$位相同，因此`n^offset` 的结果中$k$位变成0
   2. 当$n$的第$k$位是0, 和$offset$的第$k$位不同，因此 `n ^ offset`的结果中$k$位是1；

总和以上，上述运算过程（`n = n ^ (1 << k)`）实现了将$n$的第$k$位进行反转的功能。

#### **LC 1284 (转化为全零矩阵)**：翻转 `(i, j)` 及其邻居。

### 清除数字$n$的第$k$位： `n = n & ~(1 << k)`

**与非 (AND-NOT) 掩码**：创建一个**非**第k位为1的掩码 (即 `...111011...`)，与 `n` 相`&`。

1. 创建一个第$k$位是1的数字 (`1 << k`)
2. 将上面的数字取反， 即(`~(1 << k)`)，取反后的数字，只有第$k$位是0
3. 将$n$更新为`n & ~(1 << k)`，现在新的数字的第$k$为便确保是0了

#### **状态压缩**：在位掩码中标记“未访问”。

### 将数字$n$ 乘以 $2^k$：左移运算 `n << k`

```Java
n << k
```

即通过**左移运算**将$n$向左移动$k$位

### 将数字$n$除以$2 ^ k$: 右移运算 `n >> k`

```
n >> k
```

**右移**：`n / 2^k` (向下取整)



##位掩码 (Bitmask)

当 `N` 很小（通常 $N \le 20$）时，一个 32 位 `int` 可以被用作一个 `boolean` 数组或 `Set`，这称为“状态压缩”。

- `mask` 的第 `k` 位为 1 $\rightarrow$ 集合包含 `k`
- 检查 `k` 是否存在: `(mask >> k) & 1 == 1`
- 添加 `k`: `mask = mask | (1 << k)`
- 删除 `k`: `mask = mask & ~(1 << k)`

### 状态压缩 + BFS

在 BFS 搜索时，状态不仅包括 `(x, y)` 位置，还包括一个 `mask` (整数) 来表示“当前持有哪些钥匙”或“哪些灯已点亮”。

`visited[x][y][mask]`

#### Leetcode 864:获取所有钥匙的最短路径

#### Leetcode : 1284: 转化为全0矩阵的最少反转次数

### 状态压缩 + DP

#### Leetcode: 698: 划分为k个相当的子集

`dp[mask]` 表示“在 `mask` 状态下”的最优解。用于解决排列组合或集合划分问题。

#### Leetcode 437: 火柴正方形

例如，`dp[mask]` 表示 `mask` 所代表的子集是否能被划分。

### 生成所有子集

#### **LC 78. 子集**

遍历从 `0` 到 `(1 << n) - 1` 的所有整数。

每一个整数 `i` 本身就是一个位掩码，代表了原集合的一个子集。

##逐位构造与杂项

这类题没有统一的技巧，但思路都是**逐位(bit-by-bit)**处理。

| **适用场景 (Scenario)** | **核心思想 (套路)**                                          | **相关 LeetCode 题目**    |
| ----------------------- | ------------------------------------------------------------ | ------------------------- |
| **颠倒二进制位**        | 循环 32 次。每次取 `n` 的最低位 (`n & 1`)，加到 `res` 的末尾，然后 `res` 左移 (`res <<= 1`)，`n` 右移 (`n >>= 1`)。 | **LC 190. 颠倒二进制位**  |
| **负进制转换**          | (你提供的 `LC 1017`) 核心是处理余数。`n % -2` 可能是负的，需要修正：如果余数为 `-1`，则余数变为 `1`，商 `n` 需要 `+1`。 | **LC 1017. 负二进制转换** |
| **格雷编码**            | 格雷码 `G(n)` 与自然数 `n` 的转换公式：`G(n) = n ^ (n >> 1)`。 | **LC 89. 格雷编码**       |
| **IP地址/CIDR**         | (你提供的 `LC 751`) 综合了 `lowbit` ( `start & -start` ) 来找对齐，以及位移来计算掩码 (`32 - prefix`)。 | **LC 751. IP到CIDR**      |