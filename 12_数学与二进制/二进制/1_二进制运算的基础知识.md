# 二进制运算基础

## 常见的二进制运算

这是所有二进制技巧的基石。

| **运算符** | **名称**       | 运算逻辑                                                     | **核心思想 (套路)**                                          | **典型应用 (例：n = 10110)**      |
| ---------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------- |
| `&`        | **与 (AND)**   | **`&` (与):** 两个位都为1时，结果才为1。                     | **掩码 (Masking)**：用于“检查”或“清零”特定位。               | `n & (1 << 2)` 检查第2位是否为1。 |
| `|`        | **或 (OR)**    | 两个位都为0时，结果才为0。                                   | **置位 (Setting)**：用于将特定位“强行设为1”。                | `n | (1 << 1)` 将第1位设为1。     |
| `^`        | **异或 (XOR)** | 两个位不同时，结果为1。                                      | **翻转/求异 (Flipping/Finding Difference)**：用于“翻转”特定位，或利用其特性求差。 | `n ^ (1 << 3)` 翻转第3位。        |
| `~`        | **非 (NOT)**   | 按位取反，0变1，1变0。                                       | **反转 (Inverting)**：反转所有位。                           | `~n` (注意符号位)。               |
| `<<`       | **左移**       | 所有位向左移动指定的位数，右侧补0。相当于乘以 2k。           | **乘以2的k次方**：`n << k` 等价于 $n \times 2^k$。           | `n << 1` (乘以2)。                |
| `>>`       | **右移**       | 所有位向右移动指定的位数。对于正数，左侧补0；对于负数，行为取决于编译器（通常补1）。相当于除以 2k。 | **除以2的k次方**：`n >> k` 等价于 $n \div 2^k$ (向下取整)。  | `n >> 1` (除以2)。                |
| `>>>`      | **无符号右移** |                                                              | **逻辑右移**：不考虑符号位，总是补0。                        | (Java特有，处理负数时有用)。      |

## 怎样将十进制转化为二进制？

将十进制转化为二进制的基本算法是通过**不断除以2并记录余数**

```Java
public static String decimalToBinary(int decimal) {
        StringBuilder binary = new StringBuilder();
        
        // 除2直到商为0
        while (decimal > 0) {
            binary.append(decimal % 2); // 记录余数
            decimal /= 2;  // 更新商
        }
        
        // 逆序输出
        return binary.reverse().toString();
    }
```



##异或 (XOR) 的核心性质

XOR (`^`) 是二进制题的“神器”，因为它有三个独一无二的性质：

### 异或运算的核心性质

####**自反性 (Self-Inverse):** $A \oplus A = 0$

- *推论：* 任何偶数个相同的数异或，结果为 0。

####**幺元 (Identity):** $A \oplus 0 = A$

- *推论：* 0 和任何数异或，结果是那个数本身。

####**交换律与结合律:** $A \oplus B = B \oplus A$, $(A \oplus B) \oplus C = A \oplus (B \oplus C)$

- *推论：* 一堆数异或，顺序不重要。

###异或运算的常见应用 (套路)

####寻找单个不同的数： (LC 136: 只出现一次的数字)

- *描述：* 数组中只有一个数出现1次，其他都出现2次。
- *套路：* 将数组中所有数全部异或起来。出现2次的数两两抵消 (性质1)，最后只剩下那个出现1次的数 (性质2)。

```Java
public int singleNumber(int[] nums) {
    int res = 0;
    // a ^ a = 0
    // a ^ 0 = a
    for (int num : nums){
        res ^= num;
    }
    return res;
}
```

####寻找两个不同的数： (LC 260: 只出现一次的数字 III)

- *描述：* 数组中有两个数出现1次，其他都出现2次。
- *套路：*
  1. 将所有数异或，得到 `diff = A ^ B` (A, B 是那两个不同的数)。
  2. `diff` 必定不为0。找到 `diff` 中任意一个为 '1' 的位（例如 `lowbit = diff & (-diff)`）。
  3. 这个 `lowbit` 意味着 A 和 B 在这一位上必定不同 (一个是0，一个是1)。
  4. 根据这一位是0还是1，将原数组分为两组，A 和 B 必然在不同组。
  5. 问题转化为在两个子数组中分别找单个不同的数。

#### 寻找丢失的数字：（LC 268:丢失的数字）

数组 `nums` 包含 `[0, n]` 中 n 个数，找出缺失的那个数。

1. 期望的结果是 $0 \oplus 1 \oplus \dots \oplus n$。
2. 实际的结果是 `nums[0] ^ nums[1] ^ ...`。
3. 将“期望结果”与“实际结果”异或，相同的数两两抵消，剩下的就是缺失的数。

#### 交换两个数字：不使用临时变量

```
a = a ^ b;
b = a ^ b; //(a ^ b ^ b) = a
a = a ^ b; // a ^ b ^ a = b;
```



## 常用的位运算技巧 

### 清除二进制数末尾的1:$n \& (n - 1)$

- **核心思想：** **清除 `n` 的二进制表示中最低(最右)的那个 '1'。**

- *原理：* `n = ...1000...`，`n-1 = ...0111...`。两者相 `&` 后，`...1000...` 这一段变为 `...0000...`。

####[Leetcode 191]统计 '1' 的个数 (Hamming Weight):

(LC 191: 位1的个数) 不断执行 `n = n & (n - 1)` 直到 `n` 变为 0，循环的次数就是 '1' 的个数。

####[Leetcode 231]判断是否为2的幂： 

如果 `n > 0` 且 `(n & (n - 1)) == 0`，则 `n` 是2的幂 (因为它只有一个 '1')。

### 获取最右边的1所代表的数值： $n \& (-n)$

- **核心思想：** **获取 `n` 的二进制表示中最低(最右)的那个 '1' 所代表的数值。**

- *原理：* 负数在计算机中用补码表示 (`~n + 1`)。

  例如 `n = 0110` (6)，`-n = 1010` (-6)，`n & -n = 0010` (2)。

#### [Leetcode 260]分组异或：

 在 `LC 260` 中用于找到 `diff` 的 `lowbit`。

####树状数组 (Fenwick Tree)： 

这是树状数组更新和查询的核心操作。

#### [Leetcode 751]IP地址对齐：

 (LC 751: IP到CIDR) 你提供的文件中用 `start & -start` 来找到IP地址能覆盖的最大块。

### 判断数字的奇偶性：$x \& 1$

判断奇偶: `x & 1 == 1` 为奇数，`x & 1 == 0` 为偶数。

本质上来说它是在判断数字的二进制最后一位是否为1.

### 交换两个数字的数值

交换两个数 (无需额外空间): `a ^= b; b ^= a; a ^= b;`

### 检查第K位的值：` n & (1 << k)`

#### 目标： 检查第n的二进制第k位的数值

#### 核心思想： 

创建一个只在第k位为1的掩码 `(1 << k)`，与 `n` 相`&`。

- 如果结果不为0，则第k位为1。
- 如果结果是0，则第k位是0

注意这里**结果不为0， 并不是说结果一定是1**。

#### **LC 1342 (将数字变成0的步骤数)**：用 `& 1` 判断奇偶。

#### LeetCode 1356: 根据数字二进制下 1 的数目排序

#####1. 问题要点 (Key Points)

1. **输入：** 一个整数数组 `arr`。
2. **输出：** 一个新的数组，包含 `arr` 中所有的元素，但已重新排序。
3. **排序规则（双重条件）：**
   - **主规则：** 按照每个数字的二进制表示中 "1" 的 **个数**（bit count）进行 **升序** 排序。
   - **次规则：** 如果两个数字的 "1" 的个数 **相同**，则按照它们 **本身的值** 进行 **升序** 排序。

##### 本质和分析 (Core Nature & Analysis)

这道题的本质是 **自定义排序（Custom Sorting）**。

它不关心你使用什么排序算法（比如快排、归并），而是关心你如何定义两个元素 `a` 和 `b` 之间的“大小”关系。

这个“大小”关系是一个复合关系：

- 首先比较 `bit_count(a)` 和 `bit_count(b)`。
- 如果它们不相等，大小关系就确定了。
- 如果它们相等，则退回到比较 `a` 和 `b` 本身的值。

##### 规律观察 (Observations & Patterns)

**约束条件：** `0 <= arr[i] <= 10^4`。这个约束很重要。

`10^4` 大约是 $10000$。

我们知道 $2^{13} = 8192$，$2^{14} = 16384$。

这意味着数组中的任何数字，其二进制表示最多不会超过 14 位。

因此，一个数字中 "1" 的个数最多也就是 14 个（虽然 $10000$ 远没有 14 个 1）。

这个观察告诉我们，计算 "1" 的个数（`bit_count`）是一个非常快、代价很低的操作。

我们不需要担心这步的性能。

##### 核心思想和套路 (Core Idea & Techniques)

解决这类自定义排序问题，主要有两种核心套路：

######**套路一：使用自定义比较器 (Custom Comparator)**

- 这是最直观、最“正统”的解法。
- 在 Java 中，这意味着你需要实现一个 `Comparator` 接口（或者使用 Lambda 表达式）。
- 在 `compare(a, b)` 方法中，完整实现问题要点中的“双重规则”。

###### 套路二：映射与编码 (Mapping / Encoding)

这是一种更“取巧”但通常性能更高的方法。

利用 "1" 的个数很少（最多 14）和数字本身的值（最多 10000）这一特点，我们可以将这两个排序键“编码”成 **一个单独的整数**。

**编码公式：** `encoded_value = (bit_count * K) + original_value`

我们选择一个足够大的 `K`，确保 `K` 必须大于 `original_value` 的最大可能值。

根据约束，`original_value` 最大为 10000。所以我们取 `K = 10001`（或者 20000，或者 $2^{14} = 16384$ 都可以）。

**举例 (K=10001)：**

- `7` (3 个 1) -> `3 * 10001 + 7 = 30030`
- `8` (1 个 1) -> `1 * 10001 + 8 = 10009`
- `6` (2 个 1) -> `2 * 10001 + 6 = 20028`
- `5` (2 个 1) -> `2 * 10001 + 5 = 20027`

现在我们只需要对这些“编码后”的值 `[30030, 10009, 20028, 20027]` 进行 **标准升序排序**，得到 `[10009, 20027, 20028, 30030]`。

排序后，我们再将它们“解码”回原值（通过 `encoded_value % K`），就得到了 `[8, 5, 6, 7]`。这个顺序就是我们想要的。

#####实现原理和步骤 (Implementation Principle & Steps)

###### 方法一：使用bitCount方法+自定义Comparator

1. **获取 `bit_count`：** 在 Java 中，最简单的方法是使用内置函数 `Integer.bitCount(n)`。

2. **转换数组（Java 特有）：** Java 的 `Arrays.sort()` 要使用自定义 `Comparator`，必须作用于对象数组（`Integer[]`），而不能是基本类型数组（`int[]`）。所以需要一次转换。

   - `int[]` -> `Integer[]`

3. **实现 `Comparator`：**

   Java

   ```
   (a, b) -> {
       int bitsA = Integer.bitCount(a);
       int bitsB = Integer.bitCount(b);
       if (bitsA != bitsB) {
           return bitsA - bitsB; // 主规则：按 "1" 的个数升序
       } else {
           return a - b;         // 次规则：按原值升序
       }
   }
   ```

4. **排序：** `Arrays.sort(integerArray, comparator)`。

5. **转回 `int[]`：** 将排好序的 `Integer[]` 复制回 `int[]`（如果需要）。

###### 方法二：映射与编码

**选择 `K`：** `final int K = 10001;`

**编码：** 遍历 `arr`，将每个元素 `x` 替换为 `Integer.bitCount(x) * K + x`。你可以原地修改，或者存入一个新列表。

**排序：** 对这个编码后的数组（或列表）进行 **标准排序**（例如 `Arrays.sort(arr)`）。

**解码：** 再次遍历排好序的 `arr`，将每个元素 `val` 替换为 `val % K`。

**返回** `arr`。

##### 实现代码

###### 解法一：自定义比较器 (使用 Stream 简化转换)

```Java
import java.util.Arrays;
import java.util.Comparator;

class Solution {
    public int[] sortByBits(int[] arr) {
        // 1. 将 int[] 转换为 Integer[] (称为 "装箱")
        Integer[] nums = Arrays.stream(arr).boxed().toArray(Integer[]::new);

        // 2. 定义比较器
        Comparator<Integer> comparator = (a, b) -> {
            int bitsA = Integer.bitCount(a);
            int bitsB = Integer.bitCount(b);
            
            if (bitsA != bitsB) {
                // 主规则：按 "1" 的个数升序
                return bitsA - bitsB; 
            } else {
                // 次规则：按原值升序
                return a - b;
            }
        };

        // 3. 排序
        Arrays.sort(nums, comparator);

        // 4. 将 Integer[] 转回 int[] (称为 "拆箱")
        return Arrays.stream(nums).mapToInt(Integer::intValue).toArray();
    }
    
    /* // 如果你不想用 Stream，手动的转换如下：
    // int[] -> Integer[]
    Integer[] nums = new Integer[arr.length];
    for (int i = 0; i < arr.length; i++) {
        nums[i] = arr[i];
    }
    
    // ... 排序 ...
    
    // Integer[] -> int[]
    for (int i = 0; i < nums.length; i++) {
        arr[i] = nums[i];
    }
    return arr;
    */
}
```

###### 解法二：映射与编码 (更高效)

```Java
import java.util.Arrays;

class Solution {
    public int[] sortByBits(int[] arr) {
        // 1. 选择一个足够大的 K
        // 因为 arr[i] <= 10000，我们选择 10001
        final int K = 10001; 
        
        // 2. 编码：原地修改数组
        // newValue = bitCount * K + originalValue
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.bitCount(arr[i]) * K + arr[i];
        }
        
        // 3. 标准排序
        // 此时比较 10009 和 20027，会把 10009 排在前面
        Arrays.sort(arr);
        
        // 4. 解码：原地修改数组
        // encodedValue % K = originalValue
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[i] % K;
        }
        
        // 5. 返回
        return arr;
    }
}
```

##### 注意事项

**`Integer.bitCount()`**：这是 Java 中计算 "1" 的个数的最优解（通常由 JVM 优化为硬件指令）。在面试中可以直接使用，除非面试官明确要求你手写。

**`int[]` vs `Integer[]`**：在 Java 中，基本类型数组 `int[]` 不能直接使用 `Comparator`。这是解法一（比较器）的一个性能开销点，因为它需要额外的空间和时间进行装箱/拆箱。

**解法二的 `K` 值**：`K` 值的选择至关重要，它必须 **大于** `arr[i]` 的 **最大可能值**。如果 `K` 选小了（比如 100），`3*100 + 7 = 307` 和 `2*100 + 108 = 308`，就会导致 `(bitCount=3, val=7)` 排在了 `(bitCount=2, val=108)` 之后，这是错误的。

##### 经验总结

这是一个 **“自定义排序”** 的模板题。

当你看到“排序”，但排序规则很奇怪（比如按个位数、按因子数、按 bit 数），第一反应就应该是自定义排序。

**套路一（Comparator）**：最通用，最易读，适用于任何复杂的比较逻辑。缺点是在 Java 中处理基本类型数组有额外开销。

**套路二（Encoding）**：更高效，更“秀技”。它适用于 **排序键（Key）数量有限且范围可控** 的情况。它巧妙地将一个“多键排序”问题转换成了一个“单键排序”问题，从而可以使用最高效的标准排序。

###设置第 k 位为 1： `n = n | (1 << k)`

#### 将数字$n$的二进制第$k$为修改为1

**或 (OR) 置位**：创建一个第k位为1的掩码，与 `n` 相`|`。

1. 创建一个只有第$k$位是1 的数字： `int offset = 1 << k`
2. 将$n$更新为 `n = n | offset`

上述过程就完成了**将数字$n$的第$k$修改为1**的操作。

#### 常见于状态压缩中修改标记位

### 反转数字$n$的第$k$位数字：`n = n ^ (1 << k)`

#### [复习]异或运算的性质

- 相同为0
- 不同为1

#### 实现原理 - 异或

1. 创建一个第$k$位是1的数字$offset$
2. 我们已经知道$offset$的第$k$位是1， 根据抑或运算的特性
   1. 当$n$的第$k$位是1, 和$offset$的第$k$位相同，因此`n^offset` 的结果中$k$位变成0
   2. 当$n$的第$k$位是0, 和$offset$的第$k$位不同，因此 `n ^ offset`的结果中$k$位是1；

总和以上，上述运算过程（`n = n ^ (1 << k)`）实现了将$n$的第$k$位进行反转的功能。

#### **LC 1284 (转化为全零矩阵)**：翻转 `(i, j)` 及其邻居。

### 清除数字$n$的第$k$位： `n = n & ~(1 << k)`

**与非 (AND-NOT) 掩码**：创建一个**非**第k位为1的掩码 (即 `...111011...`)，与 `n` 相`&`。

1. 创建一个第$k$位是1的数字 (`1 << k`)
2. 将上面的数字取反， 即(`~(1 << k)`)，取反后的数字，只有第$k$位是0
3. 将$n$更新为`n & ~(1 << k)`，现在新的数字的第$k$为便确保是0了

#### **状态压缩**：在位掩码中标记“未访问”。

### 将数字$n$ 乘以 $2^k$：左移运算 `n << k`

```Java
n << k
```

即通过**左移运算**将$n$向左移动$k$位

### 将数字$n$除以$2 ^ k$: 右移运算 `n >> k`

```
n >> k
```

**右移**：`n / 2^k` (向下取整)



##位掩码 (Bitmask)

当 `N` 很小（通常 $N \le 20$）时，一个 32 位 `int` 可以被用作一个 `boolean` 数组或 `Set`，这称为“状态压缩”。

- `mask` 的第 `k` 位为 1 $\rightarrow$ 集合包含 `k`
- 检查 `k` 是否存在: `(mask >> k) & 1 == 1`
- 添加 `k`: `mask = mask | (1 << k)`
- 删除 `k`: `mask = mask & ~(1 << k)`

### 状态压缩 + BFS

在 BFS 搜索时，状态不仅包括 `(x, y)` 位置，还包括一个 `mask` (整数) 来表示“当前持有哪些钥匙”或“哪些灯已点亮”。

`visited[x][y][mask]`

#### Leetcode 864:获取所有钥匙的最短路径

#### Leetcode : 1284: 转化为全0矩阵的最少反转次数

### 状态压缩 + DP

#### Leetcode: 698: 划分为k个相当的子集

`dp[mask]` 表示“在 `mask` 状态下”的最优解。用于解决排列组合或集合划分问题。

#### Leetcode 437: 火柴正方形

例如，`dp[mask]` 表示 `mask` 所代表的子集是否能被划分。

### 生成所有子集

#### **LC 78. 子集**

遍历从 `0` 到 `(1 << n) - 1` 的所有整数。

每一个整数 `i` 本身就是一个位掩码，代表了原集合的一个子集。

##逐位构造与杂项

这类题没有统一的技巧，但思路都是**逐位(bit-by-bit)**处理。

| **适用场景 (Scenario)** | **核心思想 (套路)**                                          | **相关 LeetCode 题目**    |
| ----------------------- | ------------------------------------------------------------ | ------------------------- |
| **颠倒二进制位**        | 循环 32 次。每次取 `n` 的最低位 (`n & 1`)，加到 `res` 的末尾，然后 `res` 左移 (`res <<= 1`)，`n` 右移 (`n >>= 1`)。 | **LC 190. 颠倒二进制位**  |
| **负进制转换**          | (你提供的 `LC 1017`) 核心是处理余数。`n % -2` 可能是负的，需要修正：如果余数为 `-1`，则余数变为 `1`，商 `n` 需要 `+1`。 | **LC 1017. 负二进制转换** |
| **格雷编码**            | 格雷码 `G(n)` 与自然数 `n` 的转换公式：`G(n) = n ^ (n >> 1)`。 | **LC 89. 格雷编码**       |
| **IP地址/CIDR**         | (你提供的 `LC 751`) 综合了 `lowbit` ( `start & -start` ) 来找对齐，以及位移来计算掩码 (`32 - prefix`)。 | **LC 751. IP到CIDR**      |