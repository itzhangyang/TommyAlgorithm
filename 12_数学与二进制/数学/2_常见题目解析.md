# Leetcode 50. Power(x,n)

## 问题要点

给你一个浮点数 `x` 和一个整数 `n`，实现函数 `myPow(x, n)`，计算 $x^n$。

```java
输入：x = 2.00000, n = 10
输出：1024.00000
```

**输入**: 一个浮点数 `x` (底数) 和一个整数 `n` (指数)。

**输出**: `x` 的 `n` 次幂的结果，即 $x^n$。

**约束条件**:

- `-100.0 < x < 100.0`
- `n` 是一个 32 位有符号整数，其取值范围为 [−231,231−1]。

初看此题，可能会觉得很简单，直接一个循环乘 `n` 次不就行了？

但关键在于 `n` 的取值范围。

如果 `n` 非常大（例如 $2^{31}$），暴力循环将导致超时（Time Limit Exceeded, TLE）。

因此，我们需要更高效的算法。

## 问题本质与分析 - 高效的计算一个数的整数次幂

- **本质：**快速计算乘方，避免$O(N)$逐次相乘

- **数学依据：**
  - 若 $n$ 为偶数：
    $x^n = \bigl(x^2\bigr)^{\frac{n}{2}}$

  - 若 $n$ 为奇数：
    $x^n = x \times \bigl(x^2\bigr)^{\frac{n-1}{2}}$

- **边界**

  - $n$ 可为负：$x^{-n} = 1 / x^n$

  - **注意整数溢出：当 $n = -2^{31}$ 时，取反会越界**。

### 暴力算法

**暴力法 (Brute Force)**: 

最直观的想法是使用一个循环，将 `x` 连乘 `n` 次。

如果 `n` 是负数，则先计算 $x^{−n}$，然后取其**倒数**。

这种方法的时间复杂度为 $O(n)$，当 `n` 接近 $2^{31}$ 时，计算量巨大，无法通过所有测试用例。

### 高效算法

**高效算法**: 为了优化，我们需要减少**乘法的次数**。

一个关键的观察是利用**指数的性质**。

例如，计算 $x^{10}$，我们可以不乘10次，而是先计算 $x^5$，然后将其平方，即 $x^{10}=(x^5)^2$。

同样地，$x^5=x\cdot (x^2)^2$

## 核心思想与套路 - 二分幂

### 二分幂

指数每次取半，但是底数自乘，整体复杂度将为`O(logN)`

### 递归 VS 迭代

- 递归写法直观，但是消耗栈空间
- 迭代写法常用，空间`O(1)`，没有栈溢出风险

### 负指数处理

- **先将`n`转为`long`，避免溢出**
- 若原始`n < 0`，则先计算 $x^{-n}$ 后取倒数

## 难点分析和应对方法

| 难点                 | 应对                                                         |
| -------------------- | ------------------------------------------------------------ |
| 负指数导致溢出       | `long m = n;` 再取 `m = -m`，保证范围安全                    |
| 浮点累乘误差         | 二分幂大幅减少乘法次数，减缓误差累积                         |
| 递归深度风险         | 迭代写法将递归转为 `while` 循环，空间复杂度 $O(1)$，无栈深度问题 |
| 零底数与非正指数组合 | 若 $x=0$ 且 $n\le0$，根据题意可视为非法输入，通常按题目约束不会出现 |

## 实现原理和步骤

### 将指数n类型转化为long类型以防止溢出

#### 为什么要将 指数n转化为long类型？

当n是Java的整数范围时，它的取值范围是：$-2 ^ {31}$到$2^{31} - 1$

也就是

```
-2147483648 … 2147483647
```

其中最小值`Integer.MIN_VALUE` = $-2 ^ {31}$

此时，你如果直接写成

```Java
int m = n; m = -m
```

当 `n = -2147483648` 时，`-(-2147483648)` 理论上等于 $+2147483648$。

但这个值超出了 **`int` 的最大值 $2^{31}-1=2147483647$**，导致整数溢出，结果仍然是 `-2147483648`。

```java
int n = Integer.MIN_VALUE;  // -2147483648
int m = -n;                 // 结果还是 -2147483648 —— 溢出了！
```

因此将`n`的数据类型转化为`long`，就有了更大的范围

$-2 ^ {63}$ 到 $2 ^ {63} -1$

```
long m = n;   // m = -2147483648L
m = -m;       // m = +2147483648L，安全无溢出
```

这样，无论 `n` 是多少，`-m` 都能正确表示，避免了在取负时的溢出问题。

#### 怎样将指数n转化为long类型？

`long m = n`

### 处理负指数

#### 为什么要处理负指数？

因为题目允许 $n$ 为负数，而数学上定义负指数时：
$$
x^{-n} = \frac{1}{x^n}\quad(n>0)
$$
如果不单独处理负指数，就无法正确计算例如 $2^{-3}$ 这样的情况——它的值应为 $\tfrac{1}{8}$，而不是按**正向循环乘法**得出 0 次乘法的 “1”。

#####**数学定义**

 对任何非零实数 $x$ 和正整数 $n$，都有
$$
x^{-n} = \frac{1}{x^n}.
$$
不处理负号就无法得到倒数。

##### 算法实现的问题

- 如果直接使用 “累乘” 或 “快速幂” 的循环/递归模板，并且不处理负数，就会因为循环条件（如 `while (n>0)`）根本不会执行，返回的结果永远是初始值 1。

- 通过先判断并将 $n$ 转为其绝对值，就可以统一走**正指数的快速幂**流程，**最后再对结果取倒数**；这样既简洁又高效。

#### 怎样处理负指数

```
long m = n;
if (m < 0) {
    x = 1.0 / x;  // 先取倒数
    m = -m;       // 变为正指数
}
// 再按 m>0 做快速幂计算

```

### 迭代二分幂

#### 什么是二分幂？

##### 数学的指数原理 $x^n = \bigl(x^2\bigr)^{\frac{n}{2}}$

我们在上面提到过两个数学公式：

- 若 $n$ 为偶数：
  $x^n = \bigl(x^2\bigr)^{\frac{n}{2}}$

- 若 $n$ 为奇数：
  $x^n = x \times \bigl(x^2\bigr)^{\frac{n-1}{2}}$

##### 代码实现原理

假设本轮要计算 ： $cur ^ m$

我们定一个结果`mid`来存储本轮的结果。

按照上面的数学公式 

- 如果 m 是偶数： $mid = (cur ^ {2}) ^ {m/2} $
- 如果 m 是奇数：$mid = cur * cur ^{(m-1)/2}$
- 根据**整数除法的规则**，无论m是奇数还是偶数：$(m-1)/2 == m /2$

##### 代码实现的步骤

- 判断指数是否是奇数，如果是奇数：`res = res * base`;
- $base = base ^2$
- $exponenent = exponent/2$
- 下一轮继续求$(base ^ 2)^{exponent/2}$

```java
double res = 1.0, cur = x;
while (m > 0) {
    if ((m & 1) == 1) {
        res *= cur;      // 当最低位为 1 时，累乘当前 cur
    }
    cur *= cur;          // cur ← cur²
    m >>= 1;             // 指数右移，除以 2
}
```

理解版本的方式：

```java
//最终结果
double res = 1.0;
//当前底数
double base = x;
//当前指数
long exponent = m;
//
while (exponent > 0){
  //检查指数是否为奇数
  boolean isOdd = exponent % 2 == 1;
  //如果指数是奇数
  //Res = Res * Base
  if (isOdd){
    res *= base;
  }
  // 将base 变为 base ^ 2;
  boolean squared = base * base;
  base = squared;
  // 指数变为 exponent/2
  exponent = exponent / 2;
  
  // 准备下一轮的求值
}
```

这个代码其实可以使用递归的方式更加有助于理解：

```java
  private double quickPow(double x, long m) {
        // 递归终止
        if (m == 0) {
            return 1.0;
        }
        // 先计算一半的结果
        double half = quickPow(x, m / 2);
        // 根据奇偶分支组合
        if (m % 2 == 0) {
            // m 为偶数： x^m = (x^(m/2))^2
            return half * half;
        } else {
            // m 为奇数： x^m = (x^((m-1)/2))^2 * x
            return half * half * x;
        }
    }
```

## 代码实现

```java
    public double myPow(double x, int n) {
        if (n == 0) return 1;
        long m = n;
        if ( n < 0){
            x = 1/x;
            m = -m;
        }
        double res = 1.0;
        while ( m > 0 ){
            if (m % 2 == 1){
                res *= x;
            }

            x *= x;
            m = m / 2;
        }

        return res;
    }
```

## 注意事项

**类型安全**：务必先把 `n` 存入 `long`，再取负；

**浮点边界**：若 $x=0$ 且 $n\le0$，应根据题目约束提前处理或报错；

**性能**：时间复杂度 $O(\log |n|)$，空间复杂度 $O(1)$；

```java
public double myPow(double x, int n) {
    long m = n;
    return m < 0 
        ? 1.0 / quickMul(x, -m) 
        : quickMul(x, m);
}
private double quickMul(double x, long m) {
    if (m == 0) return 1.0;
    double half = quickMul(x, m / 2);
    return (m % 2 == 0) 
        ? half * half 
        : half * half * x;
}

```

## 经验总结

- 数学公式总结

### 

记 $m = |n|$，先处理负号：
$$
\text{若 }n<0:\quad x \leftarrow \frac1x,\;m \leftarrow -n
$$
再定义递归函数
$$
\text{quickPow}(x,m)=
\begin{cases}
1, & m=0,\\[6pt]
\bigl(\text{quickPow}(x,\lfloor m/2\rfloor)\bigr)^2, & m\text{ 为偶数},\\[6pt]
\bigl(\text{quickPow}(x,\lfloor m/2\rfloor)\bigr)^2\times x, & m\text{ 为奇数}.
\end{cases}
$$
**掌握快速幂模板**：可推广至幂模运算、矩阵幂、区间乘积等问题。

**边界条件务必全面**：负指数、零底数、整型溢出都是高频坑点。

**数值稳定性**：浮点运算误差难免，关键场景可考虑多重检验或高精度库。

**算法套路迁移**：二分思想不仅限于幂，还可用于查找、排序、图论分治等多种场景。

# Leetcode 69: 求平方根，只保留整数部分

```Java
class Solution {
    public int mySqrt(int x) {
        int left = 1; 
        int right = x;
        int ans = 0;
        while( left <= right){
            int mid = left + (right - left) / 2;
            long res = (long)mid * mid;
            if( res <= x){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return ans;
    }
}
```

#Leetcode 367: 判断一个数字是否是完全平方数

```Java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 1;
        int right = num;

        while(left <= right){
            int mid = left + (right - left) / 2;
            long prod = (long) mid * mid;
            if(prod == num){
                return true;
            }
            if(prod > num){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        return false;
    }
}
```

# Leetcode 977: 有序数组的平方数数组

```Java
//给定一个非降序排序的数组
//返回一个包含每个元素的平方的数组
//也需要是非降序的
//双指针方法
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int i = 0; 
        int j = n-1;
       
        LinkedList<Integer> res = new LinkedList<>();
        //注意这里的条件
        while(i <= j ){
            if(nums[i] * nums[i] >= nums[j]*nums[j]){
                res.addFirst(nums[i]*nums[i]);
                i++;
            }else{
                res.addFirst(nums[j]*nums[j]);
                j--;
            }
        }

        int[] ans = new int[n];
        for(int m = 0; m < n; m++){
            ans[m] = res.get(m);
        }
        return ans;

    }
}
```

# Leetcode 2521: 数组成绩中的不同质因数数量

## 题目描述

给你一个正整数数组 nums，请你计算数组中所有元素乘积的不同质因数的数目。

- **输入**：`nums = [2,4,3,7,10,6]`
- **过程**：乘积是 $2 \times 4 \times 3 \times 7 \times 10 \times 6 = 10080$。
- **分解**：$10080 = 2^5 \times 3^2 \times 5 \times 7$。
- **不同质因数**：$2, 3, 5, 7$。
- **输出**：4

**数据范围**：

- $1 \le nums.length \le 10^4$
- $2 \le nums[i] \le 1000$

## 本质与分析

###核心误区：求所有元素的乘积

很多初学者看到题目中的“乘积”二字，第一反应是先把所有数乘起来，再对结果进行质因数分解。

- **错误原因**：数据溢出。即使是 `long` 类型也无法存储 $10^4$ 个数字的乘积（哪怕每个数字都很小）。

###问题本质：乘积的质因数 = 各个因子质因数的并集

乘积的质因数 = 各个因子质因数的并集。

数学性质：如果 $N = A \times B$，那么 $N$ 的质因数集合是 $A$ 的质因数集合与 $B$ 的质因数集合的并集。

因此，我们**不需要计算乘积**，只需要：

1. 遍历数组中的每一个数。
2. 对每一个数分别进行质因数分解。
3. 将分解出的质数放入一个全局的 `HashSet` 中进行去重。
4. 最后返回集合的大小。

### 涉及到的数学知识

####算术基本定理：任何一个大于1的自然数都可以唯一地分解成有限个质数的乘积

任何一个大于1的自然数，都可以唯一地分解成有限个质数的乘积。

$$n = p_1^{a_1} \times p_2^{a_2} \times ... \times p_k^{a_k}$$

####试除法（Trial Division）：从2到$\sqrt{n}$逐个遍历

要判断或分解 $n$，只需要尝试从 $2$ 到 $\sqrt{n}$ 的整数即可。

- **原理**：如果 $n$ 有因数，且 $n$ 不是质数，那么它至少有一个因数小于等于 $\sqrt{n}$。
- **推论**：如果在 $2$ 到 $\sqrt{n}$ 之间没有找到因数，且 $n > 1$，则剩余的 $n$ 本身就是一个质数。

##核心思想和套路：单个数字的质因数分解

套路：单个数字的质因数分解模板。

这是算法题中非常基础且通用的模板，必须熟练掌握。

**数据结构**：使用 `HashSet` (哈希集合) 来存储质数，利用其不可重复性自动去重。

优化：

由于题目中 $nums[i] \le 1000$，数值非常小。

- 方法一（通用）：对每个数用 $\sqrt{n}$ 法分解。
- 方法二（针对小范围）：虽然 $N$ 很大，但 $nums[i]$ 很小，可以只遍历 $nums$ 一次，或者统计有哪些数字出现过，避免重复分解相同的数字。

## 实现原理和步骤

初始化一个 `HashSet<Integer>` 用于存储全局的质因子。

遍历 `nums` 数组中的每个数字 $x$。

对 $x$ 执行质因数分解：

- 从 $i = 2$ 开始循环，当 $i \times i \le x$ 时：
  - 如果 $x$ 能被 $i$ 整除：
    - 将 $i$ 加入 Set。
    - **关键步骤**：循环执行 $x = x / i$，直到 $x$ 不能被 $i$ 整除为止（把 $x$ 中所有的因子 $i$ 都除尽，确保 $i$ 是质数，且下一个找到的因子一定是更大的质数）。
  - $i$ 自增。
- 循环结束后，如果 $x > 1$，说明剩下的这个 $x$ 是一个大于 $\sqrt{原x}$ 的质数，将其加入 Set。

返回 Set 的大小。

## 实现代码

```Java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int distinctPrimeFactors(int[] nums) {
        // 使用 HashSet 自动去重
        Set<Integer> primeFactors = new HashSet<>();

        for (int num : nums) {
            // 对每个数字进行质因数分解
            decompose(num, primeFactors);
        }

        return primeFactors.size();
    }

    // 辅助函数：分解质因数并存入 Set
    private void decompose(int n, Set<Integer> primes) {
        // 从 2 开始试除，直到 i * i > n
        for (int i = 2; i * i <= n; i++) {
            // 如果 i 是 n 的因子
            if (n % i == 0) {
                // i 此时一定是质数（因为比它小的因子都已经被除尽了）
                primes.add(i);
                
                // 核心：把 n 中所有的 i 因子都除掉
                while (n % i == 0) {
                    n /= i;
                }
            }
        }
        
        // 处理最后剩下的部分
        // 如果 n > 1，说明剩下的 n 本身就是一个质数
        if (n > 1) {
            primes.add(n);
        }
    }
}
```

## 注意事项

1. **不要计算乘积**：再次强调，计算乘积是绝对的死路。
2. **While循环除尽因子**：`while (n % i == 0) n /= i;` 这一步非常关键。
   - 如果不做这一步，仅仅 `if` 判断，当 $n=12, i=2$ 时，加入2，如果不除尽，$n$ 还是12，$i$ 变成3，加入3，$n$ 还是12，$i$ 变成4，4能整除12，加入4。但4不是质数。
   - **除尽的逻辑保证了后续遇到的因子只能是质数**（因为合数的因子一定比它小，且已经被前面的循环除掉了）。
3. **时间复杂度**：
   - 外层遍历数组 $O(N)$。
   - 内层分解质因数 $O(\sqrt{M})$，其中 $M$ 是 `nums` 中的最大值（这里是 1000）。
   - 总复杂度：$O(N \sqrt{M})$。对于本题，$10^4 \times \sqrt{1000} \approx 10^4 \times 31 \approx 3 \times 10^5$，非常快。
4. **空间复杂度**：
   - 取决于不同质因数的个数。对于 1000 以内的数字，质数很少，空间占用极小。

## 经验总结

- **局部处理 vs 全局处理**：遇到“数组整体操作”（如乘积、和）的问题，先思考能否将操作拆解到“单个元素”上处理，然后再合并结果。

- **模板记忆**：`for (i=2; i*i<=n; i++) { while(n%i==0) n/=i; } if(n>1) ...` 这段代码是处理整数分解的黄金法则，建议背诵。

- **Set的作用**：在任何涉及“统计不同个数”、“去重”的场景下，优先考虑 HashSet。

  ![image-20251210185213280](/Users/tommy/Library/Application Support/typora-user-images/image-20251210185213280.png)

可以帮助直观理解为什么我们不需要算出乘积，而是把每个数像剥洋葱一样拆成质数扔进篮子里。
