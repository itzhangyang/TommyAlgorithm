
# 2. **链表**

## 常见题型：

- 链表的翻转（单链表、双链表）
- 链表的合并与分割
- 环形链表检测
- K个一组翻转链表

| 类型          | 关键词                     | 示例题目               |
| ------------- | -------------------------- | ---------------------- |
| ✅ 遍历类      | 单次遍历、双指针、快慢指针 | Leetcode 141、876      |
| ✅ 修改结构类  | 插入、删除、反转、合并     | Leetcode 21、92、25    |
| ✅ 检测结构类  | 环检测、交点、是否回文     | Leetcode 141、160、234 |
| ✅ 构造/复制类 | 深拷贝、加法、链表转树     | Leetcode 2、138、109   |
| ✅ 分段处理    | 分组反转、分区、拆分       | Leetcode 86、25、725   |
| ✅ 进阶结构    | 双向链表、随机指针、LRU    | Leetcode 146、138      |

## 解题策略：

- **快慢指针**：检测链表中是否有环或寻找中间节点。
- **递归**：解决链表翻转和合并。
- **哑结点技巧**：简化链表操作的边界情况处理。

| 策略                 | 说明                    | 适用场景                   |
| -------------------- | ----------------------- | -------------------------- |
| **虚拟头节点 dummy** | 避免头节点为空/特殊处理 | 插入、删除、合并类         |
| **快慢指针**         | 用于找中点/判断环       | 环检测、回文、找中点       |
| **双指针/滑动窗口**  | 控制节点间的相对关系    | 删除倒数第 N 个节点        |
| **递归反转**         | 借助递归栈处理反转      | 局部反转                   |
| **栈辅助**           | 倒序、回文判断          | 判断回文链表               |
| **HashSet / Map**    | 判环、去重、复制        | HashSet 判环，Map 复制指针 |
| **三指针移动**       | 当前、前驱、后继        | 链表反转、删除             |
| **分段计数**         | 分组反转/多链表拆分     | k 个一组反转、拆分链表     |

## 速查手册

| 题号 | 题目名称               | 难度 | 策略关键词              |
| ---- | ---------------------- | ---- | ----------------------- |
| 21   | 合并两个有序链表       | 简单 | 双指针 + dummy          |
| 2    | 两数相加               | 中等 | 进位模拟 + dummy        |
| 206  | 反转链表               | 简单 | 三指针/递归             |
| 92   | 反转部分链表           | 中等 | 前驱定位 + 局部反转     |
| 25   | K 个一组反转链表       | 困难 | 分组递归 + 原地反转     |
| 876  | 找中间节点             | 简单 | 快慢指针                |
| 141  | 判断链表是否有环       | 简单 | 快慢指针                |
| 142  | 找环的起点             | 中等 | Floyd 判圈定律          |
| 160  | 相交链表               | 简单 | 双指针（走两次）        |
| 234  | 判断回文链表           | 中等 | 快慢指针 + 反转后半部分 |
| 82   | 删除重复元素 II        | 中等 | 虚拟头节点 + 跳过重复段 |
| 138  | 复制带随机指针的链表   | 中等 | 哈希映射 / 原地交叉     |
| 147  | 对链表进行插入排序     | 中等 | 插入模拟 + dummy        |
| 109  | 有序链表转换二叉搜索树 | 中等 | 快慢指针 + 分治构树     |

# 常见算法策略

##Dummy节点

引入一个虚拟节点，统一处理`头节点被改动`的问题，避免**分类讨论**.

#### 实现原理

- `dummy.next=head`
- 最后返回`dummy.next`

#### 套路代码模板

```java
ListNode dummy = new ListNode(-1);
dummy.next = head;
ListNode prev = dummy;
while (prev.next !=null){
  prev = prev.next;
}
return prev.next;
```

#### 适用场景

- 删除节点
- 插入节点
- 局部操作链表需要移动头节点

#### Leetcode 83: [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

##### 题目要点分析-跳过重复节点

这里的一个重要的做法是**跳过重复的节点**

如果当前节点`current`与上一节点`prev`重复，则`prev.next=current.next`.

##### 变量定义与指针初始化

删除链表中的元素，为了减少不必要的检查，定义一个`dummy`表头。

- 定义一个`dummy`节点作为修改过之后的链表头节点
- 将`dummy`的`next` 修改为真正的头节点`head`
- 定义一个`prev`指针，指向`dummy`节点,用来指向当前第一个有效节点（比如有多个重复节点，`prev`指向其中第一个节点）
- 定义一个`current`指针，指向`head`

##### 遍历与修改链表

###### 使用`while`循环防止越界

```java
while (current ! = null ){
  ....
}
```

###### 跳过重复的节点

当当前节点与上一个节点`prev` 相同，则跳过当前节点,注意**确保`prev`指针指向的不是`dummy`节点**。

```java
while (current != null){
  // 处理重复节点，跳过
  if (dummy != prev && current.val == prev.val){
    // prev.next指向current.next，跳过current
    prev.next = current.next;
    // current 指针前移
    current = current.next;
  }else{
    //处理正常情况的节点
  }
}
```

###### 处理正常的节点

```java
while (current != null){
  if (当前节点与prev节点重复){
    ....
  }else{
    prev = current;
    current = current.next;
  }
}
```

##快慢指针 - 寻找链表的中点或者环

#### 核心思想

用两个指针，一个快一个慢，通过速度差定位特殊节点位置

#### 实现原理

- 快指针走两步，慢指针走一步
- 快指针遇到null, 慢指针在中点
- 或者快慢指针相遇有环

#### 套路代码模板

```java
ListNode slow = head, fast = head;
while (fast !=null && fast.next !=null){
  slow = slow.next;
  fast = fast.next.next;
}
return slow;
```

#### 适用场景

- 找链表中点
- 判断链表是否有环
- 找环的入口
- 找倒数第N个节点

###怎样寻找链表的中点？

```java
ListNode slow = head, fast = head;
while (fast !=null && fast.next !=null){
  slow = slow.next;
  fast = fast.next.next;
}
return slow;
```

####注意当链表的长度为基数或者偶数的时候

- 当链表长度为奇数时，slow 恰好停在中间节点。
- 当链表长度为偶数时，slow 会停在**后半段的第一个节点**。

#### Leetcode 234: 判断一个链表是否是回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

##### 题目分析

要判断链表是否是回文链表，则需要先找到链表的**中点**，然后将链表的后半段**反转**，最后比较链表的前半段与后半段的节点是否**一一想等**。

所以本题目涉及到两个重要的套路策略：

**查找链表的中点：** 采用经典的`快慢指针`算法策略

**反转链表**: 采用经典的**Dummy指针+头插法**来实现链表的反转

##### 利用快慢指针查找链表的中点

```java
ListNode slow = head;
ListNode fast = head;

while (fast != null && fast.next != null){
  slow = slow.next;
  fast = fast.next.next;
}

//slow节点就是链表的中点
```

##### 利用Dummy节点+头插法反转后半段链表

```java
//定义一个虚拟的头节点
Dummy dummy = new ListNode(-1);
while (slow != null){
  // 暂存当前节点的下一节点
  ListNode next = slow.next;
  // 将当前节点插入到dummy后面
  slow.next = dummy.next;
  dummy.next = slow;
  
  //移动到下一节点
  slow = next;
}
```

##### 比较链表的前半段和反转后的后半段

无论链表的长度是奇数还是偶数，原来链表的中点在反转之后，都变成了反转链表的最后一个节点。

因此在反转之后可以通过使用非空限制条件，逐个比较链表的值。

并且本身反转之后，理论上反转之后的链表与链表的前半部分是一样的，**包括Mid节点**。

```java
ListNode p1 = head;
ListNode p2 = dummy.next;

while (p1!=null && p2!=null){
  if (p1.val != p2.val){
    return false;
  }
  
  p1 = p1.next;
  p2 = p2.next;
}

return true;
```



###怎样检测链表中是否有环？

##### while条件是 `slow != fast`

理论上如果一个链表中有环，快指针会在某个环内的点追赶上慢指针。

##### 中断条件是 `fast == null || fast.next == null`

如果没有环，快指针就会走到链表的尾部，而不会追上慢指针。

```java
if (head == null || head.next==null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast){
            if (fast == null || fast.next == null) return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
```

###怎样寻找链表上环的入口（Leetcode 142）？

##### 寻找快慢指针的相遇点

我们已经知道可以使用快慢指针探测链表上是否存在环。

如果存在环的话，快指针会在某一时刻再次追上慢指针，我们将快指针追上满指针的地方（节点）成为相遇点。

现在我们已经有了三个重要的位置：

**起点：** 即头节点，快指针和慢指针都是从头节点出发的，所以称为起点。

**入口：**现在我们还不知道入口在哪里，但是我们知道，相遇点一定是在入口之后的。

**相遇点：**即我们上文所提到的快指针和满指针相遇的地方。

##### 推导起点-入口-相遇点的关系

- 我们假设从起点到入口的距离是`a`
- 我们假设从入口到相遇点的距离是`b`
- 我们假设从相遇点回到入口的距离是`c`

###### 在第一次相遇的时候，slow和fast分别经过了多少个节点？

- `slow`指针已经走过了`a + b`的路径长度。
- `fast`指针已经走过了`a + n(b+c) + b`, 也就是说fast指针可能已经在环内转了很多圈了

###### 从起点和相遇同时点出发一定会在入口相遇

- 因为`fast`指针是`slow`指针速度的两倍，因此：

  $2\cdot(a + b) = a + n\cdot(b + c) + b$

  整理推导一下：

  - $(a + b) = n\cdot(b+c)$
  - $a = n\cdot (b+c) -b$
  - $a = (n-1)\cdot(b+c) + c$

  于是我们得到结论：**从起点和相遇点同时出发，一定会在环的入口相遇**。

##### 实现代码

```Java

public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            //相遇说明有环，并且slow点就是相遇点
            if(slow == fast){
                //如果存在环
                //从起点和相遇点同时出发，则它们一定会在环的入口相遇
                ListNode meetPoint = slow;
                ListNode curr1 = head;
                ListNode curr2 = meetPoint;
                while(curr1 != curr2){
                    curr1 = curr1.next;
                    curr2 = curr2.next;
                }
                return curr1;
            }
        }
        return null;
    }
}
```

###利用快慢指针寻找倒数第K个节点

注意本题中，fast指针比slow指针先走，但是fast指针和slow指针的**移动速度是一样**的。

尝试让慢指针比快指针慢K-1个节点。

####先让fast指针前移K-1步

```Java
for(int i = 0; i < k - 1; i++){
  fast = fast.next;
}
```

####fast指针和slow指针同步移动直到fast走到最后一个

我们已经让fast指针先走了`k-1`步，现在fast和slow指针之间差了`k-1`步。

现在我们我们让fast和slow指针同时前移，**直到fast指针到达最后一个节点**。

```Java
while(fast != null && fast.next != null){
	//...
  slow = slow.next;
  fast = fast.next;
}
```

现在slow指针就是链表的倒数第K个节点。

#### Leetcode 19: 删除链表的倒数第K个节点 - 基于快慢指针

```Java
 //删除链表的倒数第n个节点
 //先尝试快慢指针的方式
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode slow = head;
        ListNode fast = head;
        //使用dummy node，防止删除第一个节点
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        for(int i = 0; i < n-1; i++){
            fast = fast.next;
        }
        ListNode prev = dummy;
        while(fast != null && fast.next != null){
            prev = slow;
            slow = slow.next;
            fast = fast.next;
        }

        prev.next = slow.next;
        return dummy.next;
    }

    
}
```



##反转链表套路

反转链表有三种常见的方法，适用的场景有些不同。

### 三指针反转链表 - 常见的传统方法

这是反转整个链表最基础、最经典的方法。

#### 三指针方法的核心思想 - 原地修改NEXT指针

通过迭代遍历链表，在原地逐个修改节点的 `next` 指针，使其指向前一个节点，从而实现链表的反转。

####三个指针都是干啥的？

使用三个指针协同工作，完成指针的转向：

#####Prev指针：指向前一个节点

`prev`: 指向前一个节点。反转后它将成为当前节点的后继，初始为 `null`。

#####Curr指针：指向当前正在处理的节点

`curr`: 指向当前正在处理的节点，初始为 `head`。

#####Next指针： 当前节点的下一个节点

`next`: 临时保存当前节点的原始下一个节点，防止链表断裂。

#### 具体的操作流程

##### 初始化工作

初始化 `prev = null` 和 `curr = head`。

##### 在循环中完成反转操作

###### 保存Curr节点的Next节点

```
next = curr.next
```

###### 核心操作：将当前节点指向前一个节点

```
current.next = prev
```

###### Prev指针后移 

```
prev = curr
```

###### Curr指针后移 

```
current = next
```

#### 套路代码模板

```java
ListNode prev = null, curr = head;
while (curr != null){
  ListNode nextTemp = curr.next;
  currently.next = prev;
  prev = curr;
  curr = nextTemp;
}
return prev;
```

#### 三指针反转法的适用场景

- **反转整个单链表**。
- 作为其他复杂链表问题的基础（例如：回文链表判断、链表相加等）。
- 性能最优，空间复杂度为 O(1)，时间复杂度为 O(n)。
- 面试中考察链表反转时，这是最标准的答案。

### 头插法一： 用于反转整个链表

这种方法可以理解为三指针法的另一种视角，思路是构建一个全新的反转链表。

#### 核心思想 - 依次将每个节点放到Dummy之后

创建一个新的空链表头 `newHead`。遍历原始链表，将每个节点从原链表中“摘下”，然后“插入”到这个新链表的头部。

最终，新链表就是原链表的反转版本。

#### 实现原理

##### 创建Dummy头节点

创建一个`dummy`节点，`dummy.next`初始为`null`。

这个`dummy`节点将永远是新链表的虚拟头。

##### Curr节点从Head节点开始

用`curr`指针遍历原链表，从`head`开始。

##### 在循环中对每个curr节点执行头插法操作

###### 保存next节点防止链表断裂

用`nextTemp`保存`curr`的下一个节点，防止原链表断裂。

###### 头插法的核心操作

i.  `curr.next = dummy.next`：将`curr`的`next`指向新链表的第一个真实节点。

ii. `dummy.next = curr`：将`dummy`的`next`指向`curr`，完成插入

iii.  `curr = nextTemp`：`curr`指针移动到原链表的下一个节点，继续遍历。

循环结束后，`dummy.next`指向的就是反转后链表的头节点。

#### 套路模板

```java
ListNode dummy = new ListNode(-1);
ListNode current = head;
while (current != null){
  ListNode next = current.next;
  current.next = dummy.next;
  dummy.next = current;
  current = next;
}

return dummy.next;
```

#### 适用场景

- 当需要创建一个全新的反转链表时，这个思路非常清晰。

- 逻辑上可以看作是“不断将节点插入到链表头”，Dummy节点的引入使这个“头”固定不变，代码更规整。

- 同样用于**反转整个单链表**，时空复杂度与三指针法相同。

### 头插法二：链表局部反转操作

这种方法是链表局部反转问题的精髓，它在一个**固定的窗口前**执行头插操作。

#### 核心思想 - 从区间的第二个节点开始头插操作

找到要反转区间 `[left, right]` 的前驱节点`pre`。

然后，从区间的第二个节点开始，依次将它们“摘下”并插入到`pre`节点的后面。

这个过程重复`right - left`次。

#### 实现原理

##### Dummy节点连接到Head节点

创建一个`dummy`节点，令`dummy.next = head`。

这可以优雅地处理`left = 1`的边界情况。

##### 找到待反转区间的pre节点

找到反转区间的前驱节点`pre`。让`pre`从`dummy`开始走`left - 1`步。

##### 找到待反转区间的第一个节点first

定义`first`指针，指向反转区间的第一个节点（即`pre.next`）。

在整个反转过程中，`first`指针**保持不变**，它标志着区间的“静态”头部。

##### 在right - left 次循环中执行头插操作

- 保存first节点的next节点：`next = first.next`
- 将first节点连接到`next`节点的下一个节点：`first.next = next.next`
- **头插法操作：将`next`节点插入到`pre`节点之后**
  - 将待移动节点的`next`指向当前区间的头（即`pre.next`）：`next.next = pre.next`
  - 将`pre`的`next`指向待移动节点，完成移动: `pre.next = next`

循环结束后，返回`dummy.next`。

#### Leetcode 92 : 反转链表中的特定区间

#####问题要点

- **输入**: 一个单链表的头节点 `head`，以及两个整数 `left` 和 `right`。
- **任务**: 将链表中从第 `left` 个节点到第 `right` 个节点的部分进行反转。
- **约束**:
  - 链表节点数量在 `[1, 500]` 之间。
  - `1 <= left <= right <= n` (n 是链表节点总数)。
  - 节点的值在 `[-500, 500]` 之间。
- **输出**: 修改后链表的头节点。

##### 问题本质和分析

这个问题的本质是在一个链表中**截取一个子链表**，**将其反转**，然后**再接回原链表**中。

这比单纯地反转整个链表（LeetCode 206）要复杂，因为涉及到三个部分的连接：

1. **第一部分**: 从 `head` 到 `left-1` 位置的节点。
2. **第二部分**: 从 `left` 到 `right` 位置的节点（这是需要反转的部分）。
3. **第三部分**: 从 `right+1` 到链表末尾的节点。

我们的核心任务就是，在反转第二部分之后，确保第一部分的尾部正确地指向第二部分反转后的头部，并且第二部分反转后的尾部正确地指向第三部分的头部。

为了实现这个目标，我们需要精确地定位四个关键节点/位置：

- **`pre_left`**: 第 `left-1` 个节点，即反转部分的前驱节点。
- **`left_node`**: 第 `left` 个节点，它将成为反转后的子链表的尾部。
- **`right_node`**: 第 `right` 个节点，它将成为反转后的子链表的头部。
- **`post_right`**: 第 `right+1` 个节点，即反转部分的后继节点。

整个操作的流程可以想象成： `... -> pre_left -> [left_node -> ... -> right_node] -> post_right -> ...` 反转后变成： `... -> pre_left -> [right_node -> ... -> left_node] -> post_right -> ...`

##### 背景知识

- **单链表 (Singly Linked List)**: 这是最基础的数据结构知识。你需要理解节点（Node）的概念，它包含一个值（value）和一个指向下一个节点的指针（next）。
- **指针/引用操作**: 链表问题的核心就是操作指针（在 Java 中是引用）。你需要非常清楚地知道，改变一个节点的 `next` 引用会如何影响整个链表的结构。
- **链表反转 (Iterative Method)**: 这是解决本题的核心子问题。你应该熟练掌握如何通过迭代（通常使用 `prev`, `curr`, `next` 三个指针）来反转一个完整的链表。

##### 考察点和关键挑战

###### 当left = 1的情况

当 `left = 1` 时，意味着反转的部分包含了头节点。这会导致整个链表的头节点发生改变。

###### left = right的情况

当 `left = right` 时，不需要反转。

###### right是最后一个节点的情况

当反转部分是链表的最后一部分时（`right` 是最后一个节点）。

##### 模式匹配

###### 哨兵节点模式 - Dummy

这是解决链表问题，特别是那些可能改变头节点的问题的经典模式。

通过创建一个指向 `head` 的虚拟头节点（Dummy Node），可以极大地简化边界情况的处理。

例如，当 `left = 1` 时，我们就不需要写额外的 `if` 语句来特殊处理了，因为 `pre_left` 节点在这种情况下就是我们的 Dummy Node。

###### 子问题分解能力

整个问题可以分解为 "找到反转起点" -> "反转指定长度的子链表" -> "重新连接"。

这体现了将复杂问题分解为简单子问题的思想。

##### 核心思想和套路 - 头插法

###### 核心思想 - 头插法

最优雅、最高效的套路是 **“头插法”**。

这个思想非常巧妙，我们不需要先把子链表断开，反转后再接回去，而是在遍历过程中，**动态地将要反转的节点一个个地移动到反转区域的头部**。

我们来定义几个关键指针：

- `dummy`: 哨兵节点，`dummy.next = head`。
- `pre`: 永远指向待反转区域的前一个节点（即 `pre_left`）。
- `curr`: 指向待反转区域的第一个节点（即 `left_node`），这个节点在反转过程中位置不变，最终会成为反转后的尾部。

###### 套路步骤 - 非典型的头插法

- 创建一个 `dummy` 节点，并连接到 `head`。

- 找到 `pre` 节点，即第 `left-1` 个节点。让 `pre` 指针走 `left-1` 步。

- 此时 `pre.next` 就是 `curr` 节点（第 `left` 个节点）。

- 开始循环，一共执行 `right - left` 次。在每次循环中：

  - 定义一个 `next_node` 指向 `curr.next`，这是我们要移动到头部的节点。

  - `curr` 断开与 `next_node` 的连接，指向 `next_node` 的下一个节点：`curr.next = next_node.next`。

  - 将 `next_node` 插入到 `pre` 之后：`next_node.next = pre.next`。

  - `pre` 连接到 `next_node`：`pre.next = next_node`。

- 返回 `dummy.next`。

注意在循环过程中，我们是不断的将**`curr`后面的节点**插入到`prev`节点之后， **实际上没有curr节点本身被插入到prev之后这个过程**。

因为curr节点一开始本身就是prev节点的next节点，如果curr节点也参与头插法过程，会导**环的出现**。

我们使用一个形象的比喻来解释这个过程：

假设有一队人 `A-B-C-D-E`，我们要让 `B, C, D` 这个子队伍反转。

- `A` 是 `pre` 节点，是固定不动的“参照物”。
- `B` 是 `curr` 节点，它很特殊，在整个过程中它自己不移动，但最终会跑到反转队伍的末尾。

假设有一队人 `A-B-C-D-E`，我们要让 `B, C, D` 这个子队伍反转。

- `A` 是 `pre` 节点，是固定不动的“参照物”。
- `B` 是 `curr` 节点，它很特殊，在整个过程中它自己不移动，但最终会跑到反转队伍的末尾。

1. **初始状态**: `A -> B -> C -> D -> E`
   - `pre` 指向 `A`，`curr` 指向 `B`。
   - `pre.next` 是 `B`（当前反转区域的头）。
2. **第一步：把 `C` 插入到“头”**
   - 把 `C` 从队伍里叫出来。队伍变成 `A -> B -> D -> E`。
   - 把 `C` 插入到 `A` 的后面。
   - **结果**: `A -> C -> B -> D -> E`
   - 现在 `pre.next` 是 `C`（新的反转区域的头）。
3. **第二步：把 `D` 插入到“头”**
   - 把 `D` 从队伍里叫出来。队伍变成 `A -> C -> B -> E`。
   - 把 `D` 插入到 `A` 的后面。
   - **结果**: `A -> D -> C -> B -> E`
   - 现在 `pre.next` 是 `D`（新的反转区域的头）。

循环结束，`B-C-D` 成功反转成了 `D-C-B`，并且完美地衔接在 `A` 和 `E` 之间。

**举例说明 `right - left` 次循环中的一步**：

 假设链表是 `1 -> 2 -> 3 -> 4 -> 5`，`left=2, right=4`。 

初始时： `dummy -> 1 -> 2 -> 3 -> 4 -> 5` `pre` 指向 `1`，`curr` 指向 `2`。

 状态: `pre(1) -> curr(2) -> 3 -> 4 -> 5`

##### 实现原理和步骤

###### 处理Edge Case: Left == Right

如果 `left == right`，无需反转，直接返回 `head`。

###### 创建哨兵节点

**创建哨兵节点**: `ListNode dummy = new ListNode(-1); dummy.next = head;`

###### 第一次循环：定位Prev节点和curr节点 - 窗口之前的一个节点

创建一个指针 `pre = dummy`，然后循环 `left - 1` 次，让 `pre` 移动到反转区域的前一个节点。

同时`curr`节点就是：`ListNode curr = pre.next;`

###### 第二次循环： 反转链表区间 - 非典型头插法

使用一个 `for` 循环，从 `0` 到 `right - left - 1`，执行 "头插法" 操作。

- `ListNode next = curr.next;` // 待移动的节点
- `curr.next = next.next;`     // curr 连接到 next 的后面
- `next.next = pre.next;`      // next 插入到 pre 后面
- `pre.next = next;`           // pre 连接到 next

###### 返回结果

返回 `dummy.next`。

##### 实现代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = dummy;
        for(int i = 0; i < left; i++){
            prev = curr;
            curr = curr.next;
        }
        //注意应该从curr的next节点开始做头插法
        for(int j = 0; j < right - left; j++){
           ListNode nodeToMove = curr.next;
            // `curr` 跳过 `nodeToMove`，连接到它的下一个节点
            curr.next = nodeToMove.next;
            
            // 将 `nodeToMove` 插入到 `pre` 的后面，完成一次“头插”
            nodeToMove.next = prev.next;
            prev.next = nodeToMove;
        }
        return dummy.next;
    }
}
```

##### 注意事项

**1-based vs 0-based 索引**: 题目给的是 1-based 索引（第 `left` 个），而编程中循环通常是 0-based。在定位 `pre` 节点时要小心，`for (int i = 0; i < left - 1; i++)` 正是移动 `left-1` 步。

**指针的备份**: 在移动指针前，确保你已经保存了所有必要的引用，否则可能会“丢失”链表的一部分。在上面的代码中，`nextToMove` 就是一个临时备份。

**循环次数**: 头插法循环的次数是 `right - left` 次，而不是 `right - left + 1`。这是一个很容易出错的点。可以这样理解：总共有 `right - left + 1` 个节点需要反转，第一个节点 `curr` 不动（作为锚点），我们只需要把它后面的 `right - left` 个节点依次移动到最前面即可。

**理解 `pre` 和 `curr` 的角色**: `pre` 是固定的，作为插入点头部的前一个节点。`curr` 也是固定的，作为反转区域的尾部节点（它的 `next` 指针在变化，但 `curr` 本身这个引用不变）。

##### 经验总结

**画图是王道**: 对于任何复杂的链表问题，在纸上画出节点和指针的变化过程是理解和验证算法正确性的最有效方法。一步一步地画出 `pre`, `curr`, `nextToMove` 在每次循环后的位置和指向。

**拥抱哨兵节点**: 只要链表操作可能涉及到头节点，就毫不犹豫地使用哨兵节点。它能统一逻辑，避免为 `head` 编写特殊处理代码，让代码更简洁、更健壮。

**掌握核心套路**: “头插法”反转子链表是一个非常精妙和高效的技巧，值得花时间去理解和记忆。它避免了断开和重新连接的复杂性，在一次遍历中就完成了所有操作。一旦掌握，解决类似问题会得心应手。

#### Leetcode 24: 两两交换链表中的节点-一个独立完成的中等难度的题目

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

##### 题目分析

- 需要每次遍历和修改两个节点，指针的跳跃步数也应该是每次两个。

- 链表修改和构造类的问题，最好是使用`dummy`节点和`prev`节点配合使用

  ```java
  ListNode dummy = new ListNode(-1);
  ListNode prev = dummy;
  ```

- 需要考虑每次处理两个节点的情况,则需要确保`first`和`second`都为**有效节点**的情况

  ```java
  while (first !=null && first.next != null){
    ListNode second = first.next;
    // 保留下一个first节点的指针
    ListNode nextFirst = second.next;
    //.....处理交换逻辑
    // first指针指向下一个first节点
    first = nextFirst;
  }
  ```

##### 实现原理和步骤

###### 怎样使用dummy节点来构造和修改链表？

```Java
ListNode dummy = new ListNode(-1);
ListNode prev = dummy;
/*处理核心计算逻辑开始*/
//核心计算逻辑...
/*处理核心计算逻辑结束*/

return dummy.next;
```

###### 怎样每次处理两个节点？

- 需要考虑每次处理两个节点的情况,则需要确保`first`和`second`都为**有效节点**的情况
- 每次循环的处理过程中，需要记录和修改下一个`first`节点指针

```java
while (first !=null && first.next != null){
  ListNode second = first.next;
  // 保留下一个first节点的指针
  ListNode nextFirst = second.next;
  //.....处理交换逻辑
  // first指针指向下一个first节点
  first = nextFirst;
}
```

###### 怎样交换两个相邻的节点？

**交换过程**

- 找到`second`节点:`second = first.next`
- 保存下一个`frist`节点`ListNode nextFirst = second.next`, 这是下一个循环要处理的`first`节点
- 将`second`节点设置为`prev`节点的`next`
- 将`first` 节点设置为`second`节点的`next`

**下一阶段准备**

- `Prev = second`
- `first=nextFirst`

###### 处理只有fist没有second的情况（链表节点数量为偶数）

如果first不为空并且first.next为空，则说明最后一个循环只有一个节点，因此不会做任何操作，这里需要做特殊处理

- 直接将最后一个节点添加到链表

```java
if(first !=null && first.next == null){
            prev.next = first;
        }
```

###### 返回修改后的头节点

按照上面的情况， `dummy.next`就是新的头节点，直接返回即可。

### Leetcode 25： K个一组反转链表

#### 问题要点

**输入**: 一个单链表 `head` 和一个正整数 `k`。

**任务**: 将链表中的节点每 `k` 个一组进行翻转。

**输出**: 翻转后新链表的头节点。

**核心约束**:

1. `k` 是一个正整数，且小于或等于链表的长度。
2. 如果最后剩余的节点数不足 `k` 个，则**保持原样**，不进行翻转。
3. 你需要只使用常数级别的额外空间，即 $O(1)$。

#### 问题的本质和分析 - 分块处理

这个问题的本质是对一个线性数据结构进行**分块处理**。

它不是一次性的对整个链表进行操作，而是将链表看作若干个长度为K的子链表组成的序列。

##### 核心的挑战：分组 - 反转 - 连接

- **分组：**如何准确的找到每一个组的开始节点和结束节点？
- **反转：**如何在原地反转一个子链表？
- **连接：**反转返程一个子链表以后，如何将其与前一个分组的尾部以及后一个分组的头部正确的连接起来？



想象一下链表 `1->2->3->4->5->6->7`，`k=3`。

- **第一组**: `1->2->3`。翻转后变成 `3->2->1`。
- **第二组**: `4->5->6`。翻转后变成 `6->5->4`。
- **剩余**: `7`。数量不足 `k`，保持不变。

翻转操作完成后，需要把这些断开的链表重新“缝合”起来：

- 翻转前，`...` -> `1`，`3` -> `4`。
- 翻转后，我们需要建立新的连接：`...` -> `3` (第一组的新头)，`1` (第一组的新尾) -> `6` (第二组的新头)，`4` (第二组的新尾) -> `7`。

这个“缝合”过程需要精确地记录和更新指针，是本题的难点和核心。

#### 背景知识 - 反转链表

这是解决本问题的**核心子问题**。如果你不熟悉如何用迭代（三指针法：`prev`, `curr`, `next_temp`）或递归的方式翻转一个完整的链表，那么解决这道题会非常困难。本题可以看作是多次调用“翻转单链表”这个子过程。

#### 模式匹配 - 链表分组操作

这个题目属于对链表进行**分组操作**的模式。

当你看到题目要求对链表的一部分/一段/某个规律分组的操作时，都可以联想到这种模式。

与之相似的题目有：

- **LeetCode 24. Swap Nodes in Pairs**: 两两交换节点。这其实是本题 `k=2` 的一个特例。如果你先做这道题，会对理解 `k-Group` 有很大帮助。
- **LeetCode 92. Reverse Linked List II**: 翻转链表中从 `m` 到 `n` 的部分。这道题也是翻转一个子链表，并处理好与前后部分的连接，与本题的思想高度相似。

#### 核心思想和套路：Dummy + 头插法

##### 涉及到链表修改的问题最好使用Dummy节点

解决这类链表修改问题的通用套路是使用**“虚拟头节点 (Dummy Node)”**。

######Dummy节点可以简化对头节点的处理。

对于原链表的头节点，它可能在第一次翻转后就不再是头节点了（例如 `1->2->3` 翻转后 `3` 成为头）。

如果没有 dummy node，你需要写额外的 `if/else` 来处理第一个分组。

###### Dummy节点可以作为一个固定的前驱节点的起点

Dummy node 提供了一个固定的“前驱节点”的起点，使得所有分组的处理逻辑完全一致。

##### 使用头插法反转每一个分组

这是本解法的精髓。

假设我们有如下状态： `... -> prev_group_tail -> group_head -> node2 -> node3 -> ...` 我们的目标是将 `group_head` 到 `group_tail` 这 `k` 个节点翻转。

- `prev_group_tail`: 指向上一个分组的尾节点。
- `group_head`: 是当前待翻转分组的第一个节点。在翻转过程中，它会**保持不动**，最终成为这个分组的**新尾部**。
- 我们要做的是，将 `group_head` 后面的 `k-1` 个节点，依次移动到 `prev_group_tail` 的后面。

#### 实现原理和步骤

下面用一个具体的例子 `1->2->3->4->5`, `k=3` 来走一遍流程。

#####**初始状态**: `dummy -> 1 -> 2 -> 3 -> 4 -> 5`

- `prev` = `dummy`
- `tail` = `dummy`
- `head` = `1` (这里的 `head` 仅作遍历指针)

##### 主循环过程

###### 检查剩余节点数量是否足够

从 `head` 开始，是否有足够的 `k=3` 个节点？

- 用指针 `tail` 从 `head` 开始走 `k` 步。
- `1 -> 2 -> 3`，可以走到第3个节点。检查通过。`tail` 此时指向节点 `3`。

###### 初始化Prev和Head

- `prev` 指向 `dummy`。
- `head` 指向 `1`。

###### 第二头插法：在分组内进行反转，执行k-1次

**i = 0**:

- `to_move` 指向 `head.next` (节点 `2`)。
- `head.next` = `to_move.next` ( `1` 指向 `3`)。
- `to_move.next` = `prev.next` ( `2` 指向 `1`)。
- `prev.next` = `to_move` ( `dummy` 指向 `2`)。
- **当前状态**: `dummy -> 2 -> 1 -> 3 -> 4 -> 5`

**i = 1**:

- `to_move` 指向 `head.next` (节点 `3`)。
- `head.next` = `to_move.next` ( `1` 指向 `4`)。
- `to_move.next` = `prev.next` ( `3` 指向 `2`)。
- `prev.next` = `to_move` ( `dummy` 指向 `3`)。
- **当前状态**: `dummy -> 3 -> 2 -> 1 -> 4 -> 5`

###### 为下一轮做准备

`prev` 移动到本次翻转后的尾部，即节点 `1`。

`head` 移动到下一分组的头部，即节点 `4`。

##### 主循环继续

- **检查**: 从 `head` (节点`4`) 开始，是否有足够的 `k=3` 个节点？
  - `4 -> 5 -> null`。不够3个。
- **结束循环**。

##### 返回结果 : dummy.next

`dummy.next`，即节点 `3`。最终结果: `3 -> 2 -> 1 -> 4 -> 5`。

#### 实现代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        //Edge Case
        //链表为0，或者K=1
        if(head == null || k == 1){
            return head;
        }

        //设置Dummy节点，next指向head节点
        ListNode dummy = new ListNode(-1);
        dummy.next = head;

        ListNode prevGroupTail = dummy;
        //分组的第一个节点
        ListNode groupHead = head;
        //主循环过程
        while(true){
            //如果当前Group Head为空，停止过程
            if(groupHead == null) break;

            ListNode tail = groupHead;
            //计算分组的size
            int size = 1;
            //寻找分组的最后一个节点
            while(size < k && tail.next != null){
                tail = tail.next;
                size++;
            }
            //如果分组size < k， 停止过程
            if(size < k){
                break;
            }

            //反转过程，基于第二头插法
            //groupHead本身不参与头插操作
            //从groupHead.next开始
            for(int i = 0; i < k - 1; i++){
                //将GroupHead的下一个节点摘出
                ListNode toMove = groupHead.next;
                groupHead.next = toMove.next;

                //将摘出的节点插入到prev节点之后
                toMove.next = prevGroupTail.next;
                prevGroupTail.next = toMove;
            }
            //更新GroupHead，为下一轮做准备
            //现在GroupHead已经是当前分组的GroupTail了
            //将GroupHead设置为prevGroupTail
            prevGroupTail = groupHead;
            //更新GroupHead节点为下一个分组的节点
            groupHead = groupHead.next;
        }

        return dummy.next;
    }
}
```

#### 注意事项

##### 指针的语义

在头插法中，`prev` 始终是固定的“锚点”，`group_start` 是当前翻转分组的“活动尾部”，`to_move` 是要移动的节点。

理解这三个指针在循环中的角色至关重要。

当然在**第二头插法**中Head所承担的语义也比较特殊，不参与头插操作过程，但是会不断更新自己的next。

##### 第二头插法中的头插操作次数是k-1

因为在**第二头插法**中`head`节点**不参与头插操作**,因此**只有`k-1`次头插操作**。

##### 注意指针的更新顺序

在内循环中，四行指针操作的顺序是固定的，一旦写错，链表就会**断裂或形成环**。

`group_start.next = to_move.next;` 必须在 `to_move.next` 被修改之前执行。

##### 外部循环的更新

 一轮翻转结束后，`prev` 和 `group_start` 必须正确地更新到下一分组的对应位置，否则无法继续。

#### 经验总结

**头插法 vs. 独立翻转函数**:

- **独立翻转函数法**: 逻辑更清晰，将“翻转”和“连接”分离，易于理解和调试。代码模块化更好。
- **头插法**: 代码更紧凑，将翻转和连接融为一体，是一种非常高效和炫技的原地算法。但对于初学者来说，其指针操作的逻辑可能更难一次性写对，调试起来也更具挑战性。

**思维的转变**: 头插法要求你从“移动节点”而非“交换值”的角度思考问题。它体现了链表操作的精髓——通过改变指针的指向来重塑数据结构。

**适用场景**: 当你对链表操作非常有信心，并追求极致简洁和高效的代码时，头插法是一个非常好的选择。

在面试中，如果能清晰地写出并解释这种方法，会给面试官留下深刻的印象。但如果感到不熟练，选择更模块化、更易解释的独立翻转函数法是更稳妥的选择。

##双链表分隔套路（拆分链表）

#### 核心思想

维护两个链表指针，根据条件将节点分到不同链表

#### 实现原理

- 建立两个`dummy`节点
- 遍历链表，根据条件选择归属链表

#### 套路代码模板

```java
ListNode l1 = new ListNode(-1),p1=l1;
ListNode l2 = new ListNode(-1),p2=l2;

while (current != null){
  if (满足条件){
    p1.next = current;
    p1 = p1.next;
  }else{
    p2.next = current;
    p2 = p2.next;
  }
  current = current.next;
}
p1.next = null;
p2.next = null;
return l1.next;
```

#### 适用场景

- 按照奇偶节点分组
- 小于某值的节点分组
- 划分链表

##多路归并套路

#### 核心思想

使用`小顶堆`(优先队列) 不断弹出当前最小节点

#### 实现原理

- 所有链表头节点入堆
- 取最小节点，推进对应链表

#### 套路代码模板

```java
PriortyQueue<ListNode> pq = new PriorityQueue<>((a,b)->a.val - b.val);

for (ListNode node:lists){
  if (node !=null) pq.off(node);
}

ListNode dummy = new ListNode(-1), current = dummy;

while (!pq.isEmpty()){
  ListNode node = pq.pull();
  current.next = node;
  current = current.next;
  if (node.next !=null) pq.offer(node.next);
}

return dummy.next;
```

#### 适用场景

- 合并K个升序的链表
- 多路有序合并

#### Leetcode 143: 重排链表

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



##### 题目分析

这个题目可以采用下列方式实现

- 将链表从中间截断
- 反转截断后后半截链表
- 合并两段链表

##### 实现方案

###### 找到链表的中间节点

**寻找链表中点的套路模板**

```java
private ListNode mid(ListNode head){
  ListNode slow = head;
  ListNode fast = head;
  while (fast != null && fast.next != null){
    slow = slow.next;
    fast = fast.next.next;
  }
  
  return slow;
}
```

后半段链表的头节点就是中点的下一节点

```java
ListNode mid = mid(head);
List head2 = mid.next;
//截断链表
mid.next = null;

head2 = revers(head2);
```

###### 反转后半段链表-头插法

```java
private ListNode reverse(ListNode head){
  ListNode dummy = new ListNode(0);
  ListNode current = head;
  while (current != null){
    ListNode next = current.next;
    current.next = dummy.next;
    dummy.next = current;
    current = next;
  }
  return dummy.next;
}
```



###### 合并前后两段链表-交替合并的套路

```java
private void merge(ListNode head1, ListNode head2){
  ListNode p1 = head1;
  ListNode p2 = head2;
  
  ListNode next1 = p1.next;
  ListNode next2 = p2.next;
  
  p2.next = p2;
  //记得建立p2和p1.next之间的关系
  p2.next = next1;
  
  p1 = next1;
  p2 = next2;
}
```

```java
merge(head, head2);
```

##哈希表辅助套路（带随机指针的链表复制）

#### 核心思想

空间换时间，记录**原来的节点到新节点映射关系**

#### 实现原理

- 第一遍复制节点并建立映射
- 第二遍根据映射设置`next`和`random`

#### 套路代码模板 - 链表的深拷贝

```java
Map<Node,Node> map = new HashMap<>();

Node current = head;

while (current != null){
  map.put(current, new Node(current.val));
  current = current.next;
}

current = head;
while (current != null){
  map.get(current).next = map.get(current.next);
  map.get(current).random = map.get(current.random);
  current = current.next;
}

return map.get(head);

```

#### Leetcode 19 删除链表的倒数第N个节点 - 基于哈希表

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

##### 题目分析

###### 倒数第N个节点，就是正数第length-N+1个节点

我们之前分析过，一个链表的倒数第N个节点，就是正数第`length-N+1`个节点

##### 实现原理

######   使用Dummy 来代表虚拟的链表头

```java
ListNode dummy = new ListNode(0);
dummy.next = head;
```



###### 使用哈希表存储每一个节点的索引

```java
ListNode current = head;
int i=1;
Map<Integer, ListNode> indexMap = new HashMap<>();
//将dummy节点设置为0号节点,这是一个非常好的经验
indexMap.put(0,dummy);
while(current !=null){
  indexMap.put(i,current);
  current = current.next;
  i++;
}
```

###### 怎样计算链表的长度

```java
//计算链表的长度
//i=2...current=list[2]
//i=length+1, current=null
int length = i-1;
```

###### 找到并删除倒数第N个节点

如上面的分析，倒数第N个节点就是正数第`length-N+1`个节点

所以我们只需要找到`prev` 和`next`节点，并将`next`设置为`prev.next`即可。

```java
int index = length - n + 1;
ListNode prev = indexMap.get(index-1);
ListNode next = indexMap.get(index+1);
prev.next = next;
return dummy.next;
```

##链表合并排序套路（归并排序链表）

#### 核心思想

链表天然适合归并排序（因为链表可以O(1)时间合并）

#### 实现原理

- 找中点（快慢指针）
- 分左右递归
- 合并两个有序链表

#### 套路模板

```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode mid = getMid(head);
    ListNode left = sortList(head);
    ListNode right = sortList(mid);
    return mergeTwoLists(left, right);
}
```

#### 适用场景

- 排序链表（148题）
- 分治合并相关问题

#### Leetcode 148 排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

##### 题目分析-递归归并排序套路复习

这个题目是属于典型的链表排序题目，一般来说链表排序采用归并排序的套路。

归并排序是一种递归排序方法。

###### 递归的base condition 是什么？

```java
if (head == null || head.next == null) return head;
```

###### 找到链表的中间节点

可以通过快慢指针的方式找到链表的中间节点。

```java
private ListNode getMid(ListNode head){
  ListNode fast = head;
  ListNode slow = head;
  while (fast != null && fast.next != null){
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
}
```

```java
ListNode mid = getMid(head);
ListNode head2 = mid.next;
```



###### 递归-对前半段链表进行排序

```java
ListNode left = sortList(head);
```

###### 递归-对后半段链表进行排序

```java
ListNode right = sortList(head2);
```

###### 合并-合并排序过后的两段链表-合并有序链表的套路

```java
private void merge(ListNode left, ListNode right){
  ListNode p1 = left ;
  ListNode p2 = right;
  
  ListNode dummy = new ListNode(-1);
  ListNode prev = dummy;
  
  while(p1 != null && p2 != null){
    if (p1.val <p2.val){
      prev.next = p1;
      p1 = p1.next;
      prev = prev.next;
    }else{
      prev.next = p2;
      p2 = p2.next;
      prev = prev.next;
    }
  }
  if (p1 != null) prev.next=p1;
  if (p2 != null) prev.next = p2;
  
  return dummy.next;
  }
}
```





#### Leetcode 23: [合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

##### 题目分析

这道题目本身的要点在于每次选择**从所有的链表的当前节点中选择值最小的那个**.

假设我们定义一个**候选节点列表**, 候补节点列表中包含了每一个链表的**当前节点**。

每一次我们从**候选列表**中选择了最小的节点之后，我们需要将该最小节点的**下一个节点`next`**加入候选列表。

换句话说，我们选择了谁，就要从谁所在的列表中中再取下一个节点补充到候选列表中。

##### 实现原理与步骤-基于最小堆

###### 使用dummy节点套路来构建虚拟头节点

```java
ListNode dummy = new ListNode(-1);
ListNode prev = dummy
```

###### 使用最小堆来存放候选列表

**初始化最小堆**

最小堆使用基于Java的PriorityQueue来实现，基于Node的value做升序。

```java
PriorityQueue<ListNode> pq = new PriorityQueue<>((node1,node2)->node1.val-node2.val);
```

**将每一个链表的非空头节点加入最小堆**

```java
for (int i = 0;i<lists.length;i++){
            if (lists[i] != null){
            pq.offer(lists[i]);
            }
        }
```

###### 遍历和更新最小堆

- 每次从最小堆中取出堆顶的节点元素，并追加到构建的列表

```
ListNode node = pq.poll();
prev.next = node;
prev = prev.next;
```

- 如果 node在自己的链表中还有下一个节点，则将下一个节点加入到堆中

```java
if (node.next !=null){
  pq.offer(node.next);
}
```

##### 返回`dummy.next`作为新链表的头节点

#### Leetcode 2: 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

##### 题目分析

这个题目在一定意义上可以算作是**链表合并问题**。

这个题目最重要的需要注意的地方是**进位问题**。

##### 利用链表合并问题的基本结构构造解题框架

```java
while (p1 !=null && p2 !=null){
  //.....
}

if (p1 !=null){
  while (p1 !=null){
    //....
  }
}

if (p2 !=2 null){
  while (p2 != null){
    //....
  }
}
```

##### 进位问题怎么解决？-将是否需要进位的信息传递给下一轮计算

进位的概念是需要向下一位进1，因此我们只需要将是否需要进位的信息传递给下一轮计算即可。

```java
      while (p1 != null && p2 != null) {
            int sum = p1.val+p2.val;
            if (needCarry){
                sum +=1;
            }
            int digit = sum %10;
            ListNode node = new ListNode(digit);
            prev.next = node;
            if (sum >=10){
                needCarry = true;
            }else{
                needCarry=false;
            }
            prev = prev.next;
            p1 = p1.next;
            p2 = p2.next;
        }
```

##Dummy + Dummy (双Dummy指针)套路

#### 核心思想 - 构造多个链表再合并

维护多个虚拟头节点，同时构造多条链表，再统一合并。

#### 实现原理

- 设立多个dummy
- 在遍历过程中根据不同条件，往不同链表插入节点

#### 注意事项

##### 保留当前节点的下一个节点

##### 截断当前节点与后续节点的关联

#### 套路模板

```java
ListNode dummy1 = new ListNode(-1), p1 = dummy1;
ListNode dummy2 = new ListNode(-1), p2 = dummy2;
while (curr != null) {
    if (条件A) p1.next = curr;
    else p2.next = curr;
    // 注意断开curr的原next指向！
    curr = curr.next;
}
```

#### 适用场景

- 分奇偶链表（328. 奇偶链表）
- 按大小划分链表（86. Partition List）

#### Leeched 328: 按照奇偶索引排序

```Java
 //问题分析
 //将链表的节点重新排序，奇数索引的在前，偶数索引在后
 //考虑使用两个dummy链表，然后合并
class Solution {
    public ListNode oddEvenList(ListNode head) {
        ListNode dummy1 = new ListNode(-1);
        ListNode prev1 = dummy1;
        ListNode dummy2 = new ListNode(-1);
        ListNode prev2 = dummy2;
        int i = 1;
        ListNode curr = head;
        //注意使用curr != null 作为条件
        while(curr != null){
          //将当前节点从链表中摘出
          //保留当前节点的下一个节点，防止出现环
            ListNode next = curr.next;
            curr.next = null;
            if(i % 2 == 1){
                prev1.next = curr;
                prev1 = curr;
            }else{
                prev2.next = curr;
                prev2 = curr;
            }
            curr = next;
            i++;
        }
        prev1.next = dummy2.next;
        return dummy1.next;
    }
}
```

#### Leetcode 86: 分割链表

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
 //双dummy链表的方式处理
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode dummy1 = new ListNode(-1);
        ListNode prev1 = dummy1;
        ListNode dummy2 = new ListNode(-1);
        ListNode prev2 = dummy2;

        ListNode curr = head;
        while(curr != null){
            //注意保存curr的下一个节点
            ListNode next = curr.next;
            //截断当前节点和后续节点的关联，防止链表出现环
            curr.next = null;
            if(curr.val < x){
                prev1.next = curr;
                prev1 = curr;
            }else{
                prev2.next = curr;
                prev2 = curr;
            }
            curr = next;
        }
        prev1.next = dummy2.next;
        return dummy1.next;
    }
}
```



| 套路名称   | 核心思想                     | 适用场景                   |
| ---------- | ---------------------------- | -------------------------- |
| Dummy节点  | 加虚拟头节点，统一边界处理   | 插入、删除、修改头节点问题 |
| 快慢指针   | 速度差找到中点、环、倒数节点 | 找中点、判断有环、找环入口 |
| 反转链表   | 迭代或递归改变next指向       | 整体或部分反转链表         |
| 双链表分隔 | 拆成两个链表                 | 奇偶链表、按值划分链表     |
| 多路归并   | 小顶堆合并多个链表           | 合并K个有序链表            |
| 哈希表辅助 | 记录节点映射                 | 拷贝复杂链表               |

#### Leetcode 83 分隔链表-使用两个dummy节点

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

##### 代码实现

```java
public ListNode partition(ListNode head, int x) {
        ListNode dummy1 = new ListNode(-1);
        ListNode prev1 = dummy1;
        ListNode dummy2 = new ListNode(x);
        ListNode prev2 = dummy2;

        ListNode current = head ;

        while (current != null){
            ListNode next = current.next;
            current.next = null;
            if (current.val < dummy2.val){
                prev1.next = current;
                prev1 = prev1.next;
            }else{
                prev2.next = current;
                prev2 = prev2.next;
            }
            current = next;
        }
        prev1.next = dummy2.next;
        return dummy1.next;
    }

```

##利用前缀和解决局部连续节点和相关问题

#### Leetcode 1171: 从链表中删除总和为零的连续节点

给你一个链表的头节点 `head`，请你编写代码，反复删去链表中由 **总和** 值为 `0` 的连续节点组成的**连续节点**，直到不存在这样的序列为止。

删除完毕后，请你返回最终结果链表的头节点。

 

你可以返回任何满足题目要求的答案。

（注意，下面示例中的所有序列，都是对 `ListNode` 对象序列化的表示。）

**示例 1：**

```
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
```

**示例 2：**

```
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
```

**示例 3：**

```
输入：head = [1,2,3,-3,-2]
输出：[1]
```

 

**提示：**

- 给你的链表中可能有 `1` 到 `1000` 个节点。
- 对于链表中的每个节点，节点的值：`-1000 <= node.val <= 1000`.

##### 题目分析-三种情况需要考虑

###### list[0....i] 总和为零

###### list[i] 节点为零

###### list[i...j] 总和为零

##### Dummy节点的使用套路

###### **dummy 节点的值是 0，方便前缀和初始化为 0**：

```
ListNode dummy = new ListNode(0);
dummy.next = head;
```

所以当我们第一轮从 dummy 开始时：

- 当前节点为 dummy，prefixSum = 0
- 然后继续往后加：prefixSum = 0 + head.val，依此类推

###### **如果某个从链表起点到某个节点的总和为 0，必须从 dummy 开始才能发现** 

例如：

```
[1, 2, -3, 3, 1]
      ↑   ↑
    和为0，从头开始删
```

如果不从 dummy 开始，你根本无法发现 `[1, 2, -3]` 这一段和为 0。

##### 局部连续节点和相关的问题就应该联想到前缀和套路

###### 前缀和map应该怎么定义？

- key 为前缀和
- Value 为前缀和**最后出现的节点**

###### 前缀和map应该怎么使用？

遍历链表中的节点,注意遍历的方式：

```java
for(ListNode curr = dummy; currently!= null; current = current.next){
  ....
}
```



- 对于每一个节点的current，计算其前缀和`prefixSum`
- 从`前缀和map`中查找当前前缀和的**最后出现节点`last`**, 如果存在的话,可能性有两种
  - Last 节点就是current节点，则继续继续遍历链表 `curr.next = curr.next`，也就是`curr.next = last.next`
  - Last 节点不是current节点，则跳过`list[curr+1, last]`: `curr.next = last.next`

- 总和上面两种情况的分析，无论哪一种情况，只要执行`curr.next = last.next` 即可

##### 实现原理-两次遍历

###### 第一次遍历，创建前缀和map

```java
    Map<Integer, ListNode> map = new HashMap<>();
    // 初始化前缀和
    int prefixSum = 0;
    // 计算所有的前缀和以及最后出现的节点
    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        map.put(prefixSum, curr);  // 存最后出现该前缀和的节点
    }
```

###### 第二次遍历，删除节点

注意观察删除的方式

重要的技巧，注意掌握。

```java
    // 第二次遍历前缀和
    prefixSum = 0;
    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        // 跳过list[curr.next...lastIndexOfPrefixSum] 
        ListNode last = map.get(prefixSum);
        curr.next = last.next;  // 跳过中间节点
    }
```

##### 实现代码

```Java
class Solution {
    // 尝试前最和来解决
    public ListNode removeZeroSumSublists(ListNode head) {
         ListNode dummy = new ListNode(0);
    dummy.next = head;
    //定义map最后在最后出现前缀和的节点map<sum, lastNode>
    Map<Integer, ListNode> map = new HashMap<>();
    // 初始化前缀和
    int prefixSum = 0;
    // 计算所有的前缀和以及最后出现的节点
    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        map.put(prefixSum, curr);  // 存最后出现该前缀和的节点
    }
    // 第二次遍历前缀和
    prefixSum = 0;
    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        // 跳过list[curr.next...lastIndexOfPrefixSum] 
        ListNode last = map.get(prefixSum);
        curr.next = last.next;  // 跳过中间节点
    }

    return dummy.next;
    }
}
```



## 查找链表的指定位置节点

###怎么找到链表中的第K个节点？

从1到k遍历节点

```java
ListNode current = head;
for (int i=1;i<k;i++){
  current = current.next;//i=1,current = list[2]....i=n-1, current=list[n] 
}
```

###怎么链表中的倒数第K个节点？

**倒数第k个节点就是正数第`length-k+1` 个节点**。

```java
ListNode current = head;
int mod = length % k;
for(int i=1;i<length-k+1;i++){
	current = current.next;
}

```

###怎么找到链表的最后一个节点？

```java
int length = 1;//length初始值为1，因为current初始值就是head
while (current.next != null){
  current = current.next;
  length++;
}
```

这样遍历结束以后

- `length`的值就是**链表的长度**
- `current`指针就指向**最后一个节点**

### 怎样计算链表的长度？

```java
    // 1. 计算链表长度
    int length = 1;
    ListNode tail = head;
    while (tail.next != null) {
        tail = tail.next;
        length++;
    }
```

###Leetcode 61 旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

##### 思路分析

- 计算链表长度
- 获得`k`和`length`之间的`mod=k%length`
- 找到新的尾节点：第`length-k`个节点
- 断开链接，重新链接头尾

##### 计算链表的长度

```java
    // 1. 计算链表长度
    int length = 1;
    ListNode tail = head;
    while (tail.next != null) {
        tail = tail.next;
        length++;
    }
```

#####获得`k`和`length`之间的`mod=k%length`

``` java
// 2. 计算有效的k
    k = k % length;
    if (k == 0) return head;
```

#####找到新的尾巴: 第 length - k 个节点

###### 套路-怎么找到链表中的第N个节点？

```java
ListNode current = head;
for (int i=1;i<n;i++){
  current = current.next;//i=1,current = list[2]....i=n-1, current=list[n] 
}
```

###### 套路-怎么链表中的倒数第N个节点？

倒数第N个节点就是正数第`length-n+1` 个节点。

```java
ListNode current = head;
int mod = length - n;
for(int i=1;i<length-n+1;i++){
	current = current.next;
}

```

###### 套路-怎么找到链表的最后一个节点？

```java
int length = 1;//length初始值为1，因为current初始值就是head
while (current.next != null){
  current = current.next;
  length++;
}
```

这样遍历结束以后

- `length`的值就是**链表的长度**
- `current`指针就指向**最后一个节点**

###### 新的尾巴是在哪里？

倒数前K个节点是需要转移到链表的头部的，因此倒数第K+1个节点就是新的链表的尾巴。

倒数第K+1个节点就是正数`length -(k+1)+1=length-k`个节点,所以我们使用下面的方法找到新的尾巴

```java
  ListNode newTail = head;
    for (int i = 1; i < length - k; i++) {
        newTail = newTail.next;
    }
```

#####  重新连接

找到了新的尾巴之后，我们需要：

- 保留新的尾巴的下一节点的指针，这个节点将会是**新的`head`：**`newHead = newTail.next`;
- 将新的尾巴的`next`置空
- 将旧的尾巴的`next`置为`head`

```java
ListNode newHead = newTail.next;
    newTail.next = null;
    tail.next = head;

    return newHead;
```

##### 实现代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k==0) return head;
        int length = 1;
        //计算链表的长度，找出链表的尾巴
        ListNode tail = head;
        while (tail.next !=null){
            tail = tail.next;
            length++;
        }
        //计算需要移动的节点数量，意味着需要移动最后mod个节点
        int mod = k % length;
        if (mod==0) return head;

        //找到新的尾节点， 第length - k个
        //倒数N个节点是length-N+1个，倒数第K+1个节点就是第length-k个节点
        ListNode newTail = head;
        for (int i=1;i<length-mod;i++) {
            newTail = newTail.next;
        }

        //找到新的头节点，就是新的尾节点的下一个节点
        ListNode newHead = newTail.next;

        //开始修改链表
        newTail.next=null;
        tail.next = head;        
        return newHead;

    }
}
```



##常见题型与应对套路模板速查手册

| 题型                  | LeetCode题目（≥5个）                                         | 应用套路                                    | 注意事项                                                     |
| :-------------------- | :----------------------------------------------------------- | :------------------------------------------ | :----------------------------------------------------------- |
| 遍历链表              | 206.反转链表、21.合并两个有序链表、876.链表的中间节点、234.回文链表、83.删除排序链表中的重复元素 | Dummy节点套路 / 遍历基础套路                | 判断 `curr != null`，小心空指针异常                          |
| 删除节点              | 237.删除链表节点、19.删除链表的倒数第N个节点、203.移除链表元素、82.删除排序链表中的重复元素 II、83.删除排序链表中的重复元素 | Dummy节点套路 / 快慢指针套路                | 删除头节点时需要Dummy节点保护，注意删除连续重复元素时节点移动 |
| 反转链表（整体/局部） | 206.反转链表、92.反转链表 II、25.K个一组翻转链表、61.旋转链表、24.两两交换链表中的节点 | 反转链表套路（迭代/递归） / 分段反转套路    | 反转时保护好链表连续性，局部反转时先界定边界再反转           |
| 合并链表（两个/K个）  | 21.合并两个有序链表、23.合并K个升序链表、2.两数相加、445.两数相加 II、1171.从链表中删去总和值为零的连续节点 | Dummy节点套路 / 多路归并套路（小顶堆/分治） | 注意链表合并过程指针移动顺序，K路合并可用堆或递归分治        |
| 找链表中点/倒数节点   | 876.链表的中间节点、19.删除链表的倒数第N个节点、143.重排链表、234.回文链表、328.奇偶链表 | 快慢指针套路                                | 快慢指针移动时注意终止条件，倒数节点需要快指针提前N步        |
| 判断有环/找环入口     | 141.环形链表、142.环形链表 II、160.相交链表、287.寻找重复数、876.链表的中间节点（思路类似） | 快慢指针套路 / 快慢指针截断套路             | 检查快指针和快指针.next是否为null避免空指针异常，找到环入口时要理解两次相遇的位置关系 |
| 排序链表              | 148.排序链表、21.合并两个有序链表、23.合并K个升序链表、147.对链表进行插入排序、86.分隔链表 | 归并排序套路 / 多路归并套路                 | 排序链表首选归并，不要用插排除非题目指定，分治时递归深度控制好 |
| 拷贝带随机指针链表    | 138.复制带随机指针的链表、1485.克隆带随机指针的图、133.克隆图、105.从前序与中序遍历构造二叉树（递归构建结构）、109.有序链表转换二叉搜索树 | 哈希辅助套路（空间换时间）                  | 两遍遍历：第一遍复制节点，第二遍复制random指针，注意null处理 |
| 拆分链表              | 725.分隔链表、328.奇偶链表、86.分隔链表、817.链表组件、2181.合并零之间的节点 | 双链表分隔套路 / 双Dummy指针套路            | 每条子链最后都要断开 `.next = null` 防止成环或串联错链       |
| 删除重复元素          | 83.删除排序链表中的重复元素、82.删除排序链表中的重复元素 II、203.移除链表元素、1836.删除重复元素使每个元素最多出现两次、1836.删除重复元素使每个元素最多出现一次 | Dummy节点套路 / 遍历基础套路                | 连续多个重复元素要全部跳过，区分是“保留一个”还是“全部删除”   |
| 分割链表（按值划分）  | 86.分隔链表、328.奇偶链表、725.分隔链表、2181.合并零之间的节点、430.扁平化多级双向链表 | 双Dummy指针套路                             | 小于给定值的节点放左边，大于等于放右边，最后连接时注意顺序   |
| 重排链表              | 143.重排链表、234.回文链表、92.反转链表 II、25.K个一组翻转链表、445.两数相加 II | 快慢指针套路 / 反转链表套路                 | 找中点后反转后半部分再交替合并，注意链表终止条件处理         |

##原则与实践

**套路是可以叠加使用的**。
 比如，**重排链表143**：

- 先用快慢指针找中点 → 反转后半段 → Dummy节点连接。

**Dummy节点套路几乎无处不在**。
 涉及**头节点可能变化**的地方几乎都用Dummy节点保驾护航。

**快慢指针主要应对"找位置"相关问题**。
 包括找中点、倒数节点、环检测、环入口等等。

**小顶堆（优先队列）主要应对"多路有序合并"问题**。
 合并K个链表必备。

**链表排序必用归并，绝不用快排**。
 因为链表访问随机节点代价太高，归并才是最优。

> 面对链表题，思考顺序是：
>  **要找节点？ → 快慢指针**
>  **要改结构？ → Dummy节点保护**
>  **要反转？ → 反转套路（迭代/递归/头插）**
>  **要分类？ → 双链表套路**
>  **要合并？ → 小顶堆 / 递归合并**
>  **要排序？ → 归并排序套路**

# 常见题型和应对方法

| 场景分类       | 具体目标                           | 典型题目类型       |
| -------------- | ---------------------------------- | ------------------ |
| 单链表遍历     | 统计节点、查找值、反转遍历等       | 206、876、21       |
| 指针变换       | 反转局部/整体、快慢指针查找中点    | 206、92、876       |
| 删除或添加节点 | 删除重复、删除特定节点、插入排序等 | 83、82、19、147    |
| 合并/分割链表  | 合并两个或K个、分割成K段           | 21、23、725        |
| 链表重构       | 排序、复制、回文判断、重排         | 148、138、234、143 |
| 检测结构       | 环检测、相交节点、环入口           | 141、142、160      |
| 双指针变换     | 快慢指针、对撞指针                 | 19、141、160、234  |

## 结构修改类

### 链表反转 (整体/局部)

#### 场景和目标

给定一个标准的单向链表， 将链表**全部**（如 LC 206）或**局部**（如 LC 92, 25）节点的指针方向进行反转。

#### 题型本质和分析

这是对链表最基本也是最重要的“写”操作，纯粹考验对指针操作的精确控制能力。核心在于修改一个节点的 `next` 指针时，如何保证对后续节点的引用不丢失。

#### 核心套路 - 三指针/头插法/递归反转

**三指针移动**：这是迭代法反转链表的核心，通过 `当前(current)、前驱(prev)、后继(next)` 三个指针的协同移动来完成反转。

**头插法构建链表套路**：这是一种实现原地反转的技巧，在遍历时不断将当前节点插入到虚拟头节点 `dummy` 之后。

**递归反转**：利用递归栈来处理反转，逻辑上是将问题分解为“反转头节点之后的部分”和“处理头节点”两个子问题。

迭代法（三指针/头插法）空间复杂度为 O(1)，是性能最优、最通用的方法。

#### 原理和步骤

1. 定义 `prev` 指针，初始化为 `null`，它将成为反转后链表的新头。

2. 定义 `current` 指针，初始化为 `head`。

3. 循环遍历链表，当 `current` 不为 `null` 时： a.  用 `nextTemp` 指针保存 `current.next`，防止链表断裂。 b.  执行核心反转：`current.next = prev`。 c.  将 `prev` 和 `current` 指针后移：`prev = current;`，`current = nextTemp;`。

3. 循环结束后，返回 `prev`。

#### 代码实现

```java
public ListNode reverseList(ListNode head){
  ListNode cur = head;
  ListNode prev = null;
  
  while(cur != null){
    ListNode nextTemp = cur.next;//临时保存后继节点
    cur.next = prev;//核心，反转操作
    prev = cur;//prev指针后移动
    cur = nextTemp;//cur指针后移
  }
  
  return prev;//返回新的头节点
}
```

#### 注意事项

- 指针更新的顺序至关重要，必须先保存 `current.next`。

- 对于局部反转（LC 92, 25），关键在于反转前先**定位并断开**反转区间，反转后**重新连接**前后部分。

#### 经验总结

- 整体反转是基础
  - **局部反转**是在整体反转的基础上增加了“定位”和“重连”的步骤
  - **分组反转**（LC 25）则是将“定位”和“局部反转”的操作置于一个循环中

#### Leetcode 92 : 反转链表中的特定区间

#####问题要点

- **输入**: 一个单链表的头节点 `head`，以及两个整数 `left` 和 `right`。
- **任务**: 将链表中从第 `left` 个节点到第 `right` 个节点的部分进行反转。
- **约束**:
  - 链表节点数量在 `[1, 500]` 之间。
  - `1 <= left <= right <= n` (n 是链表节点总数)。
  - 节点的值在 `[-500, 500]` 之间。
- **输出**: 修改后链表的头节点。

##### 问题本质和分析

这个问题的本质是在一个链表中**截取一个子链表**，**将其反转**，然后**再接回原链表**中。

这比单纯地反转整个链表（LeetCode 206）要复杂，因为涉及到三个部分的连接：

1. **第一部分**: 从 `head` 到 `left-1` 位置的节点。
2. **第二部分**: 从 `left` 到 `right` 位置的节点（这是需要反转的部分）。
3. **第三部分**: 从 `right+1` 到链表末尾的节点。

我们的核心任务就是，在反转第二部分之后，确保第一部分的尾部正确地指向第二部分反转后的头部，并且第二部分反转后的尾部正确地指向第三部分的头部。

为了实现这个目标，我们需要精确地定位四个关键节点/位置：

- **`pre_left`**: 第 `left-1` 个节点，即反转部分的前驱节点。
- **`left_node`**: 第 `left` 个节点，它将成为反转后的子链表的尾部。
- **`right_node`**: 第 `right` 个节点，它将成为反转后的子链表的头部。
- **`post_right`**: 第 `right+1` 个节点，即反转部分的后继节点。

整个操作的流程可以想象成： `... -> pre_left -> [left_node -> ... -> right_node] -> post_right -> ...` 反转后变成： `... -> pre_left -> [right_node -> ... -> left_node] -> post_right -> ...`

##### 背景知识

- **单链表 (Singly Linked List)**: 这是最基础的数据结构知识。你需要理解节点（Node）的概念，它包含一个值（value）和一个指向下一个节点的指针（next）。
- **指针/引用操作**: 链表问题的核心就是操作指针（在 Java 中是引用）。你需要非常清楚地知道，改变一个节点的 `next` 引用会如何影响整个链表的结构。
- **链表反转 (Iterative Method)**: 这是解决本题的核心子问题。你应该熟练掌握如何通过迭代（通常使用 `prev`, `curr`, `next` 三个指针）来反转一个完整的链表。

##### 考察点和关键挑战

###### 当left = 1的情况

当 `left = 1` 时，意味着反转的部分包含了头节点。这会导致整个链表的头节点发生改变。

###### left = right的情况

当 `left = right` 时，不需要反转。

###### right是最后一个节点的情况

当反转部分是链表的最后一部分时（`right` 是最后一个节点）。

##### 模式匹配

###### 哨兵节点模式 - Dummy

这是解决链表问题，特别是那些可能改变头节点的问题的经典模式。

通过创建一个指向 `head` 的虚拟头节点（Dummy Node），可以极大地简化边界情况的处理。

例如，当 `left = 1` 时，我们就不需要写额外的 `if` 语句来特殊处理了，因为 `pre_left` 节点在这种情况下就是我们的 Dummy Node。

###### 子问题分解能力

整个问题可以分解为 "找到反转起点" -> "反转指定长度的子链表" -> "重新连接"。

这体现了将复杂问题分解为简单子问题的思想。

##### 核心思想和套路 - 头插法

###### 核心思想 - 头插法

最优雅、最高效的套路是 **“头插法”**。

这个思想非常巧妙，我们不需要先把子链表断开，反转后再接回去，而是在遍历过程中，**动态地将要反转的节点一个个地移动到反转区域的头部**。

我们来定义几个关键指针：

- `dummy`: 哨兵节点，`dummy.next = head`。
- `pre`: 永远指向待反转区域的前一个节点（即 `pre_left`）。
- `curr`: 指向待反转区域的第一个节点（即 `left_node`），这个节点在反转过程中位置不变，最终会成为反转后的尾部。

###### 套路步骤 - 非典型的头插法

- 创建一个 `dummy` 节点，并连接到 `head`。

- 找到 `pre` 节点，即第 `left-1` 个节点。让 `pre` 指针走 `left-1` 步。

- 此时 `pre.next` 就是 `curr` 节点（第 `left` 个节点）。

- 开始循环，一共执行 `right - left` 次。在每次循环中：

  - 定义一个 `next_node` 指向 `curr.next`，这是我们要移动到头部的节点。

  - `curr` 断开与 `next_node` 的连接，指向 `next_node` 的下一个节点：`curr.next = next_node.next`。

  - 将 `next_node` 插入到 `pre` 之后：`next_node.next = pre.next`。

  - `pre` 连接到 `next_node`：`pre.next = next_node`。

- 返回 `dummy.next`。

注意在循环过程中，我们是不断的将**`curr`后面的节点**插入到`prev`节点之后， **实际上没有curr节点本身被插入到prev之后这个过程**。

因为curr节点一开始本身就是prev节点的next节点，如果curr节点也参与头插法过程，会导**环的出现**。

我们使用一个形象的比喻来解释这个过程：

假设有一队人 `A-B-C-D-E`，我们要让 `B, C, D` 这个子队伍反转。

- `A` 是 `pre` 节点，是固定不动的“参照物”。
- `B` 是 `curr` 节点，它很特殊，在整个过程中它自己不移动，但最终会跑到反转队伍的末尾。

假设有一队人 `A-B-C-D-E`，我们要让 `B, C, D` 这个子队伍反转。

- `A` 是 `pre` 节点，是固定不动的“参照物”。
- `B` 是 `curr` 节点，它很特殊，在整个过程中它自己不移动，但最终会跑到反转队伍的末尾。

1. **初始状态**: `A -> B -> C -> D -> E`
   - `pre` 指向 `A`，`curr` 指向 `B`。
   - `pre.next` 是 `B`（当前反转区域的头）。
2. **第一步：把 `C` 插入到“头”**
   - 把 `C` 从队伍里叫出来。队伍变成 `A -> B -> D -> E`。
   - 把 `C` 插入到 `A` 的后面。
   - **结果**: `A -> C -> B -> D -> E`
   - 现在 `pre.next` 是 `C`（新的反转区域的头）。
3. **第二步：把 `D` 插入到“头”**
   - 把 `D` 从队伍里叫出来。队伍变成 `A -> C -> B -> E`。
   - 把 `D` 插入到 `A` 的后面。
   - **结果**: `A -> D -> C -> B -> E`
   - 现在 `pre.next` 是 `D`（新的反转区域的头）。

循环结束，`B-C-D` 成功反转成了 `D-C-B`，并且完美地衔接在 `A` 和 `E` 之间。

**举例说明 `right - left` 次循环中的一步**：

 假设链表是 `1 -> 2 -> 3 -> 4 -> 5`，`left=2, right=4`。 

初始时： `dummy -> 1 -> 2 -> 3 -> 4 -> 5` `pre` 指向 `1`，`curr` 指向 `2`。

 状态: `pre(1) -> curr(2) -> 3 -> 4 -> 5`

##### 实现原理和步骤

###### 处理Edge Case: Left == Right

如果 `left == right`，无需反转，直接返回 `head`。

###### 创建哨兵节点

**创建哨兵节点**: `ListNode dummy = new ListNode(-1); dummy.next = head;`

###### 第一次循环：定位Prev节点和curr节点 - 窗口之前的一个节点

创建一个指针 `pre = dummy`，然后循环 `left - 1` 次，让 `pre` 移动到反转区域的前一个节点。

同时`curr`节点就是：`ListNode curr = pre.next;`

###### 第二次循环： 反转链表区间 - 非典型头插法

使用一个 `for` 循环，从 `0` 到 `right - left - 1`，执行 "头插法" 操作。

- `ListNode next = curr.next;` // 待移动的节点
- `curr.next = next.next;`     // curr 连接到 next 的后面
- `next.next = pre.next;`      // next 插入到 pre 后面
- `pre.next = next;`           // pre 连接到 next

###### 返回结果

返回 `dummy.next`。

##### 实现代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = dummy;
        for(int i = 0; i < left; i++){
            prev = curr;
            curr = curr.next;
        }
        //注意应该从curr的next节点开始做头插法
        for(int j = 0; j < right - left; j++){
           ListNode nodeToMove = curr.next;
            // `curr` 跳过 `nodeToMove`，连接到它的下一个节点
            curr.next = nodeToMove.next;
            
            // 将 `nodeToMove` 插入到 `pre` 的后面，完成一次“头插”
            nodeToMove.next = prev.next;
            prev.next = nodeToMove;
        }
        return dummy.next;
    }
}
```

##### 注意事项

**1-based vs 0-based 索引**: 题目给的是 1-based 索引（第 `left` 个），而编程中循环通常是 0-based。在定位 `pre` 节点时要小心，`for (int i = 0; i < left - 1; i++)` 正是移动 `left-1` 步。

**指针的备份**: 在移动指针前，确保你已经保存了所有必要的引用，否则可能会“丢失”链表的一部分。在上面的代码中，`nextToMove` 就是一个临时备份。

**循环次数**: 头插法循环的次数是 `right - left` 次，而不是 `right - left + 1`。这是一个很容易出错的点。可以这样理解：总共有 `right - left + 1` 个节点需要反转，第一个节点 `curr` 不动（作为锚点），我们只需要把它后面的 `right - left` 个节点依次移动到最前面即可。

**理解 `pre` 和 `curr` 的角色**: `pre` 是固定的，作为插入点头部的前一个节点。`curr` 也是固定的，作为反转区域的尾部节点（它的 `next` 指针在变化，但 `curr` 本身这个引用不变）。

##### 经验总结

**画图是王道**: 对于任何复杂的链表问题，在纸上画出节点和指针的变化过程是理解和验证算法正确性的最有效方法。一步一步地画出 `pre`, `curr`, `nextToMove` 在每次循环后的位置和指向。

**拥抱哨兵节点**: 只要链表操作可能涉及到头节点，就毫不犹豫地使用哨兵节点。它能统一逻辑，避免为 `head` 编写特殊处理代码，让代码更简洁、更健壮。

**掌握核心套路**: “头插法”反转子链表是一个非常精妙和高效的技巧，值得花时间去理解和记忆。它避免了断开和重新连接的复杂性，在一次遍历中就完成了所有操作。一旦掌握，解决类似问题会得心应手。



### 节点删除

#### 场景和目标

给定一个链表，其中部分节点满足特定条件。

将这些满足条件的节点从链表中移除，例如删除指定值的节点（LC 203）、删除重复元素（LC 83, 82）、或删除特定位置的节点（LC 19）。

#### 题型本质和分析

核心在于**安全地修改指针连接**。

通过 `prev.next = current.next` 来“跳过”要删除的 `current` 节点。

难点在于处理各种边界情况，特别是：

- 当被删除的节点是头节点。
- 或者需要删除连续多个节点时。

#### 核心思想与套路： Dummy + 双指针

使用 `prev` 和 `current` 指针进行遍历，`prev` 始终指向 `current` 的前一个节点，以便执行删除操作。

**`dummy` 节点极大简化了边界处理。双指针遍历是执行“跳过”操作的标准模式**。

#### 原理和步骤

1. 初始化一个 `dummy` 节点，使其 `next` 指向 `head`。
2. 初始化 `prev = dummy` 和 `current = head`。
3. 循环遍历链表 (`while (current != null)`)。
4. 在循环中，判断 `current`节点是否需要被删除。
   - **如果需要删除**：执行 `prev.next = current.next;`。此时 `prev` 指针**不移动**，因为下一个 `current` 节点还需要和 `prev` 比较。
   - **如果不需要删除**：`prev` 指针正常后移，`prev = current;`。
5. `current` 指针在每次循环后都正常后移 `current = current.next;`。
6. 返回 `dummy.next`。

#### 代码套路模板

```java
// 题型核心模板：删除所有值为 val 的节点 (LC 203)
public ListNode removeElements(ListNode head, int val) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;

    ListNode prev = dummy;
    ListNode current = head;

    while (current != null) {
        if (current.val == val) {
            // 删除 current 节点，prev 不动
            prev.next = current.next;
        } else {
            // prev 后移
            prev = current;
        }
        // current 后移
        current = current.next;
    }
    return dummy.next;
}
```

#### 注意事项

- 处理连续多个重复节点时（LC 82），需要一个内循环来跳过所有重复项。

- `prev` 指针是否移动，是删除逻辑中最关键、最容易出错的部分。

#### 经验总结

- 遇到任何删除节点的题目，先写下 `dummy` 节点基本不会错。删除操作的核心就是**通过前驱节点`prev`来操作**。

#### Leetcode 82: 删除链表中的重复元素

##### 删除单个节点 prev.next = curr.next

##### 删除链表中的区间 

###### 记录区间之前的节点prev(left - 1)节点

###### 记录区间的最后一个节点last

###### 删除区间prev.next = last.next

##### 实现代码

```Java
 //链表已经排序
 //删除具有重复值的节点
 //返回的链表也必须是有序的
 //考虑怎么删除节点？直接跳过即可
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = head;
        while(curr != null){
           ListNode next = curr.next;
           //如果发现next的val和curr的val一样
           if(next != null && next.val == curr.val){
            //尝试找出最后一个根curr val相同的节点
            ListNode last = next;
            while(last!= null && last.next != null &&last.next.val == curr.val){
                last = last.next;
            }
            //然后删除[curr...last]区间
            prev.next = last.next;
            curr = prev.next;
           }else{
            //如果curr和next不同，则继续执行
            prev = curr;
            curr = next;
           }
        }

        return dummy.next;
        
    }
}
```

#### Leetcode 83: 删除链表中的重复节点

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
       ListNode dummy = new ListNode(-1); // dummy节点，值设什么无所谓，不参与比较
    dummy.next = head;
    ListNode prev = dummy;
    ListNode current = head;
    
    while (current != null) {
        if (prev != dummy && current.val == prev.val) {
            // 如果当前节点和上一个节点的值相同，跳过当前节点
            prev.next = current.next;
            current = current.next;
        } else {
            // 如果不同，prev和current都往后移动
            prev = current;
            current = current.next;
        }
    }
    
    return dummy.next;
        
    }
}
```

#### 移除无序链表中的重复元素

链表**未排序**，移除重复项，保留第一个出现的节点。

##### 核心思想：如何判断是否已经出现过？

这个问题的核心在于如何在遍历链表时，判断一个节点的值是否在它*之前*已经出现过。

根据是否允许使用额外空间（"临时缓冲区"），我们有两种截然不同的解决方案。

###### 方案一：允许使用临时缓冲区（哈希表）

使用一个哈希集合（`set`）作为临时缓冲区，来存储所有已经遇到过的节点值。

具体的实现步骤一下

1. 初始化一个空的哈希集合 `seen` 和一个 `previous` 指针（初始为 `None`）。
2. 从头节点 `head` 开始遍历链表（`current` 指针）。
3. **检查 `current.val`**：
   - **如果 `current.val` 存在于 `seen` 集合中**: 这意味着它是一个重复节点。我们通过 `previous.next = current.next` 来将它从链表中“剪除”。
   - **如果 `current.val` 不在 `seen` 集合中**: 这是该值第一次出现。我们将 `current.val` 添加到 `seen` 集合中，并将 `previous` 指针更新为 `current`。
4. `current` 指针继续前进到 `current.next`。
5. 重复此过程，直到 `current` 为 `None`。

- **复杂度**:
  - **时间复杂度**: O(N)。N 是链表的长度。我们只需要遍历链表一次，哈希表的插入和查找操作的平均时间复杂度是 O(1)。
  - **空间复杂度**: O(N)。在最坏的情况下（所有节点值都不同），我们需要将所有 N 个值都存入哈希表中。

###### 方案二：不允许使用临时缓冲区 - 追赶者技术

如果不允许使用额外的空间（空间复杂度要求 O(1)），我们就不能使用哈希表。

我们采用一种类似于**选择排序**的双重循环（或称为 "Runner" / "追赶者" 技术）。

实现步骤如下：

1. 使用一个 "外层" 指针 `current` 遍历整个链表。`current` 指针代表我们当前正在检查的基准值。
2. 对于每一个 `current` 节点，使用一个 "内层" 指针 `runner`。`runner` 从 `current` 开始，向后遍历链表的剩余部分。
3. `runner` 的任务是检查它*之后*（`runner.next`）的所有节点，看是否有节点的值与 `current.val` 相等。
4. **检查 `runner.next.val`**：
   - **如果 `runner.next.val == current.val`**: 这意味着 `runner.next` 是一个重复节点。我们通过 `runner.next = runner.next.next` 将其“剪除”。
   - **如果 `runner.next.val != current.val`**: `runner` 指针正常前进到 `runner.next`。
5. 当 `runner` 遍历完 `current` 之后的所有节点，外层 `current` 指针前进到下一个节点，重复步骤 2-4。

- **复杂度**:
  - **时间复杂度**: O(N²)。外层循环 O(N)，内层循环平均 O(N)，总共是 O(N²)。
  - **空间复杂度**: O(1)。我们只使用了两个额外的指针（`current` 和 `runner`），没有使用随 N 增长的额外存储空间。



#### **LeetCode 1836. 从未排序链表中移除重复元素**

链表**未排序**，但它要求移除*所有*出现过多次的节点（即只要一个数字有重复，它就一个也不留）。

#### Leetcode 203 移除值为val的元素

需要注意的点：

- 当前节点的值若是val， 跳过当前元素`prev.next = curr.next`，但是**prev不需要移动**
- 当前节点的值若不是val，则前移prev指针

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        ListNode curr = head;
        while(curr != null){
            ListNode next = curr.next;
            if(curr.val == val){
                prev.next = next;
                //prev不需要移动
            }else{
                prev.next = curr;
                prev = curr;
                //prev 前移
            }
            curr = next;
        }
        return dummy.next;
    }
}
```

#### 删除链表中间的某个节点

Implement an algorithm to delete a node in the middle (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list, given only access to that node.

EXAMPLE

lnput:the node c from the linked lista->b->c->d->e->f Result: nothing is returned, but the new linked list looks likea->b->d->e->f

##### 核心思想：替换并删除下一个节点

这是一个非常经典的链表"脑筋急转弯"问题！

这个问题的关键在于，我们**无法访问**要删除节点（`c`）的*前一个*节点（`b`）。

在常规的删除操作中，我们需要修改 `b.next` 使其指向 `d`。但在这里我们做不到。

###### 用下一个节点的内容覆盖当前节点

既然我们无法真正删除节点 `c`，我们的核心思想是：**用下一个节点（`d`）的内容覆盖当前节点（`c`），然后删除下一个节点（`d`）。**

###### 删除下一个节点

然后删除下一个节点（`d`）。

##### 实现代码

```Python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_middle_node(node_to_delete: ListNode):
    """
    删除一个单向链表中的某个节点（非第一个，也非最后一个），
    前提是只给你这个节点的访问权限。

    这个函数不返回任何东西，它会就地修改链表。
    """
    
    # 1. 检查输入是否有效。
    # 这个问题的前提是 `node_to_delete` 既不是头节点也不是尾节点。
    # 这就保证了 `node_to_delete` 不会是 None，
    # 并且 `node_to_delete.next` 也不会是 None。
    if not node_to_delete or not node_to_delete.next:
        # 如果节点是最后一个节点或 None，这个算法是无效的。
        # 按照题目的约束，我们实际上不会进入这个分支。
        return

    # 2. 获取下一个节点
    next_node = node_to_delete.next
    
    # 3. 将下一个节点(d)的数据“复制”到当前节点(c)
    # 这使得当前节点(c)在逻辑上变成了节点(d)
    node_to_delete.val = next_node.val
    
    # 4. “删除”下一个节点(d)
    # 我们通过修改当前节点(c)的 'next' 指针，
    # 让它“跳过”原来的下一个节点(d)，直接指向(d)的下一个节点(e)
    node_to_delete.next = next_node.next
    
    # 此时，原来的节点d已经被从链表中移除，
    # 并且节点c的内容也已经被更新为d的内容。
    # 链表的状态从 a->b->c->d->e->f 变成了 a->b->d(c)->e->f
    # (d(c) 指的是：这是原来的 c 节点，但它现在存着 d 的值)
```



### 链表合并

#### 场景和目标

给定两个或多个已按升序排列的链表。

将它们合并成一个单一的、全局有序的新链表（如 LC 21, 23）。

#### 题型的本质和分析

这是经典“归并排序”算法中“合并(merge)”步骤的链表实现。它考察的是如何高效地在多个有序序列间进行比较和选择，构建一个全局有序的新序列。

#### 核心思想和套路： Dummy + 双指针/小顶堆

##### 合并两个有序链表 - 双指针分别指向不同的链表

在合并两个链表时，用两个指针分别指向两个链表的当前节点进行比较。

##### 多路归并 - 小顶堆方法

- **多路归并套路（小顶堆）**：这是合并 K 个链表的最高效方法。

`dummy` 节点统一了新链表的构建过程。双指针法能以 O(1) 额外空间完成两个有序链表的合并。小顶堆能以 O(logK) 的代价快速找到 K 个链表头中的最小值。

**虚拟头节点 dummy**：用于轻松构建新链表，无需关心哪个节点会成为新链表的头。

#### 原理和步骤 - 合并两个有序链表

创建一个 `dummy` 节点和 `current` 指针，`current` 用于构建新链表。

用指针 `p1`, `p2` 分别指向 `list1`, `list2`。

循环比较 `p1.val` 和 `p2.val`，将较小的节点连接到 `current.next`，然后移动对应的指针 (`p1` 或 `p2`) 和 `current` 指针。

当一个链表遍历完后，将另一个链表剩余的部分直接连接到 `current.next`。

返回 `dummy.next`。

#### 实现代码

```java
// 题型核心模板：合并两个有序链表 (LC 21)
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode dummy = new ListNode(-1);
    ListNode current = dummy;

    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }

    // 连接剩余的链表部分
    current.next = (list1 != null) ? list1 : list2;

    return dummy.next;
}
```

#### 注意事项

- 合并操作后，不要忘记一次性连接剩余的、非空的链表部分。
- 合并 K 个链表时（LC 23），使用优先队列（最小堆）是比反复调用两两合并更优的解法。

#### 经验总结

两链表合并是基础，是解决 K 链表合并和链表排序问题的原子操作。

### 链表分割和重排 - 多个dummy临时链表

#### 场景和目标

场景：给定一个单链表。

目标： 根据特定规则对链表进行重新组织：

- 按某个基准值 `x` 将链表分割为两部分（LC 86）
- 将链表按奇偶位次序重排（LC 328）
- 或将链表按 `L0→Ln→L1→Ln-1→…` 的模式重排（LC 143）。

#### 核心套路

- 对于**分割问题**，创建两条独立的子链表再合并，可以极大地简化指针操作，避免在原链表上进行复杂的原地修改。
- 对于**重排问题**，其解法往往是“找中点 + 反转后半段 + 合并两段”的三部曲，是多个基础套路的组合应用。

##### 链表分割： 两个Dummy指针

这是处理分割问题的最核心、最清晰的策略。

##### 按照间隔顺序重派：快慢指针

在重排问题（如 LC 143）中，用于先将链表从中间一分为二。或将链表按 `L0→Ln→L1→Ln-1→…` 的模式重排（LC 143）。

##### 反转链表

同样在重排问题中，找到中点后，通常需要将后半部分链表反转，以便于从“尾部”取节点。

#### 原理和步骤 - 分割链表

应用**双Dummy指针**套路，创建两个虚拟头节点 `dummySmall` 和 `dummyLarge`，以及它们各自的尾指针 `pSmall` 和 `pLarge`。

遍历原链表，对于每个 `current` 节点： a.  如果 `current.val < x`，则将其连接到 `pSmall` 之后，并后移 `pSmall`。 b.  否则，将其连接到 `pLarge` 之后，并后移 `pLarge`。

遍历结束后，将 `pLarge` 的 `next` 指针置为 `null`，这是为了断开原链表的连接，防止产生环。

将小于 `x` 的链表和大于等于 `x` 的链表连接起来：`pSmall.next = dummyLarge.next`。

返回 `dummySmall.next`。

#### 代码套路模板

```java
// 题型核心模板：按值 x 分割链表 (LC 86)
public ListNode partition(ListNode head, int x) {
    // 小于x的分区
    ListNode dummySmall = new ListNode(-1);
    ListNode pSmall = dummySmall;
    // 大于等于x的分区
    ListNode dummyLarge = new ListNode(-1);
    ListNode pLarge = dummyLarge;

    ListNode current = head;
    while (current != null) {
        if (current.val < x) {
            pSmall.next = current;
            pSmall = pSmall.next;
        } else {
            pLarge.next = current;
            pLarge = pLarge.next;
        }
        current = current.next;
    }
    // 关键步骤：断开大链表的尾部，并连接两个分区
    pLarge.next = null;
    pSmall.next = dummyLarge.next;

    return dummySmall.next;
}
```

#### 注意事项

使用双 Dummy 指针分割链表后，一定要将第二个分区的尾指针的 `next` 置为 `null`，这是一个非常容易忽略的细节，可能导致链表成环。

#### 经验总结

面对需要将节点“分类”的问题，立刻想到**双Dummy指针**策略。它将复杂的原地修改问题，转化为两个简单的“尾部添加”问题，思路清晰，不易出错。

###链表排序

#### 场景和目标

给定一个无序的单链表。

将其按节点值的升序进行排列，并返回排序后链表的头节点（如 LC 148, 147）。

#### 问题本质和分析

将一种高效的排序算法（如归并排序、插入排序）应用于链表这种不支持随机访问的数据结构上。

核心挑战在于，**所有操作都必须通过指针移动来完成**。

#### 核心套路 - 快慢指针 + 归并排序

- **链表合并排序套路（归并排序链表）**：这是链表排序问题的最优解和标准解法。

- **快慢指针**：在归并排序中，用于找到链表中点，以实现“分治”中的“分”操作。

#### 原理和步骤 - 归并排序

1. **递归终止条件**：如果链表为空或只有一个节点，则它已经有序，直接返回。
2. **“分”**：使用**快慢指针**找到链表中点，将链表从中间切断为两个独立的子链表。
3. **“治”**：对这两个子链表分别递归调用排序函数，使其各自有序。
4. **“合”**：调用“合并两个有序链表”（题型 1.3）的逻辑，将两个已排序的子链表合并成一个完整的有序链表。

#### 实现代码

```java
public LIstNode sortList(ListNode head){
  //Base condition
  if (head == null || head.next == null){
    return head;
  }
  
  //找到中点并且断开
  ListNode mid = findMiddleAndCut(head);
  
  //归并排序左右部分
  ListNode left = sortList(head);
  ListNode right = sortList(mid);
  
  //合并已经排序的两部分
  return mergeTwoList(left,right);
}
```

#### 注意事项

归并排序的时间复杂度为 **O(N log N)**，空间复杂度为 O(log N)，用于递归调用栈。

在找到中点后，必须将前半段的尾节点指向 `null`，以彻底将两个子链表断开。

#### 经验总结

- 链表排序问题与归并排序算法是强绑定的。理解分治思想以及它如何通过快慢指针（分）和两两合并（合）在链表上实现是解决本题型的关键。

##检测和定位类

这类题目的核心在于“只读”，通过设计精巧的指针移动策略来探测链表的结构特性或找到满足特定位置要求的节点，而不修改链表结构。

###  环路检测与定位

#### 场景和目标

给定一个链表，它可能包含一个环。

判断环是否存在（LC 141），如果存在，则精确定位环的入口节点（LC 142）。

#### 题型的本质和分析

由于链表可能带环，常规的遍历可能会导致死循环。

此题考察的是如何在**不使用额外存储空间**的情况下，通过指针的移动规律来判断和定位环。

#### 核心套路 - 快慢指针

**快慢指针**：这是 Floyd 判圈算法的核心，是解决链表环问题的标准、最优算法：

快慢指针如同操场上快慢跑者赛跑，如果赛道是环形的，快者终将从后面追上慢者。它用 O(1) 的空间复杂度解决了问题。

**HashSet / Map**：作为备用方案，可以用哈希集合记录访问过的节点来判环，但空间复杂度为 O(N)。

#### 实现原理

##### 判断链表是否有环

- 初始化快指针和慢指针均指向`head`
- 循环中`slow`每次走一步，`fast`每次走两步
- 如果`fast == null`, 说明没有环
- 如果`slow == fast`， 说明存在环

##### 寻找环的入口

在两个指针相遇以后，将一个新指针`ptr`指向`head`。

然后`ptr`与`slow`和`fast`同步前进，每次都**走一步**。

它们再次相遇的点，就是入口。

#### 代码实现

```java
public ListNode detectCycle(ListNode head){
  ListNode slow = head;
  ListNode fast = head;
  
  while(fast != null && fast.next != null){
    slow = slow.next;
    fast = fast.next.next;
    //如果相遇说明遇到了环，则寻找环的入口
    if (slow == fast){
      ListNode ptr = head;
      while(ptr != slow){
        ptr = ptr.next;
        slow = slow.next;
      }
      return ptr;
    }
    
  }
  return null;
}
```

#### 注意事项

- 快指针移动两步前，必须检查 `fast` 和 `fast.next` 都不能为 `null`。
- 理解寻找环入口的第二阶段的**数学原理（`a = (k-1)(b+c) + c`）**是彻底掌握此题的关键。

#### 经验总结

Floyd 判环算法是一个非常精妙的算法，值得花时间理解其数学原理。一旦掌握，所有链表环问题都可以迎刃而解。

### 回文结构判断

#### 场景和目标

给定一个单链表。

判断这个链表的节点值序列是否构成回文（如 LC 234）。

#### 题型的本质和分析

回文的本质是**正序和逆序相同**。

问题在于链表只能**正序遍历**。

因此，本题的核心限制是如何在单向遍历的限制下，实现你序比较。

#### 应该使用什么套路？ 快慢指针/反转链表/栈辅助

##### 通过快慢指针找到中点

用于找到链表的后半部分的起点（即中点）

##### 反转链表的后半部分

这是最优解的核心，将链表的后半部分进行原地反转

##### 栈辅助

一种更耗费空间但是思路简单的方法。将链表所有节点入栈，再遍历一遍链表，同时从栈中弹出元素进行比较。

#### 原理和步骤 - 基于快慢指针

1. 使用快慢指针找到链表的中点
2. 将链表的后半部分进行反转
3. 用两个指针分别从原链表的头部和反转后的后半部分的头部开始同步前进，逐一比较节点值。
4. 如果所有值都相同，则是回文

5. （可选），为了不破坏原来链表的结构，比较完成之后可以将后半部分再次反转，恢复原状

#### 实现代码模板套路

##### 利用快慢指针寻找链表的中点

###### 链表节点数量分别是偶数或者奇数的情况下，中点分别是哪一个？

- 当链表节点数量为奇数时，慢指针 `slow` 最终会停在正中间的那个节点上。
- 当链表节点数量为偶数时，标准的快慢指针算法最终会让 `slow` 指针停在两个中间节点的第二个上。

###### 调整中点的位置定位方式

**找中点**: 使用稍作修改的快慢指针 `while (fast.next != null && fast.next.next != null)`，这样可以让 `slow` 指针停在：

- 奇数链表的中心节点 (e.g., `1->2->3->2->1`, `slow` 在 `3`)
- 偶数链表的**第一个**中心节点 (e.g., `1->2->2->1`, `slow` 在第一个 `2`)

```java
public ListNode findMiddle(ListNode head){
  ListNode slow = head;
  ListNode fast = head;
  
  while(fast.next != null && fast.next.next != null){
    slow = slow.next;
    fast = fast.next.next;
  }
  
  return slow;
} 
```

##### 反转链表

```java
public ListNode reverseList(ListNode head){
  ListNode cur = head;
  ListNode prev = null;
  
  while(cur != null){
    ListNode temp = cur.next;
    cur.next = prev;
    prev = cur;
    cur = temp;
  }
  
  return prev;
}
```

##### 执行回文串比较过程

- 找到中间点 
- 反转后半段链表, 我们找到的后半段链表是**中点之后的部分（不包括中点）**，因此我们值需要确定后**半段是前半段链表的前缀**即可

```java
public boolean isPalindrome(ListNode head){
  if(head == null) return true;
  //寻找终点
  ListNode firstHalfEnd = findMiddle(head);
  //反转后半部分链表（中点之后的部分，不包含中点，不管链表节点数量奇数或者偶数）
  ListNode secondHalfStart = reverseList(firstHalfEnd.next);
  
  boolean ans = true;
  ListNode p1 = head;
  ListNode p2 = secondHalfStart;
  //判断反转后的后半部分链表是否是前半部分的前缀
  while(ans && p2 != null){
    if(p1.val != p2.val){
      result = false;
    }
    
    p1 = p1.next;
    p2 = p2.next;
  }
  //恢复链表
  firstHalfEnd.next = reverseList(secondHalfStart);
  return ans;
}
```

#### 注意事项

- 找到中点后，需要将前半段和后半段断开（`firstHalfEnd.next = null;`），但这在上述代码中通过反转函数隐式处理了。
- 在比较时，循环的终止条件要考虑周全。

#### 经验总结

这是一个组合题，体现了“一个复杂问题可以分解为多个简单问题的组合”的思想。它融合了快慢指针和链表反转两大核心技能。

### 链表相交判断

#### 场景和目标

- **场景**：给定两个可能在某点合并的单链表。
- **目标**：找到这两个链表的第一个公共交点节点，如果它们不相交，则返回 `null`（如 LC 160）。

#### 问题的本质和分析

如果两个链表相交，那么从交点开始，它们后续的所有节点都是共享的。

问题的挑战在于，两条链表在到达交点之前的长度可能不同，导致无法通过同步遍历直接找到交点。

#### 核心套路 - 双指针走两次

这是您的文档中提到的，也是解决此问题最巧妙、最高效的策略。

通过让两个指针走完自己的路再走对方的路，可以保证它们走过的总路程是完全相同的（`lenA + lenB`）。

这样就巧妙地消除了两条链表的长度差，如果存在交点，它们必定会在交点相遇。此方法空间复杂度为 O(1)。

###### 相交链表的重要定理结论

如果两个链表**相交**， 则使用两个指针**同步**进行如下操作：

- `pA`指针，从A链表开始遍历，结束之后再从B链表开始遍历
- `pB`指针，从B链表开始遍历，结束之后再从A链表开始

那么在这个过程中这两个指针一定会**在相交点相遇**

#### 原理和步骤

1. 创建两个指针，`pA` 指向 `headA`，`pB` 指向 `headB`。
2. 进入循环，同时移动 `pA` 和 `pB`。
3. 如果 `pA` 到达了链表 `A` 的末尾 (`pA == null`)，则将其重定向到链表 `B` 的头部 (`pA = headB`)。
4. 同理，如果 `pB` 到达了链表 `B` 的末尾，则将其重定向到链表 `A` 的头部 (`pB = headA`)。
5. 循环继续，直到 `pA == pB`。这个相遇点就是要找的交点。如果两个链表不相交，它们最终会同时变为 `null`，此时 `pA == pB` 同样成立，循环结束，返回 `null`。

#### 实现代码

```java
// 题型核心模板：相交链表 (LC 160)
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode pA = headA, pB = headB;
    while (pA != pB) {
        // pA 走一步，如果到头了就去 B 的路
        pA = (pA == null) ? headB : pA.next;
        // pB 走一步，如果到头了就去 A 的路
        pB = (pB == null) ? headA : pB.next;
    }
    return pA;
}
```

#### 注意事项

这个算法的精妙之处在于，无论链表是否相交，循环都一定会终止，并且能正确返回结果。

如果用哈希表来做，先把一条链表的所有节点存入 `HashSet`，再遍历另一条链表看节点是否存在于集合中，但空间复杂度为 O(N)。

#### 经验总结

此题是双指针技巧的极致体现。它告诉我们，有时通过构造一个“等长的路径”，可以解决因长度不等带来的不对齐问题。

### Leetcode 708:在循环有序链表中寻找插入位置（Airbnb）

这是一个非常经典的链表操作问题，它考察的是在一种特殊数据结构（循环有序链表）中进行插入操作的能力，核心在于对各种边界条件的周全考虑。

#### 问题要点

**循环链表 (Circular Linked List)**: 链表的最后一个节点的 `next` 指针指向第一个节点，而不是 `null`。

**有序 (Sorted)**: 链表中的节点值是按非递减顺序排列的。

但由于是循环的，这个“有序”存在一个**断点**：

例如 `3 -> 4 -> 5 -> 1 -> 2 -> (回到3)`。这个断点就是从最大值 `5` 到最小值 `1` 的地方。

**输入**:

- `head`: 循环链表中任意一个节点的引用。**注意：它不一定是最小值的节点**。
- `insertVal`: 需要插入的新整数值。

**输出**:

- 返回插入新节点后的链表的头节点（可以是原 `head`，也可以是新节点）。

**特殊情况**:

- 输入的链表可能为空 (`head == null`)。
- 链表中可能所有节点的值都相同。

#### 问题本质分析

问题的本质是在一个具有“循环有序”特性的链表中，准确找到插入新值的位置，从而维持其循环有序的特性。

分析这个问题，我们可以将插入位置分为三大类情况：

##### **普通情况**:

 `insertVal` 的值介于链表中某两个连续节点 `prev` 和 `curr` 的值之间。即 `prev.val <= insertVal <= curr.val`。

这是最直接、最容易想到的情况。

##### **边界情况 (断点处)**:

 `insertVal` 的值**大于链表中的最大值，或小于链表中的最小值**。

这种情况下，它应该被插入在链表的“断点”处，也就是 `prev.val > curr.val` 的地方（`prev` 是最大节点，`curr` 是最小节点）。

##### 特殊情况-所有节点值均相同

如果遍历完整个链表，都找不到上述两种情况的插入点，这说明链表中所有节点的值都是一样的。

例如 `3 -> 3 -> 3 -> (回到3)`。此时，`insertVal` 可以插入到任何位置，链表依然保持循环有序。

#### 模式匹配 - 双指针遍历

#####**算法模式**: **双指针遍历 (Two Pointers)**

使用 `prev` 和 `curr` 两个指针来遍历链表。

`prev` 指向当前节点，`curr` 指向下一个节点。

这样做的好处是，一旦找到插入位置，我们可以很方便地执行 `prev.next = newNode` 和 `newNode.next = curr` 的操作。

#####**循环处理： do-while循环**

 对于循环链表，不能用 `while (curr != null)`作为循环条件， 因为链表为循环链表。

通常采用 `do-while` 循环，并以“是否回到了起点”作为终止条件，例如 `do {...} while (curr != head)`。

这能确保即使链表只有一个节点，循环体也至少执行一次。

`while (condition)`：**先判斷，後執行**。

如果一開始條件就不滿足，循環體一次都不會執行。

`do { ... } while (condition)`：**先執行，後判斷**。

無論如何，循環體都至少會被執行一次。

因为current的初始值就是head。

#### 核心思想和套路 - 分类讨论 + 双指针遍历

#####**处理空链表**: 

这是最简单的边界情况。如果 `head` 为 `null`，创建一个新节点，让它的 `next` 指向自己，然后返回这个新节点。



#####**双指针遍历**:

- 初始化 `prev = head` 和 `curr = head.next`。
- 使用 `do-while` 循环遍历整个链表，直到 `prev` 再次回到 `head`。
- 在循环的每一步中，检查上述三种插入情况。



#####**循环内的判断逻辑**:

**寻找普通插入点**: 

检查 `prev.val <= insertVal && insertVal <= curr.val` 是否成立。如果成立，说明找到了位置，可以跳出循环。



**寻找断点插入点**: 

检查是否到达了断点，即 `prev.val > curr.val`。

如果到达了断点，再判断 `insertVal` 是否大于等于最大值 (`prev.val`) 或小于等于最小值 (`curr.val`)。

如果满足，说明找到了位置，可以跳出循环。



##### 处理全等值情况

如果 `do-while` 循环正常结束（即 `prev` 走了一圈回到了 `head`），说明没有在循环内触发任何 `break`。

这就意味着链表中**所有节点的值都相等**。

此时，新节点可以插入到**任何位置**。

我们的双指针遍历结束后，**`prev` 恰好是 `head` 的前一个节点**，`curr` 是 `head`，直接在它们之间插入即可。



#### 实现原理和步骤

1. 创建一个值为 `insertVal` 的新节点 `newNode`。
2. **处理空链表**:
   - 如果 `head` 是 `null`，则 `newNode.next = newNode`，返回 `newNode`。
3. **初始化双指针**:
   - `Node prev = head;`
   - `Node curr = head.next;`
4. **启动循环**:

- 使用 `do-while (prev != head)` 循环。
- 这个条件保证了对于单节点链表，循环体执行一次后即退出；对于多节点链表，则会完整遍历一圈。

5. **在循环中判断插入条件**:

- **情况1 (普通)**: `if (prev.val <= insertVal && insertVal <= curr.val)`，则 `break`。
- **情况2 (断点)**: `if (prev.val > curr.val)` (说明 `prev` 是最大值, `curr` 是最小值)
  - `if (insertVal >= prev.val || insertVal <= curr.val)`，则 `break`。

6. **移动指针**:

- `prev = curr;`
- `curr = curr.next;`

7. **执行插入**: 循环结束后（无论是通过 `break` 还是正常结束），`prev` 和 `curr` 都指向了正确的插入位置。

- `prev.next = newNode;`
- newNode.next = curr;

8. **返回结果**: 返回原始的 `head` 节点。

#### 实现代码

```java
    //从Head开始寻找，找最后一个小于insertVal的节点
    //case 1: current < insert < next
    //case 2: next <= current < insert, 涉及到=的情况比较复杂
    public Node insert(Node head, int insertVal) {
        Node node = new Node(insertVal);    
        if (head == null) {
            node.next = node;
            return node;
        }

        Node prev = head;
        Node curr = head.next;

        do{
            if(prev.val <= insertVal && insertVal <= curr.val) {
                break;
                //断点的情况
            }else if(prev.val > curr.val){
                if(insertVal >= prev.val || insertVal <= curr.val){
                    break;
                }
            }

            prev = curr;
            curr = curr.next; 

        }while(curr != head);

        prev.next = node;
        node.next = curr;

        return head;
        
    }
```

#### 注意事项

1. **`do-while` 循环的使用**: 这是处理循环链表的关键技巧。它能确保代码块至少执行一次，完美处理了单节点链表的情况，避免了复杂的初始化判断。
2. **空链表处理**: 必须作为第一个特例来处理，否则后续的 `head.next` 会引发 `NullPointerException`。
3. **所有节点值相同**: 我们的代码天然地处理了这种情况。当所有节点值都相同时，`if` 和 `else if` 条件永远不会为 `true`。循环会完整地跑一圈然后结束。此时 `prev` 是 `head` 的前一个节点，`curr` 是 `head`。将 `newNode` 插入它们之间是完全正确的。
4. **返回值的选择**: 题目要求返回任意一个节点的引用。由于我们没有修改原始的 `head` 节点本身（除非链表为空），所以直接返回 `head` 是最简单和安全的选择。

#### 经验总结

- **画图是王道**: 对于任何链表问题，特别是带有复杂性的（如循环、双向、带随机指针等），在纸上画出指针的移动和不同情况下的链表状态，是理清思路、发现边界问题的最有效方法。
- **分解问题**: 将一个复杂问题分解成几个核心场景和几个边界场景。如此题分解为“普通插入”、“断点插入”、“全等值插入”和“空链表”四个场景，然后逐一攻破。
- **双指针是标准工具**: 在需要修改链表结构（插入、删除）时，`prev-curr` 双指针模式是首选，因为它保留了插入位置的前一个节点的引用，使得 `prev.next = ...` 操作成为可能。
- **代码的优雅性**: 善用 `do-while` 可以让循环链表的代码变得非常简洁，避免了在循环外写很多 `if-else` 来处理单节点等特殊情况。这体现了对语言结构和数据结构特性的深刻理解。

 資料來源

## 构造与复制类

### 链表设计问题

#### Leetcode 707: 设计链表

##### 问题要点

题目要求我们设计一个链表类 `MyLinkedList`，并实现以下几个核心方法：

- `MyLinkedList()`: 构造函数，初始化一个空链表。
- `int get(int index)`: 获取链表中第 `index` 个节点的值。如果索引无效，则返回 -1。
- `void addAtHead(int val)`: 在链表的头部插入一个值为 `val` 的新节点。
- `void addAtTail(int val)`: 在链表的尾部追加一个值为 `val` 的新节点。
- `void addAtIndex(int index, int val)`: 在链表的第 `index` 个节点之前插入一个值为 `val` 的新节点。
  - 如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。
  - 如果 `index` 大于链表长度，则不会插入节点。
  - 如果 `index` 小于 0，则在头部插入节点。
- `void deleteAtIndex(int index)`: 如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

你可以选择实现单向链表或双向链表。双向链表在某些操作上（如尾部插入和删除）会更高效，但实现起来也稍微复杂一些。

##### 问题本质和分析 

这道题的本质是**考察对链表这种基础数据结构的理解和手动实现能力**。

与数组不同，链表的元素在内存中不是连续存储的。每个元素（称为**节点 Node**）包含两部分：

1. **数据 (val)**: 节点存储的实际值。
2. **指针 (next)**: 指向下一个节点的引用（或内存地址）。

双向链表的节点还会多一个**前驱指针 (prev)**，指向上一个节点。

这种结构导致了链表操作的特点：

- **查询 (get)**: 无法像数组那样通过索引直接计算出内存地址进行 O(1) 访问。必须从头节点开始，顺着 `next` 指针逐个遍历，直到找到目标位置。时间复杂度为 O(k)，其中 k 是目标索引。
- **插入/删除 (add/delete)**: 这是链表的优势所在。一旦找到了要操作的位置，只需要修改相关节点的指针即可，不需要像数组那样移动大量元素。时间复杂度是 O(1)（前提是已经拿到了要操作的节点的前驱节点）。

因此，这道题的核心就是**管理好节点之间的指针关系**，特别是在插入和删除操作中，要确保链表的连续性不被破坏。

##### 核心思想和套路

###### 虚拟头节点Dummy

对于链表问题，有一个非常强大且常用的技巧/套路：**虚拟头节点 (Dummy Head / Sentinel Node)**。

创建一个永远存在但不存储实际数据的“哨兵”节点，让它作为链表的真正头节点的前一个节点。`dummyHead.next` 永远指向真实的第一个节点。

###### 为什么使用虚拟头节点

- 1. **统一操作**: 无论是对链表头部进行操作，还是对中间、尾部进行操作，逻辑都变得统一。例如，插入一个新节点，总是发生在其前驱节点的 `next` 指针上。如果没有虚拟头节点，对头部的插入操作就需要特殊处理（需要更新 `head` 引用），而对中间节点的操作则是修改 `prev.next`。
  2. **简化边界情况**: 无需特殊处理空链表的情况。一个空链表可以被看作是一个只有虚拟头节点的链表。这使得 `addAtHead` 和 `addAtIndex(0, ...)` 的逻辑完全一样。

采用虚拟头节点后，我们的链表结构在逻辑上是这样的： `dummyHead -> Node1 -> Node2 -> ... -> null`

##### 实现原理和步骤

**1. 初始化 `MyLinkedList`**

- 创建一个 `size` 变量来记录链表的长度（节点数量）。
- 创建一个虚拟头节点 `dummyHead`。它是一个 `Node` 对象，其 `val` 无所谓，`next` 指向 `null`。

**2. `get(index)`: 获取节点值**

1. 检查 `index` 是否有效 (`index < 0` 或 `index >= size`)。如果无效，返回 -1。
2. 从虚拟头节点 `dummyHead` 开始，向后遍历 `index + 1` 次，找到第 `index` 个节点。
3. 返回该节点的值。

**3. `addAtHead(val)`**

- 这个操作等价于 `addAtIndex(0, val)`。

**4. `addAtTail(val)`**

- 这个操作等价于 `addAtIndex(size, val)`。

**5. `addAtIndex(index, val)`: 核心操作**

1. 处理 `index` 的边界情况：如果 `index < 0`，则视为 0；如果 `index > size`，直接返回，不进行任何操作。
2. 创建一个值为 `val` 的新节点 `newNode`。
3. 找到要插入位置的**前一个节点 (predecessor)**。从 `dummyHead` 开始，向后遍历 `index` 次即可找到。
4. 执行插入：
   - `newNode.next = predecessor.next;`  (新节点指向前驱节点原来指向的节点)
   - `predecessor.next = newNode;`      (前驱节点指向新节点)
5. `size` 加一。

**6. `deleteAtIndex(index)`: 核心操作**

1. 检查 `index` 是否有效 (`index < 0` 或 `index >= size`)。如果无效，直接返回。
2. 找到要删除位置的**前一个节点 (predecessor)**。从 `dummyHead` 开始，向后遍历 `index` 次即可找到。
3. 执行删除：
   - `predecessor.next = predecessor.next.next;` (前驱节点“跳过”要删除的节点，直接指向其后继节点)
4. `size` 减一。

##### 实现代码

```Java
//设计一个自己的链表
//考虑使用双链表？
class ListNode {
    int val;
    ListNode next;
    public ListNode(int val){
        this.val = val;
    }
}
class MyLinkedList {
    
    ListNode dummy;
    int size;

    public MyLinkedList() {
        this.dummy = new ListNode(-1);
        this.size = 0;
    }
    /**
    * return the indexth element
     */
    public int get(int index) {
        if (index < 0 || index >= size) return -1;
        ListNode curr = dummy;
        //寻找元素list[index]
        for(int i = 0; i <= index; i++){
            curr = curr.next;
        }
        return curr.val;
    }
    //添加到头部
    public void addAtHead(int val) {
        ListNode node = new ListNode(val);
        ListNode next = dummy.next;
        dummy.next = node;
        node.next = next;
        size++;
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        if(index > size || index < 0) return;
        ListNode node = new ListNode(val);
        //找到prev节点，即找到index-1
        ListNode prev = dummy;
        //找到prev节点，即index
        for(int i = 0; i < index; i++){
            prev = prev.next;
        }
        ListNode next = prev.next;
        prev.next = node;
        node.next = next;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if(index >= size || index < 0) return;
        ListNode prev = dummy;
        //找到第节点list[index -1]，包含dummy节点在内，应该是找到第index个节点
        for(int i = 0; i < index; i++){
            prev = prev.next;
        }
        prev.next = prev.next.next;
        size--;
    }
}
```



### 模拟算数运算

#### 场景和目标

- **场景**：给定两个用链表表示的数字。
- **目标**：模拟整数加法，并返回一个表示结果的新链表（如 LC 2）。

#### 题型的本质和分析

本质上是模拟小学的竖式加法。难点在于处理两个链表**长度不等**的情况，以及关键的“进位”逻辑。

#### 核心套路 - 双指针迭代 + Dummy

- **虚拟头节点 dummy**：用于构建结果链表。
- **双指针迭代**：用两个指针同步遍历两个输入链表。

**原因**：`dummy` 节点是构建新链表的标准实践。双指针遍历是同步处理两个输入源的自然选择。

#### 原理和步骤

1. 创建一个 `dummy` 节点和 `current` 指针。

2. 初始化一个进位变量 `carry = 0`。

3. 循环遍历两个链表，直到两个链表都为空且 `carry` 为 0。

4. 在循环中，取出两个链表当前节点的值（如果节点为空则值为 0），与 `carry` 相加得到 `sum`。

5. 根据 `sum` 计算出新节点的值 (`digit = sum % 10`) 和新的进位 (`carry = sum / 10`)。

6. 创建新节点，并连接到 `current` 之后。

7. 移动所有相关指针。

#### 实现代码

```java
// 题型核心模板：两数相加 (LC 2)
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    int carry = 0;

    while (l1 != null || l2 != null || carry != 0) {
        int val1 = (l1 != null) ? l1.val : 0;
        int val2 = (l2 != null) ? l2.val : 0;

        int sum = val1 + val2 + carry;
        carry = sum / 10;

        current.next = new ListNode(sum % 10);
        current = current.next;

        if (l1 != null) l1 = l1.next;
        if (l2 != null) l2 = l2.next;
    }
    return dummy.next;
}
```

#### 注意事项

- 循环的终止条件 `l1 != null || l2 != null || carry != 0` 非常关键，它确保了最高位的进位不会被遗漏。

- 处理空节点时，将其值视为 0，可以简化代码。

#### 经验总结

这是一个模拟题，重点在于将现实世界的计算规则（竖式加法）准确地翻译成代码逻辑，并处理好所有边界情况。

### 复杂链表的深层拷贝

#### 场景和目标

- **场景**：给定一个链表，其节点除了 `next` 指针，还有一个指向链表内任意节点的 `random` 指针。
- **目标**：创建一个全新的链表，其结构和节点值与原链表完全相同，包括 `random` 指针的指向关系也要被完美复制（如 LC 138）。

#### 问题的本质和分析

此题的难点在于 `random` 指针。在复制节点时，一个新节点的 `random` 指针需要指向另一个新节点，但那个新节点可能还没被创建。这考察的是如何处理节点间复杂的、非线性的依赖关系。

#### 核心套路 - 哈希表辅助

- **哈希表辅助**：这是最直观、最通用的解法。

**原因**：哈希表提供了一种 O(1) 复杂度的查找方式，完美地解决了“如何找到任意一个原节点对应的新节点”这一核心问题。它用空间换时间，极大简化了逻辑。

#### 原理和步骤

1. 创建一个 `HashMap<Node, Node>`。

2. **第一次遍历**：遍历原链表，对于每个节点 `curr`，创建一个新节点 `new Node(curr.val)`，并存入哈希表 `map.put(curr, newNode)`。

3. **第二次遍历**：再次遍历原链表。对于每个节点 `curr`： 
   1. a.  从哈希表中取出其对应的新节点 `newNode = map.get(curr)`。
   2.  b.  设置新节点的指针：`newNode.next = map.get(curr.next)` 和 `newNode.random = map.get(curr.random)`。

4. 返回 `map.get(head)`。

#### 代码实现

```java
// 题型核心模板：复制带随机指针的链表 (LC 138)
public Node copyRandomList(Node head) {
    if (head == null) return null;
    Map<Node, Node> map = new HashMap<>();

    // 第一次遍历: 复制节点并建立映射
    Node current = head;
    while (current != null) {
        map.put(current, new Node(current.val));
        current = current.next;
    }

    // 第二次遍历: 根据映射设置 next 和 random 指针
    current = head;
    while (current != null) {
        map.get(current).next = map.get(current.next);
        map.get(current).random = map.get(current.random);
        current = current.next;
    }
    return map.get(head);
}
```

#### 注意事项

- 哈希表法需要 O(N) 的额外空间。

- 还有一种空间 O(1) 的解法（节点拆分法），但逻辑更复杂，面试中能清晰写出哈希表法已足够优秀。

#### 经验总结

当遇到节点间存在非顺序依赖关系时，使用哈希表来建立“旧 -> 新”的映射是一种普适且强大的思想。

