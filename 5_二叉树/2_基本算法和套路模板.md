## 常见题型

- 二叉树的遍历（前序、中序、后序、层序）
- 最小/最大深度计算
- 二叉搜索树的操作（插入、删除、查找）
- 图的最短路径（BFS/DFS）
- 拓扑排序

| 类别             | 关键词                            | 示例题            |
| ---------------- | --------------------------------- | ----------------- |
| ✅ 遍历类         | 前序、中序、后序、层序、递归/迭代 | 94, 144, 145, 102 |
| ✅ 属性计算       | 高度、深度、节点数、直径          | 104, 111, 543     |
| ✅ 判断结构       | 是否平衡/对称/相同                | 100, 101, 110     |
| ✅ 路径类         | 路径和、最大路径、所有路径        | 112, 113, 124     |
| ✅ 转换类         | 构建树、扁平化、链表化            | 105, 106, 114     |
| ✅ 查找类         | 最近公共祖先、搜索路径            | 235, 236, 98      |
| ✅ 二叉搜索树专属 | 中序性质、大小关系                | 98, 700, 701, 230 |
| ✅ 变种结构       | 多叉树、完全/满/平衡树            | 222, 116, 117     |



| 类别       | 关键词                            | 示例题            | 推荐策略 / 套路                                              |
| ---------- | --------------------------------- | ----------------- | ------------------------------------------------------------ |
| ✅ 遍历类   | 前序、中序、后序、层序、递归/迭代 | 94, 144, 145, 102 | ✦ 递归三模板 ✦ 迭代用栈模拟 ✦ 层序用队列（BFS）              |
| ✅ 属性计算 | 高度、深度、节点数、直径          | 104, 111, 543     | ✦ 后序遍历计算 ✦ 分治返回局部属性（高度、最大值）            |
| ✅ 判断结构 | 是否平衡/对称/相同                | 100, 101, 110     | ✦ 同时遍历比较节点值 ✦ 镜像结构比较（对称） ✦ 后序返回高度 + early stop |
| ✅ 路径类   | 路径和、最大路径、所有路径        | 112, 113, 124     | ✦ DFS + 回溯 ✦ 累加和 + 叶子判断 ✦ 返回路径集合              |
| ✅ 转换类   | 构建树、扁平化、链表化            | 105, 106, 114     | ✦ 前/中/后序结合切片 ✦ 分治递归构造结构 ✦ Morris技巧或后序调整结构 |
| ✅ 查找类   | 最近公共祖先、搜索路径            | 235, 236, 98      | ✦ 分治法：左右递归 + 判断是否命中 ✦ 中序判 BST 路径          |
| ✅ BST 专属 | 中序性质、大小关系                | 98, 700, 701, 230 | ✦ 利用中序递增特性 ✦ 上下界剪枝 ✦ 二分查找型递归             |
| ✅ 变种结构 | 多叉树、完全/满/平衡树            | 222, 116, 117     | ✦ 层序遍历处理指针 ✦ 完全二叉树性质剪枝 ✦ 多子节点统一处理   |

## 解题策略：

- **递归**：解决树的遍历和属性计算问题。
- **BFS**：求最短路径、层序遍历等问题。
- **DFS**：路径总和、全排列生成等问题。
- **动态规划**：树上的动态规划（如最大路径和）。

## 常见遍历方式和用法

| 遍历方式          | 顺序                             | 应用场景                         |
| ----------------- | -------------------------------- | -------------------------------- |
| 前序（根左右）    | `root → left → right`            | `构建树`、序列化、复制结构       |
| 中序（左根右）    | `left → root → right`            | **二叉搜索树 BST 排序**          |
| 后序（左右根）    | `left → right → root`            | `删除节点`、`结构计算`（如高度） |
| 层序遍历（BFS）   | 从上往下逐层扫描                 | 求深度、宽度、右视图             |
| 深度优先遍历(DFS) | 从上往下探索遍历（root -> leaf） | 路径和                           |

## 基本算法和模版套路

### 分治法

> 左右子树递归求解

#### 核心思想-左右子树分别求解后合并

将左右子树问题分别求解后合并整体解

#### 实现原理

递归时从子问题返回状态结果，合并后返回上一层

#### 代码模板

```
Result left = helper(root.left);
Result right = helper(root.right);
//合并左右子树结果，返回
return merge(left,right,root);
```

#### Leetcode 543 二叉树的直径

给定一棵二叉树的根节点，返回该树的 **直径**。
 二叉树的直径是指 **任意两个节点之间路径长度的最大值**。**路径长度** 是路径经过的 **边数**。

##### 问题本质

直径的定义是两个任意节点之间的最长路径长度，路径可以不经过根节点。

但是关键在于：

- 直径一定是经过某个节点`root`的**左子树+右子树的最大深度**，这个路径正好从某个左节点走到某个右节点。

##### 问题分析-二叉树的深度问题

- 求的是最长路径的边数，而不是节点数
- 需要在**后序遍历** 中：
  - 求每个节点的左右子树的深度
  - 用`左深度+右深度`更新全局最大值

##### 实现原理

用一个全局变量 `maxDiameter`记录**最大直径**

- 计算每一个节点的**深度**=`左子树的深度+右子树的深度+1`
- 每一个节点的**直径**=`左子树深度+右子树的深度`
- 每次检查更新**最大直径** = `max(最大直径，当前节点的直径)`

##### 代码实现

```java
private int maxDiameter = 0;


private int dfs(TreeNode node){
  if (node == null) return 0;
  
  int leftDepth = dfs(node.left);
  int rightDepth = dfs(node.right);
  // 当前节点的直径=左子树深度+右子树深度
  int diameter = leftDepth+rightDepth;
  //更新最大路径
  maxDiameter = Math.max(maxDiameter, diameter);
  //返回当前节点的最大深度
  return Math.max(leftDepth,rightDepth)+1;
}
```





#### Leetcode 124 最大路径和

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

##### 核心思想-后序遍历+分治

###### 问题抽象

这是一个**树上动态规划 + 后序遍历**的问题，要求我们在每个节点选择是否使用其左/右子树路径来构成“最大路径”。

路径可以从某个节点出发，向下到达任意节点，但最终的路径不一定通过根节点 —— 因此我们需要**全局最大路径和**的概念。

###### 核心套路

- **后续遍历+分治**

  - 对于二叉树中的每个节点
    - 求**最大单边路径值：** `max(左边最大路径，右边最大路径)+当前节点值`
    - 求以**当前节点为拐点的最大路径：**`左边最大路径+当前节点值+右边最大路径`
    - 更新全局最大值: `最大路径和=max(最大路径和，当前拐点的最大路径和)`

- **定义状态**

  `maxGain(node)`:以`node`为根的**最大贡献值**（只能向上贡献**一边的路径**）

- **全局最大值维护**

  用一个变量`maxSum`来记录全局最大路径和，在递归中不断更新

##### 实现原理

###### 递归-后序遍历

```java
int maxGain(TreeNode node){
  if (node == null) return 0;
  //计算左右子树的最大贡献值，负值不选
  int leftGain = Math.max(maxGain(node.left),0);
  int rightGain = Math.max(maxGain(node.right),0);
  
  //计算以当前节点为根的拐点路径最大值
  int priceNewPath = node.val + leftGain + rightGain;
  
  //更新全局最大值
  maxSum = Math.max(maxSum,priceNewPath);
  
  //向上返回单边最大贡献
  return node.val + Math.max(leftGain,rightGain);
}
```

###### 主函数实现

```java
int maxPathSum(TreeNode node){
  maxSum = Integer.MIN_VALUE;
  maxGain(root);
  return maxSum;
}
```

##### 代码实现

```java
class Solution {
    private int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    private int maxGain(TreeNode node) {
        if (node == null) return 0;

        // 左右子树最大贡献值，负数则置为0（不选）
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 当前节点作为拐点路径的最大值
        int currentMaxPath = node.val + leftGain + rightGain;

        // 更新全局最大路径和
        maxSum = Math.max(maxSum, currentMaxPath);

        // 向上返回最大单边贡献
        return node.val + Math.max(leftGain, rightGain);
    }
}
```



#### Leetcode 236 最近公共祖先

给定一棵**二叉树**，以及两个节点 `p` 和 `q`，找出它们的**最近公共祖先（Lowest Common Ancestor, LCA）**。

**最近公共祖先的定义**：在一棵树中，`p` 和 `q` 的最近公共祖先是**同时包含 `p` 和 `q` 的最深的节点**。

##### 问题的本质

问题的本质是通过**在二叉树中寻找两个目标节点**，来确定公共祖先：

- 如果两个目标节点在同一颗子树中，需要在子树中继续寻找
- 如果两个目标节点不再同一颗子树中，则当前的根节点就是最近祖先
- 如果当前根节点就是目标节点之一，则当前的根节点就是最近祖先

##### 核心思想：分治+后序遍历

- 对于任意节点`root`,判断以下三种情况：
  - 左子树包含`p`或者`q`
  - 右子树包含`p`或者`q`
  - 当前节点就是`p`或者`q`
- 如果`p`和`q`分别出现在左右子树，`root`就是公共祖先
- 如果只在一侧子树中出现，则继续向那一侧递归

##### 递归套路：后续递归

后续遍历的思维方式是：**先处理字问题，再组合结果**

##### 实现原理

我们使用一个递归函数` lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)`;

###### 递归终止条件

- 如果`root == null`，返回`null`
- 如果`root == p || root == q`，返回`root`,因为**当前节点是目标节点之一**

###### 递归调用过程

- 递归调用**左子树**：`left =lowestCommonAncestor(root.left,p,q)`
- 递归调用**右子树：**`right = lowestCommonAncestor(root.right, p, q)`

###### 结果合并

- 如果`left!=nulll && right != null`,说明`p`和`q`分别在左右子树，当前节点`root`就是最近公共祖先
- 如果只有一个不为`null`，返回非空的那个
- 如果都为`null`，返回`null`

##### 代码实现

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
  if (root == null ) return null;
  
  if (root == q || root == q){
    return root;
  }
  
  TreeNode left = loweestCommonAncestor(node.left, p,q);
  TreeNode right = lowestCommonAncestor(node.right,p,q);
  
  if (left != null && right != null){
    return root;
  }
  
  if (left != null){
    return left;
  }else{
    return right;
  }
}
```

##### 注意事项

1. ✅ **二叉树不一定是二叉搜索树**，所以不能用 BST 的大小关系做判断；
2. ✅ 返回的是 `TreeNode` 类型，而不是值（不要返回 `root.val`）；
3. ✅ 如果 `p` 和 `q` 中有一个就是根节点，结果就是根节点本身；
4. ✅ 若 `p` 是 `q` 的祖先（或反之），返回的也会是祖先节点；
5. ✅ 确保节点值不唯一时不能用 `val ==` 做判断，必须比较 `==`（Java中对象引用）。

###### 应用场景和扩展

- 适用于任意普通二叉树

- 可以扩展用于多次查询LCA, 使用**Tarjan算法+并查集**

- 如果是**二叉搜索树**，可以利用其有序性优化（Leetcode 235）

  ```java
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if (root == null) return null;
          if (root == p || root == q){
              return root;
          }
          if (p.val < root.val && q.val > root.val){
              return root;
          }
          if (p.val > root.val && q.val < root.val){
              return root;
          }
          if (p.val < root.val) return lowestCommonAncestor(root.left, p, q);
  
          else return lowestCommonAncestor(root.right, p, q);
      }
  ```

  

#### Leetcode 110 判断平衡树

##### 代码实现

```java
    boolean isBalanced = true;
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        depth(root);
        return isBalanced;
    }

    private int depth(TreeNode root){
        if (root == null) return 0;
        int leftDepth = depth(root.left);
        int rightDepth = depth(root.right);
        if (Math.abs(leftDepth-rightDepth) > 1){
            isBalanced = false;
        }
      //merge 逻辑
        return Math.max(leftDepth, rightDepth)+1;
    }
```



### 递归遍历

#### 核心思想 

利用递归的天然**调用栈结构**，按照不同顺序访问节点

#### 实现原理

对每个节点执行操作，然后递归其左右子树，根据操作顺序决定**前中后顺序**。

#### 前序遍历套路

> 前序遍历：根->左子树->右子树

```java
public void preorder(TreeNode node, List<Integer> path){
  if (node == null) return;
  
  path.add(node.val);
  
  preorder(node.left, path);
  
  preorder(node.right, path);
}
```



#### 中序遍历模板套路

> 中序遍历：左子树->右子树->根

```
public void inorder(TreeNode node,List<Integer> path){
   //Base condition
   if (node == null) return;
   //处理左子树
   inorder(node.left, path);
   //处理当前节点
   path.add(node.val);
   //处理右子树
   inorder(node.right, path);
}
```

#### Leetcode 440. 字典序中的第K小数字

##### 问题要点

- **输入**: 两个整数 `n` 和 `k`。

- **任务**: 在从 `1` 到 `n` 的所有整数中，找到按字典序排序后的第 `k` 个数字。

- **核心概念**: **字典序 (Lexicographical Order)**。

  它不是按数字大小排序，而是像查字典一样，逐位比较数字的字符串形式。

  例如，`10` 排在 `2` 的前面，因为 `1` 的字典序小于 `2`。

- **约束条件**: `1 <= k <= n <= 10^9`。这个约束是解题的关键，它直接排除了任何时间复杂度为 `O(n)` 或更高的暴力解法。

**示例：** 输入: `n = 13, k = 2` 字典序: `1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9` 第 2 个数字是 `10`。

##### 问题的本质和分析 - 一颗天然的树！

这道题的本质不是排序，而是在一个巨大的、隐式的、有序的结构中进行**高效导航**。

如果 `n` 很小，我们可以生成所有数字，将其转换为字符串，排序后取第 `k` 个。

但 `n` 高达 `10^9`，这种方法会严重超时和超内存。

问题的突破口在于字典序的**前缀特性**。

所有以 `1` 开头的数字（1, 10-19, 100-199 等）会排在一起，然后是所有以 `2` 开头的数字，以此类推。

这种前缀结构天然形成了一棵**树**。

##### 模式匹配 - 在巨大的隐式集合中寻找第 k 个元素

本题属于一类经典问题：“**在巨大的隐式集合中寻找第 k 个元素**”。 当你看到：

1. 集合规模巨大（`10^9` 级别或更高），无法存储或遍历。
2. 集合元素有明确的排序规则。
3. 求解第 `k` 大/小元素。

就应该立即联想到，解法不是生成元素，而是通过某种计算**“跳过”**不相关的大块元素，逐步缩小范围，定位到目标。

这与**二分查找**的思想有异曲同工之妙。

##### 核心思想和套路

###### 模拟一颗10叉树

我们可以将 `1` 到 `n` 的所有数字想象成一棵十叉树（或看作一个由9棵树组成的森林）。

- **节点**: 每个数字都是一个节点。
- **父子关系**: 节点 `p` 的子节点是 `p*10, p*10+1, ..., p*10+9`。
- **根节点**: 第一层的节点是 `1, 2, 3, ..., 9`。

###### 在10叉树上进行先序遍历

对这棵树进行**先序遍历**（根-左-右），得到的节点访问顺序**恰好就是数字的字典序**。 例如：访问 `1` -> 访问 `1` 的子树（`10`, `100`... `11`, `110`...）-> 访问 `2` -> 访问 `2` 的子树...

因此，原问题被巧妙地转化为：**求这棵隐式十叉树中先序遍历的第 k 个节点是什么？**

###### 核心思路 - 下一个应该访问弟弟还是儿子？

我们模拟在十叉树上行走的过程，目标是精确地走 `k-1` 步，从起点 `1` 到达目标节点。

在任何一个节点 `curr`，我们面临一个决策：

1. 是**进入 `curr` 的子树**（向下走，访问 `curr*10`）？
2. 还是**跳过 `curr` 的整棵子树**，直接去访问 `curr` 的兄弟节点（向右走，访问 `curr+1`）？

**决策依据**: 计算以 `curr` 为根的子树中总共有多少个节点（我们称之为 `steps`）。

###### 怎么计算以curr为根的子树中一共有多少节点？

**核心思想 - 两颗子树之间的间隙**

直接去逐个数肯定是不行的，因为这又变成暴力方法了。

我们不直接看`curr`的子树，而是计算`curr`和他的下一个**兄弟节点**`curr+1`之间的容量。

将数字想象成一条线上的点。以`curr`为前缀的所有数字，都会落在`curr`和`curr+1`之间：

- `1`, `10..19`, `100..199` ... 这些数字都小于 `2`。

- `12`, `120..129`, `1200..1299` ... 这些数字都小于 `13`。

所以我们的任务就是**逐层计算**`curr`和`curr + 1`这两个边界在每一层能够**框住**多少数字。

**具体的实现**

我们设两个“指针”，`first` 和 `last`。

- `first` 代表以 `curr` 为前缀的数字在当前层的起始值。
- `last` 代表以 `curr` 为前缀的数字在当前层的结束值。

但在实际计算中，我们用 `first` 代表 `curr` 在当前层的投影，`last` 代表 `curr+1` 在当前层的投影，计算它们之间的差值，这样更简单。

我们用 `n1 = curr` 和 `n2 = curr + 1` 来代表两个边界。

- **第一层**：数字范围是 `[n1, n2 - 1]`。总数是 `n2 - n1`。
  - 例如 `curr=12`，则 `n1=12`, `n2=13`。第一层就是数字 `12` 本身，数量是 `13 - 12 = 1`。
- **第二层**：数字范围是 `[n1*10, n2*10 - 1]`。总数是 `n2*10 - n1*10`。
  - 例如 `curr=12`，则 `n1=12`, `n2=13`。第二层就是 `[120, 130-1]`，即 `120` 到 `129`，共 10 个。
- **第三层**：数字范围是 `[n1*100, n2*100 - 1]`。总数是 `n2*100 - n1*100`。
  - 例如 `curr=12`，则 `n1=12`, `n2=13`。第三层就是 `[1200, 1300-1]`，即 `1200` 到 `1299`，共 100 个。

这个规律非常清晰，但我们还没考虑上界 `n` 的限制。

**引入n的限制**

上面的计算假设了每一层都是“满”的。但实际上，所有数字都不能超过 `n`。

**关键公式**: 对于某一层，它的理论范围是 `[first, last]`。

- 当前层的数量：$last - first + 1$ ， 但是需要注意检查last是否超过范围，因此：
  - $steps = min(last,n) - first + 1$
- 计算下一层的$first$和$last$:
  - $first = first \times 10$
  - $last = last \times 10 + 9$

但由于不能超过 `n`，实际存在的数字范围是 `[first, min(n, last)]`。 

因此，这一层的实际节点数量就是：`min(n, last) - first + 1`。

**实现代码**

```java
/**
     * 计算在 [1, n] 范围内，以 curr 为前缀的数字总数 (即 curr 子树的节点数)。
     * @param curr 当前前缀 (子树的根)
     * @param n 上界
     * @return 节点总数
     */
    private long getSteps(long curr, long n) {
        long steps = 0;
        long first = curr;  // 当前层区间的开始
        long last = curr;   // 当前层区间的结束

        // 只要区间的开始还在n的范围内，就逐层计算
        while (first <= n) {
            // 将当前层的节点数累加到steps中
            // Math.min(n, last) 是为了处理最后一层不完整的情况
            steps += Math.min(n, last) - first + 1;

            // 移动到下一层
            first *= 10;
            last = last * 10 + 9;
        }
        return steps;
    }
```

###### 根据curr子树的数量决定向右走还是向下走

- **如果 `steps <= k`，向右走**: 

  说明我们拥有的步数 `k` 足以跳过整个 `curr` 子树。

  那么目标节点肯定在后面。我们就执行“向右走”：

  - `k -= steps`: **消耗掉跳过这些节点的步数**。
  - `curr++`: 移动到兄弟节点。

- **如果 `steps > k`，向下走**: 

  说明步数 `k` 不够，无法跳出 `curr` 的子树。

  目标节点必定在此子树内部。我们就执行“向下走”：

  - `k--`: 从 `curr` 走到它的第一个子节点，**消耗一步**。
  - `curr *= 10`: 移动到第一个子节点。

我们不断重复这个决策过程，`k` 的值不断减小，直到 `k` 变为 `0`，此时的 `curr` 就是我们寻找的答案。

##### 实现原理和步骤

###### 初始化当前位置和需要走的步数

- 初始化当前位置 `curr = 1`，需要走的步数 `k = k - 1`（因为 `1` 本身是第1个，我们从它出发还需要走 `k-1` 步）。

######循环迭代 - 向右走或者向下走

- 进入循环，当 `k > 0` 时执行：

  -  a. **计算 `steps`**: 实现一个函数 `getSteps(curr, n)`，计算在 `[1, n]` 范围内，以 `curr` 为前缀的数字总数。 

    - i.  该函数逐层计算。设两个指针 `first = curr`, `last = curr`。 

    - ii. 在循环中，`first` 代表当前层区间的开始，`last` 代表结束。

      `steps += Math.min(n, last) - first + 1`，这里 `min(n, last)` 是为了确保统计的数不超过 `n`。 

    - iii. 更新指针到下一层：`first *= 10`，`last = last * 10 + 9`。
    
    -  iv. 循环直到 `first > n`。 

  - b. **决策与移动**:
    -  i.  若 `steps <= k`，则 `k -= steps`, `curr++`。 
    - ii. 若 `steps > k`，则 `k--`, `curr *= 10`。

- 循环结束（`k` 减为 `0`），返回 `curr`。

##### 实现代码

```java
class Solution {
    public int findKthNumber(int n, int k) {
        // 使用 long 类型防止计算过程中溢出
        long curr = 1;
        // k减1，转换为需要从'1'开始走多少步
        k = k - 1;

        while (k > 0) {
            // 计算以curr为根的子树的节点总数
            long steps = getSteps(curr, n);

            if (steps <= k) {
                // 步数足够跳过整个子树
                // 扣除跳过的步数
                k -= steps;
                // 移动到兄弟节点
                curr++;
            } else {
                // 步数不够，说明目标在子树中
                // 向下走一步
                k--;
                // 移动到第一个子节点
                curr *= 10;
            }
        }
        return (int) curr;
    }

    /**
     * 计算在 [1, n] 范围内，以 curr 为前缀的数字总数 (即 curr 子树的节点数)。
     * @param curr 当前前缀 (子树的根)
     * @param n 上界
     * @return 节点总数
     */
    private long getSteps(long curr, long n) {
        long steps = 0;
        long first = curr;  // 当前层区间的开始
        long last = curr;   // 当前层区间的结束

        // 只要区间的开始还在n的范围内，就逐层计算
        while (first <= n) {
            // 将当前层的节点数累加到steps中
            // Math.min(n, last) 是为了处理最后一层不完整的情况
            steps += Math.min(n, last) - first + 1;

            // 移动到下一层
            first *= 10;
            last = last * 10 + 9;
        }
        return steps;
    }
}
```

##### 注意事项

**数据类型**: 在计算 `steps`、以及 `curr` 移动时，`curr * 10` 可能会超过 `Integer.MAX_VALUE`。因此，所有参与计算的变量（`curr`, `steps`, `first`, `last`）都应使用 `long` 类型，以避免溢出。

**`k` 的转换**: 将 `k` 减 1 转换为“步数”模型，使得循环内部的逻辑更清晰。`k--` 代表向下走一步，`k -= steps` 代表跳过 `steps` 步。

**`getSteps` 的精确性**: `getSteps` 函数是整个算法的核心。`Math.min(n, last)` 这个细节是保证其在边界 `n` 附近依然能正确计算的关键。

##### 经验总结

**转化思想**: 遇到看似需要排序但数据范围极大的问题，首先思考能否将问题**转化为在某种隐式结构（如图、树）上的导航问题**。

**分而治之**: 核心套路是不断地计算某个“子问题”的规模，然后判断第 `k` 个元素是否在这个子问题中，从而缩小搜索范围。

**前缀是树**: 对于数字或字符串的字典序问题，**前缀**是构建树形结构的最佳线索。

**编码细节**: 注意大数问题，及时使用 `long`。清晰的变量命名（如 `curr`, `steps`, `first`, `last`）能极大帮助理清复杂的逻辑。

#### 后序遍历模板套路

> 后续遍历： 左子树 ->右子树->根

```
public List<Integer> postOrderTraverse(TreeNode root){
   List<Integer> result = new ArrayList<>();
   
}

private void postorder(TreeNode node, List<Integer> result){
   // Base condition
   if (node == null) return;
   
   //递归逻辑
   //处理左子树
   postorder(node.left,result);
   //处理右子树
   postorder(node.right,result);
   //处理逻辑
   result.add(node.val);
   
}
```

#### 注意事项

**递归出口必须明确，题目要求访问顺序时，要选对遍历方式*

#### Leetcode 144:  Binary Tree Preorder Traversal - 遍历输出问题

##### 代码实现

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        preorder(root, path);

        return path;

        
    }

    private void preorder(TreeNode node, List<Integer> path){
        if (node == null) return;
        path.add(node.val);

        preorder(node.left, path);

        preorder(node.right, path);
    }
}
```

#### Leetcode 226: 翻转二叉树（Invert Binary Tree）

给你一棵二叉树，要求你“**翻转**”它：
 即将每一个节点的左右子树进行交换。

##### 核心思想

反转操作满足以下特点：

- 对于每个节点，只需要**交换其左右子树**
- 然后递归或者迭代对其左右子树重复此操作
- 是一个**后序遍历**或者**前序遍历**皆可的问题
- 可以使用**递归实现**，也可以使用**BFS/DFS迭代**实现

##### 实现原理

###### 递归解法

对于每个节点：

- 如果为空，返回`null`
- 否则，反转左子树和右子树
- 然后将**反转后的左右子树**交换
- 返回当前节点

###### 迭代解法-BFS

使用队列：

- 每次从队列中取出一个节点
- 变换其左右子树
- 将左右孩子加入队列，等待后续交换

##### 实现代码

###### 递归实现-后序遍历

```java
public TreeNode invertTree(TreeNode root){
  if (root == null) return null;
  
  TreeNode left = invertTree(root.left);
  TreeNode right = invertTree(root.right);
  
  root.right = left;
  root.left = right;
  
  return root;
}
```

###### 迭代实现 -BFS

```java
public TreeNode invertTree(TreeNode root){
  if (root == null) return null;
  Queue<TreeNode> queue = new LinkedList();
  queue.offer(root);
  
  while(!queue.isEmpty()){
    TreeNode node = queue.poll();
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
    
    if (node.left != null) queue.offer(node.left);
    if (node.right != null) queue.offer(node.right);
  }
  
  return root;
}
```

##### 注意事项

| 注意点        | 说明                                         |
| ------------- | -------------------------------------------- |
| 递归终止条件  | `if (root == null) return null;` 避免空指针  |
| 不要忘记返回  | 递归返回的是“翻转后”的节点，需要返回当前节点 |
| BFS中处理交换 | 在处理每个节点时**先交换再入队**左右节点     |
| 不破坏原结构  | 翻转是原地进行，不需要创建新的树节点结构     |

##### 总结

- **问题本质**：节点级别的交换操作；
- **算法类型**：树的遍历 + 局部操作；
- **解法选择**：
  - 喜欢递归 → 用 DFS；
  - 需控制栈深度/避免栈溢出 → 用 BFS；
- **空间复杂度**：
  - 递归最坏 `O(h)`（h是树高）；
  - BFS使用队列，最坏 `O(n)`。

#### Leetcode 112 路径总和（Path Sum）-前序遍历

判断**是否存在一条从根节点到叶子节点的路径**，其路径上所有节点值的和等于给定的目标值 `targetSum`。

这不是求路径数、路径本身，也不是求路径最短/最长，而是**判断“是否存在”**满足条件的路径。

##### 核心思想-前序遍历

采用**DFS遍历整棵树**，沿着路径累计当前路径和，在遇到叶子节点时判断累计和是否等于目标数字。

注意前序遍历本身也是也一种特殊的DFS遍历。

##### 实现原理

###### 遍历方式-前序遍历

使用前序遍历（`root-left-right`）最适合在递归中进行累加判断。

###### 重要技巧：判断 左子树或者右子树中是否存在路径和=`targetSum-node.val`

每次判断完成某个节点`node`之后，判断**node.val+node左子树或者右子树中的路径和**是否为`targetSum-node.val`

###### 判定终点-叶子节点

只有到达叶子节点的时候，才判断路径和是否等于目标数字

###### 剪枝优化

如果左子树或者右子树已经有一条路径满足条件，可以提前返回`true`，避免不必要的递归。

##### 代码实现

```java
public boolean hasPathSum(TreeNode root, int targetSum){
  if (root == null) return false;
  if (root.left == null && root.right == null){
    return root.val == targetSum;
  }
  //注意这个重要的方法
  int remainSum = targetSum - root.val;
  
  return hashPathSum(root.left, remainSum) || hasPathSum(root.right,remainSum);
}
```



#### Leetcode 101 是否对称

判断一棵二叉树是否是**镜像对称的**。也就是说，对于这棵树的左子树和右子树，如果一边翻转后能与另一边完全一致，则认为对称。

##### 核心思想

判断两个子树是否镜像，即：

- 两个节点的值相同
- 左节点的左子树和右节点的右子对称
- 左节点的右子树和右节点的左子树对称

可以使用**双指针比较两个子树**的结构对称性。

##### 常用套路

###### 递归解法（对称递归）：逐步比较对称的节点

###### 迭代解法（队列辅助）：通过BFS方式压入队列比较

##### 实现原理

###### 递归-递归比较两个子树是否镜像

- 递归比较两个子树是否镜像
- 关键点是：**比较一棵树的左子树和另一棵树的右子树**

```java
  public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        // 监察 左右节点是否镜像
        return isMirror(root.left, root.right);
    }

    private boolean isMirror(TreeNode p, TreeNode q){
        // 左右节点相同，则互为镜像
        if (p==null && q == null){
            return true;
        }
        if (p!=null && q == null){
            return false;
        }
        if (p==null && q!=null){
            return false;
        }
        if (p.val != q.val){
            return false;
        }
        // p的左子树和q的右子树互为镜像
        // p的右子树和q的左子树互为镜像
        return isMirror(p.left, q.right) && isMirror(p.right,q.left); 
    }
```

###### 重要Tip: 本层递归不要去判断下一层的节点的情况

也是递归本身的一个重要原则，下一层节点留给下一层递归处理。

注意这里的一个重要的原则：**无法解决的问题，留给递归解决就好**

######迭代（BFS）-使用队列模拟对称结构的成对比较

每次出队两个节点，判断是否对称，然后成对入队它们的子节点。

```java
public boolean isSymmetric(TreeNode root){
  if (root == null) return true;
  
  Queue<TreeNode> queue = new LinkedList<>();
  queue.offer(root.left);
  queue.offer(root.right);
  
  while (!queue.isEmpty()){
    TreeNode t1 = queue.poll();
    TreeNode t2 = queue.poll();
    
    if (t1 == null && t2 = null){ continue;}
    
    if (t1 == null || t2 = null || t1.val != t2.val){
      return false;
    }
    
    queue.offer(t1left);
    queue.offer(t2.right);
    
    queue.offer(t1.right);
    queue.offer(t2.left);
    
  }
  
  return true;
}
```

##### 注意事项

1. **不要只判断根左右对称**，而是整个子树结构都要对称。
2. 在递归或迭代中，注意**null 节点的成对出现**，不能只看值是否相等。
3. 对于迭代方式，注意压入顺序必须镜像对称：左-右 vs 右-左。
4. 空树本身是对称的，应返回 `true`。

#### Leetcode 98: 验证二叉搜索树（BST）

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

##### 核心思想-搜索二叉树的中序遍历arr[i]>arr[i-1]

因为二叉树的中序遍历顺序是**左子树-root-右子树**。

因为在中序遍历所产生的**中序数组**中，对于**任意索引`i>=1`， 有`arr[i]>arr[i-1]`**

##### 实现原理

###### 记录中序遍历的前置节点`prev`

记录下上一次所遍历的节点`prev`,用来比较`current`节点

###### 比较当前节点和prev节点的大小

如果当前节点小于prev节点，则说明是一棵非法二叉搜索树。

##### 实现代码

```java
class Solution {
    //这里用了一个比较简单的原则，在中序遍历中arr[i]总是比arr[0...i-1]大
    TreeNode prev = null;
    boolean isValidBST = true;
    public boolean isValidBST(TreeNode root) {
        inorder(root);
        return isValidBST;
    }

    private void inorder(TreeNode node){
        if (node == null){
            return;
        }
        //处理左子树
        inorder(node.left);
        //处理当前节点
        if(prev !=null && prev.val >= node.val){
            isValidBST = false;
            return;
        }
        prev = node;
        inorder(node.right);
    }
}
```



### BFS遍历模板（队列实现）

```
Queue(TreeNode) queue = new LinkedQueue<>();
queue.offer(root);

while (!queue.isEmpty()){
   int size = queue.size();
   for (int i=0;i<size;i++){
      TreeNode node = queue.poll();
      //todo: 处理当前节点
      if(node.left != null) queue.offer(node.left);
      if(node.right !=null) queue.offer(node.right);
   }
}
```

#### Leetcode 107: 自底向上遍历

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

##### 核心思想： BFS+LinkedList

本质上是和BFS一样的问题，但是不同的是其要求子弟向上的层序排列。

也就是说res[0] = 最后一层节点列表，相当于按照BFS顺序输出的结果reverse.

因此最简单的实现就是BFS之后，再将结果list反转一下。

###### 通过BFS实现层序遍历

这是本题目最基本的套路，通过BFS来遍历二叉树。

###### 通过LinkedList避免最后一次的反转操作

为了减少最后一步的反转操作所带来的空间和时间消耗，我们采用`LinkedList`，每次将新生成的层节点列表**添加到LinkedList的头部**，实现在生成的同时自动反转的效果，避免生成了之后再做一次反转的做法。



##### 实现代码

```java
 public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) return new ArrayList<>();

        Queue<TreeNode> queue  = new LinkedList<>();
        queue.offer(root);

        LinkedList<List<Integer>> res = new LinkedList<>();

        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i=0;i<size;i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            res.addFirst(list);
        }

        return res;
    }
```



#### Leetcode 103 之字形层序

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

##### 核心思想：BFS+双端队列+层数判断

###### 通过BFS算法实现层序遍历

通过BFS的方式利用队列实现层次遍历，入队的时候按照**正常的顺序**入队。

###### 按层读取元素是使用的套路

通过下列方法实现每次读取一整层节点

```java
int size = queue.size();
for (int i=0;i<size;i++){
  TreeNode node = queue.poll();
}
```



###### 在BFS中采用双端队列确保可以按照要求从任何一端获得元素

通过在将BFS中的队列替换为双端队列，可以确保：

- 从做到右读取整层节点时通过`deque.pollFirst()`
- 从右到左读取整层节点时通过`deque.pollLast()`

###### 记录当前遍历层数以判断元素获取顺序

在按层读取节点的逻辑中，每次读取完一整层的节点之后，累加当前的层数。

- 当当前的level % 2 = 1时，从左到右读取元素
- 当当前的level %2 =0 时，从右到左读取元素

###### **level的初始值和+1操作的时机**

- 初始值为**第一个有效值**，那么+1操作在**逻辑操作之后**

- 初始值**不是第一个有效值**，那么+1操作在**逻辑操作之前**

- 代码例子(Leetcode 111 二叉树最小深度)：

  ```java
  int depth = 1;
  
          while (!queue.isEmpty()){
              int size = queue.size();
              for (int i=0;i<size;i++){
                  TreeNode node = queue.poll();
                  if (node.left == null && node.right == null){
                      return depth;
                  }
                  if (node.left != null) queue.offer(node.left);
                  if (node.right != null) queue.offer(node.right);
              }
              depth++;
          }
  ```

  

##### 实现代码

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<List<Integer>> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int level=1;
        while (!queue.isEmpty()) {
            Deque<Integer> deque = new LinkedList<>();
            int levelSize = queue.size();
            for(int i=0;i<levelSize;i++){
                TreeNode node = queue.poll();
                if (level %2 ==1){
                    deque.offerLast(node.val);
                }else{
                    deque.offerFirst(node.val);
                }

                if (node.left != null) queue.offer(node.left);
                 if(node.right != null) queue.offer(node.right);
            }
            list.add(new LinkedList<>(deque));
            level++;
            }
        return list;
    }
```

####Leetcode 117 : 连接每一层中的节点

```
给定一个二叉树：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。

初始状态下，所有 next 指针都被设置为 NULL 。
```

##### 实现代码

```java
  public Node connect(Node root) {
      if (root == null) return null;
      Queue<Node> queue = new LinkedList<>();
      queue.offer(root);

      while (!queue.isEmpty()) {
        int size = queue.size();
        Node prev = null;
        for (int i=0; i<size; i++){
            Node node = queue.poll();
            if(prev != null){
                prev.next = node;
            }
            prev = node;
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
      }
      return root;
    }
```



### DFS遍历模板（回溯+路径类）

##### DFS High Level 理解

深度优先搜索是一种 `递归式`的`探索` 每一条可能路径的方式，它的本质是`沿着一条路径走到底，然后再回退尝试其他可能`

- DFS过程是`递归`的
- DFS过程可能是`探索`式的
- 每一次过程都是沿着一个`路径到leaf`走到底的过程
- 沿着路径走到底之后，DFS回进行`回退` 至至上一个节点

##### DFS 就像是`爬山探路`

- 你站在树根，每次往左或者往右，就像爬山的一步
- 一旦走到底(叶子)，你回头(回溯)换一条路，注意这里的回头是至`回到上一个节点`，而不是回到跟节点
- 一整条路径，就是你`从根走到叶子的完整旅程`

##### DFS就像`系统自动展开一颗可能空间树`

- 每个节点代表一个决策点
- 在当前节点决定往左走还是往右走，每次递归都是做决策
- 递归返回就是`走到底或者发现走错路`
- 整个搜索树的遍历，就是DFS

##### DFS就是系统调用战在压栈弹栈

- 每次调用dfs()就是在压栈，深入一步
- 每次函数返回，就是弹栈，回退一层
- 你可以通过观察 **递归函数的参数变化 + 返回值**，理解「走进去 → 回出来」的过程。

##### 递归DFS过程详解

注意，**前序遍历本身就是DFS**。

- Base condition

  ```
  node == null;
  ```

- 处理当前节点

  ```
  process (node){
  	if (node.isLeaf() && ....){
  	  // process node
  	}
  }
  ```

- 递归处理左子树

  ```
  dfs(node.left,List<Integer> path);
  ```

- 递归处理右子树

  ```java
  dfs(node.right,List<Integer> path);
  ```

  

```
void dfs(TreeNode node, List<Integer> path){
   //   Base condition
   if (node == null) return;
   //  处理当前节点
   path.add(node.val);
   
   
   if (node.isLeaf &&(other conditions){
     res.add(new ArrayList<>(path));
   }
   // 遍历左子树
   dfs(node.left,path);
   // 遍历右子树
   dfs(node.right,path);
   //..merge
}
```

**典型题：**

- 113 路径和 II
- 257 所有根到叶路径

#### Leetcode 113: 路径和 II

给定一个二叉树和一个目标和 `targetSum`，找到所有从根节点到叶子节点路径中，路径节点值之和等于 `targetSum` 的**所有路径**。
 每条路径应该以**节点值列表**的形式返回，所有路径组成一个二维列表。

#### 问题本质

- 路径从根到叶子
- 找所有路径，不是存在性问题
- 路径和等于目标值

#### 核心思想和套路：DFS+回溯

我们需要在遍历过程中维护一条**当前路径**，并在**符合条件**（达到叶子节点并且和为目标值）的时候**收集结果**。

#####使用**DFS**从根节点递归遍历整棵树

- 沿着路径向下累加
- 使用一个路径Path记录当前路径
- 如果当前节点是叶子节点，并且路径和等于目标值，则将`path`加入结果列表
- 每一层递归完成后进行回溯（移除当前节点），恢复路径现场

##### 回溯+DFS套路模板

```python
dfs(node, path, sum):
  if node is None: return 
  Add node to path
  if (node is leaf && sum == target): save(path)
	else:
    dfs(node.left)
    dfs(node.right)
 回溯(移除node)
  
```

#### 实现原理-回溯套路

- 递归入口从`root` 开始
- 每个`dfs`递归传入当前节点，生育目标和`remainSum`，路径`path`
- 处理当前节点：
  - 将当前节点加入路径
  - [处理当前逻辑]减去当前节点后的剩余和`remainSum`
- 判断叶子节点
  - 如果当前是叶子，并且剩余和为0，说明找到了合法路径，保存路径
- 递归左右子树
- 回溯：返回上一层前，移除路径中的当前节点（现场恢复）

#### 实现代码-注意回溯套路

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    // DFS 套路模板
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<TreeNode> path = new ArrayList<>();
        dfs(root, targetSum, path);
        return res;
    }

    private void dfs(TreeNode node, int targetSum, List<TreeNode> path){
        if (node == null) return;
        // 添加当前节点到path
        path.add(node);
        //处理当前的逻辑
        //符合条件则添加path
        int remainingSum = targetSum-node.val;
        if (node.right == null && node.left == null && remainingSum ==0){
            List<Integer> list = path.stream().map(n->n.val).toList();
            res.add(list);
        } else {
            //不符合条件则递归调用
            dfs(node.left, remainingSum, path);
            dfs(node.right, remainingSum, path);
        }
        path.remove(path.size()-1);
    }
}
```

#### 注意事项

| 注意点                                     | 说明                                             |
| ------------------------------------------ | ------------------------------------------------ |
| ✅ 路径必须是从根到**叶子节点**             | 中途的路径不算，必须是完整路径                   |
| ✅ 每次加入路径前要 `new ArrayList<>(path)` | 否则后续的回溯会影响已经加入结果集的路径         |
| ✅ 回溯步骤不可遗漏                         | `path.remove(path.size() - 1)` 是 DFS 的现场还原 |
| ✅ 剪枝逻辑可加可不加                       | 如果 `remainingSum < 0` 且全是正数可提前返回     |
| ✅ 不能用全局 path                          | 否则多个路径会被污染，需要在 DFS 过程中动态传参  |

### 构建二叉树（分治）

#### 问题定义

**构建二叉树类问题** 通常给定：

- 一些遍历结果（前序/中序/后序/层序）
- 要你构造对应的唯一或者合理的二叉树结构

#### 让你觉得无从下手的原因是什么？

- 如何确定root？
- 分隔左右子树
- 递归构建左右子树

#### 常见应对策略纵览

**典型题：**

- 105 前序 + 中序 → 构建树
- 106 中序 + 后序 → 构建树

### Morris 遍历解决问题-不使用额外栈或者递归的情况下解决问题

#### 问题背景-栈或者递归的空间复杂度问题

- 递归遍历（前序/中序/后序/BFS/DFS）- `O(h)` 
- 栈 (手动模拟系统栈)-`O(h)`

#### Morris方法解决的问题-降低空间复杂度到O(1)

空间复杂度降为 `O(1)`，适用于内存敏感型场景（如嵌入式系统、大数据处理等）

Morris方法通过**修改树的结构**，在遍历时临时建立`索引`，从而实现`O(1)` 空间

#### Morris算法的核心思想-线索二叉树

在遍历过程中临时修改🌲结构，把**前驱节点的右指针指向当前节点**，从而**避免使用栈进行回溯**

##### 核心逻辑

对于每个当前节点：

- 如果没有左子树，访问当前节点，向右移动
- 如果有左子树，找到左子树中的最右节点（`前驱节点`）
  - 如果前驱节点的`right==null`,建立临时链接`right==当前节点`，进入左子树
  - 如果前驱节点的`right==当前节点`，说明**已经回溯**，取消链接，访问当前节点，进入右子树

#### Morris 中序遍历的核心原理

对于当前节点 `curr`：

1. **如果没有左子树**：

   → 处理该节点（current节点）

   → 进入下一轮（处理右子树） `curr = curr.right`

2. **如果有左子树**：

   → 找到它`左子树中最右节点（prev）`

   - 创建`左子树最右节点`的`right`连接

     - 如果`左子树最右节点` 没有`right`连接（`prev.right == null`）
       → 建立`right`连接，将`当前节点` 设置为`左子树最右节点 `的 `right`节点：`prev.right = current`
       → 进入下一轮（处理左子树）：`curr = curr.left`

     - 如果 `左子树最右节点` 已经有`right`连接(`prev.right !=null`)，说明是第二次访问
       → 删除`左子树最右节点`的`right`连接：`prev= null`
       → 处理当前节点

       → 进入下一轮（处理右子树）， `curr = curr.right`

![image-20250404181655125](/Users/tommy/Library/Application Support/typora-user-images/image-20250404181655125.png)

#### 代码实现



```java
public morrisInOrder(TreeNode root){
	TreeNote current = root;
	
	while (current !=null){
	  // 如果左子树为空，前往右子树
		if(current.left == null){
		  //处理当前节点
		  //当前节点处理逻辑
			System.out.println(current.val+" ");
			current = current.right;
		} else {
			// 寻找左子树最右节点
			TreeNode pre = current.left;
			// 注意需要排除临时线索的情况
			while(pre.right !=null && pre.right !=current){
				pre = pre.right;
			}
			
			if (pre.right == null){
				// 第一次到达，建立线索
				pre.right = current;
				current = current.left;
			} else {
				// 第二次到达，断开线索 + 访问，注意是第二次到达的时候运行节点逻辑
        pre.right = null;
        System.out.print(curr.val + " ");
        curr = curr.right;
			}
		}
	}
}
```

### Leetcode 530:[二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

给你一棵 **二叉搜索树（BST）** 的根节点 `root`，请返回 **任意两棵不同节点值之间的最小绝对差值**。

####输入示例

```
输入：
    4
   / \
  2   6
 / \
1   3

输出：1 （节点 2 和 3 或节点 3 和 4 差值都是 1）
```

####解题思路：BST + `中序遍历`模板

- 中序遍历模板

  ```
  public void inorder(TreeNode node,List<Integer> path){
     //Base condition
     if (node == null) return;
     //处理左子树
     inorder(node.left, path);
     //处理当前节点
     path.add(node.val);
     //处理右子树
     inorder(node.left, path);
  }
  ```

- 实现的要点

  - BST的特点

    按照`中序遍历`将会得到一个`升序`的数组，最小差值即从相邻节点的差值中寻找即可

  - 定义两个`全局变量`: **_全局变量是需要定义多个函数写作的时候的很好的手段，需要注意应用_**

    - Prev: 记录上一个节点值（初始值）, 用来和当前节点进行计算差值使用
    - minDiff: 当前的最小差值（默认值为`MAX_VALUE`），使用遍历比较法计算的时候
      - 如果求最大值，则最大值的初始值为`MIN_VALUE`, 比较后续值，如果后续值小于最大值，则更新最大值
      - 如果求最小值，则最小值的初始值为`MIN_VALUE`，如果后续值大于最小值，则更新最小值

  - 计算当前几点和prev的差值，如果差值小于minDiff, 则minDiff = 差值

- 代码实现

  ```java
  class Solution {
      Integer prev = null;
      int minDiff = Integer.MAX_VALUE;
  
      public int getMinimumDifference(TreeNode root) {
          inOrder(root);
          return minDiff;
      }
  		
    	//中序遍历套路，结合prev全局变量使用
      private void inOrder(TreeNode node) {
          if (node == null) return;
  
          inOrder(node.left);
  
          if (prev != null) {
              minDiff = Math.min(minDiff, node.val - prev);
          }
          prev = node.val;
  
          inOrder(node.right);
      }
  }
  ```

###结构分析和位置索引

####核心思想和套路 

在 BFS 的基础上，为每个节点赋予一个**位置索引**，模拟其在满二叉树（堆）中的位置。

根为 `i`，左孩子为 `2*i`，右孩子为 `2*i+1`。通过索引的差值计算宽度。

##### 定义一个辅助的Pair

定义一个辅助的Pair，包含：

- 节点信息Node
- 索引信息Node

##### 使用BFS遍历所有节点

BFS的队列中存放每一个Node的**Pair信息**。

###### 初始化：将root Pair信息加入队列

一般情况下我们认为Root的index是1，因此我们只需要将`Pair(root,1)` 加入队列即可

###### 队列遍历和添加过程

对于每一个在BFS过程中出队的父节点的`Pair`信息，将其左右节点的`Pair`信息加入队列。

- **左节点的索引是`2 * parentIndex`**
- **右节点的索引是`2 * parentIndex + 1`**

#### 使用场景

##### 求二叉树最大宽度

这是最经典的场景。每一层最右边节点的索引减去最左边节点的索引，再加一，就是该层的宽度。我们只需要在遍历过程中记录每一层出现的最左和最右的索引即可。

##### 判断是否为完全二叉树

一个包含 `n` 个节点的树是完全二叉树，当且仅当所有节点的索引范围在 `[1, n]` 之间，没有间断。

我们可以在遍历时记录节点总数 `n` 和出现过的最大索引 `max_index`，最后判断 `n == max_index` 是否成立。

##### 处理堆相关问题

堆的底层实现就是一个数组，其逻辑结构是完全二叉树。堆的各种操作（上浮、下沉）都依赖于通过索引计算父子节点位置。

##### 需要知道节点在特定层级中的精确位置

例如，求解“一个满二叉树中，第k层的第m个节点是什么”。

**注意**：此方法有一个潜在的缺点。对于一个非常稀疏且深度很深的树（例如，一个长链条），节点的索引值会呈指数级增长 (`2^h`)，可能导致整数溢出。因此，在使用前需要对树的深度和宽度有一个大致的预估。

#### 代码套路模板

##### 求二叉树的最大宽度

```Java
 class Pair {
    TreeNode node;
    int index;
    public Pair(TreeNode node, int index){
        this.node = node;
        this.index = index;
    }
 }
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        Deque<Pair> deque = new LinkedList<>();
        deque.offer(new Pair(root,1));
        int maxWidth = Integer.MIN_VALUE;

        while(!deque.isEmpty()){
            int size = deque.size();
            int width = deque.peekLast().index - deque.peekFirst().index + 1;
            maxWidth = Math.max(width, maxWidth);
            for(int i = 0; i < size; i++){
                Pair curr = deque.pollFirst();
                int currIndex = curr.index;

                if(curr.node.left != null){
                    deque.offer(new Pair(curr.node.left,currIndex * 2));
                }

                if(curr.node.right != null){
                    deque.offer(new Pair(curr.node.right, currIndex * 2 + 1));
                }
            }
        }
        return maxWidth;
    }
}
```

##### 验证是否是二叉树

```Java
 class Pair{
    TreeNode node;
    int index;
    public Pair(TreeNode node, int index){
        this.node = node;
        this.index = index;
    }
 }
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        if(root == null) return true;
        Queue<Pair> queue = new LinkedList<>();
        queue.offer(new Pair(root, 1));
        int nodeCount = 1;
        int maxIndex = 1;

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Pair curr = queue.poll();

                if(curr.node.left != null){
                    int leftIndex = curr.index * 2;
                    queue.offer(new Pair(curr.node.left, leftIndex));
                    maxIndex = Math.max(leftIndex, maxIndex);
                    nodeCount++;
                }

                if(curr.node.right != null){
                    int rightIndex = curr.index * 2 + 1;
                    queue.offer(new Pair(curr.node.right, rightIndex));
                    maxIndex = Math.max(rightIndex, maxIndex);
                    nodeCount++;
                }
            }
        }
        return nodeCount == maxIndex;
    }
}
```

