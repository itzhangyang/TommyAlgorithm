### 1. 问题描述

给定一个文件系统的路径列表 paths（例如 ["/a", "/a/b", "/c/d", "/c/d/e"]）。

任务：如果在系统中存在两个或多个文件夹，它们具有相同的子目录结构

- 相同的子文件夹名，

- 且递归地包含相同的子结构

  则需要删除这些文件夹及其所有子内容。

输出：删除重复文件夹后，剩余的所有路径。

------

### 2. 本质与分析

这道题的本质是 **多叉树的子树同构判定（Subtree Isomorphism）**。

- **数据结构**：文件系统天然是一棵**Trie（字典树）或多叉树**。
- **核心难点**：如何快速判断两个节点（文件夹）下的子树结构是否完全一致。
- **定义一致性**：两个文件夹 A 和 B 相同，意味着：
  1. A 和 B 的所有子节点数量相同。
  2. A 和 B 的对应子节点名字相同。
  3. A 和 B 的对应子节点的子树结构也完全相同。

如果暴力比较任意两棵子树，复杂度极高。因此，我们需要一种方法将“树的结构”转化为“唯一的标识符”。

------

### 3. 核心思想和套路：Merkle Tree（默克尔树）

解决子树同构问题的通用套路是 **序列化（Serialization） + 哈希（Hashing）**。

#### 核心逻辑：

1. **建树**：将路径列表转化为一棵 Trie 树。
2. **后序遍历（Post-order Traversal）**：
   - 要判断当前节点是否重复，必须先知道它的子节点长什么样。
   - 因此使用后序遍历（自底向上），先计算子节点的“签名”，再通过子节点的签名生成当前节点的“签名”。
3. **序列化签名**：
   - 一个节点的唯一签名 = `(子节点1名称 + 子节点1签名) + (子节点2名称 + 子节点2签名) + ...`
   - **关键点**：为了保证唯一性，拼接前必须对子节点按名称进行**排序**。
4. **哈希/分组**：
   - 使用一个 `HashMap<String, List<Node>>` 存储签名对应的节点列表。
   - 如果某个签名对应的节点数量 $>1$，说明这些节点对应的子树结构重复，标记为“待删除”。
5. **清理与输出**：
   - 再次遍历树，跳过被标记删除的节点，收集剩余路径。

------

### 4. 实现步骤

1. **定义节点类 `Node`**：包含名字、子节点 Map (`TreeMap` 自动排序或 `HashMap` 手动排序)、删除标记、完整路径（可选）。
2. **构建 Trie**：遍历 `paths`，插入节点。
3. **计算 Hash/序列化 (DFS)**：
   - 递归处理所有子节点。
   - 收集子节点的序列化字符串。
   - **排序**这些字符串（保证结构相同但插入顺序不同的树被判定为相同）。
   - 拼接生成当前节点的序列化串。
   - 存入全局 Map 统计频率。
4. **标记删除**：遍历 Map，如果某个 Key 对应的 List 大小大于 1，将 List 中所有节点的 `deleted` 标记设为 `true`。
5. **生成结果**：DFS 遍历树，如果遇到 `deleted == true` 的节点直接返回，否则将路径加入结果集。

------

### 5. 实现代码 (Java)

Java

```Java
import java.util.*;

class Solution {
    // 1. 定义 Trie 节点
    class Node {
        String name;
        Map<String, Node> children;
        boolean deleted;
        
        public Node(String name) {
            this.name = name;
            this.children = new HashMap<>(); // 使用 HashMap，排序在序列化时做
            this.deleted = false;
        }
    }

    // 全局 Map 用于存储：序列化字符串 -> 拥有该结构的节点列表
    Map<String, List<Node>> patternMap = new HashMap<>();

    public List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {
        Node root = new Node("/");

        // 2. 构建 Trie 树
        for (List<String> path : paths) {
            Node curr = root;
            for (String folder : path) {
                curr.children.putIfAbsent(folder, new Node(folder));
                curr = curr.children.get(folder);
            }
        }

        // 3. 后序遍历，计算序列化并标记重复
        serialize(root);

        // 4. 标记删除
        for (List<Node> nodes : patternMap.values()) {
            if (nodes.size() > 1) {
                for (Node node : nodes) {
                    node.deleted = true; // 标记该节点及其子树被删除
                }
            }
        }

        // 5. 收集结果
        List<List<String>> result = new ArrayList<>();
        List<String> currentPath = new ArrayList<>();
        collectPaths(root, currentPath, result);

        return result;
    }

    // 核心：序列化子树结构
    private String serialize(Node node) {
        //以此节点为根的子树为空（叶子节点），返回空串
        if (node.children.isEmpty()) {
            return "";
        }

        // 使用 List 存储子节点的 "名字(签名)"，方便排序
        List<String> subFolderSignatures = new ArrayList<>();
        
        for (Map.Entry<String, Node> entry : node.children.entrySet()) {
            String childName = entry.getKey();
            Node childNode = entry.getValue();
            String childSignature = serialize(childNode);
            
            // 格式：name(signature)
            // 这种格式能唯一标识一个分支
            subFolderSignatures.add(childName + "(" + childSignature + ")");
        }

        // 关键：必须排序，保证结构一致性与顺序无关
        Collections.sort(subFolderSignatures);

        // 拼接当前节点的完整签名
        StringBuilder sb = new StringBuilder();
        for (String s : subFolderSignatures) {
            sb.append(s);
        }
        String currentSignature = sb.toString();

        // 只有非空子树才需要判断重复（题目隐含逻辑：叶子节点本身不算重复结构，除非它们有相同的父结构）
        // 这里将签名放入 Map
        patternMap.putIfAbsent(currentSignature, new ArrayList<>());
        patternMap.get(currentSignature).add(node);

        return currentSignature;
    }

    // 收集有效路径
    private void collectPaths(Node node, List<String> currentPath, List<List<String>> result) {
        if (node.deleted) return;

        // 根节点 "/" 不放入路径
        if (!node.name.equals("/")) {
            currentPath.add(node.name);
            result.add(new ArrayList<>(currentPath));
        }

        for (Node child : node.children.values()) {
            collectPaths(child, currentPath, result);
        }

        // 回溯
        if (!node.name.equals("/")) {
            currentPath.remove(currentPath.size() - 1);
        }
    }
}
```

------

### 6. 注意事项与细节

1. **叶子节点处理**：
   - 题目中如果两个文件夹都是空的（叶子节点），它们是否算“结构相同”并删除？
   - 题目逻辑通常指的是**非空子结构**。如果仅仅是两个不同的文件夹 `a` 和 `b` 都没有子文件，它们不应该被删除。
   - **代码处理**：我们在 `serialize` 中，如果 `children` 为空，返回 `""`，**并且不将其加入 `patternMap`**。这样叶子节点就不会参与重复判定，只有拥有子节点的节点才会被判定。
2. **序列化格式**：
   - 格式必须严谨。例如 `a` 下面有 `b`，和 `ab` 下面为空，要能区分开。
   - 使用括号包裹 `name(sub_signature)` 是一种非常稳妥的方式。
3. **排序**：
   - 这是最容易遗漏的一点。文件系统中，文件夹列出的顺序不影响其结构同一性。必须对子节点的序列化结果进行排序。
4. **时间复杂度**：
   - 假设节点数为 $N$，路径平均长度 $L$。
   - 建树：$O(N \cdot L)$。
   - 序列化：每个节点访问一次，但需要对子节点列表排序。最坏情况下复杂度较高，但在文件系统场景下，子文件夹数量通常有限。
   - 整体接近 $O(N \cdot K \log K)$，其中 $K$ 是最大子节点数。

------

### 7. 经验总结

- **遇到“树的子结构相同/重复”问题** $\rightarrow$ **思考序列化**。
- **树的序列化** $\rightarrow$ **DFS (后序遍历) + 字符串拼接**。
- **无序子节点判定** $\rightarrow$ **拼接前必须排序**。
- **高频面试考点**：这道题是 **Merkle Tree** 的简化版应用，Merkle Tree 广泛应用于分布式系统（如 Dynamo, Cassandra）的数据同步校验、Git 的版本管理以及区块链技术中。理解这道题有助于理解这些底层系统的原理。
- 