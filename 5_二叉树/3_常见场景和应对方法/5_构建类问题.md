#构建与修改类问题

| 策略                              | 场景                 | 核心思想                               |
| --------------------------------- | -------------------- | -------------------------------------- |
| 1. 前序 + 中序 构造唯一二叉树     | Leetcode 105         | 前序确定根，中序划分左右子树           |
| 2. 后序 + 中序 构造唯一二叉树     | Leetcode 106         | 后序确定根，中序划分左右子树           |
| 3. 前序 + 后序 构造可能不唯一的树 | Leetcode 889         | 前序根 + 后序划分左右（带不确定性）    |
| 4. 层序构造                       | 自定义题、序列化场景 | 使用队列构造，逐层添加左右子节点       |
| 5. BST构建                        | Leetcode 1008 等     | 利用 BST 性质：左 < 根 < 右            |
| 6. 序列化 / 反序列化              | Leetcode 297/449     | 用特殊分隔符 + DFS/BFS 编码/解码树结构 |

#### 构建套路详解

####Leetcode 105: 前序+中序构建唯一二叉树

###### 核心思想：前序确定根+中序确定边界

- 前序第一个一定是根
- 在中序中找到该根的位置，左边是左子树，右边是右子树
- 递归构建左右子树

###### 实现原理

- 使用一个**哈希表**快速查找中序中某个值的位置
- 用前序的索引控制根位置推进
- 中序的区间划分控制左右子树范围

###### 代码套路模板

1. 找到并构建根节点：**根节点就是`preorder[0]`**
2. 构建**中序索引映射HashMap**
3. 分割左右子树的前序和中序子数组
   1. 找到根节点在中序数组中的位置`rootIndex`
   2. 构建左右子树的中序数组
      1. **左子树的中序数组为inorder[0,rootIndex]**
      2. **右子树的中序数组为inorder[rootIndex,inreder.length-1]**
   3. 构建左右子树的前序数组
      1. **左子树的前序数组为preorder[1,左子树size]**
      2. **右子树的前序数组为preorder[左子树size+1, preorder.length-1]**
4. 利用左右子树的中序和前序数组，递归构建左右子树
   1. `root.left = build(leftPreorder,leftInorder)`
   2. `root.right = build(rightPreorder, rightInorder)`

```java
TreeNode build(int[] preoder, int[] inorder){
  if (preorder.length ==0 ) return null;
  
  //找到root节点
  int rootVal = preorder[0];
  TreeNode root = new TreeNode(rootVal);
  
  // 使用Map快速查找中序中某个值的位置
	Map<Integer, Integer> indexMap = new HashMap();
  for (int i = 0; i< inorder.length;i++){
    indexMap.put(inorder[i],i);
  }
  
  //在中序数组中找到当前根的位置
  int rootIndex = indexMap.get(rootVal);
  
  //划分左右子树的中序和前序数组
  int[] leftInOrder = Arrays.copyOfRange(inorder,0,rootIndex);
  int[] rightInorder = Arrays.copyOfRange(inorder,rootIndex+1, inorder.length);
  
  //左子树的前序数组为 preorder[1...左子树size]
  int[] leftPreorder = Arrays.copyOfRange(preorder,1,1+leftInorder.length);
  //右子树的前序数组为 preorder[左子树size+1,右子树size]
  int[] rightPreorder = Arrays.copyOfRange(preorder,1+leftInorder.length,preorder.length);
  
  //递归构建左右子树
  root.left = build(leftPreoder,leftInorder);
  root.right = build(rightPreorder,rightInorder);
 
  return root;
}
```

####Leetcode 106: 中序+后序构建唯一二叉树

###### 核心思想

- 后序第一个是根
- 中序划分左右子树
- 递归构建

###### 实现原理

- 使用一个**哈希表**保存中序数组的索引映射
- 通过**后序数组**寻找并构建根节点
- 通过**根节点**在中序数组中的位置：
  - **切割**左子树和右子树的**中序数组**
    - `leftInorder = inorder[0....rootIndex]`
    - `rightInorder = inorder[rootIndex+1,end]`
  - 计算**左子树和右子树的节点数量**
- 通过左子树和右子树的**节点数量**，切割**后序数组**
  - `leftPorstorder = postorder[0....leftTreeSize]`
  - `rightPostOrder = porstorder[leftTreeSize+1,postorder.length-2]`

###### 实现代码

```java
public TreeNode build(int[] postorder, int[] inorder){
  if (inorder.length ==0 ) return null;
  int n = postorder.length;
  int rootVal = postorder[n-1];
  
  TreeNode root = new TreeNode(rootVal);
  
  Map<Integer, Integer> map = new HashMap<>();
  
  for (int i=0; i<n; i++){
    map.put(inorder[i],i);
  }
  
  int rootIndex = map.get(rootVal);
  
  int[] leftInorder = Arrays.copyOfRange(0,rootIndex);
  int[] rightInorder = Arrays.copyOfRange(rootIndex+1,n);
  
  int leftSize = leftInorder.length;
  int[] leftPostorder = Arrays.copyOfRange(0,leftSize);
  int[] rightPostorder = Arrays.copyOfRange(leftSize,n-1);
  
  root.left = build(leftPostorder,leftInorder);
  root.right = build(rightPostOrder,rightInorder);
 
}
```

#### 利用中序构建平衡搜索二叉树

##### 平衡二叉搜索树的特性有哪些？

- 对于任何一个节点而言，左子树和右子树的深度差不超过1
- 搜索二叉树的特性 左 < 中 < 右

##### 中序数组的特性-升序 

按照升序排列

##### 问题分析

###### 怎么保证左子树和右子树的高度差不超过1？

确保对于每一个节点而言，**其左子节点数量和右子节点的数量差不超过1**

##### 核心思想和套路 - 二分

取数组的中点，构建当前节点：

- 递归调用构建函数，利用数组的左半段构建左子树
- 递归调用构建函数，利用数组的右半段构建右子树

##### 实现代码

```java
    public TreeNode sortedArrayToBST(int[] nums) {
        int n = nums.length;
        return buildTree(nums,0,n-1);
    }

    private TreeNode buildTree(int[] nums, int i, int j){
        if (i > j) {
        return null;  // Base case: return null when the range is invalid
        }
        int mid = (i + j) /2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = buildTree(nums, i, mid-1);
        node.right = buildTree(nums,mid+1,j);
        return node;
    }
```

##### 注意事项

- 注意Base condition条件为`i > j`

#### Leetcode 95 不同的二叉搜索树II

給定一個整數 `n`，請生成並返回所有由 `1` 到 `n` 這 `n` 個數字作為節點值，且結構上互不相同的 **二元搜尋樹 (Binary Search Tree, BST)**。

##### 问题要点

**輸入 (Input)**: 一個整數 `n`。

**輸出 (Output)**: 一個 `List<TreeNode>`，其中包含所有可能的、以 `1...n` 為節點值的唯一結構的二元搜尋樹的根節點。

**核心限制 (Constraint)**: 生成的樹必須是「二元搜尋樹 (BST)」，意味著對於任何節點：

- 其左子樹中的所有節點值都小於該節點值
- 右子樹中的所有節點值都大於該節點值

##### 问题本质和分析

問題的本質是**構造所有可能**的組合，而不是像 LeetCode 96 那樣僅僅是**計數**。

這意味著我們必須實際建立每一棵樹。

對於一個 BST，一旦我們選定了根節點 `i`，那麼根據 BST 的性質：

- 所有小於 `i` 的數字 (`1, 2, ..., i-1`) 必須全部位於其**左子樹**。
- 所有大於 `i` 的數字 (`i+1, ..., n`) 必須全部位於其**右子樹**。

這就巧妙地將一個大問題分解成了兩個完全獨立的子問題：

1. 用 `1, ..., i-1` 這些數字構造所有可能的左子樹。
2. 用 `i+1, ..., n` 這些數字構造所有可能的右子樹。

最終，以 `i` 為根的全部 BST 組合，就是將第一步得到的所有左子樹和第二步得到的所有右子樹進行**笛卡爾積 (Cartesian Product)** 組合的結果。



舉例 `n=3`，如果選擇 `2` 作為根：

- 左子樹必須由 `{1}` 構成。只有一種可能。
- 右子樹必須由 `{3}` 構成。也只有一種可能。
- 組合起來，以 `2` 為根的樹就只有一種。



如果選擇 `1` 作為根：

- 左子樹是空的。
- 右子樹由 `{2, 3}` 構成。這本身又是一個子問題，它有兩種可能的樹結構。
- 組合起來，以 `1` 為根的樹就有兩種。

##### 模式匹配 - 分治 + 动态规划

###### 分治递归 - 选择一个元素作为分割点（根）

这是最核心的模式。

选择一个元素作为当前问题的“分割点”（即**根节点**），将问题分解为更小的、独立的子问题（左右子树），递归解决子问题，最后合并子问题的解。

###### 动态规划 - 解决重复计算问题

在递归过程中，我们会发现许多子问题被**重复计算**。

例如，在`n=5`时，计算`[1, 2]`范围的子树，会在选择`3`为根时（作为左子树）和选择`4`为根时（也作为左子树的一部分）被重复调用。

这提示我们可以用**记忆化 (Memoization)**来存储子问题的解，避免重复计算，这是**自顶向下DP**的典型特征。

###### 组合而成

问题的目标是生成所有可能的组合（这里是树结构），而不是简单计数。

这类问题通常通过递归回溯或分治来穷举所有可能性。



##### 核心思想与套路 

定义一个函数，比如 `build(start, end)`，它的功能是生成由 `start` 到 `end` 范围内的所有数字构成的全部可能的BST。

###### 核心套路 - 分治

1. **选择根节点**: 遍历 `i` 从 `start` 到 `end`，让 `i` 依次作为当前范围的**根节点**。

2. **划分并递归**:

   对于每一个根 `i`，左子树的节点范围是 `[start, i-1]`。

   我们递归调用 `build(start, i-1)` 来获取所有可能的左子树列表（`List<TreeNode> leftSubtrees`）。

   右子树的节点范围是 `[i+1, end]`。

   我们递归调用 `build(i+1, end)` 来获取所有可能的右子树列表（`List<TreeNode> rightSubtrees`）。

3. **组合结果 (Cartesian Product)**: 这是一个笛卡尔积的计算过程

   我们得到了所有可能的左子树和所有可能的右子树。

   现在需要将它们组合起来：

   使用嵌套循环，遍历 `leftSubtrees` 中的每一个左子树 `leftNode`：

   - 再遍历 `rightSubtrees` 中的每一个右子树 `rightNode`。

   - 对于每一对 `(leftNode, rightNode)`，创建一个新的根 `new TreeNode(i)`，并将其左右孩子分别指向 `leftNode` 和 `rightNode`。

   - 将这个新生成的树加入到当前 `build(start, end)` 的结果列表中。

4. **处理递归边界：**

   - 当 `start > end` 时，表示这是一个空区间，无法构成节点。此时应该构建一棵“空树”。在程序中，我们用 `null` 来表示空树。

   - **一个至关重要的细节**: `build` 函数应该返回一个列表。对于空区间，我们不应该返回一个空列表 `[]`，而应该返回一个**包含 `null` 元素的列表 `[null]`**。

     **为什么？** 思考一下：当 `i=start` 时，左子树范围是 `[start, start-1]`，是空区间。

     如果 `build` 返回空列表 `[]`，那么 `for (TreeNode leftNode : leftSubtrees)` 这个循环将一次都不会执行，我们就无法生成“只有右子树”的树。

     如果返回 `[null]`，循环会执行一次，`leftNode` 取值为 `null`，正确地与所有可能的右子树进行组合。

###### 为什么可以使用动态规划解决？

從動態規劃的角度看，這個問題的本質是它具備了兩個核心特性：

1. **最優子結構 (Optimal Substructure)**: 一個大問題的解可以由其子問題的解來構造。

   具體來說，使**用數字 `[i, j]` 構造的所有 BST，可以由其子區間 `[i, k-1]`（左子樹）和 `[k+1, j]`（右子樹）的所有 BST 組合而成**。

2. **重疊子問題 (Overlapping Subproblems)**: 在計算過程中，同一個子問題會被多次需要。

   例如，在計算 `n=5` 時，構造 `[1, 3]` 區間的樹和構造 `[2, 4]` 區間的樹，都會依賴於構造 `[2, 2]` 這個子問題的解。

- **識別特徵**:
  - 問題的狀態可以用一個區間 `[i, j]` 來定義。
  - 最終目標是求解整個區間 `[1, n]`。
  - 狀態轉移通常是通過枚舉區間 `[i, j]` 內的一個「分割點」`k`，將問題分解為更小的子區間（如 `[i, k-1]` 和 `[k+1, j]`）來實現。

這是一個非常典型的區間 DP 模式，其解法通常是通過一個二維 `dp` 陣列來存儲區間解，並按區間長度從小到大的順序進行迭代。

###### 怎样使用动态规划解决？

1. **状态定义：** `dp[i][j]`是一个`List<TreeNode>`，存储了由数字`i`到`j`构成的所有BST
2. **确定迭代顺序**：我们的目标是**从小区间的解构建大区间的解**，因此最外层的遍历必须是**区间的长度**，从1到n.
3. **初始化：**
   - 创建`dp`表：`dp[n+2][n+2]`
   - 为所有`dp[i][i-1]`即（空区间）初始化一个包含`null`的表。这是所有递推的起点。
4. **状态转移：**
   - 遍歷**長度 `len`** (從 1 到 n)。
   - 遍歷**起始點 `i`** (從 1 到 n-len+1)。
   - 計算**終點 `j`** (`j = i + len - 1`)。
   - 遍歷**根節點 `k`** (從 i 到 j)。
     - 從 `dp` 表中取出已計算好的左子樹列表 `dp[i][k-1]` 和右子樹列表 `dp[k+1][j]`。
     - 通過雙重迴圈將**左右子樹進行笛卡爾積**組合，生成以 `k` 為根的新樹，並添加到 `dp[i][j]` 中。
5. **獲取結果**: 整個 DP 表填充完畢後，`dp[1][n]` 即為最終答案。

##### 难点分析和应对

###### 难点一：迭代顺序的确定

**問題**: 很多初學者會習慣性地從 `i` 和 `j` 開始迴圈，但這樣會發現在計算 `dp[i][j]` 時，其依賴的子問題（如 `dp[i+1][j]`）可能還未被計算。

**應對**: 深刻理解區間 DP 的核心——**按長度迭代**。始終將區間長度 `len` 作為最外層迴圈，確保在計算任何長度為 `len` 的區間時，所有長度小於 `len` 的區間都已經計算完畢。

###### 難點 2: 邊界條件和空子樹的處理

**問題**: 當根為 `k=i` 時，左子樹為空；當根為 `k=j` 時，右子樹為空。如何統一處理這些情況？

**應對**: 在初始化階段，就將所有代表「空區間」的 `dp[i][i-1]` 設置為一個包含 `null` 的列表 `[null]`。

這樣，在狀態轉移的迴圈中，無論子區間是否為空，都能從 DP 表中取出一個非空列表（至少包含 `null`），讓雙重迴圈邏輯保持統一和簡潔。

###### 难点三： 索引管理

- - **問題**: 涉及 `len`, `i`, `j`, `k` 四個變數，很容易在索引計算和迴圈邊界上出錯。

  - **應對**:

    1. 思路清晰：牢記每個變數的含義。

    2. 使用稍大一點的 DP 表（如 `n+2` x `n+2`）可以避免很多邊界 `if` 判斷，讓代碼更乾淨。

    3. 動手在紙上模擬 `n=3` 的情況，可以幫助理清索引關係。

         

##### 实现原理和步骤

###### 主函数`generateTrees(n)`

- 处理 `n=0` 的特殊情况，返回一个空列表。

- 调用递归辅助函数 `build(1, n)`。

###### 递归辅助函数`build(start,end)`

- **定义DP数组** 

  创建一个二维数组 `dp[n+1][n+1]`，类型为 `List<TreeNode>`，用于缓存计算结果。

  在函数开头，检查 `dp[start][end]` 是否已经计算过，如果计算过，直接返回缓存的结果。

- **创建结果列表**: `List<TreeNode> res = new ArrayList<>();`

- **处理Base Case**: 如果 `start > end`，向 `res` 中添加 `null`，然后返回 `res`。

- **主循环**: `for (int i = start; i <= end; i++)`

  - `List<TreeNode> leftSubtrees = build(start, i - 1);`
  - `List<TreeNode> rightSubtrees = build(i + 1, end);`

- **组合循环**:

  - `for (TreeNode left : leftSubtrees)`
  - `for (TreeNode right : rightSubtrees)`
    - `TreeNode root = new TreeNode(i);`
    - `root.left = left;`
    - `root.right = right;`
    - `res.add(root);`

- **缓存并返回**: 在函数末尾，将 `res` 存入 `memo[start][end]`，然后返回 `res`。

##### 实现代码

```java
class Solution {
    // 使用一个二维数组作为备忘录，缓存计算过的子问题的结果
    private List<TreeNode>[][] memo;

    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new ArrayList<>();
        }
        // 初始化备忘录，大小为 (n+1) x (n+1)
        memo = new ArrayList[n + 1][n + 1];
        return build(1, n);
    }

    /**
     * 递归函数，用于构建由 [start, end] 范围内数字组成的所有唯一BST
     * @param start 范围的起始值
     * @param end 范围的结束值
     * @return 一个列表，包含所有可能的BST的根节点
     */
    private List<TreeNode> build(int start, int end) {
        // Base Case: 如果范围无效，返回一个包含 null 的列表
        if (start > end) {
            List<TreeNode> res = new ArrayList<>();
            res.add(null);
            return res;
        }

        // 检查备忘录，如果已经计算过，直接返回结果
        if (memo[start][end] != null) {
            return memo[start][end];
        }

        List<TreeNode> result = new ArrayList<>();

        // 1. 遍历所有可能的根节点
        for (int i = start; i <= end; i++) {
            // 2. 递归构建所有可能的左子树
            List<TreeNode> leftSubtrees = build(start, i - 1);
            
            // 3. 递归构建所有可能的右子树
            List<TreeNode> rightSubtrees = build(i + 1, end);
            
            // 4. 组合左右子树
            for (TreeNode left : leftSubtrees) {
                for (TreeNode right : rightSubtrees) {
                    // 创建根节点
                    TreeNode root = new TreeNode(i);
                    // 连接左右子树
                    root.left = left;
                    root.right = right;
                    // 将新构建的树加入结果列表
                    result.add(root);
                }
            }
        }
        
        // 将当前范围的结果存入备忘录
        memo[start][end] = result;
        
        return result;
    }
}
```

##### 注意事项

1. **Base Case 的 `[null]` 返回值**：再次强调，这是此题最关键的技巧。返回空列表 `[]` 会导致逻辑错误，无法生成只有单侧子树的结构。
2. **记忆化的必要性**：若不使用记忆化，纯粹的递归解法会因为大量重复计算而严重超时（Time Limit Exceeded）。子问题 `build(start, end)` 的重复性非常高。
3. **指针和对象**: 在组合左右子树时，我们是直接将 `left` 和 `right` 指针赋给新 `root` 的 `left` 和 `right` 字段。我们不需要深拷贝子树，因为这些子树结构在一次组合中是固定的，这既高效又正确。
4. **备忘录的索引**: 备忘录数组 `memo` 的大小设为 `[n+1][n+1]` 是为了让数字范围 `1` 到 `n` 能直接用作数组索引，代码更直观。

##### 经验总结

**从计数到构造**: 许多算法问题都有“计数”和“构造”两个版本。计数问题通常可以用DP求解，状态是数值。构造问题也常用DP（或记忆化递归），但状态是构造出的对象集合（如本题的 `List<TreeNode>`）。

**分治是生成组合结构的利器**: 当一个复杂对象可以由“一个选择 + 多个子问题对象的组合”定义时，分治法就是天然的解法。本题的“一个根 + 左子树集合 + 右子树集合”就是典型模式。

**识别递归中的重复**: 在写递归解法时，要时刻思考“这个函数会不会被同样的参数重复调用？”。如果会，那么记忆化就是必不可少的优化手段，能将指数级复杂度降低到多项式级。

**`null` 的妙用**: 在树的递归构造中，`null` 不仅仅是“无”，它也是一种合法的结构（空树）。在需要返回集合的场景下，用 `[null]` 来代表“所有可能的空树集合”（这个集合里只有一个成员，就是`null`本身），是一个非常优雅的处理方式。

#### Leetcode 96: 不同的二叉搜索树

##### 问题要点

**输入**: 一个正整数 `n`。

**目标**: 计算由 `1, 2, ..., n` 这 `n` 个节点，可以构成多少种**结构上唯一**的二叉搜索树 (BST)。

**输出**: 一个整数，代表 BST 的总数量。

与 Leetcode95的核心区别：

**LC 95 (构造)**: 要求生成所有可能的树结构。

**LC 96 (计数)**: 只要求计算出总共有多少种结构，无需生成它们。这通常意味着问题可以用更简单的DP状态（数值而非对象列表）来解决。

##### 问题本质和分析

这是一个组合计数问题。

其本质与 LeetCode 95 的分析完全相同：一棵BST的结构由其根节点唯一确定地划分为左右子树。

令 `G(n)` 为用 `n` 个不同节点（例如 `1...n`）可以构成的不同BST的数量。

我们来分析如何计算 `G(n)`。

我们可以依次选择 `1, 2, ..., n` 中的每一个数 `i`作为根节点：

**当 `i` 作为根节点时**:

- 其左子树必须由所有小于 `i` 的数构成，即 `{1, 2, ..., i-1}`。这共有 `i-1` 个节点。用这 `i-1` 个节点能构成的不同左子树的数量是 `G(i-1)`。
- 其右子树必须由所有大于 `i` 的数构成，即 `{i+1, ..., n}`。这共有 `n-i` 个节点。用这 `n-i` 个节点能构成的不同右子树的数量是 `G(n-i)`。

**一个关键的抽象**: 

BST的结构数量只与节点的**数量**有关，与节点的**具体数值**无关。

例如，用 `{1, 2}` 构成的BST数量，和用 `{5, 6}` 构成的BST数量是完全一样的。

因此，由 `n-i` 个数 `{i+1, ..., n}` 构成的BST数量就是 `G(n-i)`。

根据**乘法原理**，当根为 `i` 时，总的BST数量是 $G(i-1) * G(n-i)$。

最后，根据加法原理，我们将所有可能的根节点 `i` (从 `1` 到 `n`) 的情况相加，就得到了 `G(n)` 的总数。

于是，我们得到了一个递推公式：

$$G(n) = \sum_{i=1}^n G(i-1) \times G(n-i)$$



##### 模式匹配 - 动态规划

上述的递推公式 `G(n)` 依赖于 `G(0), G(1), ..., G(n-1)` 的解。

这是一个完美的DP问题。

我们可以创建一个DP数组，**自底向上**地计算出 `G(0), G(1), ..., G(n)`。



##### 核心思想

**核心思想**：利用动态规划，将 `n` 个节点的问题，分解为求解更少节点（`0` 到 `n-1` 个）的子问题。

######**定义 DP 状态**:

- `dp[i]` 表示：用 `i` 个节点能够构成的不同二叉搜索树的总数量。
- 我们的目标是求解 `dp[n]`。

###### 确定状态转移方程

- 根据上面的分析，`dp[i]` 的值是通过枚举根节点，然后将左右子树的可能性相乘再相加得到的。
- 如果我们有 `i` 个节点，让 `j` (`1 <= j <= i`) 作为根节点。
- 左子树有 `j-1` 个节点，可能性为 `dp[j-1]`。
- 右子树有 `i-j` 个节点，可能性为 `dp[i-j]`。
- 因此，$dp[i] = \sum_{j=1}^{i} dp[j-1] \times dp[i-j]$。

###### 确定Base cases

- `dp[0] = 1`。

  这是一个至关重要的、非直观的 base case。

  它代表一个**空集**只能构成**一种**树结构，

  即“空树”（`null`）。

  这保证了当子树为空时（例如根为`1`，左子树有`0`个节点），公式 `dp[0] * dp[i-1]` 能够正确计算。

  如果 `dp[0]=0`，所有计算结果都会是0。

- `dp[1] = 1`。**但是不需要初始化！**

  1个节点只能构成一种树（就是它自己）。

  我们可以用公式验证：`dp[1] = dp[0] * dp[0] = 1 * 1 = 1`。

  `dp` 数组在 `new int[n+1]` 时，所有元素默认初始化为 `0`。

  让我们再精确地跟踪一次：

  - `int[] dp = new int[n+1];`  -> `dp` 数组所有值为 `0`
  - `dp[0] = 1;` -> `dp[0]` 变为 `1`
  - `dp[1] = 1;` -> `dp[1]` 变为 `1`
  - **进入循环 `i=1`:**
    - `j=1` 时，执行 `dp[1] += dp[0] * dp[0];`
    - 此时 `dp[1]` 的值是 `1`，`dp[0]` 的值是 `1`。
    - 这行代码变成了 `dp[1] = 1 + (1 * 1)`，结果 `dp[1]` 会被错误地计算成 `2`。

###### 确定计算顺序

我们显然需要从 `dp[0]` 开始，依次计算 `dp[1], dp[2], ...` 直到 `dp[n]`。

这是一个标准的**自底向上**的计算过程。

##### 实现原理和步骤

1. **处理特殊情况**: 如果 `n=0`，返回1（或者根据题意，如果 `n` 保证为正，则可忽略）。

2. **创建 DP 数组**: `int[] dp = new int[n + 1];`

3. **初始化 Base Case**: `dp[0] = 1;`

4. **外层循环**: 遍历我们要计算的DP状态，`for (int i = 1; i <= n; i++)`。这个 `i` 代表当前要计算的节点总数。

5. **内层循环**: 遍历所有可能的根节点选择，`for (int j = 1; j <= i; j++)`。

   这个 `j` 代表根节点在 `1...i` 序列中的位置（也可以理解为左子树的节点数+1）。

6. 在 `dp[i]` 的计算中，累加 `dp[j-1] * dp[i-j]`。

7. `dp[i] += dp[j-1] * dp[i-j];`

8. **返回结果**: 循环结束后，`dp[n]` 中存储的就是最终答案，返回 `dp[n]`。

##### 实现代码

```java
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        
        return dp[n];
    }
```

##### 注意事项

**`dp[0] = 1`的理解**: 这是整个DP能够正确工作的基石。你可以这样理解：当 `n=1` 时，根是`1`，左子树有0个节点，右子树有0个节点。其总数是 `dp[0] * dp[0]`。我们知道 `n=1` 时只有1种树，所以 `dp[0] * dp[0]` 必须等于 `1`，因此 `dp[0]` 必须是 `1`。

**循环的含义**: 外层循环 `i` 是在填充DP表，从 `dp[1]` 一直计算到 `dp[n]`。内层循环 `j` 是在应用DP递推公式，通过枚举所有可能的根节点位置来计算当前的 `dp[i]`。

**数据类型**: `n` 的最大值是19，`n=19` 时的卡特兰数是 `1,767,263,190`，在 `int` 的范围内。如果 `n` 更大，需要使用 `long`。

##### 经验总结

- **从构造到计数是降维**: 比较 LC95 和 LC96，可以深刻体会到，当问题从“构造所有解”简化为“计算解的数量”时，DP的状态通常可以“降维”。我们不再需要存储 `List<TreeNode>`，只需要一个 `int` 就够了，这大大简化了问题。
- **识别核心递推关系**: 很多DP问题的关键在于找到问题规模 `n` 与 `n-1`, `n-2`... 等更小规模问题之间的数学关系。本题的 `G(n) = Σ G(i-1) * G(n-i)` 就是这个核心。
- **重视`dp[0]`**: 在动态规划中，`dp[0]` 或类似的基础状态的定义往往是解决问题的关键。一定要仔细思考 "0个物品"、"空字符串"、"空树" 等情况的价值，它通常是递推公式的起点。

## 二叉树的序列化与反序列化

### 问题定义

- 反转树
- 展开为链表
- 将树的结构保存为字符串

### 核心思想

#### 树的修改

递归的队子树进行操作，通常在后序位置完成对当前节点的指针修改。

#### 树的序列化

关键是必须包含空节点信息才能唯一确定树的结构。

常用前序遍历来序列化、反序列化，反序列化时时候**队列**辅助按照相同顺序构建。

### Leetcode 297: 二叉树的序列化和反序列化

#### 问题要点

这是一个设计题，要求你设计一个算法，将一个二叉树转换成一个字符串（序列化），并且能够将这个字符串再转换回原来的二叉树（反序列化）。

1. **序列化 (Serialize)**: 输入一个二叉树的根节点 `root`，输出一个表示该树结构的字符串。
2. **反序列化 (Deserialize)**: 输入一个经过序列化后的字符串，输出恢复后的二叉树的根节点。
3. **正确性**: 经过序列化再反序列化之后，得到的二叉树必须与原始二叉树完全相同。
4. **无格式限制**: LeetCode 明确指出，你如何设计序列化/反序列化的格式和算法都可以，只要能保证可逆即可。

#### 问题本质和分析

问题的本质是将一个二维的、具有层级关系的数据结构（树）无损地编码（Encode）成一个一维的线性数据结构（字符串），并能够从这个一维结构中解码（Decode）出完全相同的二维结构。

核心挑战在于，我们不仅要保存每个节点的值，还必须完整地保存节点之间的父子关系，即**树的结构**。

如果我们只使用常规的树遍历（如中序遍历）来记录节点值，会丢失结构信息。

例如，对于中序遍历结果 `[1, 2, 3]`，我们无法确定根节点是 1, 2, 还是 3，因此无法唯一地重建树。

为了解决这个问题，我们必须在遍历过程中加入额外的信息来标记树的结构。

最直接有效的方法就是**记录空指针 `null`**。

通过记录 `null` 子节点，我们就能精确地知道每个节点的子节点情况，从而保证了树结构的唯一性。

#### 模式套路匹配

##### 树的遍历

这是解决所有树问题的基础。此题的核心就是选择一种合适的遍历方式来线性化树的结构。

##### 前序遍历

它的“根-左-右”顺序非常适合递归地构建和解析树。处理完根节点后，可以立即递归处理左子树，然后递归处理右子树，逻辑非常清晰。

##### 广度优先搜索

它按层级顺序处理节点，非常直观。使用队列 (Queue) 可以很自然地实现。

#### 核心思想和套路

##### 套路一：基于深度优先遍历（前序遍历）

###### 序列化的过程 - 采用前序遍历的过程

采用“根-左-右”的顺序遍历树。当遇到一个节点时，记录下它的值；

如果遇到一个空指针 `null`，则记录一个特殊的标记（如 "null" 或 "#"）。节点值之间用分隔符（如 ","）隔开。

###### 反序列化的过程 - 基于队列

将字符串按分隔符分割成一个列表或队列。

然后递归地构建树。每次从列表/队列头部取出一个值：

- 如果值是 `null` 标记，说明这里是一个空节点，返回 `null`。
- 如果值是数字，就创建一个新节点，然后**递归地调用自身来构建该节点的左子树**，接着**再递归调用自身构建右子树**。

##### 为什么前序遍历有效？

因为前序遍历首先访问根节点。

在反序列化时，我们读取的第一个值就是当前子树的根。

然后我们知道接下来的数据块描述的是它的左子树，再往后的数据块描述的是它的右子树。

这种结构与递归的定义完美契合。



##### 套路二： 基于广度优先遍历

###### 序列化的过程

- **序列化**: 使用一个队列 (Queue) 来进行层序遍历。
  1. 将根节点入队。
  2. 当队列不为空时，出队一个节点。
  3. 记录该节点的值（如果是 `null` 就记录特殊标记）。
  4. 如果该节点非空，则将其左、右子节点（即使是 `null`）都入队。

###### 反序列化过程

1. 将字符串分割成节点值列表。第一个值是根节点，创建它。

2. 使用一个队列，并将根节点入队。这个队列用来存放待连接子节点的父节点。

3. 遍历节点值列表（从第二个元素开始），每次取两个值，分别对应队头父节点的左、右子节点。

4. 创建左、右子节点（如果值不是 `null` 标记），并连接到父节点上。如果创建了新节点，也需要将它们入队，因为它们未来也需要连接自己的子节点。

#### 实现原理和步骤

##### 基于前序遍历的实现

######序列化 (Serialize)

1. 创建一个 `StringBuilder` 用于高效拼接字符串。
2. 定义一个递归辅助函数 `buildString(TreeNode node, StringBuilder sb)`。
3. **递归基线 (Base Case)**: 如果当前节点 `node` 为 `null`，向 `sb` 追加 "null" 和一个分隔符 ","。然后返回。
4. **递归步骤**: a. 向 `sb` 追加当前节点的值 `node.val` 和一个分隔符 ","。 b. 递归调用 `buildString(node.left, sb)` 来序列化左子树。 c. 递归调用 `buildString(node.right, sb)` 来序列化右子树。
5. 主函数 `serialize` 调用这个辅助函数，并返回 `sb.toString()`。

**示例**: 树 `[1, 2, 3, null, null, 4, 5]` 序列化结果: `"1,2,null,null,3,4,null,null,5,null,null,"`

######反序列化 (Deserialize)

1. 将输入的字符串按分隔符 "," 分割成一个字符串列表 `List<String>`。

2. 为了方便按顺序消耗节点值，最好将列表转换成队列 `Queue<String>`。

3. 定义一个递归辅助函数 `buildTree(Queue<String> nodes)`。

4. **递归步骤**: 

   a. 从队列中取出一个字符串 `val = nodes.poll()`。 

   b. **递归基线 (Base Case)**: 如果 `val` 等于 "null"，说明这是一个空节点，直接返回 `null`。

    c. 创建一个新的树节点 `TreeNode node`，其值为 `Integer.parseInt(val)`。

    d. 递归调用 `node.left = buildTree(nodes)` 来构建左子树。 e. 递归调用 `node.right = buildTree(nodes)` 来构建右子树。

    f. 返回创建的节点 `node`。

5. 主函数 `deserialize` 准备好队列，并调用辅助函数返回最终的树根。

##### 基于BFS的是实现

###### 序列化

**处理空树**: 如果根节点 `root` 为 `null`，直接返回空字符串 `""`。

**初始化**:

- 创建一个队列 `Queue<TreeNode>`，并将根节点 `root` 入队。
- 创建一个 `StringBuilder` 用于拼接最终的字符串。

**层序遍历**:

- 当队列不为空时，开始循环。
- 从队列中取出一个节点 `node`。
- **处理当前节点**:
  - 如果 `node` 为 `null`，向 `StringBuilder` 中追加 `null` 标记 (例如 "null") 和分隔符。然后继续下一次循环（因为 `null` 节点没有子节点）。
  - 如果 `node` 不为 `null`，向 `StringBuilder` 中追加节点的值和分隔符。
- **处理子节点**:
  - 如果当前节点 `node` **不为 null**，则将其左子节点 `node.left` 和右子节点 `node.right` **依次入队**。**关键点在于：无论子节点是否为 `null`，都必须将它们入队**，这样才能完整地记录树的结构。

**返回结果**: 循环结束后，`StringBuilder` 中就包含了完整的层序遍历序列化字符串。

###### 反序列化

**处理空输入**: 如果输入字符串 `data` 为空，直接返回 `null`。

**初始化**:

- 将字符串按分隔符分割成一个数组 `nodesArray`。
- 创建根节点。数组的第一个元素 `nodesArray[0]` 就是根节点的值。`TreeNode root = new TreeNode(Integer.parseInt(nodesArray[0]))`。
- 创建一个队列 `Queue<TreeNode>`，并将根节点 `root` 入队。

**按层构建树**:

- 使用一个指针 `i`（初始为 1）来遍历 `nodesArray`。
- 当队列不为空时，开始循环。
- 从队列中取出一个父节点 `parent`。
- **构建左子节点**:
  - 读取 `nodesArray[i]`。如果它不是 `null` 标记，就创建一个新的左子节点，并将其连接到 `parent.left`。
  - 然后将这个**新的左子节点入队**，因为它将来也需要连接自己的子节点。
  - `i` 指针后移一位。
- **构建右子节点**:
  - 读取 `nodesArray[i]`。如果它不是 `null` 标记，就创建一个新的右子节点，并将其连接到 `parent.right`。
  - 然后将这个**新的右子节点入队**。
  - `i` 指针再后移一位。

**返回结果**: 当 `nodesArray` 被遍历完后，整棵树就构建完成了。返回 `root`。

#### 实现代码

##### 基于前序遍历

```Java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

// Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Codec {

    private static final String NULL_SYMBOL = "null";
    private static final String SEPARATOR = ",";

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) {
            return ""; // 或者返回 NULL_SYMBOL，取决于反序列化的实现
        }
        StringBuilder sb = new StringBuilder();
        buildString(root, sb);
        return sb.toString();
    }
    
    // 递归辅助函数，用于序列化
    private void buildString(TreeNode node, StringBuilder sb) {
        if (node == null) {
            sb.append(NULL_SYMBOL).append(SEPARATOR);
        } else {
            sb.append(node.val).append(SEPARATOR);
            buildString(node.left, sb);
            buildString(node.right, sb);
        }
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || data.isEmpty()) {
            return null;
        }
        
        String[] nodesArray = data.split(SEPARATOR);
        // 使用 LinkedList 实现 Queue，方便 poll 操作
        Queue<String> nodesQueue = new LinkedList<>(Arrays.asList(nodesArray));
        return buildTree(nodesQueue);
    }
    
    // 递归辅助函数，用于反序列化
    private TreeNode buildTree(Queue<String> nodes) {
        String val = nodes.poll();
        
        if (val == null || val.equals(NULL_SYMBOL)) {
            return null;
        }
        
        TreeNode node = new TreeNode(Integer.parseInt(val));
        node.left = buildTree(nodes);
        node.right = buildTree(nodes);
        
        return node;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```



##### 基于BFS

```Java
import java.util.LinkedList;
import java.util.Queue;

// TreeNode 定义同上一个回答
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}


public class Codec {

    private static final String NULL_SYMBOL = "null";
    private static final String SEPARATOR = ",";

    // Encodes a tree to a single string using BFS.
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                sb.append(NULL_SYMBOL).append(SEPARATOR);
                continue; // null 节点没有子节点，直接进入下一次循环
            }

            sb.append(node.val).append(SEPARATOR);
            queue.offer(node.left);
            queue.offer(node.right);
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree using BFS.
    public TreeNode deserialize(String data) {
        if (data == null || data.isEmpty()) {
            return null;
        }

        String[] nodesArray = data.split(SEPARATOR);
        
        // 第一个元素是根节点的值
        TreeNode root = new TreeNode(Integer.parseInt(nodesArray[0]));
        
        // 队列用于存放待处理的父节点
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        // 从索引 1 开始，每次循环处理一对子节点（左和右）
        for (int i = 1; i < nodesArray.length; ) {
            TreeNode parent = queue.poll();

            // 处理左子节点
            if (!nodesArray[i].equals(NULL_SYMBOL)) {
                TreeNode leftChild = new TreeNode(Integer.parseInt(nodesArray[i]));
                parent.left = leftChild;
                queue.offer(leftChild);
            }
            i++; // 移动到右子节点的位置

            // 检查是否数组越界，因为最后一个父节点可能只有一个左孩子
            if (i < nodesArray.length) {
                // 处理右子节点
                 if (!nodesArray[i].equals(NULL_SYMBOL)) {
                    TreeNode rightChild = new TreeNode(Integer.parseInt(nodesArray[i]));
                    parent.right = rightChild;
                    queue.offer(rightChild);
                }
                i++; // 移动到下一对子节点的开始位置
            }
        }
        
        return root;
    }
}
```

#### 注意事项

**空指针表示**: 必须选择一个不会与正常节点值冲突的符号来表示 `null`。例如，`"null"`、`"#"`、`"N"` 都是常见的选择。

**分隔符**: 同样，分隔符也必须是节点值中不会出现的字符。如果节点值本身可能包含逗号，那么就需要更复杂的编码（如转义字符），但这超出了本题的常规要求。

**空树处理**: 要正确处理输入是 `null` 的情况。序列化一个空树应该返回一个空字符串或一个代表 `null` 的字符串，反序列化时也要能正确处理。

**数据类型**: 本例代码处理的是 `int` 类型的值。如果节点值是其他类型（如 `String`），`Integer.parseInt()` 部分需要相应修改。

**效率**:

- 在序列化时，使用 `StringBuilder` 而不是 `+` 来拼接字符串，可以避免创建大量不必要的中间字符串对象，效率更高。
- 在反序列化时，将分割后的数组转换为 `Queue` 或使用一个全局索引来遍历数组，比每次递归都传递子数组更高效。

#### 经验总结

**问题的核心是结构**: 此题的核心不是值的存储，而是**结构**的无损存储和恢复。抓住“如何表示 `null`”这一点，问题就迎刃而解。

**遍历方式的选择**:

- **DFS (前序遍历)**: 代码通常更简洁，递归逻辑非常自然。是解决此类问题的首选和最经典方法。
- **BFS (层序遍历)**: 迭代实现，可以避免在树极度倾斜（skewed tree）时发生栈溢出（Stack Overflow）的风险。在某些面试场景下，面试官可能会追问这种非递归解法。

**模式的通用性**: 这种序列化/反序列化的思想是计算机科学中的一个基础且重要的概念。它不仅适用于二叉树，也适用于 N叉树、图等其他数据结构。其应用场景广泛，如：

- **数据持久化**: 将内存中的对象状态保存到文件或数据库中。
- **网络通信**: 在网络上传输复杂的数据结构。
- **进程间通信**: 在不同进程之间共享数据。
- **深拷贝 (Deep Copy)**: 一个对象的深拷贝可以通过先序列化再反序列化来实现。

#### 反转二叉树



### 将二叉树展开为链表