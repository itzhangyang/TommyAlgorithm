#判断结构

###Leetcode 110: 判断一颗二叉树是否是平衡树

#### 问题描述

给定一个二叉树，判断它是否是高度平衡的。

对于本题，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1

#### 问题要点

##### 平衡的定义 - 树中每一个节点的左右子树高度差都不超过1

**不是指根节点的左右子树高度差**，而是指**树中每一个节点**的左右子树高度差都不超过1。

上面的问题是我容易犯的错误。

##### 递归性

这个定义天然具有递归性。一棵树是平衡的，当且仅当：

- 它的左子树是平衡的。
- 它的右子树是平衡的。
- 它自身的左右子树高度差不超过1。

##### 高度的计算 - 需要一个计算高度的方法

树的高度定义为从根节点到最远叶子节点的最长路径上的节点数。

`1 + max(left_height,right_height)`，空树的高度通常认为是0

#### 问题的本质 - 收集子树的高度来判断当前节点的平衡性

##### 自顶向下的思路

个直接但效率不高的思路是“自顶向下”（Top-down）：

1. 判断根节点是否平衡：
   - 计算左子树的高度 `h_left`。
   - 计算右子树的高度 `h_right`。
   - 检查 `abs(h_left - h_right) <= 1` 是否成立。
2. 如果成立，再递归地去判断左子树 `isBalanced(root.left)` 和右子树 `isBalanced(root.right)` 是否都为平衡二叉树。

##### 自顶向下的方式效率低下

当我们计算当前节点的高度时，会遍历其所有子节点。

而在递归判断子节点是否平衡时，又会重复计算其子孙节点的高度。

例如，计算根节点高度时已经遍历了整个树，之后又要对 `root.left` 再次遍历以判断其平衡性，存在大量的重复计算。

其时间复杂度最坏情况下（链状树）为 $O(N^2)$，最优情况下（完全二叉树）为 $O(NlogN)$。

#####自底向上的方法

为了优化，我们需要一种方法，在一次遍历中既能得到子树的高度，又能知道子树是否平衡。

这就引出了更优的“自底向上”（Bottom-up）的解法。

#### 模式匹配

##### 深度优先搜索

问题的定义本身就是递归的，因此很自然地想到使用递归来解决。

##### 后序遍历 - 解决问题的关键套路

这是解决此类问题的关键套路。

想一想，为了判断当前节点 `node` 是否平衡，你需要先知道它的左子树和右子树的信息（即它们的高度和它们本身是否平衡）。

这种**先处理子节点，再根据子节点的信息处理父节点**的模式，正是后序遍历（左 -> 右 -> 根）的核心思想。

####核心思想与套路 - DFS后序遍历

核心思想是采用**自底向上(Bottom-up)的后序遍历**。

我们不对每个节点重复计算高度，而是在计算高度的过程中就进行平衡性检查。

##### 核心思想

###### 检查左右子树是否平衡

创建一个递归辅助函数，比如`checkHeight(node)`:

- 如果以`node`为根的子树是**平衡**的，返回该子树的真实高度
- 如果以`node`为根的子树是**不平衡**的，则返回一个特殊标记`-1`，表示此路不同，已经发现不平衡了

###### 计算当前树是否平衡

在接下来的遍历过程中，对于当前节点`curr`:

- 我们先递归调用 `checkHeight(curr.left)` 和 `checkHeight(curr.right)` 获取左右子树的结果。
- 拿到结果后，首先检查它们是否为 `-1`。只要有一个是 `-1`，就意味着子树已经不平衡了，那么整棵树也就不可能平衡，我们立即向上返回 `-1`，这个 `-1` 会像一个中断信号一样一直传递到顶层。
- 如果左右子树都是平衡的（返回值都不是`-1`），我们再比较它们的高度差。如果高度差大于1，说明当前节点 `curr` 破坏了平衡，我们同样返回 `-1`。
- 如果当前节点也满足平衡条件，我们就返回它真实的高度 `1 + max(left_height, right_height)`，供上层节点使用。

通过这种方式，我们只对每个节点访问一次，就完成了高度计算和平衡性检查两项任务。

#### 实现原理

#####**主函数 `isBalanced(root)`**：

- 调用辅助函数 `checkHeight(root)`。
- 判断辅助函数的返回值。如果它不等于 `-1`，说明整棵树都是平衡的，返回 `true`。否则，返回 `false`。

#####**辅助函数 `checkHeight(TreeNode node)`**：

- **Base Case (递归出口)**：如果 `node` 为 `null`，表示空树。空树是平衡的，其高度为 `0`。所以返回 `0`。
- **递归下降 (后序遍历)**：
  - 调用 `leftHeight = checkHeight(node.left)` 递归处理左子树。
  - **剪枝**：如果 `leftHeight == -1`，说明左子树已经不平衡，无需继续，直接返回 `-1`。
  - 调用 `rightHeight = checkHeight(node.right)` 递归处理右子树。
  - **剪枝**：如果 `rightHeight == -1`，说明右子树已经不平衡，无需继续，直接返回 `-1`。
- **处理当前节点**：
  - 检查当前节点的平衡性：`if (Math.abs(leftHeight - rightHeight) > 1)`，如果不平衡，返回 `-1`。
  - 如果平衡，计算并返回当前节点的高度：`return 1 + Math.max(leftHeight, rightHeight)`。

####代码套路模板

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }
    //计算二叉树的高度
    //如果不平衡返回-1
    //如果平衡，返回树的真实高度
    private int height(TreeNode node){
        if(node == null) return 0;
        //计算左子树的高度
        int leftHeight = height(node.left);
        //计算右子树的高度
        int rightHeight = height(node.right);
        //如果左子树或者右子树不平衡，返回-1
        if(leftHeight == -1 || rightHeight == -1) return -1;
        //如果左子树和右子树的高度差大于1，返回-1
        if(Math.abs(leftHeight - rightHeight) > 1) return -1;
        //返回当前树的高度差
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

###Leetcode 101: 判断二叉树是否对称

判断二叉树是否对称，即左右子树是镜像关系。

##### 核心思想和套路 - DFS

使用 **DFS**，递归判断左右子树是否互为镜像。

##### 难点分析和应对

递归比较节点时，需要考虑对称的镜像性质。

##### 实现代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        if(root.left == null && root.right == null){
            return true;
        }
        return isSymmetric(root.left,root.right);
    }

    private boolean isSymmetric(TreeNode p, TreeNode q){
        if(p == null && q == null) return true;
        if(p== null && q != null){
            return false;
        }
        if(p != null && q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return isSymmetric(p.left,q.right) && isSymmetric(p.right,q.left);
    }
}
```

###Leetcode 100 : 判断两颗二叉树是否相同

判断两棵二叉树是否完全相同，节点结构和节点值都要相同。

##### 核心思想 - DFS（前序遍历）

使用DFS，递归判断左右子树是否相同

##### 难点分析与应对

递归过程中，节点值和子树结构需要完全匹配

##### 代码套路模板

```java
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p== null && q != null){
            return false;
        }
        if(p != null && q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
```

### Leetcode 958: 二叉树的完全性检验

#### 核心思想 - 比较最大索引和节点总数

采用BFS的方式对二叉树进行遍历。

遍历的过程中入队前做如下两件事：

- 更新节点总数
- 对当前节点进行索引化：
  - `leftIndex = parent.index * 2`
  - `rightIndex = parent.index * 2 + 1`
- 同时记录当前最大的索引

上述过程结束后，比较节点总数和最大索引是否相等即可。

#### 实现代码

```Java
 class Pair{
    TreeNode node;
    int index;
    public Pair(TreeNode node, int index){
        this.node = node;
        this.index = index;
    }
 }
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        if(root == null) return true;
        Queue<Pair> queue = new LinkedList<>();
        queue.offer(new Pair(root, 1));
        int nodeCount = 1;
        int maxIndex = 1;

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Pair curr = queue.poll();

                if(curr.node.left != null){
                    int leftIndex = curr.index * 2;
                    queue.offer(new Pair(curr.node.left, leftIndex));
                    maxIndex = Math.max(leftIndex, maxIndex);
                    nodeCount++;
                }

                if(curr.node.right != null){
                    int rightIndex = curr.index * 2 + 1;
                    queue.offer(new Pair(curr.node.right, rightIndex));
                    maxIndex = Math.max(rightIndex, maxIndex);
                    nodeCount++;
                }
            }
        }
        return nodeCount == maxIndex;
    }
}
```

