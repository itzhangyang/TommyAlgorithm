

| 类别             | 关键词                            | 示例题            |
| ---------------- | --------------------------------- | ----------------- |
| ✅ 遍历类         | 前序、中序、后序、层序、递归/迭代 | 94, 144, 145, 102 |
| ✅ 属性计算       | 高度、深度、节点数、直径          | 104, 111, 543     |
| ✅ 判断结构       | 是否平衡/对称/相同                | 100, 101, 110     |
| ✅ 路径类         | 路径和、最大路径、所有路径        | 112, 113, 124     |
| ✅ 转换类         | 构建树、扁平化、链表化            | 105, 106, 114     |
| ✅ 查找类         | 最近公共祖先、搜索路径            | 235, 236, 98      |
| ✅ 二叉搜索树专属 | 中序性质、大小关系                | 98, 700, 701, 230 |
| ✅ 变种结构       | 多叉树、完全/满/平衡树            | 222, 116, 117     |



# 树形动态规划 - 二叉树上最优/计数/选择组合问题

## 场景和目标 - 二叉树结构中的最优/计数/选择组合问题

#### 树形动态规划问题的特征

树形DP通常用于解决在二叉树上寻找最优解的问题。这些问题往往具有以下特征：

- **最优子结构**: 整个树的最优解可以由其左右子树的最优解推导出来。
- **重叠子问题**: 在计算过程中，某些子树的状态会被多次计算。DP通过记忆化（或自底向上递推）来避免重复计算。

##常见的场景

### 路径问题

- 寻找二叉树中的最长路径（直径）。

- 寻找从根节点到叶子节点的最大/最小路径和。

- 寻找任意两个节点之间的最大/最小路径和。

### 选择/组合问题

- **打家劫舍III**: 在二叉树中选择节点，使得相邻（父子）节点不能同时被选中，求选中节点值的最大和。

- **二叉树的着色问题**: 对节点进行染色，要求相邻节点颜色不同，求方案数或最小代价。

- **监控二叉树**: 在节点上放置摄像头来监控所有节点，求最少需要多少个摄像头。

### 计数问题

- 计算满足特定条件的二叉搜索树（BST）有多少种。
- 计算满足某种形态的子树有多少个。

## 核心思想和套路- 计算`[A最优解，B最优解]`

###核心思路 - 计算父节点状态所需要的所有子节点信息

- 思考**为了计算当前节点 `u` 的状态，你需要从其子节点 `v` 获取哪些信息**？

- 将这些需要的信息定义为递归函数的返回值。

  返回值通常是一个数组、元组(Tuple)或哈希表(Map)，包含了**计算父节点状态所需的所有子节点信息**。

  **这是树形DP最关键的一步**。

  状态定义是否清晰、全面，直接决定了问题能否解决。

###实现套路 - DFS后序自底向上的遍历

通过定义清晰的 **状态**，并找出 **状态转移方程**，利用递归（通常是深度优先搜索, DFS）遍历树的每个节点，在后序遍历的位置（即处理完左右子树之后）完成当前节点的状态计算，最终得到根节点的状态作为整个问题的解。

- 我们通过递归函数（DFS）深入到树的最底部（叶子节点）。

- 叶子节点作为递归的边界条件，其状态通常很容易确定。

- 在递归返回的过程中，利用已经计算好的左右子节点的状态，来计算当前节点的状态。这个过程恰好符合 **后序遍历** 的顺序（左 -> 右 -> 根）。

### 举例：打家劫舍III

#### 问题要点

不能同时偷窃直接相连的父子节点，求最大偷窃金额。

#### 状态思考：偷不偷当前节点？

对于任意一个节点 `u`，我们有两种选择：**偷** 或 **不偷**。

- 如果 **偷** `u`，那么它的左右子节点 `left` 和 `right` 都 **不能偷**。
- 如果 **不偷** `u`，那么它的左右子节点 `left` 和 `right` **既可以偷，也可以不偷**（取其最大值）。

#### 返回值定义：偷或者不偷的结果

递归函数 `dfs(node)` 需要返回一个包含两个值的数组或元组 `[stolen_max, not_stolen_max]`。

- `stolen_max`: 表示 **偷** `node` 节点时，以 `node` 为根的子树能得到的最大金额。
- `not_stolen_max`: 表示 **不偷** `node` 节点时，以 `node` 为根的子树能得到的最大金额。



## 模式套路匹配

### 问题求解依赖子树问题

问题的答案需要综合考虑当前节点的左右子树的信息。例如，求树的直径，需要知道左子树的深度和右子树的深度。

### 局部最优解可以推导全局最优解

通过计算每个子树的局部最优解，可以最终推导出整棵树的全局最优解。

### 无后效性

一个节点的状态一旦确定，就不会再被其祖先节点的状态所改变。计算只依赖于其子节点。

### 问题通常出现的形式

**问题通常以“最大/最小”、“计数”、“可行性”等形式出现**。

**典型例题匹配：**

- **“求最大/小...”** -> LeetCode 124. 二叉树中的最大路径和, LeetCode 337. 打家劫舍 III
- **“求数量/方案数...”** -> LeetCode 96. 不同的二叉搜索树
- **“求最少/最小代价...”** -> LeetCode 968. 监控二叉树



## 实现原理

### DFS递归函数的定义

实现树形DP的主要载体。函数签名通常是 `dfs(TreeNode node)`。

### 基准情况

 递归的终止条件。对于二叉树，通常是 `if node is None:`，此时返回一个表示空状态的值（如 `[0, 0]` 或 `0`）。

### 递归下降

 对当前节点的左右子节点调用递归函数，获取它们的状态信息。

```
left_status = dfs(node.left)
right_status = dfs(node.right)
```

### 状态计算

在后序遍历的位置，根据从左右子节点获取的状态 `left_status` 和 `right_status`，以及当前节点 `node` 自身的值，计算出 `node` 节点的状态。

```
# 伪代码：以打家劫舍III为例
stolen_at_current = node.val + left_status[1] + right_status[1]
not_stolen_at_current = max(left_status) + max(right_status)
```

### 返回状态

```
return [stolen_at_current, not_stolen_at_current]
```

### 主函数

调用递归函数，并从返回的根节点状态中提取最终答案。

##注意事项

### 状态定义要清晰

必须明确递归函数返回的每一个值代表什么物理意义。这是避免逻辑混乱的关键。

### 返回值的设计

返回值必须包含计算父节点状态所需的所有信息，不多也不少。

### 全局变量 VS 返回值

- 如果最终答案必然是由根节点的状态决定的（如“打家劫舍III”），那么可以直接从主函数调用`dfs(root)`的返回值中提取。

- 如果最终答案可能出现在树的任何一个局部，而不仅仅是根节点（如“二叉树最大路径和”，最大和可能不过根节点），那么通常需要一个全局变量（或作为类成员变量）在递归过程中不断更新。

### 空节点的处理

确保基准情况（`node is None`）返回的状态值是正确的，不会影响父节点的计算。

例如，对于求和，空节点返回0；对于求最大值，可能返回一个极小值。

### 避免重复计算

树形DP天然地通过递归避免了对同一个节点的重复处理。但如果题目是图而非树（存在环），则需要额外的 `visited` 集合来防止死循环。

## 经验总结

**先从简单例子入手**: 从“求树的最大深度”这类最简单的题目开始理解递归和后序遍历如何传递信息。

**多画图分析**: 当状态定义不清晰时，在纸上画一个简单的二叉树，手动模拟计算过程。从叶子节点开始，一步步计算父节点的状态，看看需要哪些信息，自然就能想清楚返回值的结构。

**刻意练习，分类归纳**: 将做过的树形DP问题进行分类（路径类、选择类、计数类等）。总结每一类问题在状态定义上的共同点和不同点。

**学习经典模型**:

- **最大路径和模型**: 递归函数返回“以当前节点为端点的最大向下路径和”。
- **打家劫舍模型**: 递归函数返回“偷/不偷当前节点”的两种状态下的最大收益。
- **监控摄像头模型**: 递归函数返回当前节点及其子树的三种状态（被覆盖但无摄像头、被父节点覆盖、自身有摄像头）的最小代价。

**不要畏惧复杂的返回值**: 有些困难的问题可能需要返回包含3个甚至更多值的状态数组。只要每个值的物理意义清晰，并且状态转移逻辑正确，问题就能迎刃而解。

## Leetcode 337: 打家劫舍III

### 问题要点 - 二叉树上的打家劫舍问题

这是一个在二叉树结构上进行的“打家劫舍”问题。

1. **数据结构**: 房屋的连接方式是一个二叉树，而不是一个线性的数组。
2. **约束条件**: 不能同时抢劫两个**直接相连**的房屋。这里的“直接相连”指的是父节点和其直接的子节点。
3. **目标**: 在满足约束条件的情况下，计算出能够抢劫到的**最大**金额。

### 问题本质和分析

这个问题的本质是在一个树形结构上进行带有约束的决策，以求得全局最优解。

这是一个典型的**树形动态规划 (Tree DP)** 问题。

####我们面临的两种选择：偷不偷？

##### 偷当前节点 - 不能偷它的直接子节点

如果我们抢劫了当前节点 `node`，根据规则，我们就不能抢劫它的直接子节点 `node.left` 和 `node.right`。

此时，我们能获得的最大金额是 `node.val` 加上**不抢劫**左子节点所能获得的最大金额，再加上**不抢劫**右子节点所能获得的最大金额。

##### 不偷当前节点 - 那偷不偷它的子节点呢？

如果我们不抢劫当前节点 `node`，那么对于它的子节点 `node.left` 和 `node.right`，我们没有任何限制。

我们可以选择抢劫它们，也可以选择不抢劫它们。为了使总金额最大化，我们应该取抢劫或不抢劫其子节点所能得到的最大值。

所以，总金额是**左子树能提供的最大金额**加上**右子树能提供的最大金额**。

最终，对于 `node` 这个节点（以及其构成的子树），我们能获得的最大金额就是上述两种选择中较大的一个。

$maxMoney(node)=max(抢劫node,不抢劫node)$

这个递推关系清晰地表明了我们可以使用递归来解决，并且**子问题的解可以被父问题复用**，这是动态规划的典型特征。

### 模式套路匹配

#### 树形动态规划 - 后序遍历

问题的状态（能抢到的最大金额）依赖于其子树的状态。

我们需要从叶子节点开始，自底向上地计算每个节点的状态，直到根节点。

这通常通过**后序遍历 (Post-order Traversal)** 的方式实现。

#### 递归 + 记忆化搜索 - 避免重复计算

一个朴素的递归会产生大量的重叠子问题，导致时间复杂度过高。

通过返回一个包含多种状态信息的结构，我们可以避免重复计算，这本质上就是动态规划的思想。

### 核心思想和套路

单村的递归函数如果只返回一个值（该子树能够抢到的最大值）是不够的。

因为我们在计算父节点`P`的状态的时候，如果要决定抢劫`P`，我们就需要知道其子节点`C`不被抢劫时的最大金额。

而不仅仅是`rob(c)`的返回值（`rob(c)`可能是抢了`c`也可能是没抢`c`）。

因此，核心思想是让递归函数返回一个包含两种状态的数组或者对象。

- 状态0: **不抢劫**当前节点时，该子树能获得的最大金额。

- 状态1: **抢劫**当前节点时，该子树能获得的最大金额。

我们定义一个递归函数 `dfs(node)`，它返回一个长度为 2 的数组 `int[] result`：

- `result[0]`: 代表**不抢劫** `node` 时，`node` 子树能抢到的最大金额。
- `result[1]`: 代表**抢劫** `node` 时，`node` 子树能抢到的最大金额。

通过这种方式，我们在一次遍历中就能获得解决父问题所需的所有信息。

### 实现原理和步骤

#### 定义递归函数

创建一个辅助函数，例如 `int[] dfs(TreeNode node)`。

#### 设置基准情况 - 当前节点为null

如果当前节点 `node` 为 `null`，那么无论抢或不抢，金额都是 0。因此返回 `new int[]{0, 0}`。

#### 递归下降

- 对左子节点进行递归调用: `int[] leftStatus = dfs(node.left);`

- 对右子节点进行递归调用: `int[] rightStatus = dfs(node.right);`

#### 计算状态

##### 抢劫当前节点

如果抢劫 `node`，则不能抢劫其子节点。

所以最大金额是 `node.val` 加上左子节点**不被抢劫**时的金额 (`leftStatus[0]`) 和右子节点**不被抢劫**时的金额 (`rightStatus[0]`)。

`robCurrent = node.val + leftStatus[0] + rightStatus[0];`

##### 不抢劫当前节点

如果不抢劫 `node`，那么其左右子节点可以被抢，也可以不被抢。

我们取它们各自能产生的最大金额即可。

左子树的最大金额是 `max(leftStatus[0], leftStatus[1])`，右子树同理。

`notRobCurrent = Math.max(leftStatus[0], leftStatus[1]) + Math.max(rightStatus[0], rightStatus[1]);`

#### 返回结果

 将当前节点计算出的两个状态打包成数组返回: `return new int[]{notRobCurrent, robCurrent};`

#### 主函数调用

在主函数 `rob(TreeNode root)` 中，调用 `dfs(root)`，得到根节点的两个状态。最终答案就是这两个状态中的最大值。

### 实现代码

```Java
 //树形打家劫舍
 //不能抢劫一条路径上的连续两个节点
 //抢了node,就不能抢node.left和node.right
 //
class Solution {
    public int rob(TreeNode root) {
        int[] res = robRoom(root);
        return Math.max(res[0],res[1]);
    }

    private int[] robRoom(TreeNode node){
        if(node == null){
            return new int[]{0,0};
        }
        int[] left = robRoom(node.left);
        int[] right = robRoom(node.right);

        int[] res = new int[2];
        //抢劫当前节点，不能抢劫子节点
        res[0] = left[1] + right[1] + node.val;
        //不抢劫当前节点，可以抢劫或者不抢劫左右子节点
        res[1] = Math.max(left[0], left[1]) + Math.max(right[0],right[1]);
        return res;
    }
}
```

### 注意事项

#### 避免朴素递归 - 避免重复计算

千万不要写成 `rob(node) = max(node.val + rob(node.left.left) + ..., rob(node.left) + rob(node.right))` 这种形式。因为它会产生大量的重复计算（例如 `rob(node.left.left)` 会被多次调用），导致时间复杂度达到指数级别，从而超时。

#### 状态定义的清晰性

理解为什么需要返回一个包含两个状态的数组是解决此问题的关键。

如果只返回一个值，父节点将无法根据自己的决策（抢或不抢）来正确地利用子节点的信息。

#### 空间换时间

这种树形 DP 的方法利用了额外的空间（递归栈和返回的数组）来存储中间状态，从而将时间复杂度优化到线性 O(N)，其中 N 是节点的数量。

#### 遍历顺序 - 自底向上

算法的内在逻辑是后序遍历。必须先得到子节点的状态，才能计算父节点的状态。

### 经验总结

#### 识别模式

当遇到在树/图上求最优解（最大/最小/计数等）的问题，且一个节点的决策会影响其相邻节点的决策时，要优先考虑树形动态规划。

#### 定义状态

树形 DP 的核心是为每个节点定义清晰的状态。

思考一下：“为了让父节点做出决策，我需要从子节点那里获得哪些信息？” 在本题中，就是“抢”和“不抢”两种状态。

#### 自底向上

树形 DP 的计算过程是自底向上（从叶到根）的，这天然地与**后序遍历**的递归实现相契合。

#### 举一反三

这个“返回一个数组/对象来表示多种状态”的技巧在很多树形 DP 问题中都非常有用。

例如，求解树的最大路径和、树的直径等问题时，虽然状态定义不同，但思想是相通的。

掌握了这个套路，就能解决一大类树形 DP 问题。

## Leetcode 968: 监控二叉树

### 问题要点

给定一个二叉树的根节点 `root`，我们需要在树的节点上安装摄像头。

每个摄像头都能监控其所在的节点、其父节点和其左右两个**直接子节点**。

目标是计算并返回覆盖整棵树所有节点所需的**最小**摄像头数量。

**核心限制:**

- 树的节点数量在 `[1, 1000]` 范围内。
- 每个节点的值 `Node.val` 均为 0，这意味着节点值本身不提供有用信息。

**理解监控范围：** 一个摄像头的作用范围是一个“十字形”区域，覆盖了节点本身和其上下左右的邻居。

### 问题本质和分析

此问题的本质是在一棵树上进行决策，以最小的成本（摄像头数量）达成全局目标（所有节点被覆盖）。

对于任何一个节点，我们都有两种选择：**放置摄像头** 或 **不放置摄像头**。

#### 放置摄像头

该节点、其父节点和其子节点都会被覆盖。

这是一个局部最优决策，因为它一次性覆盖了多个节点。

#### 不放置摄像头

该节点必须依赖其父节点或其子节点上的摄像头来被覆盖。

这种**局部决策会影响全局结果**的特点，以及寻求最优解（最小数量），强烈暗示了动态规划或贪心算法。

由于问题结构是树，因此这自然地导向了**树形动态规划 (Tree DP)** 的思路。

关键的观察点是：

一个节点的状态，不仅取决于它自身，还与其子树的状态和其父节点的状态紧密相关。

为了做出最优决策，一个节点需要从其子节点获取信息。

这种自底向上的信息传递过程，天然地契合了**后序遍历 (Post-order Traversal)**。

#### 进一步分析可以发现一个贪心策略

##### 叶子节点最不划算

在叶子节点放置摄像头只能覆盖它自己和它的父节点。

而在其父节点放置摄像头，不仅能覆盖父节点、叶子节点，还能覆盖父节点的另一个子节点（如果存在）以及父节点的父节点。

因此，将摄像头放置在叶子节点的父节点，通常是更优的选择。

##### 延迟放置 - 尽可能的向上推迟放置摄像头

遵循第一点的思想，我们应该尽可能地“向上”推迟放置摄像头。

换言之，除非一个节点必须被覆盖，且无法由其子节点覆盖，我们才在其父节点处放置摄像头。

这个贪心策略是本题的核心，它指导我们从树的底部向上做出最优决策。

### 模式套路匹配

#### 树形动态规划特征

- 问题定义在一棵树上。
- 要求一个全局最优解（最小/最大/计数等）。
- 一个节点的解依赖于其子节点的解。
- 通过递归（通常是深度优先搜索，DFS）来计算，并在递归返回时合并子问题的解。

#### 与常规动态规划的区别

树形DP的状态定义通常与节点本身相关，并且状态转移沿着树的边进行，而不是像线性DP那样沿着数组索引。

此题的解法是树形DP的一个非常优雅的应用，通过为每个节点定义清晰的状态，并利用后序遍历自底向上地解决问题。

### 核心思想和套路

解决本题的核心是为每个节点定义一组状态，这组状态能够充分表达其子树的情况，并为父节点提供做出决策所需的全部信息。

一个节点 `u` 在其子树被处理完毕后，对于其父节点 `p` 来说，有以下三种可能的状态：

#### 状态 0 (State 0): 未被覆盖 (Uncovered)

- 含义：节点 `u` 自身未被任何摄像头覆盖。

- 对父节点 `p` 的要求：`p` **必须**放置一个摄像头来覆盖 `u`。

#### 状态 1 (State 1): 已放置摄像头 (Has a Camera)

- 含义：节点 `u` 自身安装了一个摄像头。

- 对父节点 `p` 的要求：`p` 已经被 `u` 覆盖，无需额外操作。`p` 的决策将基于其另一个子节点的情况。

#### **状态 2 (State 2): 已被覆盖但无摄像头 (Covered, No Camera)**

- 含义：节点 `u` 自身没有摄像头，但它被其子节点上的摄像头覆盖了。

- 对父节点 `p` 的要求：`p` 未被 `u` 的子树覆盖，`p` 仍需等待其父节点或其另一个子树来覆盖它。

#### 决策逻辑（后序遍历）

我们使用一个返回值为节点状态的 `dfs` 函数进行后序遍历。对于当前节点 `cur`：

##### 递归处理左右子树

- `left_state = dfs(cur.left)`
- `right_state = dfs(cur.right)`

##### 根据子节点状态做出决策

###### 情况一：只要有一个子节点是“状态0 (未被覆盖)”

```
if (left_state == 0 || right_state == 0)
```

- 那么当前节点 `cur` **必须**放置一个摄像头。

- 放置后，摄像头数量加一 (`count++`)。

- 当前节点 `cur` 的状态变为“状态1 (已放置摄像头)”，返回 `1`。

###### **情况二：如果两个子节点都被覆盖了，且其中至少一个子节点自身有摄像头**

```
if (left_state == 1 || right_state == 1)
```

- 这意味着当前节点 `cur` 已经被其子节点上的摄像头覆盖了。

- `cur` 自身不需要再放摄像头，也不需要父节点来覆盖它。

- 当前节点 `cur` 的状态变为“状态2 (已被覆盖但无摄像头)”，返回 `2`。

###### 情况三：两个子节点都是“状态2 (已被覆盖但无摄像头)”

```
if (left_state == 2 && right_state == 2)
```

- 这意味着 `cur` 的两个子节点都被它们各自的子节点覆盖了，但它们自身没有摄像头。

- 因此，当前节点 `cur` 自身没有被覆盖。

- `cur` 将这个“未被覆盖”的状态传递给它的父节点。

- 当前节点 `cur` 的状态变为“状态0 (未被覆盖)”，返回 `0`。

##### 特殊处理的根节点

当 `dfs` 遍历完成后，根节点 `root` 可能返回状态 `0` (未被覆盖)。

这意味着整棵树的根部需要一个摄像头来覆盖。

因此，如果 `dfs(root)` 的结果是 `0`，我们需要额外再加一个摄像头。

### 实现原理和步骤

#### 定义全局变量记录摄像头总和

定义一个全局变量 `cameras` 用于记录摄像头的总数。

#### 主函数的定义:`minCameraCover`

- 初始化 `cameras = 0`。

- 调用 `dfs` 辅助函数，获取根节点的状态。

- 如果 `dfs(root)` 返回 `0`（根节点未被覆盖），则说明根节点需要一个摄像头，将 `cameras` 加一。

- 返回 `cameras` 的值。注意处理只有一个节点的特殊情况。

#### 辅助函数`dfs(TreeNode node)`

##### Base Case:节点为null

- 如果节点为 `null`，它不需要被覆盖，也不提供覆盖。
- 可以认为它处于一个“已被覆盖”的状态，因为它不会对父节点产生“必须放摄像头”的要求。因此返回状态 `2`。

##### 调用递归

 递归调用 `dfs` 处理左右子节点，获取它们的状态 `left` 和 `right`。

##### 状态判断

- 如果 `left == 0 || right == 0`，则当前节点必须放摄像头。`cameras++`，并返回状态 `1`。
- 如果 `left == 1 || right == 1`，则当前节点已被子节点覆盖。返回状态 `2`。
- 如果 `left == 2 && right == 2`，则当前节点未被覆盖，需要父节点来覆盖。返回状态 `0`。
- （注意：上述判断顺序是固定的，确保了逻辑的正确性）。

####最终返回：

主函数根据根节点的最终状态决定是否需要额外增加一个摄像头，并返回总数。



### 代码实现

```Java
class Solution {
    private int cameras = 0;

    /**
     * 定义节点的三种状态:
     * 0: 该节点未被覆盖 (Uncovered)
     * 1: 该节点已安装摄像头 (Has a Camera)
     * 2: 该节点已被覆盖，但自身没有摄像头 (Covered, No Camera)
     */
    private static final int UNCOVERED = 0;
    private static final int HAS_CAMERA = 1;
    private static final int COVERED_NO_CAMERA = 2;

    public int minCameraCover(TreeNode root) {
        // 如果根节点是叶子节点，必须放一个摄像头
        if (root.left == null && root.right == null) {
            return 1;
        }

        // dfs返回根节点的状态。如果根节点是UNCOVERED，说明它需要一个摄像头。
        // 这个摄像头可以放在它自己身上。
        if (dfs(root) == UNCOVERED) {
            cameras++;
        }
        return cameras;
    }

    private int dfs(TreeNode node) {
        // Base Case: 空节点，可以认为是“已被覆盖”的状态，
        //因为它不需要被监控，也不会对父节点产生任何“需要被覆盖”的要求。
        if (node == null) {
            return COVERED_NO_CAMERA;
        }

        // 后序遍历
        int leftState = dfs(node.left);
        int rightState = dfs(node.right);

        // 情况1: 子节点中有一个是“未被覆盖”状态
        // 那么当前节点必须放置摄像头，来覆盖子节点。
        if (leftState == UNCOVERED || rightState == UNCOVERED) {
            cameras++;
            return HAS_CAMERA;
        }

        // 情况2: 子节点中有一个装了摄像头
        // 那么当前节点已经被子节点覆盖了。
        if (leftState == HAS_CAMERA || rightState == HAS_CAMERA) {
            return COVERED_NO_CAMERA;
        }

        // 情况3: 左右子节点都处于“已被覆盖但无摄像头”的状态
        // 意味着当前节点未被覆盖，需要父节点来覆盖它。
        // 此处返回UNCOVERED，将需求传递给父节点。
        // 注意：这个 `if (leftState == COVERED_NO_CAMERA && rightState == COVERED_NO_CAMERA)` 
        // 其实可以省略，因为前面的if已经排除了其他所有情况。
        return UNCOVERED;
    }
}
```

### 标准DP解法

#### 问题的本质和分析 - 动态规划的视角

从动态规划的角度看，这个问题的核心特征是**最优子结构**。

也就是说，一棵树的最小摄像头问题，可以由其左右子树的最小摄像头问题来推导解决。



当我们考察一个节点 `u` 时，为了计算包含 `u` 的整棵子树的最小摄像头数，我们仅仅需要知道其左子树 `l` 和右子树 `r` 的最优解信息。

我们不需要知道 `l` 和 `r` 的孙子节点具体是如何放置的，只需要知道 `l` 和 `r` 在各自的最优策略下处于什么“状态”即可。

这种自底向上（从子树到父树）构建最优解的模式，正是树形动态规划的用武之地。

#### 核心思想 - 严格的动态规划范式

##### 状态的定义

是DP的核心。

对于树上的任意一个节点 `u`，我们需要定义一组状态，这组状态需要能够完全描述 `u` 所在子树的情况，并且足以让 `u` 的父节点做出决策。

我们定义一个数组 `dp[u]` 或者一个函数返回值，它包含三个值，分别对应节点 `u` 的三种状态：

- **`dp[u][0]`**: 节点 `u` 处于**未被覆盖**状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  要让 `u` 不被覆盖，它的子节点 `l` 和 `r` 必须都不能放摄像头。

  同时，`l` 和 `r` 必须被它们各自的子节点覆盖。

- **`dp[u][1]`**: 节点 `u` 处于**放置了摄像头**的状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  这个状态的成本包括在 `u` 上放置的1个摄像头，以及其左右子树在任意状态下的最小摄像头数（因为 `u` 上的摄像头可以覆盖所有情况）。

- **`dp[u][2]`**: 节点 `u` 处于**被子节点覆盖，但自身无摄像头**的状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  要达到这个状态，`u` 的左子树或右子树中，必须至少有一个放置了摄像头。

##### 状态转移方程

假设我们已经通过后序遍历，计算出了节点 `u` 的左子节点 `l` 和右子节点 `r` 的DP状态数组 `dp[l]` 和 `dp[r]`。现在我们要计算 `dp[u]`。

###### 计算`dp[u][1]`(在`u`处放置摄像头)

这是最简单的。因为 `u` 自己放了摄像头，它的子节点 `l` 和 `r` 就都被覆盖了。

为了总摄像头数最少，我们应该为 `l` 和 `r` 的子树选择成本最低的状态。

$dp[u][1] = 1 + min(dp[l][0], dp[l][1], dp[l][2]) + min(dp[r][0], dp[r][1], dp[r][2]) $

###### 计算 `dp[u][0]` ( `u` 未被覆盖):

要让 `u` 不被覆盖，`u` 自身不能放摄像头，其父节点也不能放（这是从父节点视角看），其子节点也不能放。

所以，`l` 和 `r` 必须处于“被它们自己的子节点覆盖”的状态，也就是状态2。

$dp[u][0] = dp[l][2] + dp[r][2] $

果某个子节点无法达到状态2（例如叶子节点），那么 `u` 也无法达到状态0。

在这种情况下，我们可以将 `dp[u][0]` 设为一个极大值（代表不可能）。

###### 计算 `dp[u][2]` ( `u` 被子节点覆盖):

这意味着 `l` 或 `r` 中至少有一个节点放了摄像头。我们希望总数最少，所以分两种情况取最小值：

- **左子节点放置摄像头**

  成本是 `dp[l][1]`。

  此时右子节点 `r` 已被 `u` 覆盖（虽然我们这里不关心父节点），它只需要满足自身子树最优即可，所以取 `min(dp[r][1], dp[r][2])`。

  （注意：`r` 不能是状态0，因为它必须被覆盖）。

  更严谨地说，`r`可以被`u`覆盖，所以它取`min(dp[r][...])`。

- **右子节点放置摄像头**

  右子节点 `r` 放摄像头：成本是 `dp[r][1]`，左子树同理。

为了覆盖 `u`，要么左孩子放摄像头，要么右孩子放摄像头。

- 如果左孩子 `l` 放摄像头，那么右孩子 `r` 的状态可以是任意的，因为它已经被 `u` 的父亲角色 `l` 覆盖了（实际上是被u的摄像头覆盖）。所以 `r` 取其子树的最小值。

- 所以，总成本是 `min(左孩子放摄像头成本 + 右子树总成本, 右孩子放摄像头成本 + 左子树总成本)`

  $dp[u][2] = min(dp[l][1] + min(dp[r][0], dp[r][1], dp[r][2]), \quad dp[r][1] + min(dp[l][0], dp[l][1], dp[l][2])) $

##### Base Case

对于一个空节点 `null`：

- 它不需要被覆盖，也不能放摄像头。
- `dp[null][0] = 0` （0个摄像头，是未覆盖状态）
- `dp[null][1] = \infty` （不可能放摄像头，用极大值表示）
- `dp[null][2] = 0` （0个摄像头，可视作已被覆盖状态，因为它不产生“需要覆盖”的需求）

##### 最终结果

对于根节点 `root`，它不能处于“未被覆盖”的状态。

所以最终答案是 `min(dp[root][1], dp[root][2])`。

#### 实现原理和步骤

1. **定义递归函数：** 设计一个递归函数 `dfs(node)`，它返回一个长度为3的数组 `int[]`，分别代表 `dp[node][0]`, `dp[node][1]`, `dp[node][2]`。
2. **后序遍历：** 在函数内部，首先递归调用 `dfs(node.left)` 和 `dfs(node.right)` 获取左右子节点的DP数组。
3. **处理Base Case：** 如果 `node` 是 `null`，返回 `{0, Integer.MAX_VALUE / 2, 0}`。除以2是为了防止加法溢出。
4. **状态计算：** 根据上面推导的状态转移方程，利用子节点的DP数组计算当前节点的DP数组。
5. **返回结果：** `dfs` 函数返回计算出的当前节点的DP数组。
6. **主函数调用：** 在主函数中，调用 `dfs(root)` 得到根节点的DP数组 `root_dp`，最终结果就是 `min(root_dp[1], root_dp[2])`。

#### 实现代码

```Java
class Solution {
    /**
     * 本解法严格遵循树形DP范式
     * 定义一个递归函数，返回一个数组 res, 长度为3
     * res[0]: 代表node节点【未被覆盖】时，其子树所需的最少摄像头数
     * res[1]: 代表node节点【放置摄像头】时，其子树所需的最少摄像头数
     * res[2]: 代表node节点【被子节点覆盖，自身无摄像头】时，其子树所需的最少摄像头数
     */
    public int minCameraCover(TreeNode root) {
        int[] rootDp = dfs(root);
        // 根节点不能是“未被覆盖”的状态，所以从另外两种状态中取最小值
        return Math.min(rootDp[1], rootDp[2]);
    }

    private int[] dfs(TreeNode node) {
        // Base Case: 空节点
        if (node == null) {
            // [未覆盖, 放摄像头, 已覆盖]
            // 未覆盖：0个摄像头
            // 放摄像头：不可能，设为极大值
            // 已覆盖：0个摄像头，因为它不需要被覆盖
            return new int[]{0, Integer.MAX_VALUE / 2, 0};
        }

        // 后序遍历，先获取左右子节点的DP状态数组
        int[] leftDp = dfs(node.left);
        int[] rightDp = dfs(node.right);

        // 状态转移方程

        // 状态0: node未被覆盖。
        // 那么其子节点必须是被它们自己的子节点覆盖的状态。
        int dp0 = leftDp[2] + rightDp[2];

        // 状态1: node放置摄像头。
        // 成本为1 (node自身) + 左右子树在任何状态下的最小成本。
        int minLeft = Math.min(leftDp[0], Math.min(leftDp[1], leftDp[2]));
        int minRight = Math.min(rightDp[0], Math.min(rightDp[1], rightDp[2]));
        int dp1 = 1 + minLeft + minRight;
        
        // 状态2: node被子节点覆盖。
        // 那么必须是左子节点放摄像头，或者右子节点放摄像头。取两者中的较小值。
        // Case A: 左孩子放摄像头, 右孩子取最小值
        int caseA = leftDp[1] + minRight;
        // Case B: 右孩子放摄像头, 左孩子取最小值
        int caseB = rightDp[1] + minLeft;
        int dp2 = Math.min(caseA, caseB);

        return new int[]{dp0, dp1, dp2};
    }
}
```

#### 从DP视角看第一个解法

现在您再看第一个解法，就会豁然开朗。

- 第一个解法中，`dfs` 函数返回一个整数 `0, 1, 2`，这其实就是代表当前节点在**其父节点看来**应该处于哪种状态才能达成最优。
- `return 0` 对应 `dp[u][0]` 的情况，告诉父节点：“我没被覆盖，你必须放摄像头！”
- `return 1` 对应 `dp[u][1]` 的情况，告诉父节点：“我放了摄像头，你被覆盖了。”
- `return 2` 对应 `dp[u][2]` 的情况，告诉父节点：“我被我的孩子覆盖了，你不用管我。”
- 全局变量 `cameras` 的累加，则是在发生 `dp[u][1]` 状态转移时（即决定放置摄像头时）进行的。

第一个解法是一个**状态压缩**和**过程优化**的版本。

它没有显式地计算每种状态的最小摄像头数，而是通过返回一个状态标记，隐式地引导整个决策过程朝着最优解进行。

这种实现方式更简洁，但理解起来需要从贪心的角度切入。

而我们刚刚详细分析的严格DP版本，则清晰地展示了其背后完整的动态规划逻辑。

两者殊途同归，内核思想完全一致。

## 树形动态规划的核心框架

### 识别问题模式

- 场景： 发生在一棵树上
- 目标：要求一个全局最优解（最大值/最小只/总方案数）
- 约束：一个节点的决策会影响或者受与其直接相连的节点的决策所限制
- 结论： 这个问题具备最优子结构的特性，即父问题的最优解依赖于子问题的最优解。

### 确定信息流和遍历方式

- 由于父节点的决策需要依赖其子树的计算结果，信息流是**自底向上**的

- 在树的遍历中，唯一能实现**先处理子节点再处理父节点**的就是后序遍历

  因此实现上几乎总是采用递归的深度优先搜索来模拟后序遍历。

### 状态推导和转移方程

#### 父节点需要知道子树的哪些信息？

当我们处理完一个节点 `u` 的子树后，为了让 `u` 的父节点 `p` 能够做出最优决策，`p` 需要从 `u` 这里知道哪些**最关键的信息**？

将这些“关键信息”设计成一个状态数组（或元组、对象等）。

递归函数/DFS的返回值就应该是这个状态数组。

这个状态数组的**维度**和**每个维度的含义**是区分不同问题的关键。

### 确定最终答案

当整个遍历结束，我们得到根节点的最终状态数组。

根据问题的整体约束，从根节点的状态数组中选取一个或多个状态的值，计算出最终答案

## Leetcode 337和968在树形DP框架下的对比

| 抽象套路步骤        | LeetCode 337 (打家劫舍 III)                                  | LeetCode 968 (监控二叉树)                                    |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 识别问题模式** | 在树上求最大偷窃金额。约束：不能同时偷父子节点。是典型的树形DP。 | 在树上求最小摄像头数。约束：所有节点必须被覆盖。摄像头覆盖范围是父、子、自身。是典型的树形DP。 |
| **2. 遍历方式**     | 后序遍历（DFS递归）。                                        | 后序遍历（DFS递归）。                                        |
| **3. 定义节点状态** | **父节点 `p` 需要知道什么？** 如果 `p` 决定偷，那么它必须知道不偷 `u` 能得到的最大金额。如果 `p` 决定不偷，那么它可以从偷或不偷 `u` 中选择一个最大值。 **结论**: `p` 需要知道 `u` 在“偷”和“不偷”两种情况下的最优解。 **状态数组 `int[2]`**: `res[0]`: 不偷 `u` 时，`u` 子树的最大金额。`res[1]`: 偷 `u` 时，`u` 子树的最大金额。 | **父节点 `p` 需要知道什么？** `p` 需要知道 `u` 的覆盖情况来决定自己是否要放摄像头。具体来说：1. `u` 是否**没被覆盖**，强制 `p` 必须放摄像头？ 2. `u` 是否自己**放了摄像头**，从而把 `p` 也顺便覆盖了？ 3. `u` 是否**被自己的孩子覆盖了**，既不麻烦 `p` 也不帮助 `p`？ **结论**: `p` 需要知道 `u` 的三种覆盖状态。 **状态数组 `int[3]`**: `res[0]`: `u` 未被覆盖时的最小摄像头。`res[1]`: `u` 放了摄像头的最小摄像头。`res[2]`: `u` 被孩子覆盖的最小摄像头。 |
| **4. 状态转移方程** | 设 `left` 和 `right` 为左右子节点返回的状态数组。`// 计算u不偷的情况` `res[0] = max(left[0], left[1]) + max(right[0], right[1]);` `// 计算u偷的情况` `res[1] = u.val + left[0] + right[0];` | 设 `left` 和 `right` 为左右子节点返回的状态数组。 `// 计算u放摄像头` `res[1] = 1 + min(left) + min(right);` `// 计算u未被覆盖` `res[0] = left[2] + right[2];` `// 计算u被孩子覆盖` `res[2] = min(left[1] + min(right), right[1] + min(left));` |
| **5. 确定最终答案** | 根节点没有父节点，所以它既可以被偷，也可以不被偷。取两者最大值。 **`max(root_res[0], root_res[1])`** | 根节点不能处于“未被覆盖”的状态。所以只能从“放摄像头”或“被孩子覆盖”中选。 **`min(root_res[1], root_res[2])`** |

## Leetcode 834 树中距离之和

相见动态规划章节。

