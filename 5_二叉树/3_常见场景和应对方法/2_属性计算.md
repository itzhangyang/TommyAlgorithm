#属性计算

###LeetCode 104: 求树的最大深度

####核心思想和套路 - DFS(max(leftDepth,rightDepth) + 1)

使用DFS，递归计算左右子树的最大深度，返回最大深度

####难点分析和应对 - 空节点处理

递归需要处理空节点，确保深度计算无误。

####代码套路模板

```java
public int maxDepth(TreeNode root){
  if (root == null) return 0;
  
  int leftDepth = maxDepth(root.left);
  int rightDepth = maxDepth(root.right);
  
  return Math.max(leftDepth, rightDepth) + 1;
}
```

###求树的最小深度 - LC - 111

#### 问题要点

给定一个二叉树，找出其最小深度。

最小深度是从根节点到**最近叶子节点**的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例 1:**

- 输入: `root = [3,9,20,null,null,15,7]`
- 输出: `2`
- 解释: 节点 3 -> 9 是最短路径，长度为 2。

##### 最小深度的定义 - 必须到叶子节点结束

路径必须从根节点开始，到 **叶子节点** 结束。

##### 叶子节点定义 - 必须同时没有左右节点

一个节点如果同时没有左孩子和右孩子，它才是叶子节点。

#####关键陷阱 - 只有一个子节点的节点不是叶子节点

如果一个节点只有一个孩子（比如只有左孩子），那么这个节点**不是**叶子节点。

因此，不能简单地认为它的深度是 1。

必须继续沿着那个唯一的孩子路径向下寻找叶子节点。

#### 问题的本质和分析

这个问题的本质是在一个树形结构中，寻找从起点（根节点）到满足特定条件（是叶子节点）的终点的**最短路径**。

#####最短路径问题优先考虑BFS实现

对于图论和树中的“最短路径”问题，我们应该立刻想到**广度优先搜索 (BFS)**。

BFS 的特性是按层级进行遍历，它能够保证第一次找到目标节点时，所经过的路径就是最短的。

这与本题“最小深度”的要求完美契合。

##### 如果非要使用DFS的话需要注意的事项 - 避免关键陷阱

当然，**深度优先搜索 (DFS)** 也可以解决这个问题，但需要对递归逻辑进行特殊处理，以避免上面提到的“关键陷阱”。

在 DFS 中，你需要遍历到每一个叶子节点，记录下它们的深度，然后返回所有深度中的最小值。

相比之下，BFS 一旦找到第一个叶子节点就可以立即停止，因此在某些树形结构下（比如一个很深的“链表”状树，但其根节点旁边有一个很浅的叶子节点），BFS 的效率会高得多。

#### 模式套路匹配

##### 广度优先搜索 - 天然适合寻找最短路径

- **模式**: 在树或图中寻找最短路径。
- **信号**: 题目中出现“最小”、“最短”、“最近”、“层”等关键词。
- **匹配原因**: BFS 按层遍历，天然地适合寻找最短距离。找到的第一个符合条件的节点，其所在的层级就是最小深度。

##### 深度优先搜索/递归

**模式**: 任何涉及树的遍历、路径查找、属性计算的问题。

**信号**: 问题的解可以通过子问题的解来构建。例如，一个节点的最小深度与其子树的最小深度有关。

**匹配原因**: 树的结构天然具有递归性。但需要注意，**本题的递归关系不是简单的 `1 + min(left, right)`**，需要特殊处理。

####核心思想和套路 

##### 基于BFS的实现 - 最佳解法

一层一层地遍历树。在遍历过程中，记录当前的层数（也就是深度）。

当我们第一次遇到一个叶子节点时，当前的层数就是最小深度，直接返回即可。

###### 算法流程

- 如果根节点 `root` 为 `null`，返回深度 0。

- 创建一个队列 `queue`，并将根节点 `root` 入队。

- 初始化深度 `depth = 1`。

- 进入循环，只要队列不为空： 

  - a.  记录当前层的节点数量 `levelSize`。 

  - b.  遍历当前层的所有节点（循环 `levelSize` 次）： 

    - i.  从队列中取出一个节点 `currentNode`。

    - ii. **判断是否为叶子节点**: 如果 `currentNode.left == null` 并且 `currentNode.right == null`，说明我们找到了第一个叶子节点，它是最近的。直接返回当前深度 `depth`。 

    - iii. 如果有左孩子，将左孩子入队。

    - iv. 如果有右孩子，将右孩子入队。 
  - c.  当前层的所有节点处理完毕后，深度加一 `depth++`。


##### 基于DFS的实现

通过递归计算每个节点的最小深度。关键在于处理**只有一个子树**的情况。

###### Base Case - 当前节点为null

如果当前节点 `node` 为 `null`，返回 0。这表示空树的深度为 0。

###### 递归分解

- 递归计算左子树的最小深度 `leftDepth = minDepth(node.left)`。

- 递归计算右子树的最小深度 `rightDepth = minDepth(node.right)`。

###### 结果合并处理

- 如果左子树为空 (`leftDepth == 0`)，而右子树不为空，说明当前节点不是叶子节点，且路径必须经过右子树才能找到叶子。此时最小深度是 `1 + rightDepth`。
- 同理，如果右子树为空 (`rightDepth == 0`)，而左子树不为空，最小深度是 `1 + leftDepth`。
- **合并这两个条件**: 如果 `leftDepth == 0` 或 `rightDepth == 0`，说明至少有一个子树为空，我们必须走非空的那条路，所以结果是 `1 + leftDepth + rightDepth` (因为其中一个为0) 或者 `1 + max(leftDepth, rightDepth)`。
- 如果左右子树都**不为空** (`leftDepth > 0 && rightDepth > 0`)，说明左右两边都有叶子节点，我们应该选择路径更短的那一边。此时最小深度是 `1 + min(leftDepth, rightDepth)`。

#### 代码套路模板- BFS

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;

        while(!queue.isEmpty()){
            depth++;
            int size = queue.size();
            for(int i=0; i < size; i++){
                TreeNode node = queue.poll();
                if(node.left == null && node.right == null){
                    return depth;
                }
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
        }
        return depth;
    }
}
```



####代码套路模板 -DFS

```java
public int minDepth(TreeNode node){
  if (root == null) return 0;
  if (root.right == null && root.left == null) return 1;
  if (root.left == null) return minDepth(root.right) + 1;
  if (root.right == null) return minDepth(root.left) + 1;
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

###求二叉树的节点数量

可以采用遍历方法计算节点数量。

### Leetcode 543: 求二叉树的直径

#### 问题要点

- **定义**: "二叉树的直径" 是指树中**任意两个节点**之间最长路径的**长度**。

- **路径长度**: 这里的长度指的是路径上所包含的**边的数量**。

- **关键约束**: 这条最长路径**可能穿过根节点，也可能不穿过根节点**。它可能完全存在于左子树或右子树中。

#### 问题的本质和分析

##### 误区：直径 = 左子树的最大深度 + 右子树的最大深度

初看此题，很多人会陷入一个误区：直径 = 左子树的最大深度 + 右子树的最大深度。

这个想法只考虑了**穿过根节点**的情况。

但实际上，最长的路径可能完全隐藏在某一侧的子树中。

##### 正确的想法：计算穿过任意一个节点的最长路径长度

正确的思考方式是，对于树中的**任意一个节点**，我们可以计算出**穿过该节点**的最长路径长度。

这个长度等于它的 `左子树深度` + `右子树深度`。

那么，整棵树的直径，就是**所有节点**的“穿过该节点的最长路径长度”中的**最大值**。

这个分析将一个全局的问题（整棵树的直径）分解成了在每个节点上进行的局部计算（穿过该节点的最长路径），然后取全局最大值。

这自然地引出了使用深度优先搜索（DFS）来遍历所有节点，并在遍历过程中进行计算和更新。

#### 模式套路匹配

##### 深度优先搜索

解决此问题的核心是遍历每一个节点，并获取其子树的信息。DFS (特别是后序遍历) 是处理这类问题的标准方法。

##### 后序遍历 - 先计算左右子树的深度

为了计算以某个节点为“拐点”的路径长度，我们必须先知道其左、右子树的深度。

这意味着我们需要先处理完左子树和右子树，然后再处理当前节点。

这正是后序遍历的 `左 -> 右 -> 根` 的思想。

##### 分治思想

我们可以将问题分解为：

- 左子树的直径
- 右子树的直径
- 穿过当前根节点的最长路径
- 最终结果是这三者中的最大值。我们的解法虽然没有显式计算前两者，但通过在每次递归中更新全局最大值，隐式地覆盖了所有情况。

##### 递归函数的双重功能

递归函数既需要向上返回一个值（子树的深度），又需要在递归过程中更新一个全局状态（最大直径）。

这是树形DP或递归问题中一个非常常见的技巧。

#### 核心思想和套路 - 整棵树的直径等于**所有节点**的 `左子树深度 + 右子树深度` 这个值的最大值。

我们设计一个递归函数（例如 `depth()`），这个函数主要做两件事：

1. **主要任务 (返回值)**: 计算并**返回**以当前节点为根的子树的**最大深度**。这个返回值是给它的父节点使用的。
2. **副作用 (更新全局变量)**: 在计算深度的过程中，我们顺便得到了当前节点的 `左子树深度` 和 `右子树深度`。利用这两个值，我们计算出**穿过当前节点**的路径长度 (`左深度 + 右深度`)，并用它来更新一个全局的（或成员）变量，该变量用于记录迄今为止发现的最大直径。

通过这种方式，我们只需要对树进行一次遍历，就可以同时完成深度的计算和直径的更新，非常高效。

#### 实现原理

**初始化一个成员变量**: 在类中定义一个变量 `maxDiameter`，并初始化为 0。这个变量将跨越递归的边界，用于存储全局的最大直径。

**主函数入口**: `diameterOfBinaryTree(TreeNode root)` 作为主函数。它调用递归辅助函数，并最终返回 `maxDiameter`。

**设计递归辅助函数**: 创建一个私有辅助函数 `depth(TreeNode node)`。

- **功能**:
  - 返回以 `node` 为根的子树的最大深度。
  - 在过程中更新 `maxDiameter`。
- **实现**:
  - **基本情况 (Base Case)**: 如果 `node` 为 `null`，说明到达了叶子节点的下一层，其深度为 0，直接 `return 0`。
  - **递归分解 (Recursive Step)**:
    - 递归调用 `depth(node.left)` 计算左子树的最大深度，记为 `leftDepth`。
    - 递归调用 `depth(node.right)` 计算右子树的最大深度，记为 `rightDepth`。
  - **处理当前节点 (Process Current Node)**:
    - **更新直径**: 计算穿过当前节点的路径长度 `currentDiameter = leftDepth + rightDepth`。然后更新全局最大值 `maxDiameter = Math.max(maxDiameter, currentDiameter)`。
    - **返回深度**: 根据深度的定义，以当前节点为根的子树的深度是 `1 + Math.max(leftDepth, rightDepth)`。将这个值返回给上一层调用。

**启动与返回**: 在主函数中，调用 `depth(root)` 来启动整个递归过程。递归结束后，`maxDiameter` 中就保存了最终结果，返回它即可。

#### 实现代码

```Java
 //求二叉树的直径的长度
 //直径是二叉树中最长的路径，这条路径可能经过根节点，也可能不经过根节点
 //路径的长度是指路径两个端点之间的边的数量
 //求每个子树的左右子树的最大高度，该节点的直径就是左子树的最大高度+右子树的最大高度
class Solution {
    int diameter = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return diameter;
    }

    private int depth(TreeNode node){
        if(node == null) return 0;
        //计算左子树的深度
        int leftDepth = depth(node.left);
        //计算右子树的深度
        int rightDepth = depth(node.right);
        //更新最大直径
        diameter = Math.max(diameter, leftDepth + rightDepth);
        //返回当前树的高度
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

#### 注意事项

**路径长度与节点数**: 题目要求的是**边的数量**。我们计算的 `leftDepth + rightDepth` 正好是穿过当前节点的路径上的边数，无需转换。例如，左边一条边（深度1），右边两条边（深度2），总路径是3条边。

**全局变量的使用**: 在Java中，由于基本类型是按值传递的，递归函数无法直接修改上层函数栈中的 `maxDiameter` 变量。因此，通常将其设为成员变量（如本例），或者使用一个长度为1的数组 `int[]` 或其他可变对象来传递引用。

**后序遍历的本质**: 请务必理解代码中 `maxDiameter` 的更新发生在 `depth(node.left)` 和 `depth(node.right)` 调用**之后**，这体现了后序遍历的核心思想：处理完子问题后，再处理当前节点的问题。

**深度与高度**: 在这个问题中，我们将叶子节点的深度定义为1，空节点的深度定义为0。这个定义可以根据习惯调整（比如高度从0开始），但只要在计算中保持一致，结果就是正确的。这里的定义 `1 + max(...)` 是最直观且最常见的。

#### 经验总结

**一题多解，举一反三**: LeetCode 543 是一个典型的树形问题，其解法思想可以应用于许多其他问题，例如：

- LeetCode 124. 二叉树中的最大路径和 (Binary Tree Maximum Path Sum) - 思路极其相似，只是从计算深度和变成了计算路径和。
- LeetCode 687. 最长同值路径 (Longest Univalue Path) - 同样是在递归中同时返回值和更新全局变量。

**识别递归的双重任务**: 当你发现一个树的问题，需要的信息（如深度、子树和）和最终要求解的目标（如直径、最大路径和）不完全一致时，就要考虑使用这种“**递归函数返回A，顺便更新全局变量B**”的套路。这是一个非常强大且通用的技巧。

**不要陷入局部最优**: 要时刻提醒自己，全局最优解（整棵树的直径）不一定和根节点的局部最优解（穿过根的路径）是一回事。解决方案必须能覆盖所有节点，确保找到真正的全局最优。我们的算法通过遍历每个节点并将其作为潜在的“拐点”来计算路径，保证了这一点。



### Leetcode 662: 计算二叉树的最大宽度

#### 问题要点

1. **定义宽度**: 树的宽度是指在**任意一层**中，最左边的非空节点和最右边的非空节点之间的跨度。
2. **包含`null`节点**: 这个跨度需要计算中间的所有节点，即使它们是 `null`。
3. **计算方式**: 宽度等于该层最右边非空节点的“位置”减去最左边非空节点的“位置”再加 1。
4. **目标**: 找到所有层中，宽度的最大值。

**示例:**

```
      1
     / \
    3   2
   / \   \
  5   3   9
```

- 第一层: `[1]`，最左是1，最右是1。宽度 = 1 - 1 + 1 = 1。
- 第二层: `[3, 2]`，最左是3，最右是2。宽度 = 2 - 1 + 1 = 2。
- 第三层: `[5, 3, null, 9]`，最左是5，最右是9。宽度 = 4 - 1 + 1 = 4。
- 最大宽度为 4。

#### 问题本质和分析

##### 问题的本质 - 计算索引或者位置之间的距离

这个问题的核心挑战在于如何给每个节点一个唯一的、可用于计算距离的“位置”或“索引”。

简单地在每一层从1开始计数是行不通的，因为它无法体现 `null` 节点所占据的空间。

问题的本质是**将二叉树的节点映射到一个数学坐标系中**。

##### 满二叉树和它的性质

我们可以把任何一个二叉树想象成一个**满二叉树（Complete Binary Tree）**。

在满二叉树中，每个节点都有一个固定的位置编号。

如果我们给根节点编号为 `i`，那么它的：

- 左子节点编号为 `2 * i`
- 右子节点编号为 `2 * i + 1`

如果我们从0开始编号，根为 `i`，则左子节点为 `2*i+1`，右子节点为 `2*i+2`。

##### 每个节点标记一个绝对位置

**为了计算方便，我们通常从1开始**。

通过这种方式，无论树长什么样，每个节点都有了一个绝对的位置索引。

这样，每一层的宽度就可以通过下面公式计算：

$width=rightmostIndex−leftmostIndex+1$

我们的任务就变成了遍历树的每一层，找出每一层的 `leftmost_index` 和 `rightmost_index`，计算宽度，并维护一个全局的最大宽度值。

##### 当心陷阱 - 溢出问题 - 使用Long类型存储索引

当树的深度很深时，索引 `i` 会以 2h (其中 `h` 是深度) 的速度增长，这会轻易导致标准的32位整型（`Integer`）溢出。

因此，**必须使用64位长整型（`Long`）来存储节点的索引**。

#### 模式套路 - 索引化节点

**二叉树遍历**: 这是一个典型的二叉树遍历问题。

**分层处理**: 问题要求计算“每一层”的宽度，这是一个强烈的信号，表明 **广度优先搜索 (BFS)** 是最自然、最直观的解法。BFS 的核心就是一层一层地处理节点。

**节点附加信息**: 在遍历过程中，我们不仅需要节点本身，还需要它的附加信息——“索引”。因此，在队列中存储的不能仅仅是 `TreeNode`，而是一个包含 `(TreeNode, index)` 的数据结构（如自定义类、Pair或数组）。



#### 核心思想和套路 - 坐标化

##### 核心思想：坐标化/索引化 (Coordinate-ization / Indexing)

将树的物理结构问题，通过赋予坐标（索引），转化为一个数学计算问题。

##### 套路： BFS逐层遍历

1. 使用一个队列来进行 BFS。队列中存储的元素包含节点及其在满二叉树中的索引。

2. 在每一轮 BFS 循环中，处理当前层的所有节点。

3. 在处理每一层之前，记录下当前队列的大小 `size`，这就是当前层的节点数。

4. 在循环 `size` 次的过程中：

   - 记录下第一个出队节点的索引，作为该层的 `leftmost_index`。

   - 不断更新 `rightmost_index` 为当前出队节点的索引。

   - 将出队节点的非空子节点连同它们的新索引（左：`2*i`，右：`2*i+1`）一同入队，为下一层的处理做准备。

5. 处理完一层后，用 `rightmost_index - leftmost_index + 1` 计算该层宽度，并更新全局最大宽度。

6. 重复此过程，直到队列为空。

#### 实现原理和步骤

以BFS为例，步骤如下：

1. **初始化**:
   - 创建一个 `maxWidth` 变量，初始为0。
   - 处理边界情况：如果 `root` 为 `null`，直接返回 0。
   - 创建一个队列 `queue`。为了存储节点和索引，我们可以创建一个简单的辅助类 `NodeInfo(TreeNode node, long index)`。
2. **起始状态**:
   - 将根节点和它的初始索引（我们定为1）放入队列：`queue.offer(new NodeInfo(root, 1L))`。
3. **循环遍历 (BFS)**:
   - 当队列不为空时，进入循环。
   - 获取当前层的节点数量 `levelSize = queue.size()`。
   - 定义 `leftmostIndex` 和 `rightmostIndex` 变量，用于记录当前层的最左和最右索引。
   - 循环 `levelSize` 次，处理当前层的所有节点：
     - 从队列中取出一个 `NodeInfo` 对象 `current`。
     - 获取节点 `node = current.node` 和索引 `index = current.index`。
     - 如果是当前层的第一个节点 (`i == 0`)，记录 `leftmostIndex = index`。
     - 无论何时，都用当前索引更新 `rightmostIndex = index`。
     - 如果左子节点 `node.left` 不为 `null`，将其和新索引 `index * 2` 包装成 `NodeInfo` 对象加入队列。
     - 如果右子节点 `node.right` 不为 `null`，将其和新索引 `index * 2 + 1` 包装成 `NodeInfo` 对象加入队列。
   - 当前层处理完毕后，计算宽度 `currentWidth = rightmostIndex - leftmostIndex + 1`。
   - 更新最大宽度 `maxWidth = Math.max(maxWidth, currentWidth)`。
4. **返回结果**:
   - BFS 结束后，`maxWidth` 中存储的就是最终结果，返回它。

### 实现代码

```Java
 class Pair {
    TreeNode node;
    int index;
    public Pair(TreeNode node, int index){
        this.node = node;
        this.index = index;
    }
 }
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        Deque<Pair> deque = new LinkedList<>();
        deque.offer(new Pair(root,1));
        int maxWidth = Integer.MIN_VALUE;

        while(!deque.isEmpty()){
            int size = deque.size();
            int width = deque.peekLast().index - deque.peekFirst().index + 1;
            maxWidth = Math.max(width, maxWidth);
            for(int i = 0; i < size; i++){
                Pair curr = deque.pollFirst();
                int currIndex = curr.index;

                if(curr.node.left != null){
                    deque.offer(new Pair(curr.node.left,currIndex * 2));
                }

                if(curr.node.right != null){
                    deque.offer(new Pair(curr.node.right, currIndex * 2 + 1));
                }
            }
        }
        return maxWidth;
    }
}
```

#### 注意事项

**索引溢出**: 这是本题最核心的陷阱。树的深度每增加一层，索引值可能会翻倍。对于一个深度为 `d` 的树，最右侧节点的索引可能达到 2d。如果树很深且偏斜，这个值会迅速超出 `Integer.MAX_VALUE`。**务必使用 `long` 来存储索引**。

**BFS 分层逻辑**: `int levelSize = queue.size();` 这行代码至关重要。它固定了当前层的节点数量，确保内层循环不多不少，正好处理完一层的所有节点。这是 BFS 分层遍历的标准模式。

**索引起点**: 索引是从 0 开始还是从 1 开始都可以，只要保持一致即可。

- 从 1 开始: `root=1`, `left=2*i`, `right=2*i+1`
- 从 0 开始: `root=0`, `left=2*i+1`, `right=2*i+2` 代码中采用的是从1开始，更为直观。

#### 经验总结

**转化思想**: 此题是“将几何/结构问题转化为代数/数学问题”的典范。通过给节点赋予坐标（索引），我们将一个看似复杂的“宽度”问题，简化为了简单的“索引相减”问题。

**模式识别**: 遇到涉及“层”、“深度”、“逐层”等概念的树问题时，应第一时间想到 **BFS**。它是解决这类问题的最有力工具。

**警惕数据范围**: 在算法题中，尤其是涉及乘法和指数增长的场景（如树的索引、动态规划的状态压缩等），要时刻对数据范围保持警惕，考虑是否需要使用 `long` 或 `BigInteger` 来防止溢出。

**DFS 解法**: 这个问题也可以用 DFS 解决。DFS 的思路是维护一个列表或哈希表，`Map<Integer, Long> leftmostIndices`，记录在每个深度（depth）第一次访问到的节点的索引。在 DFS 遍历时，传入当前节点的 `(depth, index)`。对于每个节点，计算 `index - leftmostIndices.get(depth) + 1` 作为当前深度下的一个潜在宽度，并更新全局最大值。DFS 在空间复杂度上可能更有优势（O(H)，H为树高），而BFS为O(W)，W为树的最大宽度。

