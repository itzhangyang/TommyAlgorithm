# 树的修改与转换

这类问题不只是读取树的信息，而是要直接修改树的结构，例如翻转、扁平化等。

## Leetcode 226: 反转二叉树

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode left = root.left;
        TreeNode right = root.right;

        root.left = invertTree(right);
        root.right = invertTree(left);

        return root;
    }
}
```



## Leetcode 114: 将二叉树展开为链表

Given the `root` of a binary tree, flatten the tree into a "linked list":

- The "linked list" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.
- The "linked list" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.

```Java
class Solution {

    public void flatten(TreeNode root) {
        List<TreeNode> path = new ArrayList<>();
        preorder(root, path);
        TreeNode dummy = new TreeNode(-1);
        TreeNode prev = dummy;
        for(TreeNode node : path){
            prev.right = node;
            node.left = null;
            node.right = null;
            prev = node;
        } 
    }

    private void preorder(TreeNode node,List<TreeNode> path){
        if(node == null){
            return;
        }
        path.add(node);

        preorder(node.left,path);
        preorder(node.right, path);
    }
}
```

## Leetcode 116: 设置二叉树节点的next为右侧节点

You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

```Java
class Solution {
    public Node connect(Node root) {
        if(root == null){
            return null;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            Node prev = null;

            for(int i = 0; i < size; i++){
                Node curr = queue.poll();
                if(prev != null){
                    prev.next = curr;
                }
                prev = curr;
                if(curr.left != null){
                    queue.offer(curr.left);
                }
                if(curr.right != null){
                    queue.offer(curr.right);
                }
            }
        }
        return root;
    }
}
```

