# 二叉搜索树

**问题定义**: 验证、查找、插入、删除、裁剪、寻找第K小元素、LCA等。

**核心思想**: 牢记并利用 **左 < 根 < 右** 的性质。

- **验证**: 递归时，不仅比较父子，还要维持一个 `(min, max)` 的有效值区间。
- **LCA**: 如果 p、q 都比根小，则去左子树；都大则去右子树；否则根就是LCA。
- **第K小**: BST 的中序遍历是天然的升序序列。

## Leetcode 98: 验证二叉树是否是二叉搜索树 - 中序遍历

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

### 核心思想 - 中序遍历

- 初始化一个列表`path`
- 中序遍历二叉树，将每个节点加入path
- 验证list是否是递增的
  - 如果`list.get(i-1) > list.get(i)`, 返回`false`

### 实现代码

####基于中序遍历输出的列表

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        inorder(root,path);
        for(int i= 1; i < path.size(); i++){
            System.out.print(path.get(i)+",");
            if(path.get(i-1) >= path.get(i)) return false;
        }
        return true;
    }

    private void inorder(TreeNode node, List<Integer> path){
        if(node == null) return;
        inorder(node.left, path);
        path.add(node.val);
        inorder(node.right, path);
    }
}
```

#### 基于中序遍历过程

关键是设置两个核心变量：

- 前驱节点，当前节点的前置节点，用来比较与当前节点之间的值
- 是否搜索二叉树

```Java
class Solution {
    TreeNode prev = null;
    boolean isValidBST = true;
    public boolean isValidBST(TreeNode root) {
        inorder(root);
        return isValidBST;
    }

    private void inorder(TreeNode node){
        if(node == null){
            return;
        }

        inorder(node.left);

        if(prev != null && prev.val >= node.val){
            isValidBST = false;
            return;
        }
        prev = node;

        inorder(node.right);
        
    }
}
```



## Leetcode 230: 寻找搜索二叉树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

### 核心思想 - 利用中序遍历

利用中序遍历生成二叉树的遍历序列，返回`list.get(k-1)`即可。

#### 生成中序遍历数组的套路

```Java
    private void inorder(TreeNode node){
        if(node == null) return;

        inorder(node.left);
        list.add(node.val);
        inorder(node.right);
    }
```

### 实现代码

```Java
class Solution {
    private List<Integer> list;
    public int kthSmallest(TreeNode root, int k) {
        list = new ArrayList<>();
        inorder(root);
        return list.get(k-1);
    }

    private void inorder(TreeNode node){
        if(node == null) return;

        inorder(node.left);
        list.add(node.val);
        inorder(node.right);
    }
}
```

## Leetcode 450: 从二叉搜索树中删除一个节点

### 问题要点

1. **输入**: 一个二叉搜索树 (BST) 的根节点 `root` 和一个整数 `key`。
2. **任务**: 在该 BST 中找到值为 `key` 的节点，并将其删除。
3. **约束**: 删除节点后，树必须 **仍然保持二叉搜索树的性质**。
4. **输出**: 修改后 BST 的根节点。注意，根节点本身可能被删除，所以返回新的根节点非常重要。

#### 二叉树的性质

- 对于任意节点 `node`：
  - 其左子树中所有节点的值都 **小于** `node.val`。
  - 其右子树中所有节点的值都 **大于** `node.val`。
  - 其左右子树也必须分别是二叉搜索树。

### 问题的本质和分析 - 如何填补删除后的空缺

这个问题的本质不是 "查找"，而是 "删除并维护结构"。

查找一个节点在 BST 中很简单，挑战在于删除节点后如何用最小的代价去 "填补" 它留下的空缺，同时维持 BST 的性质。

#### 要删除的节点是叶子节点

这是最简单的情况。直接将其从树中断开即可（即让其父节点的对应指针指向 `null`）。

#### 要删除的节点只有一个子节点 - 将其父节点连接到其子节点

也比较简单。

将 `node` 的父节点直接连接到 `node` 的那个唯一的子节点上，跳过 `node` 即可。

#### 要删除的节点有两个子节点

这是最复杂，也是最核心的情况。

我们不能简单地删除它，因为会留下两个 "孤儿" 子树。

##### 从子节点中寻找替代者

为了维持 BST 性质，我们需要在 `node` 的位置上找到一个 "替代品"。这个替代品必须：

- 比 `node` 左子树的所有节点都大。
- 比 `node` 右子树的所有节点都小。

##### 替代者的候选人 - 后继节点和前驱节点

有两个理想的候选者：

- **后继节点 (Successor)**: `node` 右子树中的最小值。

- **前驱节点 (Predecessor)**: `node` 左子树中的最大值。

##### 选择候选人之后的操作

a. 在 `node` 的右子树中找到最小值节点 (即后继节点 `successor`)。

b. 将 `node` 的值替换为 `successor` 的值。

c. 现在问题转化了：**原问题是删除 `node`，现在变成了删除 `successor`**

由于 `successor` 是其所在子树的最小值，**它一定没有左子节点**，因此删除 `successor` 就变成了上述情况 1 或 2，这是一个递归的简化过程

### 核心思想和套路 ： 寻找 - 替换 - 重连。

使用一个返回 `TreeNode` 的递归函数。

这个返回值是至关重要的，它代表了当前子树在操作完成后的新根。

父节点通过接收这个返回值来更新自己的子节点指针，从而实现 "重连"。

#### 递归函数(`deleteNode`)的设计

##### 递归终止条件： root为null

如果 `root == null`，说明树是空的或者没找到 `key`，直接返回 `null`。

##### 递归查找

- 如果 `key < root.val`，说明要删除的节点在左子树。

  我们应该在左子树中执行删除操作，并 **更新当前节点的左孩子**。

  即：`root.left = deleteNode(root.left, key);`

- 如果 `key > root.val`，同理，在右子树中执行删除并更新右孩子。

  即：`root.right = deleteNode(root.right, key);`

##### 找到节点

如果 `key == root.val`，我们找到了要删除的节点，开始处理上述的三种情况。

##### 叶子节点或者只有一个子节点

如果待删除节点是叶子节点或者只有一个节点，则：

- 如果 `root.left == null`，则用 `root.right` 替代它（即使 `root.right` 也是 `null`，也同样适用）。返回 `root.right`。
- 如果 `root.right == null`，则用 `root.left` 替代它。返回 `root.left`。

##### 有两个子节点的情况

有两个子节点的情况，则**寻找最右边最小的节点**，并且将节点的值修改为最右边最小节点的值，然后删除最右边最小的节点。

- 找到右子树的最小节点 (后继节点 `successor`)。

- 将 `root.val` 替换为 `successor.val`。

- 在右子树中，递归地删除那个后继节点。即：`root.right = deleteNode(root.right, successor.val);`

##### 返回当前节点

在每一步操作完成后，返回 `root`。这个 `root` 可能是原始的 `root`，也可能是被替换后的新子树根。

### 实现原理和步骤 (Implementation Principle and Steps)

让我们用一个具体的例子来走一遍流程，假设要删除的节点有两个孩子。

```
      5
     / \
    3   6
   / \   \
  2   4   7
```

**目标**: `deleteNode(root, 5)`

1. 调用 `deleteNode(node=5, key=5)`。`key == node.val`，找到节点。
2. 节点 5 有两个孩子 (3 和 6)。进入情况 3。
3. **寻找后继节点**: 在右子树 (根为 6) 中寻找最小值。这个最小值是 6。
4. **值替换**: 将节点 5 的值替换为后继节点的值 6。

```
      6  <-- 值被替换
     / \
    3   6
   / \   \
  2   4   7
```

5. **转化问题**: 现在问题变成了在原来的右子树中删除值为 6 的节点。调用 `deleteNode(node=6, key=6)`。

   - 在右子树中，`key == node.val` (都是 6)。

   - 这个值为 6 的节点只有一个右孩子 7。进入情况 2。

   - 函数返回它的右孩子 7。

6. **重连**:

   上一步调用 `root.right = deleteNode(root.right, successor.val)` 中的 `root` 是指值为 6 (原值为5) 的节点。

   它接收到返回值 7，并将其设置为自己的新右孩子。

   ```
         6
        / \
       3   7  <-- 重连完成
      / \
     2   4
   
   ```

7. 整个过程结束，返回新的根节点 6。最终的树是合法的 BST。

### 实现代码

```Java

class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        // 1. 递归终止条件：树为空或未找到节点
        if (root == null) {
            return null;
        }

        // 2. 递归查找：根据BST性质向左或向右查找
        if (key < root.val) {
            // 在左子树中删除，并用返回的新左子树根更新当前节点的左指针
            root.left = deleteNode(root.left, key);
        } else if (key > root.val) {
            // 在右子树中删除，并用返回的新右子树根更新当前节点的右指针
            root.right = deleteNode(root.right, key);
        } else {
            // 3. 找到要删除的节点 (key == root.val)
            
            // 情况 1 & 2: 节点是叶子或只有一个子节点
            if (root.left == null) {
                return root.right; // 返回右子树作为新的根 (如果右子树也为null，则返回null)
            }
            if (root.right == null) {
                return root.left; // 返回左子树作为新的根
            }

            // 情况 3: 节点有两个子节点
            // 找到右子树中的最小节点 (后继节点)
            TreeNode successor = findMin(root.right);
            // 将当前节点的值替换为后继节点的值
            root.val = successor.val;
            // 在右子树中递归删除那个后继节点
            root.right = deleteNode(root.right, successor.val);
        }
        
        // 返回当前（可能被修改过的）子树的根
        return root;
    }

    /**
     * 辅助函数：在一个BST中找到最小值节点
     * @param node The root of the BST to search in.
     * @return The node with the minimum value.
     */
    private TreeNode findMin(TreeNode node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}
```

### 注意事项

1. **返回值的关键性**: `root.left = deleteNode(...)` 和 `root.right = deleteNode(...)` 是算法的核心。递归调用返回的是修改后的子树的根，必须将这个新的根重新连接到父节点上，否则树的结构不会被更新。
2. **根节点删除**: 这个算法天然地处理了根节点被删除的情况。如果 `key` 就是初始 `root` 的值，那么函数最后会返回一个新的 `root`。
3. **后继/前驱选择**: 代码中我们用了后继节点（右子树的最小值）。你完全可以使用前驱节点（左子树的最大值），逻辑是对称的，效果一样。
4. **时间复杂度**: O(H)，其中 H 是树的高度。在最坏的情况下（树退化成链表），H=N，复杂度为 O(N)。在平衡二叉搜索树中，H=logN，复杂度为 O(logN)。
5. **空间复杂度**: O(H)，主要由递归调用栈的深度决定。

### 经验总结

**递归思维是王道**: 对于树结构的操作（增、删、改、查），递归提供了一种非常清晰和简洁的表达方式。定义好递归函数的 **输入、输出和功能** 是解决问题的第一步。

**画图推演**: 在思考树的问题时，尤其是有结构修改时，一定要在纸上画图。模拟删除叶子节点、单孩子节点、双孩子节点的过程，可以帮助你理清逻辑，避免出错。

**理解指针/引用的重连接**: Java中的对象是通过引用传递的。`root.left = ...` 这一步操作的本质是改变 `root` 节点内部的 `left` 引用，使其指向一个新的 `TreeNode` 对象（即递归调用返回的对象）。

**问题转化**: 复杂问题简单化是重要的解题思想。本题中，最复杂的 "删除有两个子节点的节点" 被成功转化为了更简单的 "删除只有一个或零个子节点的节点" 问题，这是算法的精髓所在。

## Leetcode 700：在二叉树中查找元素

```Java
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null){
            return null;
        }
        if(val > root.val){
            return searchBST(root.right,val);
        }else if(val < root.val){
            return searchBST(root.left,val);
        }else{
            return root;
        }
    }
```

## Leetcode 701: 在BST中插入元素

```Java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null){
            return new TreeNode(val);
        }
        if(root.val > val){
            root.left = insertIntoBST(root.left, val);
        }else{
            root.right = insertIntoBST(root.right,val);
        }
        return root;
    }
}
```

## Leetcode 669: 修剪二叉搜索树

### 问题要点 - 移除范围`[low,high]`之外的节点

给定一个二叉搜索树 (BST) 的根节点 `root` 和一个整数范围 `[low, high]`。

你需要修剪这棵树，使得最终的树中只包含所有值在 `[low, high]` 范围内的节点。

修剪后的树应该仍然是一个合法的二叉搜索树。

**核心要求：**

1. **移除范围外的节点**：所有值小于 `low` 或大于 `high` 的节点都必须被删除。
2. **保持BST结构**：修剪后剩下的节点必须重新构造成一棵新的、合法的二叉搜索树。
3. **相对结构保持**：对于在范围内的节点，它们之间的原始父子关系或祖先-后代关系应该尽可能被保留。

### 问题的本质和分析

这个问题的本质是在一个二叉搜索树中进行范围删除，并**同时维持其二叉搜索树的特性**。

#### BST的性质

二叉搜索树 (BST) 有一个关键性质：对于任意节点 `node`：

- 其左子树中所有节点的值都**小于** `node.val`。
- 其右子树中所有节点的值都**大于** `node.val`。

这个性质是解决问题的关键。

当我们遍历到某个节点 `node` 时，可以利用它的值与范围 `[low, high]` 的关系来做出决策：

#### 当`node.val < low`：应该被删除

- 这个节点本身需要被删除。

- 根据 BST 的性质，该节点的**整个左子树**所有节点的值都小于 `node.val`，因此也必然小于 `low`。

  所以**整个左子树**都应该被丢弃。

- 但是，该节点的**右子树**可能包含在 `[low, high]` 范围内的值。

  因此，**修剪后的树应该存在于其右子树中**。

  我们需要继续在右子树中寻找合法的根。

#### 当`node.val > high`：应该被删除

- 这个节点本身需要被删除。

- 根据 BST 的性质，该节点的**整个右子树**所有节点的值都大于 `node.val`，因此也必然大于 `high`。

  所以**整个右子树**都应该被丢弃。

- 但是，该节点的**左子树**可能包含在 `[low, high]` 范围内的值。

  因此，**修剪后的树应该存在于其左子树中**。

  我们需要继续在左子树中寻找合法的根。

#### 如果 `low <= node.val <= high`

- 这个节点是合法的，应该被保留在树中。

- 但是，**它的左右子树可能含有不合法的节点，需要被修剪**。

- 因此，**我们需要递归地去修剪它的左子树和右子树**，并将修剪后的结果重新连接到当前节点上。

### 模式套路匹配 - 分治

这个问题的解决方式完美匹配了**树的递归（深度优先搜索）处理模式，特别是“分而治之” (Divide and Conquer)** 的思想。

- **模式**：对树进行操作，一个节点的最终状态（或其子树的结构）**依赖于其子节点的状态**。
- **套路**：定义一个递归函数 `trimBST(node, low, high)`，该函数的功能是**修剪以 `node` 为根的子树，并返回修剪后新子树的根节点**。

**函数的返回值**至关重要，它代表了处理完当前子问题后的“最终结果”（即新的子树根节点），父节点将使用这个返回值来更新自己的子节点引用。

### 核心思想和套路

核心思想是设计一个递归函数，该函数处理当前节点，并返回处理后应该**接替**当前节点位置的新节点。

#### 套路总结

#####**定义递归函数**： `TreeNode trim(TreeNode node, int low, int high)`

- **输入**：当前节点 `node` 和范围 `[low, high]`。
- **输出**：修剪后，`node` 这个位置应该由哪个节点来占据。

##### **处理基本情况 (Base Case)**：node为null

如果 `node` 为 `null`，说明已经到了叶子节点的下一层，直接返回 `null`。

##### 递归分解和处理

###### 情况一： `node.val < low`:删除节点及其左子树

- 当前节点和它的整个左子树都不合法。

- 最终的结果必然在右子树中。

- 因此，我们只需要递归修剪右子树，并**返回修剪后右子树的根**。

```
return trim(node.right, low, high);
```

###### 情况二： `node.val > high`:删除节点及其右子树

- 当前节点和它的整个右子树都不合法。

- 最终的结果必然在左子树中。

- 因此，我们只需要递归修剪左子树，并**返回修剪后左子树的根**。

```
return trim(node.left, low, high);
```

###### 情况三： `low <= node.val <= high`:修剪其左右子树

- 当前节点是合法的，需要保留。

- 但是它的左右子树需要被修剪。

- 递归修剪左子树，并将返回的新根连接到 `node.left`。

```
node.left = trim(node.left, low, high);
```

- 递归修剪右子树，并将返回的新根连接到 `node.right`。

```
node.right = trim(node.right, low, high);
```

- 最后，当前节点 `node` 依然是这个位置的合法根，返回它。

```
return node;
```

### 实现原理和步骤

从根节点 `root` 开始调用递归函数 `trimBST(root, low, high)`。

递归函数会深入到树的每个需要检查的节点。

在回溯（`return`）的过程中，节点的指针（`left`, `right`）会被重新赋值。

- 如果一个子节点被修剪掉了（例如，`node.val < low`），那么父节点对它的引用就会被更新为它的孙子节点（`node.right` 修剪后的结果）。
- 如果子节点本身合法，它的引用不变，但它的子树可能已经改变。

整个过程就像从下到上地“重建”这棵树，最终顶层调用 `trimBST(root, ...)` 会返回整个修剪后新树的根。

### 实现代码

```Java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        // 1. 基本情况：如果当前节点为空，直接返回 null
        if (root == null) {
            return null;
        }

        // 2. 如果当前节点的值小于 low，那么它本身和它的左子树都应该被丢弃。
        //    修剪后的树一定在它的右子树中。
        if (root.val < low) {
            // 返回对右子树进行修剪后的结果
            return trimBST(root.right, low, high);
        }

        // 3. 如果当前节点的值大于 high，那么它本身和它的右子树都应该被丢弃。
        //    修剪后的树一定在它的左子树中。
        if (root.val > high) {
            // 返回对左子树进行修剪后的结果
            return trimBST(root.left, low, high);
        }

        // 4. 如果当前节点的值在 [low, high] 范围内，则该节点应该被保留。
        //    接着，我们需要递归地修剪它的左子树和右子树，并更新左右子节点的引用。
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);

        // 返回保留的当前节点作为（子）树的根
        return root;
    }
}
```

### 注意事项

**BST的性质是前提**：这个解法高度依赖于二叉搜索树的有序性。如果输入不是BST，这个算法将得到错误的结果。

**指针的重新连接**：理解 `return` 语句和赋值语句 `node.left = ...` 的作用是关键。递归的返回值被上一层调用者用来更新其子节点的引用，这正是实现“修剪”和“连接”的核心机制。

**原地修改**：该算法是在原地修改树的结构，它通过改变节点的 `left` 和 `right` 指针来完成修剪，而不是创建一个全新的树。空间复杂度主要是递归栈的深度，即 O(H)，其中 H 是树的高度。

### 经验总结

####**树问题优先考虑递归**：

几乎所有的树问题都可以用递归的方式来优雅地解决。思考的模式是：假设你已经解决了子问题（即子树已经处理好了），你只需要考虑如何处理当前节点即可。

####**明确递归函数的定义**：

在写递归代码之前，一定要清晰地定义函数的**功能、输入和输出**。在本题中，`trimBST(node, ...)` 的功能不是“寻找”或“检查”，而是“修剪以`node`为根的树，并**返回**新树的根”。这个“返回新根”的定义是解题的灵魂。

####**利用BST性质简化问题**：

遇到BST相关问题，一定要思考如何利用其左小右大的性质来剪枝或简化逻辑。在本题中，正是这个性质让我们能够直接丢弃整个子树，而不是逐个检查子树中的每个节点。

####**画图模拟**：

对于树的问题，画图模拟递归的调用和回溯过程非常有帮助，可以让你清晰地看到指针是如何变化的，以及树的结构是如何被重塑的。

# 完全二叉树

完全二叉树 (Complete Binary Tree) 具有特殊的结构性质，可以用来进行算法优化，避免对整棵树进行完整遍历。

## 完全二叉树的特征和属性

**性质**: 一棵完美二叉树 (Perfect Binary Tree) 的节点数是 $2^h−1$（其中 h 是高度）。完全二叉树的子树中，至少有一个是完美二叉树。

**利用性质**: 我们可以通过比较左右子树的高度来快速判断子树是否为完美二叉树，**从而使用公式计算其节点数，而不是递归遍历**。

### 什么是完全二叉树？

### 什么是完美二叉树？



## 实现原理

1. 计算从根节点出发，一直向左走的高度 `left_height`。

2. 计算从根节点出发，一直向右走的高度 `right_height`。

3. 如果 `left_height == right_height`，说明整棵树是**完美二叉树**，节点数可直接用公式 $2^{leftHeight}−1$ 计算。

4. 如果 `left_height != right_height`，说明它是一个普通的完全二叉树。

   此时，我们无法使用公式，但可以确定其左右子树中必有一个是完美二叉树。

   这时我们再递归地计算左右子树的节点数，然后加上根节点，即 `1 + countNodes(root.left) + countNodes(root.right)`。

   由于其中一次递归会很快地命中完美二叉树的条件并返回，因此整体复杂度优于普通遍历。

## Leetcode 222: 计算完全二叉树中的节点数量

### 问题要点

**输入**: 一个**完全二叉树** (Complete Binary Tree) 的根节点 `root`。

**输出**: 该树中节点的总个数。

**核心要求**: 题目希望你能设计一个比常规遍历（时间复杂度为 O(N)，其中 N 是节点总数）更高效的算法。

###问题本质和分析 - **利用完全二叉树的特殊结构**来加速节点数量的计算

#### 朴素解法 - DFS或者BFS

最容易想到的方法是使用深度优先搜索（DFS）或广度优先搜索（BFS）来遍历整个树，每访问一个节点就将计数器加一。

**时间复杂度**: O(N)，因为需要访问树中的每一个节点。

**空间复杂度**: O(H) 或 O(W)，其中 H 是树的高度，W是树的最大宽度。对于完全二叉树，H=logN，空间复杂度为 O(logN)（递归栈）或 O(N)（队列）。

**问题**: 这个解法没有利用到“完全二叉树”的任何特性，对于任意二叉树都适用。因此，它不是本题的最优解。

#### 优化解法分析 - 利用完全二叉树的性质

#####**完全二叉树的性质**:

1. 完全二叉树的所有层都是满的，除了可能的最后一层。
2. 最后一层的节点都尽可能地靠左排列。

##### 满二叉树的性质

一个高度为 `h` 的满二叉树，其节点总数是固定的，为 2h−1。

这个公式是我们的优化关键。如果我们能确定树中存在一个满二叉树的子树，我们就可以用公式直接计算出这部分子树的节点数，而无需遍历。

##### 如何找到满二叉树子树？

对于任何一个节点 `node`，我们可以计算它左子树的高度和右子树的高度。

##### 计算左子树和右子树的最左路径

**关键判断**：我们不计算整个子树的实际高度，而是计算**沿着最左侧路径一直走到底的高度**。

从根节点 `root` 开始，我们计算其左子树的“最左高度” `leftHeight` 和右子树的**最左高度** `rightHeight`。

- `leftHeight`：从 `root.left` 出发，一直**向左走到底**的深度。
- `rightHeight`：从 `root.right` 出发，一直**向左走到底**的深度。

###### 如果左侧路径高度和右侧最左路径高度一致 - 左子树是满二叉树

- 这意味着什么？如下图所示，由于最后一层节点是从左到右填充的，如果左子树的最左路径和右子树的最左路径长度相等，那么**根节点的左子树必定是一棵满二叉树**。

- 此时，左子树的节点数可以直接用公式算出：$2^{leftHeight}−1$。

- 树的总节点数 = $1 (根节点) + (2^{leftHeight}−1) (左子树) + countNodes(root.right)$ (递归计算右子树)。

- 简化后为：$2^{leftHeight}+countNodes(root.right)$。

###### 左子树最左高度大于右子最左树高度 - 右子树是满二叉树

这意味着最后一层的节点填充只进行到了左子树，右子树还没有被填满。因此，**根节点的右子树必定是一棵满二叉树**，且其高度为 `rightHeight`。

此时，右子树的节点数可以直接用公式算出：$2^{rightHeight}−1$。

树的总节点数 = 1 (根节点) + `countNodes(root.left)` (递归计算左子树) + (2^rightHeight−1) (右子树)。

简化后为：1+countNodes(root.left)+(2^rightHeight−1)=countNodes(root.left)+2^rightHeight。

通过上述递归逻辑，在每一步中，我们都能将问题规模缩小一半（只递归一边），并且计算高度的操作本身也是对数级的，从而实现了整体效率的提升。

### 核心思想和套路 - 转化为满二叉子树并使用公式计算

####核心思想

将“遍历所有节点”的问题，转化为“在对数时间内确定一个满二叉子树并用公式计算，然后递归处理另一半”的问题。

#### 核心套路

1. 计算左右子树的“最左深度”。

2. 比较两个深度。

3. 根据比较结果，确定其中一个子树是满二叉树。

4. 使用公式 2h−1 计算该满二叉树的节点数。

5. 对另一个不确定的子树进行递归调用。

6. 将结果汇总。

### 实现原理和步骤

**主函数 `countNodes(root)`**:

- **Base Case**: 如果 `root` 为 `null`，返回 0。
- **计算高度**:
  - 初始化一个指针 `leftNode = root.left` 和 `rightNode = root.right`。
  - 初始化高度计数器 `leftHeight = 0` 和 `rightHeight = 0`。
  - 循环，当 `leftNode` 不为 `null` 时，`leftHeight++`，`leftNode = leftNode.left`。
  - 循环，当 `rightNode` 不为 `null` 时，`rightHeight++`，`rightNode = rightNode.left`。
- **判断和递归**:
  - 如果 `leftHeight == rightHeight`，说明左子树是满的。返回 `$ (1 \ll leftHeight) + \text{countNodes(root.right)} $`。 (`1 << h` 是计算 2h 的高效位运算方法)。
  - 否则 (`leftHeight > rightHeight`)，说明右子树是满的。返回 `$ \text{countNodes(root.left)} + (1 \ll rightHeight) $`。

### 实现代码

```Java
/**
 * Definition for a binary tree node.
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    /**
     * 主函数，计算完全二叉树的节点数
     * 时间复杂度: O(logN * logN)
     * 空间复杂度: O(logN) - 递归栈的深度
     */
    public int countNodes(TreeNode root) {
        // Base case: 空树
        if (root == null) {
            return 0;
        }

        // 1. 分别计算左右子树的“最左侧”高度
        TreeNode leftSubtreeRoot = root.left;
        TreeNode rightSubtreeRoot = root.right;
        
        int leftHeight = 0;
        while (leftSubtreeRoot != null) {
            leftSubtreeRoot = leftSubtreeRoot.left;
            leftHeight++;
        }

        int rightHeight = 0;
        while (rightSubtreeRoot != null) {
            rightSubtreeRoot = rightSubtreeRoot.left;
            rightHeight++;
        }

        // 2. 根据高度判断
        if (leftHeight == rightHeight) {
            // 如果左右子树的最左高度相同，说明左子树是满二叉树
            // 节点总数 = 1 (根节点) + (2^leftHeight - 1) (左子树) + 递归计算右子树
            // 简化为: (1 << leftHeight) + countNodes(root.right)
            // (1 << leftHeight) 等价于 Math.pow(2, leftHeight)
            return (1 << leftHeight) + countNodes(root.right);
        } else { // leftHeight > rightHeight
            // 如果左子树的最左高度大于右子树，说明右子树是满二叉树
            // 节点总数 = 1 (根节点) + 递归计算左子树 + (2^rightHeight - 1) (右子树)
            // 简化为: countNodes(root.left) + (1 << rightHeight)
            return countNodes(root.left) + (1 << rightHeight);
        }
    }
    
    /**
     * 作为对比的朴素解法
     * 时间复杂度: O(N)
     * 空间复杂度: O(logN)
     */
    public int countNodesNaive(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + countNodesNaive(root.left) + countNodesNaive(root.right);
    }
}
```

### 注意事项

**时间复杂度分析**: `countNodes` 函数本身会递归调用。每次调用都需要计算左右子树的高度，这个操作的时间复杂度是 O(H)，即 O(logN)。递归的路径是从根节点到叶子节点，深度也是 O(logN)。所以总的时间复杂度是 $O(logN×logN)=O((logN)^2)$。

**空间复杂度分析**: 算法使用的额外空间主要是递归调用栈的深度，它等于树的高度，所以空间复杂度是 O(H)=O(logN)。

**位运算**: 使用 `1 << h` 来计算 2h 比 `Math.pow(2, h)` 更高效，是处理二进制和幂运算时的常用技巧。

**审题**: 一定要抓住**“完全二叉树”**这个关键词。如果这是一棵普通二叉树，该优化算法将不成立，只能使用 O(N) 的遍历。

### 经验总结

**不要满足于暴力解**: 当你看到一个问题时，先思考暴力解或朴素解。然后，仔细分析题目给出的所有条件，尤其是数据结构的特殊性质，思考如何利用这些性质来优化算法。

**满二叉树是优化的金钥匙**: 在处理完全二叉树相关的问题时，"满二叉树"是一个非常有用的子结构。它的节点数、高度等都有确定的数学关系，可以帮助我们剪枝或进行快速计算。

**分治思想的广泛应用**: 分治法是算法设计的基石之一。将大问题分解为性质相同的小问题，是解决复杂问题的有效途径。本题就是通过比较高度，巧妙地将问题分解，并确保其中一个子问题有 O(1) 的解（通过公式）。

**画图帮助理解**: 对于树、图等结构化问题，画图是理解算法逻辑、推演边界条件的最好方法。画出 `leftHeight == rightHeight` 和 `leftHeight > rightHeight` 两种情况的示意图，算法逻辑便一目了然。

