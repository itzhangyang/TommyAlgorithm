#路径类 - DFS + 回溯

这类问题是**DFS + 回溯 (Backtracking)** 思想的经典应用。

通常使用**前序遍历**的框架，在递归进入子节点前“做选择”（将当前节点加入路径），在从子节点返回后“撤销选择”（将当前节点移出路径）。

- **实现原理**:
  1. 定义一个递归函数 `dfs(node, current_sum)`，表示从根走到 `node` 节点时，路径上已经累加的和。
  2. **前序位置**：将当前节点的值加入 `current_sum`。
  3. **终止条件**: 如果当前是叶子节点，检查 `current_sum` 是否等于目标值。如果是，则找到一条路径。
  4. **递归调用**: 对左右子节点递归调用 `dfs`。
  5. **回溯**: 如果需要记录路径本身（而不仅仅是判断存在性），则在函数返回前，需要将当前节点从路径记录中移除。

## 根节点到叶子节点的总和

###Leetcode 112: 判断路径和是否等于目标值的路径是否存在

判断从根到叶的路径和是否等于目标值

####核心思想与套路 - DFS

使用DFS，递归遍历每条路径并累加路径

####难点分析和应对

需要确保路径的累加值不出错

####代码模板

```java
public boolean hasPathSum(TreeNode root, int sum){
  if (root == null) return false;
  if (root.left == null && root.right == null){
    return root.val == sum;
  }
  return hasPathSum(root.left,sum - root.val)
    || hasPathSum(root.right, sum = root.val);
}
```

### Leetcode: 列举二叉树中所有的从根节点到叶子节点的路径

#### 问题要点

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

####核心思想 - 基于当前节点的回溯算法

使用上述方法二中，基于当前节点的回溯方法

- 判断当前节点是否满足终止条件，满足则返回
- 将当前节点加入路径
- 判断路径是否满足条件，若满足则加入结果，但是不返回
- 递归调用子节点
- 回溯当前节点，将当前节点从路径中删除

#### 实现代码

```Java
 //DFS 回溯
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path);
        return res;

    }

    private void backtrack(TreeNode node, List<Integer> path){
        if(node == null){
            return;
        }
        path.add(node.val);
        if(node.left == null && node.right == null){
            String result = path.stream()
                            .map(String::valueOf)
                            .collect(Collectors.joining("->"));
            res.add(result);
            //不要return
        }
        backtrack(node.left, path);
        backtrack(node.right, path);

        path.remove(path.size() - 1);
    }


}
```

### Leetcode 113:列举所有路径和为Target的路径[中序+回溯]

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

#### 一个错误的解实现

```
 //回溯+先序遍历
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path, targetSum);
        return res;
    }

    private void backtrack(TreeNode node, List<Integer> path, int currentTargetSum){
        if(currentTargetSum == 0 && node == null){
            res.add(new ArrayList<>(path));
            return;
        }
        if(node == null){
            return;
        }

        int newCurrentTarget = currentTargetSum - node.val;
        path.add(node.val);
        backtrack(node.left, path, newCurrentTarget);
        backtrack(node.right, path, newCurrentTarget);
        path.remove(path.size() - 1);
    }
}
```

现在来说错在哪里了？

#####回溯算法上两个最关键的节点

######终止条件(Base Case): 什么时候此路不通或者走到头了？

回溯算法本质上是在一个“决策树”上进行深度优先搜索（DFS）。

终止条件就是告诉程序什么时候应该停止向下探索，然后返回上一层。

在你的代码里，`if(node == null)` 就是一个正确的终止条件。

因为在树的遍历中，走到 `null` 节点就意味着这条分支到头了，必须返回。

###### 关键的错误：混淆了找到了一个解和搜索到终点的两种情况

`if(currentTargetSum == 0 && node == null)` 这个条件试图把“找到解”和“分支结束”合二为一，但它的逻辑是：“当我们走过一个节点，发现路径和对了，并且下一步是 `null` 时，就算成功”。

这显然是错的，因为成功的判断点应该是节点本身，而不是它下面的 `null`。

**思考诀窍**：问自己，“对于当前的节点/状态，我还能往下走吗？” 如果不能（比如节点为 `null`，或者数组越界），那就应该 `return`。这是最纯粹的终止条件。

##### 回溯算法的两种视角 

###### 方式一：做选择的视角：站在当前节点，决定下一步要走哪

这种方式通常适用于排列组合等场景。

这种方式我们称之为**站在当前节点，决定下一步要走哪**。

这就像你站在一个十字路口，前面有几条路（选项）。

你的思考过程是：

- **遍历所有选项：**查看所有可走的路
- **做出选择：**选中其中一条路，然后**把这条路（选项）加入到你的路径记录中**
- **前进:**沿着这条路走到下一个路口（递归调用）
- **回溯：**从下一个路口回来后，把刚刚那条路从你的路径记录中划掉，然后尝试其他的路。

用代码来描述这个过程，通常会有一个** `for` 循环**：

```Java
void backtrack(当前路径, 其他状态参数) {
    // ----------------------------------------------------
    // 1. 终止条件 (成功找到解)
    // ----------------------------------------------------
    // 这是算法正确性的基础。
    if (当前路径已经构成一个完整的解) {
        res.add(new ArrayList<>(path)); // 收集结果
        return;
    }

    // ----------------------------------------------------
    // 2. 终止条件 (当前路径已不可能构成解 -> 剪枝)
    // ----------------------------------------------------
    // 这个检查点是可选的，用于优化。它判断整个当前路径是否已经“跑偏”了。
    if (当前路径已确定无法通向任何有效解) {
        return; // 提前返回，砍掉整个无效分支
    }

    // ----------------------------------------------------
    // 3. 循环遍历所有“原始”选项
    // ----------------------------------------------------
    for (选项 item : 所有选项列表) {
        // ------------------------------------------------
        // 4. 剪枝 (跳过当前这个不合法的选项)
        // ------------------------------------------------
        // 这个检查点也是可选的，用于优化。它判断“当前这个选项”是否值得去尝试。
        if (选项 item 不合法或会产生重复) {
            continue; // 跳过这个选项，继续循环下一个
        }

        // 5. 做出选择
        // 将当前选项加入路径，并更新状态
        path.add(item);
        // ... 其他状态更新 (例如 used[i] = true)

        // 6. 递归
        // 进入下一层决策
        backtrack(更新后的路径, 更新后的状态参数);

        // 7. 撤销选择 (回溯)
        // 将刚才的选项从路径中移除，并恢复状态，以便下一次循环
        path.remove(path.size() - 1);
        // ... 其他状态恢复 (例如 used[i] = false)
    }
}
```

**关键点**：`add` 和 `remove` 操作是**围绕着递归调用**的，通常在 `for` 循环内部。我们添加的是“下一步的选择”。

###### 方式二：走路径的视角：到达了一个新节点，先记录下来

更直观，常见于树和图的深度优先搜索。

这种方式我们称之为 **“到达了一个新节点，先记录下来”**。

这就像你已经在探索一条路了，每次到达一个新的城市以后，你做的第一件事：

- **记录当前位置：**拿出地图，在当前的城市画个圈
- **判断状态：**看看这个城市是不是你的目的地
- **探索前方：**看看从这个城市除法，有哪些路可以走，然后沿这些路继续前进
- **离开此地：** 当你从这个城市出发的所有路径都探索完并返回后，说明这个城市对你没用了。你在地图上将刚刚画的圈擦掉，然后

在 Path Sum II 问题中看到的实现：

```Java
// 伪代码：树的路径问题
void backtrack(当前节点) {
    if (当前节点 == null) return; // 此路不通

    // 1. 记录当前位置 (把当前节点加入路径)
    path.add(当前节点.val);

    // 2. 判断状态
    if (当前节点是叶子 && 满足路径和条件) {
        res.add(new ArrayList<>(path));
        // 注意：这里不能直接return，因为还需要执行最后的remove操作
    }

    // 3. 探索前方
    backtrack(当前节点.left);
    backtrack(当前节点.right);

    // 4. 离开此地 (撤销选择)
    path.remove(path.size() - 1);
}
```

###### 两种方法的总结 - 基于当前节点

我们将当前地点成为当前节点，选项点成为选项

- 方法一：选项节点加入path
  - 判断路径是否满足条件，**满足条件加入结果，并返回**
  - 判断是否满足终止条件，满足则返回
  - 对于当前位置的**下一批选项中的每一个选项**
    - 查看**选项**是否合法或者可能造成重复，不合法continue
    - 将**选项**加入path
    - 递归调用选项
    - 回溯**选项节点**：从path中删除选项节点
- 方法二： 当前节点加入Path
  - 先判断**当前节点是**否达到终止条件，到达终止个条件返回
  - **当前节点**加入path
  - 判断路径是否满足条件，**满足条件了加入结果，但是不要返回**
  - 递归调用**子节点**
  - 回溯**当前节点**：从path中删除当前节点

###### 收集结果： 什么时候“Bingo！找到一个答案了”？

这是回溯算法的另一个核心，也是你代码出错的关键。**收集结果的判断，必须与题目要求的目标状态完全匹配。**

对于 LeetCode 113，目标状态是什么？

- 条件A：当前节点必须是 **叶子节点** (`node.left == null && node.right == null`)。
- 条件B：从根到 **当前这个叶子节点** 的路径和，必须等于 `targetSum`。

这两个条件必须同时满足，才能把当前路径 `path` 加入最终结果 `res`。

**你的错误在于：**

1. **判断时机过早/过晚**：你在 `node == null` 的时候判断，时机太晚了，已经走过了叶子节点。
2. **判断条件不完整**：你只判断了 `sum`，完全忽略了“必须是叶子节点”这个至关重要的约束。

**思考诀竅**：在递归函数的开头，紧接着处理完终止条件之后，就应该问自己：“当前的状态（节点、路径、剩余值等），是否已经构成了一个符合题目要求的完整解？” 如果是，就把当前路径的**一个拷贝** (`new ArrayList<>(path)`) 存入结果集。

####正确的实现

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, targetSum, path);
        return res;
    }

    private void backtrack(TreeNode node, int targetSum, List<Integer> path){
      //1.判断当前节点是否满足终止条件
        if(node == null) return;
        //2. 将当前节点加入path
        path.add(node.val);
      //3.判断当前path是否满足条件
        if(targetSum == node.val && node.left == null && node.right == null){
          //满足条件则加入结果集，但是不要return
            res.add(new ArrayList<>(path));
            // return; 这里不能执行return， 因为还需要执行最后的remove操作
        }
				//4. 递归调用子节点
        backtrack(node.left, targetSum - node.val, path);
        backtrack(node.right, targetSum - node.val, path);
				//5. 回溯当前节点
        path.remove(path.size() - 1);
    }
}
```

###Leetcode 1372:求二叉树中最长的Z形路径

#### 问题要点

给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。

请你返回给定树中最长 **交错路径** 的长度。

####问题本质和分析

- 锯齿路径从树的**任意节点**开始，每次交替方向，左 -> 右 或 右 -> 左。

- 路径的长度是指**从一个节点到达另一个节点所经过的边数**。

- 路径的方向**必须交替**，即从一个节点到下一个节点时，**必须沿着不同的子树（左或右）移动**。

- 本题是典型的**二叉树深度优先遍历（DFS）**题目。
- 深度优先遍历需要通过递归来搜索树的所有路径，记录当前的路径长度，并对路径的方向进行判断。

#### 模式套路匹配

这个问题非常符合**树的深度优先搜索 (DFS)** 或**树形动态规划 (Tree DP)** 的模式。

##### 深度优先搜索

我们需要遍历树中的每一个节点。

对于每个节点，我们需要根据其子节点的信息来计算某些值。

递归（DFS）是解决这类问题的最自然、最直接的方法。

函数的返回值或参数需要携带额外的信息来帮助父节点做决策。

##### 后序遍历思想

子问题的解（子树中的最长交错路径信息）可以用来构建父问题的解。

具体来说，一个节点的左子树向右延续的交错路径长度，可以用来计算当前节点向左走能得到的交错路径长度。

这体现了动态规划中“最优子结构”的思想。

我们可以定义一个递归函数 `dfs(node)`，它不仅要处理子树，还需要返回一些信息给调用者。具体来说，它需要返回从 `node` 出发，分别向左和向右走的最长交错路径长度。

#### 核心思想与套路

##### 定义递归函数的契约

首先，明确你的DFS递归函数是用来做什么的。

我们的 `dfs(node, length, isLeft)` 的契约（contract）就是： **“探索从 `node` 节点出发的所有可能性，并假设到达 `node` 的交错路径长度为 `length`，且这一步是通过 `isLeft` 方向完成的。”**

##### 延续当前路径或者重启一个新路径

这是整个套路最关键的一步。

当你站在一个节点上，你有两个孩子节点可以选择。

对于每一个选择，你都要考虑两种可能性：

###### 延续当前路径

如果这个选择的方向与你来的方向**相反**，那么恭喜你，交错路径得以延续。

- **操作**: 路径长度 `length + 1`，同时**翻转**方向标志，然后继续递归。
- *例如：从左边来的 (`isLeft == true`)，那么选择右孩子就是延续路径。*

###### 重启一个新的路径

如果这个选择的方向与你来的方向**相同**，那么抱歉，交错路径中断了。

但没关系，我们可以从这里开启一段**全新的交错路径**。

- **操作**: 路径长度**重置为 1**，并将方向标志设为**当前选择的方向**，然后继续递归。

- *例如：从左边来的 (`isLeft == true`)，你还选择左孩子，那么这就是一条长度为1的新路径的开始。*

通过在每个节点的左右两个方向上都执行这个“延续或重启”的判断，我们就能确保**不漏掉任何一条可能的交错路径**。

这个“重启”操作，天然地覆盖了“最长路径可以从任意节点开始”这个题目要求。

##### 使用全局变量实时打擂 - 最大值和最小值的常见套路

对于寻找“最大/最小”值的问题，一个常见的套路就是设置一个全局变量（如 `maxLength`），在遍历的每一步都进行“打擂台”式的更新。

- **更新时机**: 在递归函数的入口处，就用当前传入的 `length` 来更新 `maxLength`。
- **原因**: 因为到达当前节点的这条长度为 `length` 的路径本身就是一条完整的、有效的交错路径。最长的路径可能在这里就结束了，不一定非要走到叶子节点。所以每走一步，都要回头看看自己刚走过的路是不是已经创造了新纪录。

##### 总结：DFS + （延续/重启二元决策） + 全局变量

这个模式不仅适用于本题，也广泛适用于其他需要在树中寻找满足特定“历史路径”限制条件的题目，例如“寻找路径总和等于某值的路径”、“寻找最长同值路径”等。它将复杂的路径约束问题，简化为了在每个节点上基于“历史状态”的简单、局部决策。

####实现原理和步骤

##### 递归函数的设计：`dfs(node,length,isLeft)`

这个函数是整个算法的核心，它的三个参数定义了当前“行走”的状态：

- `TreeNode node`: 你现在站在哪个节点上。

- `int length`: 你走到当前这个节点，已经走了多远（路径长度）。

- `boolean isLeft`: 你是**如何到达**当前这个节点的？

  - `true`: 你是从父节点的**左边**走过来的。

  - `false`: 你是从父节点的**右边**走过来的。

##### 算法的启动

最长的交错路径可能从任何地方开始，我们的算法通过遍历所有节点和所有可能性来覆盖这一点。

- 我们无法从 `root` 节点“到达”它自己，所以真正的路径是从 `root` 的孩子开始的。
- `dfs(root.left, 1, true)`: 启动第一条探索路径。我们从 `root` 走到 `root.left`，这条路径长度为 **1**，并且它是通过**向左**走实现的。
- `dfs(root.right, 1, false)`: 启动第二条探索路径。我们从 `root` 走到 `root.right`，路径长度为 **1**，通过**向右**走实现。
- `maxLength` 初始为0，用来在整个探索过程中记录我们遇到的最长路径。

##### 递归过程中的决策

######先更新维护全局最大长度

在做任何决策以前，我们先用当前的路径长度`length`更新全局最大值。

这是因为**到达当前节点**本身就形成了一条有效的交错路径，它可能就是最长的那一条，所以不能错过。

`maxLength = Math.max(maxLength,length)`

###### 如果你是从左边过来的 

如果你是从左边来的，那么你现在是有两个选项：

- **继续交错 (Zig-Zag!):** 你必须向**右**走。我们调用 `dfs(node.right, length + 1, false)`。

  - `node.right`: 移动到右孩子。
  - `length + 1`: 路径长度加一。
  - `false`: 告诉下一个节点，你是从右边过来的。

- **打破规则重新开始：**如果你偏要向左走，那么交错路径就断了。

  不过没关系，从`node.left`这里可以开启一条**全新的路径**。

  这条全新路径的第一步是`node -> node.left`

  - `node.left`: 移动到左孩子。
  - `1`: 新路径的长度从1开始。
  - `true`: 告诉下一个节点，你是从左边过来的。

###### 如果你是从右边走过来的

逻辑完全对称。

1. **继续交错:** 必须向**左**走。调用 `dfs(node.left, length + 1, true)`。
2. **重新开始:** 如果向**右**走，则开启新路径。调用 `dfs(node.right, 1, false)`。

####实现代码

```java
class Solution {
    int maxLength = 0;

    public int longestZigZag(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 开启DFS，分别从根节点的左孩子和右孩子开始
        // 路径从 root->left 构成，长度为1，方向为“左”
        dfs(root.left, 1, true); 
        // 路径从 root->right 构成，长度为1，方向为“右”
        dfs(root.right, 1, false);
        return maxLength;
    }

    /**
     * 深度优先搜索
     * @param node 当前节点
     * @param length 到达当前节点时，已经形成的交错路径的长度
     * @param isLeft 一个布尔标记，true表示到达当前节点node的这一步是“向左”走的
     */
    private void dfs(TreeNode node, int length, boolean isLeft) {
        // 1. Base Case: 如果节点为空，路径结束
        if (node == null) {
            return;
        }

        // 2. 更新全局最大值
        //    一条有效的交错路径已经形成了（长度为length），尝试更新最大值
        maxLength = Math.max(maxLength, length);

        // 3. 核心递归逻辑：根据上一步的方向，决定下一步怎么走
        if (isLeft) {
            // 上一步是向左来的 (parent -> left -> node)
            // a) **延续路径**: 下一步必须向右走。
            //    路径长度增加1，方向变为“右”(false)
            dfs(node.right, length + 1, false);
            
            // b) **中断并重启路径**: 如果也从左边走，交错路径中断。
            //    从当前节点的左孩子开启一条全新的路径，长度为1，方向为“左”(true)
            dfs(node.left, 1, true);
        } else { // 上一步是向右来的 (parent -> right -> node)
            // a) **延续路径**: 下一步必须向左走。
            //    路径长度增加1，方向变为“左”(true)
            dfs(node.left, length + 1, true);
            
            // b) **中断并重启路径**: 如果也从右边走，交错路径中断。
            //    从当前节点的右孩子开启一条全新的路径，长度为1，方向为“右”(false)
            dfs(node.right, 1, false);
        }
    }
}
```

#### 注意事项

##### 路径长度的正确定义

题目要求的是“边的数量”。

我们的算法逻辑——延续路径时 `length + 1`，重启路径时设为 `1`——完全符合这个定义。

这是一个常见的细节陷阱，**如果误解为节点数量，会导致结果偏差1**。

##### 状态参数的清晰定义

`dfs(node, length, isLeft)` 中，布尔标志 `isLeft` 的含义必须非常清晰且在整个递归中保持一致。

我们将其定义为“**到达当前 `node` 的上一步**是向左走的”。

混淆其含义（例如，误解为“下一步应该向左走”）是导致逻辑错误的主要原因。

##### 全局最大值的更新时机

`maxLength` 必须在递归函数的**入口处**立即更新。

因为一条长度为 `length` 的有效路径在调用 `dfs(node, length, ...)` 时已经形成。

最长路径完全可能在树的中间节点结束，而不是在叶子节点。

如果只在 `node == null` 时更新，就会遗漏所有非叶子节点结尾的最长路径。

##### 递归的正确启动

真正的交错路径是**从根节点的子节点**开始计算的。

因此，主函数中需要分别从 `root.left` 和 `root.right` 启动DFS，并将初始长度设为 `1`，同时正确设置初始方向。

这是将问题从抽象的“树”转化为具体的“第一步路径”的关键。

##### 重启逻辑的重要性

在递归中，除了“延续”路径，另一个分支“重启”路径（即`dfs(..., 1, ...)`）至关重要。

它不仅是处理交错中断的情况，更重要的是，它隐式地实现了“**从树中任意节点开始**”这一要求。

每当路径中断并重启时，就相当于将当前节点视为一个新的起始点，从而保证了对所有可能路径的完全覆盖。

#### 经验总结

#####**识别信息流方向：**前序或者后序

**选择前序或后序遍历 (Pre-order vs. Post-order)** 这是解决所有树路径问题的核心决策点。

- **前序遍历 (参数传递，Top-Down)**: 当一个节点的决策依赖于**从根到它的路径信息**时（如本题的方向、到此的路径和、当前深度），应选择前序遍历。将状态作为参数自顶向下传递，逻辑清晰直接。
- **后序遍历 (返回值，Bottom-Up)**: 当一个节点的决策依赖于其**左右子树的计算结果**时（如子树高度、子树节点数、左右子树的最大路径），应选择后序遍历。让子节点将信息汇总返回给父节点。

##### 将路径问题转化为状态机

这个解法本质上是把树的遍历看作一个状态机。

递归函数 `dfs(node, length, isLeft)` 就是这个状态机，它的参数定义了所有必要的状态。

每一步递归调用，都是一次状态转移。

这个思想可以把一个看似宏大的问题，分解为在每个节点上进行的、定义清晰的局部状态转移，极大地降低了心智负担。

##### 掌握延续/重启的通用模式

在处理带约束的路径问题时，“延续或重启”是一个非常强大的子模式。在每个节点做决策时，主动思考两种可能性：

- 如何操作才能**满足约束**，并延续当前状态？ (`length + 1`)
- 如果**违反约束**，应该如何处理？通常是重置状态，开启一个新的计数。 (`length = 1`) 这个模式确保了算法的完备性。

##### 代码即思想

参数传递式的DFS写法，其代码结构几乎就是我们思考问题时的“内心独白”：“我现在在`node`，我是从`isLeft`方向走了`length`步过来的。

下一步，如果我走右边，就是延续；如果我走左边，就是重启...”。

让代码逻辑与思考过程同步，是写出优雅、不易错代码的关键。

## 任意节点到任意节点的路径最大和

###Leetcode 124: 求二叉树中的最大路径和

#### 问题要点

#####路径 (Path) 的定义：

路径被定义为从树中任意节点开始，沿着父-子连接，达到任意节点的序列。

#####路径的灵活性 - 任意节点开始任意节点结束

- 路径**不一定**需要经过根节点。
- 路径可以**从任意节点开始，到任意节点**结束。
- 路径中每个节点最多只能出现一次。
- 路径至少包含一个节点。

#####节点值 (Node Values) - 可能是负数

节点的值可能是正数、负数或零。这一点非常重要，因为它意味着我们可能需要“放弃”某些子树的路径来获得更大的和。

##### 目标 - 路径最大和

找到所有可能的路径中，路径和最大的是多少。

#### 问题的本质和分析 - 最大路径可能出现在任何位置

这个问题的核心难点在于，最大路径可能出现在树的任何位置。

##### 以某个节点为拐点的路径

对于任意一个节点 `node`，以它为“拐点”或“最高点”的路径是什么样的？

这条路径会包含 `node` 本身，并可能连接其左子树中的一条向下的路径和右子树中的一条向下的路径。

这条路径形如一个“拱形” (arch) 或者倒 'V' 形。

##### 最大路径可能存在于左子树或者右子树中

最大路径也可能完全存在于 `node` 的左子树中，或者完全存在于 `node` 的右子树中，而与 `node` 本身无关。

这种结构天然地指向了**递归**。

我们可以对每个节点进行分析，计算出穿过它的最大路径和，并在所有节点的计算结果中取一个全局最大值。

##### 给自己计算的值和返回给父节点的值不一致

这就引出了一个核心矛盾：

- **对于当前节点 `node`**：我们想计算 `node.val + (来自左子树的贡献) + (来自右子树的贡献)`，这个值可能成为全局最大路径和。
- **对于 `node` 的父节点**：它不关心以 `node` 为拐点的“拱形”路径。它只关心从 `node` 出发，**单向往下**延伸能提供的最大路径和（即 `node.val + max(左子树贡献, 右子树贡献)`），因为只有这样的单向路径才能和父节点连接起来，继续向上延伸。

这个“为自己计算的值”和“向上返回给父节点的值”不一致，是解决本题的关键。

#### 套路模式匹配

##### 深度优先搜索

问题结构具有递归性，对一个树的操作可以分解为对左右子树的相同操作。

##### 后序遍历

在处理当前节点之前，我们必须先知道其左、右子树能提供的信息（即从左右子树出发向下的最大路径和）。这正是后序遍历的特点（左 -> 右 -> 根）。

##### 全局变量 VS 递归返回值 - 非常经典的模式

这是一个非常经典的模式。递归函数本身返回一个值（给上一层递归调用使用），同时在递归过程中更新一个全局变量（用于记录整个过程中的最优解）。

- **全局变量**：记录全局的最大路径和。
- **递归返回值**：记录从当前节点出发向下的“单边”最大路径和。

#### 核心思想与套路

我们的核心策略是设计一个递归函数，例如 `maxGain(node)`，并维护一个全局变量 `maxSum`。

##### 全局变量 - 维护最大路径和

它负责记录到目前为止发现的全局最大路径和。

在遍历每个节点时，我们都会计算以该节点为“拐点”的路径和，并用这个值来尝试更新 `maxSum`。

初始化为 `Integer.MIN_VALUE`，因为最大路径和可能是负数。

##### 递归函数（maxGain(node)）

**定义**：该函数计算并返回从 `node` 节点开始，**向下延伸的单边最大路径和**。这个路径要么进入左子树，要么进入右子树，不能同时进入。

**作用**：这个返回值是提供给 `node` 的父节点使用的。

**计算过程：**

- 计算左子树最大深度：`leftGain = Math.max(0, maxGain(node.left))`
- 计算右子树最大深度：`rightGain = Math.max(0, maxGain(node.right))`
- 更新最大路径值： `maxSum = Math.max(maxSum, node.val + leftGain + rightGain)`
- 返回最大深度：Return value for parent: `return node.val + Math.max(leftGain, rightGain)`

#### 实现原理和步骤

##### 主函数流程

- **初始化**：在主函数 `maxPathSum` 中，声明一个成员变量或一个单元素数组 `maxSum`，并将其初始化为 `Integer.MIN_VALUE`。

- **调用递归**：从 `root` 节点开始调用递归辅助函数 `maxGain(root)`。

- **返回结果**：递归结束后，`maxSum` 中存储的就是最终答案，返回 `maxSum`。

#####辅助函数**`maxGain(TreeNode node)` 辅助函数的详细步骤：**

1. **处理基线条件 (Base Case)**：如果 `node` 为 `null`，返回 0。
2. **递归计算左右子树**：
   - `int leftGain = Math.max(0, maxGain(node.left));`
   - `int rightGain = Math.max(0, maxGain(node.right));`
   - 这里使用 `Math.max(0, ...)` 是为了剪枝。如果子树的单边路径和为负，则不采纳它，视其贡献为 0。
3. **更新全局最大路径和**：
   - 计算以当前 `node` 为“拐点”的路径和：`int currentPathSum = node.val + leftGain + rightGain;`
   - `maxSum = Math.max(maxSum, currentPathSum);`
4. **返回单边最大路径和**：
   - 向父节点返回从当前 `node` 向下延伸的单边最大路径和。
   - `return node.val + Math.max(leftGain, rightGain);`

#### 实现代码

```Java
class Solution {
    //初始化为最小值，因为可能有负数路径
    int maxPathSum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxPathSum;
    }

    private int maxGain(TreeNode node){
        if(node == null) return 0;
        //排除负数路径，使用Math.max(0,maxGain(node.left))
        int leftGain = Math.max(0,maxGain(node.left));

        int rightGain = Math.max(0, maxGain(node.right));
        //计算当前路径和
        int pathSum = leftGain + rightGain + node.val;
        //更新最大路径和
        maxPathSum = Math.max(pathSum, maxPathSum);
        //返回当前子树深度和
        return Math.max(leftGain,rightGain) + node.val;
    }
    
}
```

#### 注意事项

- **`maxSum` 的初始化**：必须是 `Integer.MIN_VALUE`，而不是 0。因为树中可能全是负数节点，这种情况下最大路径和就是一个负数。例如，对于只有一个节点 `[-3]` 的树，答案是 `-3`。

- **`max(0, ...)` 的使用**：这是算法的精髓之一。它体现了“如果一条路是亏钱的（路径和为负），那我就不走”的思想，即剪枝。

- **区分全局更新和返回值**：一定要清晰地区分 `maxSum = max(maxSum, node.val + leftGain + rightGain)` 和 `return node.val + max(leftGain, rightGain)`。前者是尝试更新最终答案，后者是为递归的上一层提供计算材料。这是两个完全不同的目的。

- **路径的定义理解**：要反复确认自己理解了“任意节点到任意节点”的含义。我们的算法之所以正确，就是因为它隐式地在以每个节点为路径“最高点”的情况下都计算了一遍，从而覆盖了所有可能性。

#### 经验总结

- **识别模式是关键**：当你遇到一个需要在树中找最优解（最大/最小/最长等）且这个最优解不一定与根节点有关的问题时，就要立刻想到“全局变量 + 递归辅助函数”这个模式。

- **明确递归函数的语义**：在动手写代码前，一定要用一句话清晰地定义你的递归函数是做什么的，它的输入是什么，输出（返回值）代表什么。对于本题，`maxGain(node)` 的定义就是“返回以 `node` 为起点，向下延伸的单边最大路径和”。定义清晰了，代码的逻辑自然就清晰了。

- **分解问题**：将一个复杂的问题（全局最大路径）分解成在每个节点上的两个小问题：

  1. 以我为根的子问题，对我自己（全局 `maxSum`）的贡献是什么？

  1. 我能为我的父节点提供什么价值（返回值）？

- **画图模拟**：对于复杂的树问题，拿一个例子，在纸上画出递归的调用栈和每个节点的计算、更新、返回过程，可以极大地帮助理解算法的执行流程。

###Leetcode 988: 从叶结点开始的最小字符串 

###### 问题要点

给定一个二叉树，每个节点的值是一个 `0` 到 `25` 之间的整数，分别对应字母 `'a'` 到 `'z'`。

我们需要从**叶子节点**开始，向上到**根节点**，形成一个字符串。在所有可能的从叶子到根的路径中，找到字典序最小的那个字符串。

**示例**

假设树的结构如下，节点中的数字代表其值：

```java
    0 (a)
   / \
  1 (b) 2 (c)
 / \   / \
3 (d) 4 (e) 5 (f) 6 (g)
```

- 从叶子节点 `d` (3) 到根节点 `a` (0) 的路径是 `d -> b -> a`，形成的字符串是 "dba"。
- 从叶子节点 `e` (4) 到根节点 `a` (0) 的路径是 `e -> b -> a`，形成的字符串是 "eba"。
- 从叶子节点 `f` (5) 到根节点 `a` (0) 的路径是 `f -> c -> a`，形成的字符串是 "fca"。
- 从叶子节点 `g` (6) 到根节点 `a` (0) 的路径是 `g -> c -> a`，形成的字符串是 "gca"。

在 "dba", "eba", "fca", "gca" 中，字典序最小的是 "dba"。因此，函数应返回 "dba"。

###### 问题的本质和分析

此问题的核心在于两个操作的结合：

1. **遍历所有从根到叶的路径**: 为了构建从叶子到根的字符串，我们必须首先能够识别出树中所有的完整路径。
2. **字符串的构建与比较**: 在遍历过程中，我们需要按照“从叶到根”的顺序构建字符串，并持续追踪迄今为止找到的字典序最小的字符串。

一个常见的误区是试图自底向上（从叶子到根）进行遍历。然而，在标准的树结构中，节点只有指向子节点的指针，而没有指向父节点的指针，这使得自底向上的遍历非常困难。

因此，更自然的方法是采用**自顶向下**的遍历方式，例如深度优先搜索 (DFS)。

在从根向叶遍历的过程中，我们可以记录下路径上的节点。

当到达一个叶子节点时，我们就拥有了一条完整的从根到叶的路径。

此时，我们再将这条路径反转，即可得到题目所要求的“从叶到根”的字符串，然后进行比较。

###### 背景知识

**二叉树 (Binary Tree)**: 一种基础的数据结构，每个节点最多有两个子节点，通常称为左子节点和右子节点。

**深度优先搜索 (Depth-First Search, DFS)**: 一种用于遍历或搜索树或图的算法。

DFS 会沿着一条路径尽可能深地搜索，直到到达该路径的末端，然后回溯到上一个节点，继续探索其他未访问过的路径。

递归是实现DFS的常用且自然的方式。

**字典序 (Lexicographical Order)**: 也称为字母序或词典序，是一种基于字母表的排序方法。在比较两个字符串时，从第一个字符开始逐个比较。第一个出现差异的字符决定了两个字符串的顺序。例如，"apple" < "apply" 因为在第四个字符处 'l' < 'p'。在Java中，`String` 类的 `compareTo()` 方法就是用来进行字典序比较的。

###### 考察点

- **树的遍历**: 熟练掌握二叉树的深度优先搜索（DFS）遍历，特别是递归的实现方式。
- **递归思想**: 理解如何通过递归函数的参数来传递路径信息，以及递归的终止条件（基准情况）。
- **字符串操作**: 能够在遍历过程中高效地构建和比较字符串。
- **算法设计**: 能够将问题分解为“遍历路径”和“比较结果”两个子问题，并设计出正确的算法流程。

###### 模式匹配

这个问题符合一个非常经典的算法模式：**在树的所有根到叶路径中寻找最优解**。

这类问题的通用解法模式通常是：

1. 使用深度优先搜索（DFS）来遍历所有路径。
2. 在递归函数中，维护一个“当前状态”的变量（在本题中，即为当前路径形成的字符串）。
3. 当遍历到叶子节点时，意味着一条完整的路径已经形成。此时，根据问题要求处理这条路径的结果（在本题中，是与全局最小字符串进行比较和更新）。
4. 在递归回溯时，需要相应地恢复“当前状态”，以确保不影响对其他路径的遍历。

###### 核心思想和套路

核心思想是**使用深度优先搜索（DFS），在遍历的同时构建从当前节点到根的字符串**。

套路如下:

1. **定义一个全局变量或引用**：用于存储当前找到的最小字符串。

   可以初始化为一个字典序非常大的字符串，或者在找到第一个叶子路径时再进行初始化。

2. **设计一个递归辅助函数**：`dfs(TreeNode node, String currentString)`

   - `node`: 当前遍历到的节点。
   - `currentString`: 从根节点到 `node` 的**父节点**所形成的路径字符串（注意顺序）。

3. **递归逻辑**

   **处理当前节点**: 将当前节点的值对应的字母加到路径字符串的前面。

   因为我们是从根向下遍历，而题目要求从叶到根的顺序，所以在每一步都将新字符加在最前面，可以巧妙地在遍历结束时直接得到逆序的字符串。

   ```java
   char ch = (char) ('a' + node.val);
   String path = ch + currentString;
   ```

   **判断叶子节点 (基准情况)**: 如果当前节点是叶子节点（`node.left == null && node.right == null`），说明我们找到了一条完整的路径。

   - 将当前形成的路径字符串 `path` 与全局最小字符串进行比较。
   - 如果 `path` 更小，则更新全局最小字符串。
   - 递归终止，返回。

   **递归调用 (Recursive Step)**: 如果当前节点不是叶子节点，则对其非空的子节点继续进行DFS。

   - `if (node.left != null) dfs(node.left, path);`
   - `if (node.right != null) dfs(node.right, path);`

###### 实现原理和步骤

**主函数 `smallestFromLeaf`**:

- 创建一个成员变量 `smallestString`，并初始化为一个特殊值或 `null`。
- 调用递归辅助函数 `dfs`，从根节点开始，初始路径字符串为空字符串 `""`。
- 返回 `smallestString`。

**递归函数 `dfs(TreeNode node, String currentPath)`**:

- **参数**: `node` 是当前节点，`currentPath` 是从根到 `node` 父节点的路径（字符顺序是从叶到根）。
- **边界检查**: 如果 `node` 为 `null`，直接返回。
- **构建新路径**: 将当前节点的值 `(char)('a' + node.val)` 拼接到 `currentPath` 的**开头**，形成新的路径字符串 `newPath`。
- **叶子节点判断**: 检查 `node` 是否为叶子节点。
  - 如果是，则将 `newPath` 与全局的 `smallestString` 比较。
  - 如果 `smallestString` 尚未初始化或者 `newPath` 的字典序更小，则更新 `smallestString = newPath`。
- **继续遍历**: 对 `node` 的左子节点和右子节点（如果存在）递归调用 `dfs`，并传入 `newPath`。

###### 实现代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    String smallestString = null;

    public String smallestFromLeaf(TreeNode root) {
        if (root == null) {
            return "";
        }
        dfs(root, new StringBuilder());
        return smallestString;
    }

    private void dfs(TreeNode node, StringBuilder currentPath) {
        // 将当前节点的值对应的字符插入到路径的开头
        currentPath.insert(0, (char) ('a' + node.val));

        // 检查当前节点是否是叶子节点
        if (node.left == null && node.right == null) {
            String pathStr = currentPath.toString();
            // 如果是第一个找到的路径，或者当前路径字典序更小
            if (smallestString == null || pathStr.compareTo(smallestString) < 0) {
                smallestString = pathStr;
            }
        }

        // 递归访问子节点
        if (node.left != null) {
            dfs(node.left, currentPath);
        }
        if (node.right != null) {
            dfs(node.right, currentPath);
        }

        // 回溯：在返回到父节点之前，将当前节点添加的字符移除
        // 这样可以确保兄弟节点的路径计算不受影响
        currentPath.deleteCharAt(0);
    }
}
```

###### 注意事项

**字符串构建方向**: 题目要求是从叶子到根，而遍历是从根到叶子。务必在构建字符串时进行逆序处理，即每次将新字符加在字符串的**最前面**。

**全局最小值的初始化**: 全局最小字符串 `smallestString` 的初始值需要妥善处理。可以设为 `null`，在找到第一条路径时直接赋值；或者设为一个字典序上不可能出现的“最大”字符串（例如用 `~` 字符组成的字符串）。

**回溯 (Backtracking)**: 如果使用可变对象（如 `StringBuilder`）来传递路径状态，必须在递归返回后进行状态的回溯，以避免对其他分支的计算产生干扰。使用不可变的 `String` 可以简化代码，避免手动回溯。

**空树处理**: 注意处理根节点为 `null` 的边界情况。

###### 经验总结

LeetCode 988 是一个很好的练习题，它将树的遍历与具体的业务逻辑（字符串比较）结合在了一起。解决此问题的关键在于选择合适的遍历策略并正确处理路径的构建。

- **优先选择DFS**: 对于求解所有路径相关的问题，深度优先搜索通常是更直观和易于实现的选择。
- **理解递归中的状态传递**: 思考在递归调用中需要传递哪些信息来维持算法的正确性。在本题中，就是 `currentPath`。
- **注意可变与不可变对象**: 在递归中使用 `StringBuilder` (可变) vs `String` (不可变) 有着重要的区别。前者效率可能更高但需要手动回溯，后者代码更简洁但可能创建更多对象。在算法竞赛中，除非性能瓶颈非常明显，否则优先选择代码简洁、不易出错的方案。
- **触类旁通**: 掌握了这种“DFS + 路径追踪”的模式后，可以轻松解决一系列类似问题，例如 "路径总和 II" (Path Sum II, LeetCode 113)、"二叉树的所有路径" (Binary Tree Paths, LeetCode 257) 等。这些问题都遵循着相似的递归遍历和路径记录的解题范式。

### Leetcode 437: 统计和为target的路径的总数

//详解 哈希表 - 树的前缀和

### 二叉树的对角线打印

#### 问题要点

给定一个二叉树的根节点 `root`，按照“对角线”的顺序返回所有节点的值。

#####**对角线的定义：**

- 根节点 `root` 位于第 0 条对角线。
- 对于任意节点 `node`：
  - 它的**右子节点** (`node.right`) 与它在**同一条**(Same Diag)对角线上。
  - 它的**左子节点** (`node.left`) 在它的**下一条**(Next Diag)对角线上（即 `node` 的对角线索引 + 1）。
- 你需要从第 0 条对角线开始，按顺序（0, 1, 2, ...）收集每条对角线上的所有节点。
- 在同一条对角线内，节点的顺序应为**从上到下**（即按遍历的先后顺序）。

**示例：**

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

- **对角线 0:** 8, 10, 14
- **对角线 1:** 3, 6, 7, 13
- **对角线 2:** 1, 4

**输出：** `[8, 10, 14, 3, 6, 7, 13, 1, 4]`

#### 问题的本质和分析 - 分组遍历

这个问题的本质是一个**分组遍历（Grouping Traversal）**问题。

它不像标准的 DFS (前/中/后序) 或 BFS (层序) 那样简单地访问节点，而是要求我们根据一个特定属性（“对角线索引”）对节点进行分组，然后按组的顺序输出。

核心挑战在于：

1. **确定分组键（Grouping Key）：** 我们需要为每个节点计算它所属的“对角线索引”。
2. **按键聚合（Aggregation）：** 将所有具有相同“对角线索引”的节点值聚合在一起。
3. **保证顺序（Ordering）：** 确保对角线本身是按 0, 1, 2... 的顺序输出的，并且每条对角线内部的节点也是按从上到下的顺序。

#### 规律观察 (Pattern Observation)：每条对角线可以看作由若干个左子节点作为起点向右延伸的链表

根据问题的定义，我们可以观察到以下规律：

- **规律一（右子树）：** 沿着一条 `node -> node.right -> node.right.right ...` 的路径，所有节点都属于**同一条**对角线。
- **规律二（左子树）：** 每当访问一个**左子节点**时，对角线的索引值就会 `+1`。
- **规律三（遍历顺序）：** 在上图示例中，`[8, 10, 14]` 都在 `d=0`。`[3, 6, 7]` 和 `[13]` 都在 `d=1`。`[1, 4]` 都在 `d=2`。
- `8` (d=0) 的左孩子 `3` 开启了 `d=1`。
- `3` (d=1) 的左孩子 `1` 开启了 `d=2`。
- `3` (d=1) 的右孩子 `6` 保持在 `d=1`。
- `6` (d=1) 的左孩子 `4` 开启了 `d=2`。
- `10` (d=0) 的左孩子 (null)。
- `14` (d=0) 的左孩子 `13` 开启了 `d=1`。

这揭示了一个关键点：**每条对角线可以看作是由若干个“左子节点”作为“起点”，然后向右延伸形成的链表**。

#### 核心思想与套路 (Core Idea and Technique)

##### 套路一：BFS + 哈希表（通用分组套路）

这是解决此类“分组遍历”问题的通用方法（也适用于垂序遍历等）。

1. **使用 `Map<Integer, List<Integer>> map`：**
   - `Key (Integer)`: 存储对角线索引 `d`。
   - `Value (List<Integer>)`: 存储该对角线上的所有节点值。
2. **使用 BFS 队列：** 队列中不能只存 `TreeNode`，必须同时存储它对应的对角线索引。我们可以用一个辅助类 `Pair(TreeNode node, int d)` 或者 `Queue<TreeNode>` 和 `Queue<Integer>` 两个队列。
3. **遍历：**
   - 将 `(root, 0)` 入队。
   - 循环处理队列：
     - 出队 `(curr, d)`。
     - 将 `curr.val` 添加到 `map.get(d)` 对应的列表中。
     - 如果 `curr.left` 存在，将 `(curr.left, d + 1)` 入队。
     - 如果 `curr.right` 存在，将 `(curr.right, d)` 入队。
4. **输出：** 遍历 `Map`，从 `d=0` 开始，按顺序 `d=1, d=2...` 将 `List` 拼接到最终结果中。

- **优点：** 思路清晰，是标准的分组套路，不易出错。
- **缺点：** 需要 `Map` 的额外空间，并且最后还需要一次遍历 `Map` 来组装结果。

#####套路二：优化的 BFS (队列法，更巧妙)

这是针对此问题**特性**的更优解法，它利用了“规律三”的观察。

1. **核心思想：** 我们用一个队列，但这个队列里只存储每条对角线的**起始节点**。
2. **数据结构：**
   - `List<Integer> result`: 存储最终结果。
   - `Queue<TreeNode> queue`: 仅用于存储“下一条”对角线的“起始节点”（即那些通过 `left` 访问到的节点）。
3. **遍历：**
   - 将 `root` 入队（`d=0` 这条对角线的起始点）。
   - 启动一个外层循环 `while (!queue.isEmpty())`。这个循环**一次迭代处理一整条对角线**。
   - 在外层循环中，`TreeNode node = queue.poll()`，`node` 是当前对角线的起始点。
   - 启动一个内层循环 `while (node != null)`，这个循环负责**遍历当前这条对角线**。
     - `result.add(node.val)`：将当前节点加入结果。
     - `if (node.left != null)`：**发现“下一条”对角线的起点，将其入队。**
     - `node = node.right`：**移动到当前对角线的下一个节点。**

- **优点：** 一次遍历即可得到最终顺序，空间复杂度更优（最差 O(N)，平均 O(√N)），代码极其简洁。

我们将采用**套路二**来实现，因为它更高效且更符合题意。

#### 实现原理： 基于套路二

1. **定义 `TreeNode` 类：** 包含 `val`, `left`, `right`。
2. **初始化：**
   - 创建一个 `List<Integer> result` 用于存放最终结果。
   - 创建一个 `Queue<TreeNode> queue` (例如 `LinkedList`)。
3. **处理边界：** 如果 `root == null`，直接返回空的 `result`。
4. **启动遍历：** 将 `root` 节点加入 `queue`。
5. **外层循环（遍历所有对角线）：**
   - `while (!queue.isEmpty())`：
   - 从队列中取出一个节点 `TreeNode node = queue.poll()`。这个 `node` 是当前要处理的对角线的“头节点”。
6. **内层循环（遍历当前对角线上的所有节点）：**
   - `while (node != null)`：
   - **a. 访问：** 将 `node.val` 添加到 `result` 列表中。
   - **b. 存储下一条对角线的起点：** 如果 `node.left` 不为 `null`，将其加入 `queue`。
   - **c. 沿当前对角线移动：** `node = node.right`。
7. **返回：** 当外层循环结束时，`result` 列表即为所求，返回 `result`。

#### 实现代码

```Java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class DiagonalTraversal {

    /**
     * 执行二叉树的对角线遍历
     * (使用优化的 BFS 队列法)
     */
    public List<Integer> diagonalTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        // 队列只存储每条对角线的“起始节点”
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        // 外层循环：遍历所有对角线
        while (!queue.isEmpty()) {
            // node 是当前对角线的“起始节点”
            TreeNode node = queue.poll();

            // 内层循环：遍历这条对角线上的所有节点
            while (node != null) {
                // 1. 将当前节点值加入结果
                result.add(node.val);

                // 2. 如果有左孩子，它是“下一条”对角线的起点，将其入队
                if (node.left != null) {
                    queue.offer(node.left);
                }

                // 3. 沿着当前对角线移动到右孩子
                node = node.right;
            }
        }

        return result;
    }

    // --- 示例用法 ---
    public static void main(String[] args) {
        /*
         * 8
         * / \
         * 3   10
         * / \    \
         * 1   6    14
         * / \   /
         * 4   7 13
         */
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(3);
        root.right = new TreeNode(10);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(6);
        root.right.right = new TreeNode(14);
        root.left.right.left = new TreeNode(4);
        root.left.right.right = new TreeNode(7);
        root.right.right.left = new TreeNode(13);

        DiagonalTraversal solution = new DiagonalTraversal();
        List<Integer> diagonalOrder = solution.diagonalTraversal(root);
        
        // 预期输出: [8, 10, 14, 3, 6, 7, 13, 1, 4]
        System.out.println(diagonalOrder); 
    }
}
```

#### 注意事项

1. **明确定义：** 解决任何遍历问题前，首要任务是**精确理解“序”的定义**。这个问题的“对角线”定义（`left` 进 `d+1`, `right` 进 `d`）与“垂序遍历”（`left` 进 `col-1`, `right` 进 `col+1`）截然不同。
2. **不要混淆：** 再次强调，此题不是 LeetCode 498 (矩阵)。如果你在面试中遇到此题，最好先和面试官确认“对角线”的具体定义。
3. **套路选择：**
   - `Map + BFS/DFS` 的通用分组套路（套路一）虽然代码稍多，但**更通用、更稳妥**，适用于各种需要按“键”分组的遍历。
   - 优化的队列法（套路二）代码更简洁，但它**强依赖**于“右子节点在同一组”这个特性。

#### 经验总结 (Experience Summary)

二叉树的对角线遍历”是一个非常好的非标准遍历练习。

- 它考察了你是否能脱离“前中后序”和“层序”的思维定式，根据新的规则（`d` 和 `d+1`）来组织遍历。
- 它展示了**队列（Queue）**的两种不同用法：
  1. **标准 BFS（层序）：** 队列用于存储“下一层”的所有节点，用 `size()` 来分隔层级。
  2. **本题解法（套路二）：** 队列用于存储“下一个任务单元”的**起始点**。在这里，一个“任务单元”就是一条完整的对角线。
- 这个“队列 + 内外循环”的模式（外循环处理队列中的任务起点，内循环处理任务单元本身）是一个非常强大的技巧，值得掌握。它将一个二维的树结构“拉平”成了一系列一维的链表（对角线）来处理。
