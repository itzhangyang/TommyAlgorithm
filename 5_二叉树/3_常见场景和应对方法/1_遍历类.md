# 遍历类

## 深度优先搜索 DFS

首先我们需要明确一下归属，二叉树的前序/中序/后序遍历都可以看作是**深度优先搜索**。

其核心在于明确**递归函数的定义**：这个函数在当前节点上需要做什么？

在当前节点，先处理一部分逻辑，然后将剩下的问题交给左右子树去解决（递归调用），最后根据子问题的结果汇聚成当前节点的最终结果。

###前序遍历： 根 - 左 - 右

遍历二叉树，按照**根 - 左 - 右**的顺序输出左右节点

####核心思想

- 使用**DFS**，递归遍历节点
- 访问当前节点，递归访问左子树，再递归访问右子树

####难点分析和应对

递归顺序需要严格控制

####代码套路模板

```java
public List<Integer> preorderTraversal(TreeNode root){
  List<Integer> res = new ArrayList<>();
  preorder(root,res);
  return res;
}

private void preorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  res.add(root.val);
  
  preorder(root.left,res);
  
  preorder(root.right,res);
}
```

###中序遍历：左 - 根 - 右

遍历二叉树，按照中序顺序（左子树 -> 根 -> 右子树）输出所有节点。

####核心思想

- 使用DFS
- 递归遍历左子树，访问根节点，再递归访问右子树

####难点分析和应对

递归时要保证左根右的顺序

####代码实现

```java
private void inorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  
  //左节点调用递归
  inorder(root.left, res);
  //处理根节点
  res.add(root.val);
  //处理有节点
  inorder(root.right,res);
}
```

###后序遍历： 左 -  右 - 根

遍历二叉树，按照左-右-根的方式输出所有节点

####核心思想 - DFS

- 使用DFS 
- 递归遍历左右子树，最后访问根节点

####难点分析和应对

根节点的处理要确保放在左右节点之后

####代码实现

```java
private void postorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  
  //递归调用左子树
  postorder(root.left, res);
  //递归处理右子树
  postorder(root.right,res);
  //处理根节点
  res.add(root.val);
}
```

###Leetcode 1038: [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)[逆中序遍历累加和]

这道题目要求将一个二叉搜索树（BST）转化为一个大于或等于它自身的累加树（Greater Sum Tree）。

这意味着树的每个节点的值将变为**大于等于它的节点**的所有节点的值之和。

具体地，树的每个节点的值将替换为**该节点及其右侧子树中所有节点**的值的总和。

####BST 特性 - 左 < 中 < 右

对于任意节点，左子树小于该节点，右子树的值大于该节点

目标是将节点的值修改为**该节点**以及**右子树所有节点**的和

####考察点 - 树的遍历和反向累加

通常情况下，我们使用中序遍历来处理BST相关的问题，但是由于这里需要修改为比当前节点大的和，因此需要使用**逆中序遍历**

####核心思想和套路： 逆中序 + 累加过程

需要注意的是，并不是要将每个节点的值 = 节点的值 + 其右子节点的值。

因为Greater节点的范围包含了：

- 右子节点
- 父祖辈节点

所以并不是简单的将节点重置为右子节点+当前节点就完事了。

正确的做法是维护一个**全局变量**或通过**引用传递**的变量来记录到目前为止所有已访问过节点（也就是所有值比当前节点大的节点）的**累加和**。

#####**逆中序过程**： 通过逆中序遍历来处理问题：

- 在遍历过程中，**当前节点需要先访问到它的右节点**，从而保证当前节点已经累加了右子树及其所有后代的值
- 通过这种方式，我们可以在遍历过程中实现累加的操作

#####**累加过程：**

在逆中序过程中，每次访问一个节点时，需要

- 将当前值与前一个累加变量相加
- 更新当前节点的值

这样可以保证节点的值逐渐变成原树的总和。

####实现原理和步骤

- 使用 **逆中序遍历（右-根-左）** 来遍历整个树。
- 维护一个**全局变量 `sum`** 来存储当前的累加和。(这一点是非常重要的实践)
- 对于每个节点
  - 将 `sum`累加到该节点上
  - 更新`sum`为该节点的累加
- 当遍历完成之后，树的每个节点就变成了累加树

####代码实现

```java
private int sum = 0;
public TreeNode bstToGst(TreeNode root){
  //右，中，左的树序
  if (root == null) return;
  //处理右节点
  bstToGst(root.right);
  
  //处理root节点
  sum += root.val;
  root.val = sum;
  
  //处理左节点
  bstToGst(root.left);
}
```

**`sum`**：用来保存当前累加和的全局变量。

**`bstToGst(TreeNode root)`**：采用递归的方式进行逆中序遍历。

- 先递归遍历右子树，使得我们能够处理当前节点之后的所有节点。
- 累加当前节点的值到 `sum` 上，并更新当前节点的值为 `sum`。
- 然后递归遍历左子树。

####时间复杂度

时间复杂度是 **O(n)**，其中 `n` 是树的节点数。因为每个节点都会被访问一次，且我们使用的是递归遍历

####空间复杂度

空间复杂度是 **O(h)**，其中 `h` 是树的高度。递归调用栈的最大深度为树的高度，因此空间复杂度为树的高度。对于平衡二叉树，`h` 是 **O(log n)**；对于退化树，`h` 是 **O(n)**。

####注意事项

需要小心处理树的结构，确保递归调用时不破坏树的结构。

本题的关键点在于逆中序遍历，而不是简单的中序遍历，因为我们需要对比当前节点和右子树的值进行累加。

####经验总结

**逆中序遍历** 是解决此类问题的常用技巧，尤其在处理需要从大到小的顺序累加时，非常有效。

需要理解题目中的转换过程，本题并非传统的递归求解问题，而是基于当前节点和右子树的值的累加，适合使用递归来避免手动维护栈。

##层序（BFS）- 按层遍历二叉树，输出每一层的节点

#### 核心思想和套路 - 广度优先搜索

使用队列逐层遍历树，每次处理当前层的所有节点。

#### 难点分析和应对

队列的管理要确保每一层的节点都被正确处理。

#### 代码实现

```java
public List<List<Integer>> levelOrder(TreeNode root){
  List<List<Integer>> result = new ArrayList<>();
   if (root == null) return result;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(currentLevel);
    }
    return result;
}
```

### Leetcode 102: 收集二叉树每层节点的列表

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        List<List<Integer>> res = new ArrayList<>();

        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.poll();
                list.add(curr.val);
                if(curr.left != null){
                    queue.offer(curr.left);
                }

                if(curr.right != null){
                    queue.offer(curr.right);
                }
                
            }
            res.add(list);
        }

        return res;
    }
}
```

### Leetcode 199: 二叉树的右侧视图

Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return *the values of the nodes you can see ordered from top to bottom*.

####核心思想与套路

我们采用广度优先遍历的方式，又叫做层次遍历。

每次遍历一层的节点，判断每个节点是否是最后一个节点，如果是最后一个节点，则加入结果集合即可。

最后的结果集合便是从右侧看二叉树所看到的所有节点。

#### 实现代码

```Java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        if(root == null){ return new ArrayList<>();}
        List<Integer> res = new ArrayList<>();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.poll();
                if(i == size - 1){
                    res.add(curr.val);
                }
                if(curr.left != null){
                    queue.offer(curr.left);
                }
                if(curr.right != null){
                    queue.offer(curr.right);
                }
            }
        }
        return res;
    }
}
```

### Leetcode 103: Z形层次遍历二叉树

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

#### 核心思想 - 双链表

可以使用一个双链表，并且维护一个变量reversed。

每次遍历以后，将所有节点加入双链表，无论reversed是否为`true`。

然后根据reversed将双链表中的节点加入到一个新列表中：

- reversed = true, 则不断的从双链表表头取出数据加入列表，直到双链表为空
- reversed = false，则不断从双链表尾部去除数据加入列表，直到双链表为空

最后将新的列表加入到结果集合中即可。

#### 实现代码

```Java
   public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean reversed = false;
        Deque<Integer> deque = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();

        while (!queue.isEmpty()) {
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.poll();
                deque.add(curr.val);
                if(curr.left != null){
                    queue.offer(curr.left);
                }
                if(curr.right != null){
                    queue.offer(curr.right);
                }
            }
            List<Integer> list = new ArrayList<>();
            if(reversed){
                while(!deque.isEmpty()){
                    list.add(deque.pollLast());
                }
            }else{
                while(!deque.isEmpty()){
                    list.add(deque.pollFirst());
                }
            }
            reversed = !reversed;
            res.add(list);
        }

        return res;
    }
```

## 求二叉树中两个节点的公共祖先

### Leetcode 236: 求普通二叉树中两个节点的公共祖先

#### 问题要点

- **输入：**一个二叉树的根节点root，以及树中两个不同节点`p`和`q`

- **输出：** 节点`p`和节点`q`的最近公共祖先

- **定义：** **最近公共祖先**的定义：在一个树中，同时拥有`p`和`q`作为后代的最深的节点（**距离根最远**）的节点。

  一个节点也可以**是它自己的后代**。

- **约束条件**
  - 树中所有的节点都是**唯一**的
  - `p`和`q`是不同的节点，并且一定存在树中
  - 这是一颗普通的二叉树，不是二叉搜索树

#### 问题的本质和分析

这个问题的本质是在一个树中寻找一个**分叉点**。

这个分叉点`L`满足以下两个条件之一：

- 节点`P`和`q`分别位于左子树和右子树中
- 节点`L`就是`P`，另外一个节点在某个子树中
- 节点`L`就是`q`，节点`P`在某个子树中

从根节点开始向下看，LCA就是`p`和`q`这两条**路径第一次相交的那个节点**。

- 在此节点之上， `p`和`q`位于同一个方向（都在左边或者都在右边）；
- 在此节点（包括此节点）之下，它们的路径开始分叉。

#### 套路模式匹配

##### 树的遍历

解决任何树相关的问题，都离不开遍历。我们需要访问树的节点来寻找`p`和`q`。

##### DFS

这个问题具有明显的递归结构。一个节点的LCA问题，可以分解为在其左右子树中寻找LCA的子问题。

这种“自顶向下分解，自底向上传递信息”的特性，非常适合使用递归（也就是DFS）来解决。

##### 后序遍历

在递归的实现中，我们需要先处理左右子树，然后根据左右子树的返回结果，来判断当前节点是什么情况。

这种“左-右-根”的处理顺序，正是后序遍历的特点。

#### 核心思想和套路

核心思想是设计一个**递归函数**，这个函数能够帮助我们**从下至上**地传递信息。

我们定义一个递归函数 `lowestCommonAncestor(currentNode, p, q)`，它的功能是： **在以 `currentNode` 为根的子树中查找 `p` 和 `q`，并根据查找结果返回一个特定的节点。**

这个函数的返回值有四种情况：

1. 如果在 `currentNode` 的子树中**同时找到了 `p` 和 `q`**，则返回它们的LCA。
2. 如果在 `currentNode` 的子树中**只找到了 `p`**，则返回 `p`。
3. 如果在 `currentNode` 的子树中**只找到了 `q`**，则返回 `q`。
4. 如果在 `currentNode` 的子树中**既没找到 `p` 也没找到 `q`**，则返回 `null`。

##### 递归的终止条件

- 如果当前节点 `currentNode` 为 `null`，说明已经越过叶子节点，什么也没找到，直接返回 `null`。

- 如果当前节点 `currentNode` 就是 `p` 或者 `q` 本身，那么我们已经找到了目标之一。

  根据我们的函数定义，此时应该返回 `currentNode`。

  因为 `p` 或 `q` 的更深层的子节点不可能是 `p` 和 `q` 的公共祖先了。

##### 递归的分解

- 向左子树递归，得到左子树的查找结果：`leftResult = lowestCommonAncestor(currentNode.left, p, q)`。
- 向右子树递归，得到右子树的查找结果：`rightResult = lowestCommonAncestor(currentNode.right, p, q)`。

##### 结果的合并

是最关键的一步，分析 `leftResult` 和 `rightResult` 的返回值：

1. **`leftResult` 和 `rightResult` 均不为 `null`**: 这说明什么？

   根据我们函数的定义，`p` 和 `q` 一个在左子树，一个在右子树。

   那么当前节点 `currentNode` 就是它们的“分叉点”，也就是LCA。我们返回 `currentNode`。

2. **`leftResult` 不为 `null`，`rightResult` 为 `null`**: 

   这说明 `p` 和 `q` 都在左子树中。

   左子树的调用 `leftResult` 已经返回了它们的LCA或者`p`/`q`中的一个。

   我们只需要将这个结果继续向上传递即可。所以返回 `leftResult`。

3. **`leftResult` 为 `null`，`rightResult` 不为 `null`**: 

   同理，这说明 `p` 和 `q` 都在右子树中。返回 `rightResult`。

4. **`leftResult` 和 `rightResult` 均为 `null`**: 

   说明左右子树都没有找到 `p` 或 `q`，返回 `null`。

通过这个自底向上的信息传递，当递归回溯到真正的LCA节点时，它的左右子树递归调用会分别返回`p`和`q`（或包含它们的子LCA），从而满足第一种合并情况，正确地将自己作为LCA返回。

#### 实现原理和步骤

**定义主函数 `lowestCommonAncestor(root, p, q)`**: 这是问题的入口。

**处理递归的终止条件**:

- 检查 `root` 是否为 `null`。如果是，返回 `null`。
- 检查 `root` 是否等于 `p` 或 `q`。如果是，返回 `root`。

**递归调用**:

- 在左子树中查找：`TreeNode left = lowestCommonAncestor(root.left, p, q);`
- 在右子树中查找：`TreeNode right = lowestCommonAncestor(root.right, p, q);`

**合并和返回结果**:

- 如果 `left != null && right != null`，说明 `p` 和 `q` 分布在 `root` 的两侧，`root` 就是LCA，返回 `root`。
- 如果 `left == null`，说明LCA（或者`p`/`q`）不在左子树，那它一定在右子树，返回 `right`。
- 如果 `right == null`，说明LCA（或者`p`/`q`）不在右子树，那它一定在左子树，返回 `left`。
- (注意：上面的`left == null`和`right == null`的判断已经包含了两者都为`null`的情况。例如，如果`left`是`null`，就返回`right`，此时`right`可能是`null`也可能不是，逻辑是完备的)。一个更简洁的写法是：`return left == null ? right : (right == null ? left : root);`

#### 实现代码

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
       if(root == p){
        return root;
       }
       if(root == q){
        return root;
       }
       if(p == q){
        return p;
       }
       TreeNode left = lowestCommonAncestor(root.left, p, q);
       TreeNode right = lowestCommonAncestor(root.right, p, q);
       if(left != null && right != null){
        return root;
       }
       if(left != null){
        return left;
       }
       if(right != null){
        return right;
       }
       return null;
    }
}
```

#### 注意事项

#####**问题假设的重要性**: 

此算法的简洁性高度依赖于“`p` 和 `q` 一定存在于树中”这个前提。

如果 `p` 或 `q` 可能不存在，那么当 `lowestCommonAncestor(root, p, q)` 返回一个非`null`节点时，你无法确定这个返回的是 `p`、`q` 还是真正的LCA。

这种情况下，需要额外的信息来验证是否两个节点都被找到了。

##### **与LCA of a BST的区别**: 

不要和 LeetCode 235 (二叉搜索树的最近公共祖先) 混淆。

对于BST，可以利用其节点值的**有序性**，通过比较 `p.val` 和 `q.val` 与 `currentNode.val` 的大小关系，以 O(logN) 的时间复杂度找到LCA，而无需遍历整棵树。

本题是普通二叉树，必须遍历。

#####**时间和空间复杂度**:

- **时间复杂度**: O(N)，其中 N 是树中节点的数量。因为在最坏情况下，我们需要访问树中的每一个节点一次。

- **空间复杂度**: O(H)，其中 H 是树的高度。

  这是由递归调用栈的深度决定的。在最坏情况下（树退化为链表），H=N；在最好的情况下（完全平衡二叉树），H=logN。

### Leetcode 235: 二叉搜索树中寻找两个节点的最近公共祖先

#### 问题要点

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

#### 核心思想 - 利用二叉搜索树的特性

- 如果root 为null， 返回null
- 如果root为p或者q, 返回root
- 找到`p`和`q`中的较大值和较小值
  - 较大值为`larger`
  - 较小值为`smaller`
- 如果root介于`larger`和`smaller`之间，返回root
- 如果root小于`smaller`，说明结果在左子树，递归调用`lowestCommonAncestor(root.left,p,q)`
- 如果root大于`larger`，说明结果在右子树，递归调用`lowestCommonAncestor(root.right,p,q)`

#### 实现代码

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        if(root == p || root == q){
            return root;
        }
        TreeNode larger = p.val > q.val ? p : q;
        TreeNode smaller = p.val > q.val ? q : p;

        if(root.val > smaller.val && root.val < larger.val ){
            return root;
        }

        if(root.val > larger.val){
            return lowestCommonAncestor(root.left, p, q);
        }
        if(root.val < smaller.val){
            return lowestCommonAncestor(root.right, p, q);
        }
        return null;
    }
```

