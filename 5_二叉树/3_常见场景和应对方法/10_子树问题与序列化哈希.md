# 子树问题与序列化哈希

这类问题涉及到识别、比较或者寻找重复的子树。

当子树的结构和值完全相同时，我们认为它们是相同的。

## 核心思想与套路 - 生成子树唯一标识

决这类问题的关键在于，如何为每个子树生成一个**唯一的标识符**

**最常用的方法是序列化 (Serialization)**。

将每个子树序列化成一个字符串，然后利用哈希表 (HashMap) 来存储和计数这些字符串，从而高效地发现重复的子树。

## 实现原理

### 选择序列化方式

 通常使用前序或后序遍历来序列化。为了区分结构，必须将空节点 (null) 也包含进来。

### 后序遍历 + 序列化

使用后序遍历是最自然的，因为它首先处理完子树，得到子树的序列化结果，然后再处理当前节点。

#### 后序遍历序列化的套路模板

```Java
private String postorderSerialize(TreeNode node){
  if(node == null){
    return "#";
  }
  
  String leftSerial = postorderSerialize(node.left);
  String rightSerial = postorderSerialize(node.right);
  
  String serial = node.val +"," + leftSerial +"," + rightSerial
}
```



### 递归函数

**`dfs(node)`**: 返回以 `node` 为根的子树的序列化字符串。

### 哈希表记录

在 `dfs` 函数内部，生成当前子树的序列化字符串后，将其存入哈希表。

通过哈希表可以判断该子树是否重复出现。

## Leetcode 652: 找到二叉树中重复的子树

### 问题要点

**输入**: 一个二叉树的根节点 `root`。

**输出**: 一个 `List<TreeNode>`，其中包含所有重复子树的根节点。

**"重复"的定义**: 两棵子树如果拥有完全相同的结构以及在对应位置上拥有相同的节点值，那么它们就是重复的。

**输出要求**: 对于同一类重复的子树（比如有3个或更多相同的子树），只需要将其中任意一个根节点放入结果列表一次即可。

### 问题的本质和分析

这个问题的本质是如何**识别**和**记录**树中的每一个子树，并判断哪些子树出现了不止一次。

直接在树结构上进行两两比较是非常低效的。

如果我们遍历树中的每个节点，然后以该节点为根，再遍历一次树来寻找与之相同的子树，时间复杂度会非常高 (近似 O(N²))。

因此，我们需要一种更高效的方式来表示和比较子树。

核心思路是：**为每一个子树生成一个独一无二的“签名”或“指纹” (Signature / Fingerprint)**。

如果两个子树的签名相同，我们就可以认为这两个子树是重复的。

最常见的签名就是将子树**序列化 (Serialize)** 为一个字符串。

只要我们的序列化算法能保证“相同的子树一定产生相同的字符串，不同的子树一定产生不同的字符串”，问题就转化为了一个统计字符串出现次数的问题，这可以用哈希表（HashMap）轻松解决。



### 一个错误的实现

```Java
class Solution {
    private Map<String, List<TreeNode>> map;
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        List<TreeNode> res = new ArrayList<>();
        map = new HashMap<>();
        StringBuilder path = new StringBuilder();
        postorder(root, path);
        for(Map.Entry<String, List<TreeNode>> e : map.entrySet()){
            List<TreeNode> list = e.getValue();
            if(list.size() > 1){
              res.add(list.get(0));
            }
        }
        return res;
    }

    private void postorder(TreeNode node,StringBuilder path){
        if(node == null) return;

        path.append(node.val+",");
        //左节点
        postorder(node.left, path);
        //右节点
        postorder(node.right, path);
        //当前节点
        map.computeIfAbsent(path.toString(), x -> new ArrayList<>()).add(node);
        
        path.deleteCharAt(path.length() - 1);
    }
}
```

#### 核心问题 - path的使用方式

#### Path不应当成为成员变量

您将同一个 `StringBuilder` 对象 `path` 在整个递归过程中传递。

这意味着当递归从左子树返回，进入右子树时，`path` 中仍然保留着左子树的序列化信息。

它没有被重置或隔离。

#### 序列化的内容不正确： 遍历路径而不是子树的信息

您生成的 `path` 字符串实际上是**从根节点到当前节点的遍历路径**，而不是**以当前节点为根的子树的结构**。

#### 简单的例子演示

```
      1
     / \
    2   3
```

1. `postorder(1, path)`: `path` is `""`.

   - `path.append("1,")`. `path` becomes `"1,"`.

   - `postorder(2, path)`:
     - `path.append("2,")`. `path` becomes `"1,2,"`.
     - 左右子树为 `null`，返回。
     - `map.put("1,2,", [node(2)])`. **这里是第一个错误**，`"1,2,"` 并不代表子树 `2`，而是代表路径 `1->2`。

- `postorder(3, path)`: 此时 `path` 仍然是 `"1,2,"`！

  - `path.append("3,")`. `path` 变成 `"1,2,3,"`.

  - 左右子树为 `null`，返回。

  - `map.put("1,2,3,", [node(3)])`.

- 回到 `postorder(1, path)` 的结尾，此时 `path` 是 `"1,2,3,"`。

- `map.put("1,2,3,", [node(1)])`. **这里是第二个错误**，这个 key 覆盖了刚刚为 `node(3)` 存入的项。

最终，`map` 里的 key 都是从根开始的某种前序遍历路径，完全不能代表各个子树的结构，因此无法找到重复的子树。

### 核心思想和套路：后序遍历 + 序列化 + 哈希表

#### 为啥是后序遍历？

后序遍历的顺序是 `左子树 -> 右子树 -> 根节点`。

这个顺序天然适合构建子树的签名。

因为当我们要计算以 `node` 为根的子树的签名时，**我们必须先知道它的左子树和右子树长什么样**。

后序遍历保证了在处理 `node` 本身之前，我们已经通过递归调用处理完了它的左右子树，并拿到了它们的签名。

这是一种“自底向上”的构建过程。

#### 套路总结

这是一个典型的**“通过递归解决子问题，并将子问题的解返回给父问题”**的模式。

- **子问题**: 为以 `node` 为根的子树生成序列化签名。
- **递归关系**: `node` 的签名由 `node.val`、`左子树的签名` 和 `右子树的签名` 共同决定。
- **返回值**: 递归函数不返回 `void`，而是返回它所处理的子问题的解，即**序列化字符串**。

###实现原理和初始化步骤

#### 初始化Map<序列化字串，出现次数>

创建一个哈希表 `map` 用于存储 `{序列化字符串 -> 出现次数}`，以及一个列表 `res` 用于存储结果。

#### 设计递归函数

定义一个辅助函数 `dfs(TreeNode node)`，它的功能是：

- 接收一个节点 `node`。
- 返回以 `node` 为根的子树的序列化字符串。
- 在过程中，检查并更新 `map`，如果发现重复，则更新 `res` 列表。

#### 递归基准情况

- 如果 `node` 为 `null`，它也代表了一种结构。

- 我们必须将其表示出来，否则会产生歧义（例如，只有一个左孩子的树和一个只有右孩子的树可能会被误判）。

  返回一个特殊的标记符，比如 `"#"`。

#### 递归执行

- 调用 `dfs(node.left)` 获得左子树的序列化字符串 `leftSerial`。
- 调用 `dfs(node.right)` 获得右子树的序列化字符串 `rightSerial`。

#### 构造当前签名（组合递归调用结果）

将当前节点的值、左子树签名、右子树签名拼接起来，形成当前子树的唯一签名。

为了避免数字拼接的歧义（例如 `1` 和 `23` vs `12` 和 `3`），必须使用分隔符。

最终签名为 `String serial = node.val + "," + leftSerial + "," + rightSerial;`。

#### 检查和记录

- 在 `map` 中查找 `serial` 的出现次数。

- 将 `serial` 的计数值加一。

- **关键点**: 如果更新后的计数值**正好等于 2**，说明这是我们第一次发现这个子树是重复的。此时，将当前 `node` 添加到 `res` 列表中。只在等于 2 时添加，可以确保同一类重复子树只被添加一次。

#### 返回签名

- 将构造好的 `serial` 返回给上一层递归调用。

#### 主函数返回

- 调用 `dfs(root)` 启动整个过程。

- 返回 `res` 列表。

### 代码实现

```Java
class Solution {
    Map<String, Integer> map;
    List<TreeNode> res ;
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        map = new HashMap<>();
        res = new ArrayList<>();
        postorder(root);
        return res;
    }

    private String postorder(TreeNode node){
        if(node == null){
            return "#";
        }
        
        String leftSerial = postorder(node.left);
        String rightSerial = postorder(node.right);
        String serial = node.val + "," + leftSerial +","+ rightSerial;

        map.put(serial, map.getOrDefault(serial,0) +1 );

        if(map.get(serial) == 2){
            res.add(node);
        }
        return serial;
    }
}
```

### 注意事项

**序列化的唯一性**: 必须使用分隔符（如 `,`）来避免歧义。例如，没有分隔符时，`val=1`, `left=2`, `right=null` 和 `val=12`, `left=null`, `right=null` 可能会产生相同的字符串。

**`null` 节点的表示**: 必须为 `null` 节点生成一个占位符（如 `"#"`），否则无法区分树的结构。例如，`[1, 2]` 和 `[1, null, 2]` 如果不处理 `null`，可能会被错误地序列化为一样的内容。

**添加结果的时机**: 只在 `count == 2` 时添加节点是最高效简洁的。如果你在 `count >= 2` 时添加，就需要额外的机制（比如用一个 `Set`）来防止同一个节点被重复添加。

#### 经验总结

**识别模式**: 当题目要求识别、比较或计数树中的**子结构**时，首先考虑**序列化 + 哈希表**的思路。

**选择遍历方式**: 对于需要依赖子问题解来构造当前问题解的场景（自底向上），**后序遍历**通常是最佳选择。

**递归函数的设计**: 精心设计递归函数的**返回值**。让它返回子问题的解，而不是依赖外部变量或仅通过参数传递状态，通常能写出更清晰、更少 bug 的代码。

**关注边界和细节**: 序列化中的**分隔符**和**空节点表示**是决定方案成败的关键细节，务必考虑周全。

## Leetcode 572: 判断一棵树是否为另外一棵树的子树

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

### Option 1: 基于递归和isSame套路

#### 判断两棵树是否一样的套路

- 两个节点都为null，返回true
- 其中一个节点为null，返回false
- 两个节点值不一样，返回false
- 调用递归判断两者的左右子树是否也一样

```Java
    private boolean isSame(TreeNode node1, TreeNode node2){
        if(node1 == null && node2 == null) return true;
        if(node1 == null || node2 == null) return false;
        if(node1.val != node2.val) return false;
        return isSame(node1.left,node2.left) && isSame(node1.right,node2.right);
    }
}
```

#### 如何利用上述套路判断一棵树是否为另外一棵树的子树？

##### 定义递归函数`isSubtree(root, subRoot)`

返回`subRoot`是否是`root`的子树。

###### Base condition - 都为空或者只有一个为空

- 都为空的情况下，直接返回`true`
- 其中一个为空的情况下，返回`false`

###### 判断`subRoot`树是和当前`root`树相同

调用`isSame`方法判断两棵树是否相同，如果相同，直接返回`true`

##### 调用递归

如果当前`root`和`subRoot`为根的树不相同，则递归调用。

计算`subRoot`是否为左节点或者右节点的子树

```
return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);
```

#### 实现代码

```Java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if(root == null && subRoot == null) return true;
        if(root == null && subRoot != null) return false;
        if(isSame(root, subRoot)){
            return true;
        }

        return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);

    }

    private boolean isSame(TreeNode node1, TreeNode node2){
        if(node1 == null && node2 == null) return true;
        if(node1 == null || node2 == null) return false;
        if(node1.val != node2.val) return false;
        return isSame(node1.left,node2.left) && isSame(node1.right,node2.right);
    }
}
```

### Option 2: 基于哈希序列化的方案

#### 核心思想 - 生成每一个子树的序列

##### 生成`root`中每一棵子树的签名序列

我们使用之前所学习过的子树签名生成方法，利用后序遍历生成每一个子树的签名，并将签名加入到一个**Set**中。

##### 生成`subRoot`的签名序列

使用相同的算法生成`subRoot`的签名序列

##### 检查`subRoot`的签名是否在`root`子树的签名Set中

检查主树所生成的签名Set中是否包含`subRoot`的签名即可。

#### 生成每一棵子树的签名的套路

```Java
    private String postorderSerialize(TreeNode node,boolean addToSet){
        if(node == null){
            return "#";
        }
        String leftSerial = postorderSerialize(node.left, addToSet);
        String rightSerial = postorderSerialize(node.right, addToSet);
        
        String serial = node.val + "," + leftSerial + "," + rightSerial;
        if(addToSet){
            set.add(serial);
        }
        return serial;
    }
```

#### 代码实现

```Java
class Solution {
    private Set<String> set;
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        set = new HashSet<>();
        postorderSerialize(root,true);
        String subSerial = postorderSerialize(subRoot,false);
        return set.contains(subSerial);
    }

    private String postorderSerialize(TreeNode node,boolean addToSet){
        if(node == null){
            return "#";
        }
        String leftSerial = postorderSerialize(node.left, addToSet);
        String rightSerial = postorderSerialize(node.right, addToSet);
        
        String serial = node.val + "," + leftSerial + "," + rightSerial;
        if(addToSet){
            set.add(serial);
        }
        return serial;
    }
}
```



