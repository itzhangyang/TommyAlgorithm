# 5. **二叉树**

## 二叉树类型

### 二叉搜索树（BST): 左子树<根节点<右子树

#### 实现原理-值的有序性

利用值的有序性剪枝搜索空间，提高效率

#### 应用场景

- 快速查找某个值
- 寻找最大值/最小值/前驱/后继
- 转换为有序数组

####代码套路模板

```java
public TreeNode searchBST(TreeNode root, int val){
  if (root == null || root.val == val) return root;
  
  if (val < root.val) return searchBST(root.left,val);
  if (val >= root.val) return searchBST(root.right, val);
}
```

####注意事项

- 插入/删除操作涉及到操作调整
- 注意平衡性，否则**退化为链表**

####经验总结

- **总序遍历结果是升序的**
- **插入与删除是典型的递归结构题目，注意边界和空节点的处理**

### 平衡二叉树（AVL/红黑树）：高度差 <= 1

#### 核心思想-保持平衡的BST

在BST基础上，保持树的高度平衡（**AVL树： 高度差 <=1**）

#### 实现原理-插入或删除后反转

插入或者删除后，若失衡，通过**旋转（左旋转或者有旋转）**修复**平衡特性**

#### 注意事项

实现较复杂，面试中常考其原理、应用，不需手写代码

#### 经验总结

- Java 中 `TreeMap`/`TreeSet` 底层基于红黑树
- 知道什么时候使用红黑树而不是哈希表（需要有序性）// 确认

### 完全二叉树 & 满二叉树

| 类型       | 定义                                       |
| ---------- | ------------------------------------------ |
| 满二叉树   | 所有非叶节点都有两个子节点，叶子都在同一层 |
| 完全二叉树 | 从上到下、从左到右填满，最后一层可以不满   |

#### 应用场景

- 数组存储二叉树（比如堆、优先队列）
- 判断结构特性（是否完全/满二叉树）

#### 怎么判断一颗二叉树是否为完全二叉树-BFS+标志

按照BFS遍历二叉树，按照完全二叉树+BFS的遍历顺序，如果某一个节点为`null`，那么BFS序列中后面就不应该再有 非`null`的节点。

```java
public boolean isCompletedTree(TreeNode root){
  Queue<TreeNode> queue = new LinkedList<>();
  queue.offer(root);
  boolean mustBeLeaf = false;
  
  while (!queue.isEmpty()){
    TreeNode node = queue.poll();
    // 如果当前node为null，那么按照完全二叉树的定义，按照BFS顺序后面的节点都必须是null
    if (node == null){
      mustBeLeaf = true;
    }else{
      //如果在BFS序列中已经有节点是null，但是当前节点不为null，说明不是完全二叉树
      if (mustBeLeaf) return false;
      queue.offer(node.left);
      queue.offer(node.right);
    }
  }
  
  return true;
}
```

#### 注意事项

- 对**最后一层**的判断需要细致
- 与堆结构关系密切（**堆是完全二叉树**）

### 堆-优先队列的树形实现

#### 核心思想： 最大堆&最小堆

- 最大堆： 父节点>= 子节点
- 最小堆：父节点 <= 子节点

#### 实现原理-使用数组模拟二叉树

假设一个节点的`index= i`

- 节点的左子节点的`index = 2i+1`
- 节点的右子节点`index=2i+2`

#### 使用优先队列的套路模版

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
```

#### 常见的应用场景

- Top-K 问题
- 实时中位数
- 调度问题

#### 注意事项

- 插入和删除的时间复杂度是`O(logn)`
- 建堆的复杂度是`O{n}`

### 总结对比

| 类型            | 有序性    | 平衡性  | 应用场景               | 注意事项            |
| --------------- | --------- | ------- | ---------------------- | ------------------- |
| 普通二叉树      | ❌         | ❌       | 遍历、路径、构建树结构 | 模板构建递归逻辑    |
| 二叉搜索树      | ✅         | ❌       | 查找、前驱后继         | 注意退化为链表      |
| AVL/红黑树      | ✅         | ✅       | 插入删除查找都要高效   | 实现复杂，重逻辑    |
| 完全/满二叉树   | ❌         | ❌       | 判断结构、堆           | 层序遍历判断条件    |
| 堆（最大/最小） | ❌（局部） | ✅（弱） | 优先队列、Top-K        | 数组模拟 + 下标计算 |

###快速检索关键字 - 什么是Trie树？

Trie树本质上是一颗**多叉树**，

- 每一个节点代表一个字符
- 从根节点到某个节点的路径表示一个字符的**前缀**。

相比哈希表只能支持**整体匹配**，Trie可以支持**前缀匹配**、**单词检索**、**词频统计**等操作，具有天然优势。

####核心思想：利用公共前缀节点节省存储空间和查询效率

- 每一个节点代表一个字符
- 每一个路径代表一个前缀
- 插入和查询操作都是通过**逐字符**的方式进行
- 利用节点中是否标记为**某个单词的结尾**来区分前缀和完整单词

####实现原理

#####节点的定义

```Java
class TrieNode{
  //当前字符，很多时候这个字符并没有实际作用
  //我们写在这里，表示这个节点所代表的字符
  char ch;
  //子节点列表
  Map<Character,TrieNode> children = new HashMap<>();
  //是否是某个单词的结尾
  boolean isEndOfWord;
}
```

**当前字符：**我们上文说过，在Trie树中每一个节点代表一个字符，根节点的字符是`null`

**子节点列表：**从当前节点（字符出发），后序可以找到的字符节点的列表

一般情况下有两种表示方法：

**HashMap表示：**`Map<Character,TrieNode> children = new HashMap<>()`， 这种方法的好处是容易理解

**数组表示：**对于只有26个字母组成的单词，我们使用一个`TrieNode[] children = new TrieNode[26]`，每一个字母通过`c - 'a'`映射到其对应的索引，这种方法的好处是节省空间，但是如果字符种类多并且不可预测的时候，最好是使用HashMap。

**是否属于单词的终点：**表示目前节点是否是某个单词的结尾,如果从`root`节点到当前节点恰好构成一个单词，将该节点的`isEndOfWord`标注为`true`;

##### Trie树的定义

Trie树的定义十分简单，只有一个`root`节点就足有。

在这个基础上我们无论是插入单词，或者查找单词，都从根节点开始即可。

#####插入一个单词

从`root`节点到叶子节点，一次查找当前单词的每一个字符

- 从`root` 节点的**子节点**中寻找当前单词的第一个字符（`son`）
- 从`son`节点的**子节点**中寻找当前单词的的第二个字符`granson`
- 从**孙子**节点的**子节点**中寻找当前单词的第三个字符**重孙子**
- 一次类推，如果某个节点不存在，则创建一个

将单词的最后一个字符对应的节点的`endOfWord`设置为`true`，表示**从`root`节点到该节点构成一个单词**

```java
public void insert(String word){
  //1.找到root节点
  TrieNode node = root;
  for (char c : word.toCharArray()){
    int idx = c-'a';
    //2. 尝试从当前节点的子节点中找到下一个字符
    // 如果不存在该字符，则为该节点
    if (node.children[idx] == null){
      node.children[idx] = new TrieNode();
    }
    node = node.children[idx];
  }
  //1. 最后一个字符的节点设置为endOfWord
  node.isEndOfWord = true;
}
```

#####判断是否存在某个前缀

要查找某个前缀是否存在于Trie树中，我们需要定义一个**当前节点**指针，初始指向根节点：

- 从`root`节点开始，查找前缀的第一个字母是否存在于`root`节点的`children`列表中

  - 如果不存在，则直接返回false;

  - 如果存在，则将当前节点指针指向`children`中对应的子节点：

    `current = current.children.get(c)`；

    然后继续进行下一步。

- 基于前缀的下一个字符和当前节点，继续上一个步骤的流程。

- 如果都找到了，那么返回最后的当前节点即可。

- 如果最后的节点不为空，则说明该前缀存在于Trie树中

```Java
public boolean startsWith(String prefix){
  return searchPrefix(prefix) != null;
}

private TreeNode searchPrefix(String prefix){
  TrieNode node = root;
  for (char c : prefix.toCharArray()){
    int idx = c-'a';
    if (node.children[idx] != null) return null;
    node = node.children[idx];
  }
  return node;
}
```

##### 查找完整单词

```java
public boolean search (String word){
  TrieNode last = searchByPrefix(word);
  if(last == null){
    return false;
  }
  return last.isEndOfWord;
}
```

####Trie树适用于哪些场景？

| 应用场景                   | 举例问题或用途                                       |
| -------------------------- | ---------------------------------------------------- |
| **字符串查找与匹配**       | 查找一个单词是否在集合中，或是否有以某前缀开头的单词 |
| **自动补全系统**           | 搜索引擎建议、IDE代码补全等                          |
| **敏感词过滤、关键词屏蔽** | 快速定位包含敏感前缀的文本                           |
| **词频统计**（结合权重）   | 统计单词出现次数，或找出出现频率最高的前缀或单词     |
| **回文对、替换词链**       | Leetcode 336 回文对、648 单词替换等问题              |
| **T9/电话号码映射**        | 数字转字母组合搜索                                   |

####使用Trie树的时候应该注意哪些问题？

| 注意点                           | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 空间占用大                       | 特别是在字符集很大的情况下（如 Unicode），节点会很稀疏，可使用 Map 替代数组 |
| 非常依赖字符集大小               | 设计数据结构时需提前明确字符集（如只支持 a-z、小写字母、数字等） |
| 删除操作复杂                     | 如果需要支持删除单词，需要额外判断是否可以删除节点或回溯删除路径 |
| 常用于面试题，但不适用于模糊匹配 | 不能处理模糊匹配（如通配符匹配或正则）除非特殊设计           |

####使用经验和技巧总结

| 技巧                         | 建议                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 优先使用数组简洁高效         | 如果字符集小（如小写英文字母），优先用 `TrieNode[26]` 数组代替 Map，性能更高 |
| 标记终止位置                 | 一定要有 `isEndOfWord` 或 `word` 字段来区分完整单词和前缀    |
| 字符映射简化                 | `char - 'a'` 是常用技巧，用于把字母映射到数组索引            |
| 可以结合 Trie + DFS / 回溯   | 例如 Leetcode 212 单词搜索 II，Trie 用于加速剪枝             |
| Trie 可扩展为带权重结构      | 可在节点中记录 `count`, `word`, `weight` 等信息以支持更多功能 |
| Trie + 压缩路径 = Radix Tree | 压缩节点路径可以进一步提升空间利用率（如Double-Array Trie、DAWG） |

####Leetcode 336 回文对

我们要找出字符串数组 `words[]` 中所有的索引对 `(i, j)`，使得：

> ```
> words[i] + words[j]` 是一个回文字符串，且 `i != j
> ```

##### 核心思想-基于Trie树优化

###### 核心观察

- 回文具有**对称性**：如果某个前缀是回文，则它的后转的反转可以构成回文对
- 我们希望在`O(k)`的时间内判断某个`word[i]`能否与`word[j]`配合形成回文

###### 解决方式

- 将每个单词的**反转**插入Trie树（正向匹配=反向插入）
- 在每个Trie树的节点记录：
  - `wordIndex`:记录**以该节点结尾**的单词的索引
  - `belowIsPalindrome`: 记录**以该节点为前缀**时，其**后缀是回文**的字符串索引

通过Trie实现**快速前缀匹配 + 回文剪枝判断**

##### 实现原理

###### 构建Trie树-插入反转以后的单词

对每个单词`word`:

- 倒序插入到`Trie`中
- 在**插入过程**中，**如果前缀形成回文，则把该单词的索引加入`belowIsPalindrome`**
  - 如果一个单词的**逆序的前缀**`reversed[0...i-1]`是一个回文串，那么说明**原来单词的后缀**`original[n-1-i...n-1]`是一个回文串


###### *遍历原始数组找回文对

- 遍历每个单词`word[i]`，从做到右查找：

  - 如果当前字符在Trie上无法继续，剪枝结束

  - 若在中途遇到`word[j]`结束，并且当前剩余的后缀`suffix`是回文，则`[i,j]`是一组答案

- 匹配完成当前单词后，遍历该`Trie`节点下所有`belowIsPalindrome`，它们也可以和当前单词构成回文对

##### 实现代码

###### 构建Trie树

```java
class TrieNode {
  Map<Character,TrieNode> children = new HashMap<>();
  int wordIndex = -1;//词语的index
  List<Integer> belowIsPalindrome = new ArrayList<>();
}

class TrieTree {
  TrieNode root;
  
  public TrieTree(){
    this.root = new TrieNode();
  }
  /**
  *word
  *index, 单词在数组中的索引
  **/
  public void insert(String word, int index){
    String reversed = new StringBuilder(word).reverse().toString();
    for (int i=0; i < reversed.length; i++){
      //如果word[i...n-1]是回文串
      //将该单词的索引加入到belowIsPalindrome列表中
      if (isPalindrome(reversed,i,reversed.length()-1)){
        node.belowIsPalindrome.add(index);
      }
      
      char ch = reversed.charAt(i);
      node = node.children.computeIfAbsent(ch, k -> new TrieNode());
    }
    
    node.wordIndex = index;
    node.belowIsPalindrome.add(index);//插入Trie树的是反转之后的单词，因此原单词本身也是反转单词的一个回文串
  }
  
  public void search(String[] words, int index, List<List<Integer>> result){
    TrieNode node = root;
    String word = words[index];
    // 1. 在Trie树中查询该单词前缀的反转串
    // 2. 找到了单词某个前缀对应的反转串，并且该单词剩余部分是回文串，则符合条件
    for (int i=0; i< word.length(); i++){
      // 在Trie树中找到了对应的匹配的反转串（wordIndex >=0 说明这是一个在word数组中的单词）
      // 并且该单词的原词的索引和当前单词的index不一样
      // 并且当前词的剩余部分是一个回文串（空串也是回文串）
      if (node.wordIndex >= 0
          && node.wordIndex != index 
          && isPalindrome(word,i,word.length-1)){
        result.add(Arrays.asList(index, node.wordIndex));
      }
      
      char ch = word.charAt(i);
      //如果当前字符在Trie上无法继续，剪枝结束
      if (!node.children.containsKey(ch)) return;
      node = node.children.get(ch);
    }
    //如果能够执行到这里，说明整个单词是完全匹配了
    //则遍历终点node的belowIsPalindrome列表
    //如果后续的部分还有padlinedrome的话，说明该反转串可以和当前词组成回文串
    for (int j : node.belowIsPalindrome){
      if (index != j){
        result.add(Arrays.asList(index,j));
      }
    }
  }
}
```

###### 判断单词的子串是否是回文串

```java
private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) return false;
        }
        return true;
    }

```

###### 调用Trie树寻找回文对

``` java
public List<List<Integer>> palindromePairs(String[] words){
  List<List<Integer>> result = new ArrayList<>();
  TrieTree trieTree = new TrieTree();
  TrieNode root = trieTree.root;
  // Step 1. 构建TrieTree;
  for (int i=0; i<words.length;i++){
    String word = words[i];
    trieTree.insert(word,i);
  }
  
  // Step 2: 遍历每个原始单词，查找其可能的回文组合
        for (int i = 0; i < words.length; i++) {
            trieTree.search(words, i, result);
        }

        return result;
}
```

###自动排序的键值对集合 - TreeMap

#### TreeMap的基本特性 - Key的有序性

`TreeMap` 是 Java 集合框架中 `Map` 接口的一个重要实现。

与 `HashMap` 不同，`TreeMap` 最大的特点是它能**保证键（Key）的有序性**。

它通过**红黑树（Red-Black Tree）**这种自平衡二叉搜索树来实现，从而确保了高效的查找、插入和删除操作，其时间复杂度均为对数级别，即 $O(logN)$。

#### TreeMap的适用场景

当您需要一个自动排序的键值对集合时，`TreeMap` 是最佳选择。具体场景包括：

##### 需要对Key进行排序的场景

- **排行榜**：例如，按分数高低对玩家进行排名，其中玩家ID为Key，分数为Value（或者反过来，分数为Key，玩家列表为Value）。

- **按字母顺序显示**：需要按字母顺序显示用户列表、商品目录或任何其他按名称索引的数据。

- **时间序列数据**：按时间戳（作为Key）存储和处理事件或数据点，`TreeMap`可以自然地按时间顺序组织它们。

##### 进行范围查找的场景

这是 `TreeMap` 一个非常强大的功能，`HashMap` 无法高效完成。

- **价格区间查询**：在一个电商网站上，查找所有价格在 $50 到 $100 之间的商品。

  可以使用 `subMap(50, 100)` 快速获取这个范围内的所有商品。

- **日志分析**：查找某个**特定时间**段内（例如，从 `2025-08-10 10:00:00` 到 `2025-08-10 11:00:00`）的所有日志条目。

- **获取部分数据**：获取排在最前面的N个元素 (`headMap`) 或排在最后面的N个元素 (`tailMap`)。

##### 查找最值或者邻近键的场景

由于其有序性，`TreeMap` 可以非常高效地找到最大/最小键，或某个键的“前一个”或“后一个”键。

- **查找最高/最低分**：直接使用 `lastKey()` 和 `firstKey()`。
- **日历应用**：查找某个给定日期的下一个或上一个日程安排。可以使用 `higherKey(date)` 或 `lowerKey(date)`。
- **数据拟合**：给定一个值，需要找到数据库中与它最接近的（大于等于或小于等于）的键。可以使用 `ceilingKey(key)` 或 `floorKey(key)`。

#### TreeMap的主要特性

##### 有序性 (Ordered)

- `TreeMap` 中的元素默认按照键的**自然顺序**（Natural Ordering）进行排序。

  这意味着键必须实现 `java.lang.Comparable` 接口。

  例如，`Integer`, `String`, `Double` 等都实现了该接口。

- 如果键没有自然顺序，或者您需要自定义排序规则（例如，不区分大小写排序字符串），可以在创建`TreeMap`时传入一个 `java.util.Comparator` 对象。

##### 对数时间复杂度

- 由于其底层是红黑树，`put()`, `get()`, `remove()`, `containsKey()` 等核心操作的时间复杂度都是 $O(logN)$，其中 n 是 `TreeMap` 中元素的数量。

- 这虽然比 `HashMap` 的平均 O(1) 慢，但在需要排序的场景下，这个性能是非常出色的，并且性能稳定，没有 `HashMap` 在扩容时可能出现的性能抖动。

##### 键的约束 (Key Constraints)

- **不允许 `null` 键**：因为 `TreeMap` 需要对键进行比较，而 `null` 无法与其他任何值进行比较（会抛出 `NullPointerException`）。

- **允许 `null` 值**：值（Value）可以是 `null`。

- 键必须是**可相互比较的**：如果您向 `TreeMap` 中添加不同类型的键（例如，同时添加 `String` 和 `Integer`），除非您提供了能处理这种情况的 `Comparator`，否则会在运行时抛出 `ClassCastException`。

##### 非线程安全 (Not Thread-Safe)

- 与 `HashMap` 一样，`TreeMap` 本身不是线程安全的。如果在多线程环境中使用，必须手动进行同步。可以使用 `Collections.synchronizedMap(new TreeMap(...))` 来包装它，或者使用 `java.util.concurrent.ConcurrentSkipListMap` 作为线程安全的替代品。

##### 丰富的导航方法 (Rich Navigation Methods)

- `firstKey()` / `lastKey()`: 获取第一个（最小）和最后一个（最大）键。

- `firstEntry()` / `lastEntry()`: 获取第一个和最后一个键值对。

- `lowerKey(K key)` / `floorKey(K key)`: 返回小于 / 小于等于给定 `key` 的最大键。

- `higherKey(K key)` / `ceilingKey(K key)`: 返回大于 / 大于等于给定 `key` 的最小键。

- `pollFirstEntry()` / `pollLastEntry()`: 移除并返回第一个 / 最后一个键值对。

- `descendingMap()`: 返回一个与原`Map`顺序相反的视图。

#### 核心思想和实现原理

##### 核心思想 - 自动维护元素顺序的数据结构

`TreeMap` 的核心思想是**使用一种能够自动维护元素顺序的数据结构来存储键值对**。

它牺牲了 `HashMap` 的极致插入和查找速度（O(1)），换取了对全体数据按键排序的能力以及高效的范围查找和邻近查找功能。

##### 实现原理 - 红黑树

###### 什么是红黑树？ - 一种自平衡的二叉搜索树

- **二叉搜索树（BST）** 的特点是：对于任何节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。这使得查找非常高效。

- **问题**：普通的BST在最坏情况下（例如，插入已排序的数据）会退化成一个链表，导致操作复杂度变为 $O(N)$。

- **自平衡**：红黑树通过一系列严格的规则（**节点颜色、旋转、变色**），确保树在插入和删除操作后始终保持“大致平衡”，其高度永远不会超过 $2⋅log2(N+1)$。

  这就从根本上保证了其**所有核心操作的时间复杂度稳定在 $O(logN)$**。

###### TreeMap的工作原理

- **存储结构**：`TreeMap` 的每个节点 `Entry` 不仅存储了键（key）和值（value），还存储了指向左孩子、右孩子和父节点的引用，以及一个表示节点颜色的布尔值（通常 `RED` 或 `BLACK`）。
- **插入 (`put`)**：当您调用 `put(key, value)` 时，`TreeMap` 会：
  1. 从根节点开始，按照二叉搜索树的规则查找 `key` 的插入位置。
  2. 将新的 `Entry` 插入到该位置，并默认标记为红色。
  3. 为了维持红黑树的性质（例如，“不能有两个连续的红色节点”），程序会执行一系列的**左旋**、**右旋**和**颜色变换**操作，以重新平衡树。
- **查找 (`get`)**：直接利用二叉搜索树的特性，从根节点开始比较，如果要找的键小于当前节点，就去左子树；如果大于，就去右子树。这个过程的路径长度受限于树的高度，因此是 $O(logN)$。
- **删除 (`remove`)**：同样先查找到要删除的节点，然后从树中移除它。移除后，树的平衡可能被打破，此时也需要通过旋转和变色操作来恢复红黑树的性质。

#### 总结对比：TreeMap vs. HashMap vs. LinkedHashMap

| 特性               | HashMap                     | LinkedHashMap               | TreeMap                          |
| ------------------ | --------------------------- | --------------------------- | -------------------------------- |
| **排序**           | 无序                        | 插入顺序 或 访问顺序        | **按键排序（自然顺序或自定义）** |
| **底层实现**       | 哈希表 (数组 + 链表/红黑树) | 哈希表 + 双向链表           | **红黑树**                       |
| **核心操作复杂度** | 平均 O(1)                   | 平均 O(1)                   | **O(logn)**                      |
| **null 键/值**     | 允许1个null键，多个null值   | 允许1个null键，多个null值   | **不允许null键**，允许多个null值 |
| **主要优势**       | 速度最快，通用性强          | 保持插入顺序，可实现LRU缓存 | **自动排序，支持范围查找**       |
| **主要劣势**       | 顺序不确定                  | 额外维护链表，开销稍大      | 性能略低于HashMap                |

选择哪种 `Map` 实现，完全取决于您的具体需求。如果需要最快的速度且不关心顺序，用 `HashMap`；如果需要保持插入顺序，用 `LinkedHashMap`；如果需要一个自动排序的集合并进行范围查找，那么 `TreeMap` 就是不二之选。

#### Leetcode 218: 天际线 - TreeMap的应用

##### 问题要点

**输入 (Input):** 一个建筑物的列表 `buildings`，其中每个建筑物由一个数组 `[Li, Ri, Hi]` 表示。

- $L_i$: 建筑物左侧的 x 坐标。
- $R_i$: 建筑物右侧的 x 坐标。
- $H_i$: 建筑物的高度。

**输出 (Output):** 一个 "关键点" 列表，该列表唯一地定义了天际线。

- 每个关键点是一个 `[x, y]` 数组，代表天际线轮廓的一个**转折点**。
- 关键点是天际线水平线段的**左端点**。

**核心要求:**

1. 将所有建筑物合并，形成一个单一的天际线轮廓。
2. 输出的列表必须**按 x 坐标排序**。
3. 不能有连续的、相同高度的水平线段。例如，`[[2, 10], [5, 10]]` 是不合法的，应合并为 `[[2, 10]]`。
4. 不能有垂直的线段。例如，在同一 x 坐标上，高度发生变化，应只保留最高的那个点。

##### 问题的本质和分析

问题的本质是**将多个矩形（建筑物）的轮廓合并，并找出轮廓发生变化的关键转折点**。

直接观察天际线，我们会发现它的高度只可能在建筑物的**左边界**或**右边界**发生变化。

这些边界的 x 坐标就是我们需要关注的**事件点**。

这启发我们使用一种经典的计算几何算法——**扫描线算法 (Sweep-Line Algorithm)**。



###### 扫描线算法

我们可以想象有一条垂直于 x 轴的扫描线，从左到右扫过整个平面。

当这条扫描线遇到建筑物的左边界或右边界时，当前位置可见的最高建筑高度可能会发生改变。

如果确实发生了改变，那么就产生了一个天际线的关键点。

因此，问题被转化成：

1. 确定所有的**事件点**（即所有建筑物的左右边界）。
2. 按 x 坐标顺序处理这些事件点。
3. 在处理每个事件点时，我们需要一种高效的方式来知道当前所有**活跃**的（即扫描线正穿过的）建筑物中的最大高度。

##### 背景知识

###### 扫描线算法 - 将 D 维几何问题降维到 D−1 维

这是一种将 D 维几何问题降维到 D−1 维来处理的算法思想。

对于这个 2D 平面问题，我们用一条 1D 的垂直线（扫描线）从左到右扫描，将连续的几何问题离散化为在特定“事件点”的处理。



###### 基于红黑树的TreeMap

在扫描线移动过程中，我们需要一个数据结构来动态维护当前所有活跃建筑物的高度，并能快速地：

1. **添加**一个新的高度（当遇到左边界时）。
2. **删除**一个旧的高度（当遇到右边界时）。
3. **查询**当前的最大高度。

- **最大堆 (Max-Heap / PriorityQueue):** 添加和查询最大值非常快 (分别为 $O(logN)$ 和 O(1))，但删除任意元素很慢 (O(N))。

  这使得它不是最理想的选择，但可以通过一些技巧实现（懒删除）。

- **平衡二叉搜索树 (如 Java 的 `TreeMap` )**: 这种数据结构可以高效地支持添加、删除和查找最大/最小值，所有操作的平均时间复杂度都是 $O(logN)$。它内部是**有序**的，因此非常适合这个问题。`TreeMap` 在 Java 中是基于红黑树实现的。

##### 本题的考察点是什么？

- **算法思想:** 能否识别出这是一个典型的**扫描线问题**。
- **数据结构选择:** 能否为**动态维护最大高度**这个子问题选择合适的数据结构 (`TreeMap` 是最佳选择之一)并分析其复杂度。
- **细节处理能力 (Edge Cases):**
  - **相同 x 坐标的处理顺序:** 如果一个建筑结束，同时另一个建筑在同一个 x 坐标开始，应该先处理哪个？如果两个左边界或两个右边界在同一 x 坐标，处理顺序是什么？这会影响结果的正确性。
  - **输出格式化:** 如何确保输出符合题目要求，合并多余的点。

##### 模式匹配

这个问题属于 **扫描线/区间问题** 的范畴。

当你看到涉及大量矩形、区间重叠、覆盖、合并等问题时，都应该首先想到**扫描线**算法。

类似的问题有：

- **LeetCode 253. Meeting Rooms II (会议室 II):** 扫描线扫过时间轴，事件是会议的**开始和结束**，需要维护的是当前需要的会议室数量（即重叠区间的最大数量）。
- **LeetCode 759. Employee Free Time (员工空闲时间):** 将所有人的工作时间区间合并，然后找出其中的空隙。
- **飞机在天空中数量 (Number of Airplanes in the Sky):** 和会议室问题几乎一样。

模式是：**将区间的端点作为事件，排序后进行扫描，并用一个数据结构维护扫描过程中的状态。**



##### 核心思想和套路

###### 转化于离散化

将每个建筑物 `[L, R, H]` 拆分为两个事件点：

- **左端点 (进入点):** `(L, H)`，表示在 x=`L` 处，有一个高度为 `H` 的建筑物出现了。
- **右端点 (离开点):** `(R, H)`，表示在 x=`R` 处，高度为 `H` 的建筑物消失了。

为了在排序时区分左右端点，我们使用一个经典技巧：**将左端点的高度记为负数**。

- 左端点: `(L, -H)`
- 右端点: `(R, H)`

###### 排序规则

将所有事件点放入一个列表并排序。排序规则至关重要：

1. **x 坐标** 从小到大排序。

2. 如果 x 坐标相同，**根据高度排序**。此时 `(L, -H)` 和 `(R, H)` 的表示法优势就体现出来了。

   因为 `-H` 是负数，它会自然地排在正数 `H` 前面。这意味着：

   - **如果一个左边界和一个右边界 x 坐标相同，左边界事件会先被处理**。

     这符合逻辑，先让建筑进来，再让旧的建筑出去。

   - **如果两个左边界 x 坐标相同，高度更高的那个（即 `-H` 更小的那个）会先被处理**。

   - **如果两个右边界 x 坐标相同，高度更低的那个（即 `H` 更小的那个）会先被处理**。

这个排序规则完美地处理了所有边界情况。

###### 扫描和状态维护

- 遍历排序后的事件点列表。

- 使用一个 `TreeMap<Integer, Integer>` 来维护**当前活跃的高度**及其出现次数。

  Key 是高度，Value 是**该高度的建筑物数量**。

- 我们预先在 `TreeMap` 中放入 `(0, 1)`，代表地面，高度为 0。表示有一个高度为0的高度，这可以简化很多边界逻辑。

- 遍历每个点 `(x, h)`：

  - 如果 `h < 0` (左端点): 将高度 `-h` 加入 `TreeMap`，计数加一。

  - 如果 `h > 0` (右端点): 将高度 `h` 从 `TreeMap` 中移除，计数减一。

    如果计数变为 0，则从 Map 中彻底删除该高度。

###### 生成结果

- 在处理完每个事件点后，查询 `TreeMap` 中的最大高度 (即 `map.lastKey()`)。

- 设 `prevMaxHeight` 为上一个关键点的高度，`currentMaxHeight` 为当前 `TreeMap` 中的最大高度。

- **如果 `currentMaxHeight != prevMaxHeight`**，说明**天际线高度发生了变化，这是一个关键点**！

  将 `[x, currentMaxHeight]` 加入结果列表。

- 更新 `prevMaxHeight = currentMaxHeight`。

##### 实现原理和步骤

###### 创建和排序事件列表

**创建事件点列表:** 创建一个 `List<int[]>` 或 `List<List<Integer>>`。遍历输入 `buildings`，对于每个 `[L, R, H]`，向列表中添加 `[L, -H]` 和 `[R, H]`。

**排序事件点:** 使用 `Collections.sort` 和自定义比较器对事件点列表进行排序。比较逻辑是：先比较 x 坐标，如果相同，再比较 y 坐标。

###### 初始化结果列表和相关变量

- `result`: 一个空的 `List<List<Integer>>` 用于存放最终结果。

- `heightMap`: 一个 `TreeMap<Integer, Integer>`。用来记录当前高度为x的**活跃区间**的数量。

  初始化时放入 `heightMap.put(0, 1)`。- 含义是**高度为0的活跃区间现在有1个**。

- `prevMaxHeight`: 一个整型变量，初始化为 0。用来记录**上一轮扫描中的当前最大高度**。

######循环处理 - 更新和处理活跃的高度区间

- 遍历排序后的事件点 `p`。
- `x = p[0]`, `h = p[1]`。
- **如果 h < 0 (左端点):**
  - 当前高度为： `height = -h`。
  - 更新高度为`height`的区间的数量：`heightMap.put(height, heightMap.getOrDefault(height, 0) + 1)`。
- **如果 h > 0 (右端点):**
  - 当前高度为：`height = h`。
  - 获取高度为`height`的区间的数量，`count = heightMap.get(height)`。
  - 如果 `count == 1`，则从TreeMap中删除该高度 `heightMap.remove(height)`。
  - 否则，`heightMap.put(height, count - 1)`。

######判断与记录

- 获取**当前最高的高度**：`currentMaxHeight = heightMap.lastKey()`。
- 如果 当前的高度**不等于**上一个高度：`currentMaxHeight != prevMaxHeight`:
  - 将 当前的高度加入**活跃高度**中：`[x, currentMaxHeight]` 添加到 `result` 列表中。
  - 更新 `prevMaxHeight = currentMaxHeight`。

**结果优化 (可选但推荐):**

- 上述逻辑可能会产生垂直的冗余点，比如 `[2, 10]` 后面紧跟着 `[2, 12]`。

  一个好的处理方式是，在添加结果前，检查 `result` 列表的最后一个点。

  - 如果新点的 x 坐标与最后一个点相同，则更新最后一个点的高度；
  - 否则，添加新点。

- 同时，如果新点的高度与最后一个点的高度相同，则不添加，以**合并水平线**。

- 一个更简洁的实现方式是将同一x坐标的点聚合在一起处理，可以避免上述问题。

##### 实现代码

```java
class Solution {
    class Point{
        int x;
        int h;
        public Point(int x, int h){
            this.x = x;
            this.h = h;
        }
    }
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<List<Integer>> res = new ArrayList<>();

        //1. 将Building列表转化为一个事件列表
        // 一个Building转化为两个事件
        List<Point> pointList = new ArrayList<>();
        for(int[] b : buildings){
            //building起点转化为一个起始事件
           pointList.add(new Point(b[0], -b[2]));
           //building的终点转化为一个结束事件
           pointList.add(new Point(b[1], b[2]));

        }
        //1. 按照起点 + 高度对事件点进行排序
        pointList.sort((a,b) -> {
            if(a.x != b.x){
                return a.x - b.x;
            }else{
                return a.h - b.h;
            }
        });
        //3. 初始化HeightMap，将(0,1)加入到height map
        TreeMap<Integer,Integer> heightMap = new TreeMap<>();
        heightMap.put(0, 1);
        int prevMaxheight = 0;
        //4. 遍历所有的事件点
        for(Point point : pointList){
            //4.1 如果当前事件点是起点，更新Height Map +1
            if(point.h < 0){
                heightMap.put(-point.h, heightMap.getOrDefault(-point.h, 0)+1);
            //4.2 如果当前事件点是终点 
            }else{
                //4.2.3 获取当前高度计数
                int count = heightMap.getOrDefault(point.h, 0);
                //如果计数为1，直接从Height Map中删除
                if(count == 1){
                    heightMap.remove(point.h);
                //如果计数不为1， 则计数-1
                }else{
                    heightMap.put(point.h, count - 1);
                }
            }
            //4.3 检查当前最高的高度是否变了
            //如果变了，说明是从当前的事件点开始变了
            //将新的高度和起点加入到结果集当中，并更新prev max height
            int currentMaxHeight = heightMap.lastKey();
            if(currentMaxHeight != prevMaxheight){
                res.add(Arrays.asList(point.x,currentMaxHeight));
                prevMaxheight = currentMaxHeight;
            }
        }

        return res;
    }
}
```

##### 注意事项

- **排序是灵魂:** `(L, -H)` 和 `(R, H)` 的表示法以及对应的排序规则是整个算法中最巧妙和关键的部分。它确保了在同一位置，进入事件、高度变化事件总是优先于离开事件被处理，避免了错误的判断。

- **数据结构的选择:** `TreeMap` 是此题的“神器”。它的 `O(\log N)` 复杂度保证了整体解法的时间复杂度为 `O(N \log N)` (瓶颈在排序)，其中 N 是建筑物的数量。

- **地平线 (Ground):** 在 `TreeMap` 中预置 `(0, 1)` 是一个非常好的编程实践。它确保了即使所有建筑物都消失后，`heightMap` 仍然不为空，`lastKey()` 总能返回一个有效的“地面”高度 0，从而避免了空指针异常，并简化了代码逻辑。

- **结果去重:** 务必确保最终结果中没有冗余点，即同一水平线上的点（如 `[x1, h]`, `[x2, h]`）和同一垂直线上的点（如 `[x, h1]`, `[x, h2]`）都被正确合并。

##### 经验总结 (Experience Summary)

**抽象问题:** LeetCode 218 是将一个具象的几何问题抽象为“事件点处理”模型的典范。学会这种抽象能力是解决复杂算法问题的关键。

**识别模式:** 掌握扫描线算法模式，能够让你在面对区间、矩形覆盖、重叠计算等一系列问题时游刃有余。

**工具箱:** 将 `TreeMap`（或等价的平衡树结构）和巧妙的排序技巧（如负号法）加入你的算法工具箱。它们在很多问题中都能派上用场。

**分步解决:** 解决这类复杂问题时，应遵循“分解->设计->实现->优化”的步骤。

1. **分解:** 分解为事件点、排序、扫描、状态维护。
2. **设计:** 为每个步骤选择合适的算法和数据结构。
3. **实现:** 编写清晰、正确的代码。
4. **优化:** 思考并处理各种边界情况和冗余输出。