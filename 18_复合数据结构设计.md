# 复合数据结构设计

# 经典高频Leetcode解析





### 4. 核心模式：属性追踪 (辅助数据结构)



**挑战：** 需要在 O(1) 时间获取某个全局属性（如最小值、最大值）。 **应对策略：** 使用一个辅助数据结构，冗余存储每一步的属性状态。

1. **LC 155. Min Stack (最小栈)**
   - **简介：** `push`, `pop`, `top`, `getMin` 均为 O(1)。
   - **设计：** `Stack<Integer> dataStack` + `Stack<Integer> minStack`。`minStack` 的栈顶永远是 `dataStack` *当前状态* 的最小值。
2. **LC 359. Logger Rate Limiter (日志速率限制器)**
   - **简介：** `shouldPrintMessage(timestamp, message)` 为 O(1)。
   - **设计：** `HashMap<String, Integer>`。`Map` 存储 `message` 及其“下次允许打印的时间”。
3. **LC 362. Design Hit Counter (设计点击计数器)**
   - **简介：** `hit(timestamp)` (O(1))，`getHits(timestamp)` ( O(N) 或 O(1) )。查询过去5分钟的点击量。
   - **设计：** `Queue<Integer>` (存储时间戳)。`getHits` 时 `poll` 掉所有过期的时间戳，队列大小即为答案。
4. **LC 348. Design Tic-Tac-Toe (设计井字棋)**
   - **简介：** `move(row, col, player)` 必须 O(1) 判断胜负。
   - **设计：** 使用 `int[] rows`, `int[] cols`, `int diag`, `int antiDiag` 数组。`player 1` 加 1，`player 2` 减 1。检查任一数组/变量的绝对值是否等于 `n` 即可 O(1) 判断胜利。



### 5. 核心模式：迭代器 / 扁平化 (Iterator Pattern)



**挑战：** 深度未知的嵌套结构，要求实现 `hasNext()` 和 `next()` 迭代器。 **应对策略：** 使用 `Stack` 模拟递归（DFS），实现“惰性求值”。

1. **LC 341. Flatten Nested List Iterator (扁平化嵌套列表迭代器)**
   - **简介：** 迭代 `[1, [4, [6]]]` 这种嵌套结构。
   - **设计：** `Stack<Iterator<NestedInteger>>`。`hasNext()` 负责展开列表，直到栈顶是一个整数。
2. **LC 251. Flatten 2D Vector (展开二维向量)**
   - **简介：** `LC 341` 的简化版，只有一层嵌套。
   - **设计：** 两个指针/索引，`row_idx` 和 `col_idx`。`hasNext()` 负责在 `col_idx` 到达行尾时，`row_idx++` 并跳过空行。
3. **LC 173. Binary Search Tree Iterator (二叉搜索树迭代器)**
   - **简介：** `next()` 和 `hasNext()` 均为 O(1) 均摊时间。
   - **设计：** **受控的 DFS (Controlled DFS)**。使用 `Stack<TreeNode>`。构造时，将所有左子节点压栈。`next()` 时，`pop` 栈顶 (这就是最小值)，然后将该节点的**右子树的所有左子节点**压栈。



### 6. 核心模式：路径 / 前缀依赖 (Trie Pattern)



**挑战：** 操作（增/查）依赖于“前缀”或“文件路径”。 **应对策略：** **Trie (字典树)**，或 `Node` 内部嵌套 `Map`。

1. **LC 208. Implement Trie (Prefix Tree) (实现 Trie (前缀树))**
   - **简介：** 实现 `insert`, `search`, `startsWith`。
   - **设计：** `TrieNode` 类，包含 `boolean isEnd` 和 `TrieNode[26]` (或 `Map`)。
2. **LC 211. Design Add and Search Words Data Structure (添加与搜索单词)**
   - **简介：** `search` 支持 `.` 通配符。
   - **设计：** `Trie` + **DFS**。`search` 时，遇到 `.` 则递归遍历 `children` 中的所有非空节点。
3. **LC 1166. Design File System (设计文件系统)**
   - **简介：** `createPath("/a/b/c", 1)` 要求 `/a/b` 必须存在。`get` O(L)。
   - **设计：** `Trie` 结构。`TrieNode` 包含 `int value` 和 `Map<String, TrieNode> children` (用 `Map` 而不是数组，因为路径名任意)。



### 7. 核心模式：序列化 / 反序列化 (Serialization)



**挑战：** 将非线性结构（如树）无损地编码为线性字符串，并能反向解析。 **应对策略：** BFS (层序) 或 DFS (前序) + `null` 标记。

1. **LC 297. Serialize and Deserialize Binary Tree (二叉树的序列化与反序列化)**
   - **简介：** 将树转为字符串，再转回树。
   - **设计 (BFS)：** `Queue<TreeNode>`。层序遍历，`null` 节点用特殊符号（如 "N"）标记。反序列化时，用 `Queue` 辅助重建。
   - **设计 (DFS)：** 递归。前序遍历，`null` 节点用 "N" 标记。反序列化时，用 `Queue<String>` (存放 `split` 后的值) 辅助递归构建。
2. **LC 385. Mini Parser (迷你语法分析器)**
   - **简介：** 解析 `"[123,[456,[789]]"` 这种字符串。
   - **设计：** **`Stack<NestedInteger>`**。遇到 `[`，创建新列表并压栈。遇到 `]`，`pop` 栈顶列表，并将其 `add` 到（新的）栈顶列表中。遇到数字，解析并 `add` 到当前栈顶列表。



### 8. 核心模式：基础结构模拟 (Meta-Design)



**挑战：** 要求你从零开始实现一个标准库里的数据结构。 **应对策略：** 深刻理解该结构的核心原理（如哈希冲突、链表指针）。

1. **LC 706. Design HashMap (设计哈希映射)**
   - **简介：** 不使用内置 `HashMap` 实现 `put`, `get`, `remove`。
   - **设计：** **拉链法 (Chaining)**。`List<Entry>[] buckets`。`hash(key) % capacity` 找到桶，然后在桶的 `List` 中遍历 `Entry`。
2. **LC 707. Design LinkedList (设计链表)**
   - **简介：** 实现 `get`, `addAtHead`, `addAtTail`, `addAtIndex`, `deleteAtIndex`。
   - **设计：** `Node` 类 + `head/tail` 哨兵节点。
3. **LC 622. Design Circular Queue (设计循环队列)**
   - **简介：** `enQueue`, `deQueue`, `isFull`, `isEmpty`。
   - **设计：** **数组 + `head/tail` 指针**。关键在于 `(tail + 1) % capacity` 的取模运算。
4. **LC 641. Design Circular Deque (设计循环双端队列)**
   - **简介：** 在 `LC 622` 基础上增加 `insertFront`, `deleteLast`。
   - **设计：** **数组 + `head/tail` 指针**。`head` 指针需要反向移动 `(head - 1 + capacity) % capacity`。
5. **LC 232. Implement Queue using Stacks (用栈实现队列)**
   - **简介：** `push`, `pop`, `peek`, `empty`。
   - **设计：** **双栈法 (Two Stacks)**。`inStack` 负责 `push`。`outStack` 负责 `pop/peek`。当 `outStack` 为空时，将 `inStack` 所有元素“倾倒”进 `outStack`。



### 9. 核心模式：图 / 依赖传播 (Graph / Dependency Propagation)



**挑战：** 你的设计中的元素互相依赖（A 依赖 B，B 依赖 C），修改一个元素需要级联更新所有依赖它的元素。 **应对策略：** **有向图 + 拓扑排序 (BFS)**。

1. **LC 631. Design Excel Sum Formula (设计 Excel 求和公式)**
   - **简介：** `set(r, c, v)`，`sum(r, c, strs)`。`set` 一个单元格需要自动更新所有依赖它的公式。
   - **设计：** `Cell[][]` 数组 + **两个 `Map`（图）**：
     1. `Map<Cell, Set<Cell>> childToParents` (反向图，用于传播更新)
     2. `Map<Cell, Set<Cell>> parentToChildren` (正向图，用于 `set` 时断开旧依赖)
   - `set` 时，从被修改的 `Cell` 开始，**BFS** 遍历 `childToParents` 图，重新计算并传播更新。



### 10. 杂项 / 特殊功能 (Miscellaneous)



1. **LC 346. Moving Average from Data Stream (数据流中的移动平均值)**
   - **简介：** `next(val)` (O(1)) 计算最后 `k` 个元素的平均值。
   - **设计：** **`Queue<Integer>` (或循环数组) + `double currentSum`**。`next` 时，`add` 新元素，`currentSum += val`。如果队列超限，`poll` 旧元素，`currentSum -= old_val`。
2. **LC 1146. Snapshot Array (快照数组)**
   - **简介：** `set(idx, val)`，`snap()` (O(1))，`get(idx, snap_id)`。
   - **设计：** `List<TreeMap<SnapID, Value>>[]`。
   - **核心技巧：** `set` 时，只在 `array[index]` 对应的 `TreeMap` 中设置 `(current_snap_id, val)`。`get` 时，在 `TreeMap` 中使用 `floorEntry(snap_id)` 找到 O(logN) 找到快照版本的值。
