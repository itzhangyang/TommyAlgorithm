## 典型复合数据结构和特性

### 索引列表

**组合：** `HashMap<Value, Index>` + `ArrayList<Value>`

**特性：**

- `Value` 映射到它在 `List` 中的索引。
- `List` 提供基于索引的 $O(1)$ 访问。

**核心技巧：** **Swap-and-Pop**。

**解决：** `LC 380 (Insert Delete GetRandom O(1))`



### 存储指针的HashMap

**组合：** `HashMap<Key, Node>` + `DoublyLinkedList<Node>`

**特性：**

- `Key` 映射到它在 `LinkedList` 中的 `Node` 引用。
- `LinkedList` 维护顺序。
- 使用**哨兵 (Sentinel) `head/tail` 节点**来避免空指针检查。

**核心技巧：** `map.get(key)` $\rightarrow$ $O(1)$ 找到 `node` $\rightarrow$ $O(1)$ 通过 `node.prev/node.next` 修改链表。

**解决：**

- `LC 146 (LRU Cache)`: (你提到的 `LRU`)。
- `LC 460 (LFU Cache)`: (更复杂的版本，`HashMap` 映射到 `DoublyLinkedList` 的 `Node`，而 `DoublyLinkedList` 的 `Node` *又* 包含一个 `LinkedHashSet` 来存 `key`)。
- `LC 432 (All O(1) Data Structure)`: (链表的 `Node` 是 "桶"，桶内有 `Set<Key>`)。

### 双堆中位数查找器 (Two-Heap Median Finder)

**组合：** `MaxHeap<Integer>` (存小数) + `MinHeap<Integer>` (存大数)

**特性：**

- 始终保持 `maxHeap.size() == minHeap.size()` 或 `maxHeap.size() == minHeap.size() + 1`。
- `maxHeap` 的堆顶永远是“左中位数”，`minHeap` 的堆顶永远是“右中位数”。

**核心技巧：** `addNum(num)` 时，如果 `num <= maxHeap.peek()`，则放入 `maxHeap`；否则放入 `minHeap`。**放入后必须 rebalance 两个堆**，确保大小平衡。

**解决：** `LC 295 (Find Median from Data Stream)`

### 数据结构：字典树 (Trie / Prefix Tree)

- **组合：** 本质上是 `Node` 的嵌套 `Map`。每个 `Node` 包含：
  - `boolean isEndOfWord`
  - `Map<Character, Node> children`
- **特性：**
  - 共享前缀。
  - 结构本身代表了路径/层级。
- **核心技巧：** 逐个字符（或逐个路径段）遍历，在 `children` Map 中向下移动。
- **解决：** `LC 208 (Implement Trie)`, `LC 1166 (Design File System)`

### 数据结构：跳表(Skiplist)

**组合：** 多层（概率性）的 `LinkedList`。

**特性：**

- 一个**概率性**数据结构，用随机性来换取实现的简洁性。
- 提供 $O(\log N)$ **平均**时间复杂度的 `search`, `insert`, `delete`。
- **不需要**像 `AVL/Red-Black Tree` 那样进行复杂的“旋转”和“再平衡”操作。

**核心技巧：** `insert` 时，通过“抛硬币”决定这个新节点要“晋升”到多少层。`search` 时，从最高层的“快速通道”开始查找，逐层下降。

**解决：** `LC 1206 (Design Skiplist)`。在面试中，当你需要一个 $O(\log N)$ 的有序结构时，如果你不想（或不会）手写平衡二叉树，**主动提出 `Skiplist`** 是一个非常亮眼的回答，显示了你广阔的知识面。