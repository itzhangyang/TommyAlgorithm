##1. 核心模式：O(1) 查找 + O(1) 顺序 (指针哈希图)



**挑战：** 需要同时 O(1) 查找任意元素，并 O(1) 维护元素的插入/使用顺序（如找到最早/最晚的元素）。 **应对策略：** `HashMap<Key, Node>` + `DoublyLinkedList<Node>` (并使用**哨兵节点** `head/tail` 来简化边界处理)。

###**LC 146. LRU Cache (LRU 缓存机制)**

- **简介：** 经典中的经典。`get` 和 `put` 均为 O(1)。`put` 时若超容量，需 O(1) 驱逐“最久未使用”的元素。
- **设计：** `HashMap` 提供 O(1) 查找 `Node`，双向链表维护“最近使用”的顺序（头部=最近，尾部=最久）。

```Java
class Node {
    int key;
    int val;
    Node prev;
    Node next;
    public Node(int key, int val){
        this.key = key;
        this.val = val;
    }
}
class LRUCache {

    Node dummyHead;
    Node dummyTail;

    int capacity;

    int size;

    Map<Integer, Node> map = new HashMap<>();

    public LRUCache(int capacity) {
        this.dummyHead = new Node(-1, -1);
        this.dummyTail = new Node(-1, -1);

        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;
        this.capacity = capacity;
        this.size = 0;
    }
    
    public int get(int key) {
        System.out.println("Getting key:"+ key);
        if(!map.containsKey(key)){
            return -1;
        }

        Node node = map.get(key);
        moveToHead(node);
        // printList();
        return node.val;
    }


    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            node.val = value;
            moveToHead(node);
            return;
        }
        System.out.println("put key:"+ key+",value:"+value);
        if(size >= capacity){
            removeTail();
        }

        Node node = new Node(key, value);

        insertToHead(node);
        map.put(key, node);

        // printList();
        size++;
    }
  
  

    private void insertToHead(Node node){
        Node next = dummyHead.next;
        node.next = next;
        next.prev = node;

        node.prev = dummyHead;
        dummyHead.next = node;
    }
  
    private void moveToHead(Node node){
        System.out.println("Moving ["+node.key+","+node.val+"] " + " to head" );
        removeNode(node);

        Node oldFirst = dummyHead.next;

        node.next = oldFirst;
        //记得更新oldFirst的prev指针
        oldFirst.prev = node;
        node.prev = dummyHead;

        dummyHead.next = node;
    }

    private void removeNode(Node node){
        Node prev = node.prev;
        Node next = node.next;

        prev.next = next;
        next.prev = prev;
    }

    private void removeTail(){
        Node toRemove = dummyTail.prev;
        System.out.println("Removing Node:"+"["+toRemove.key+","+ toRemove.val+"]");
        removeNode(toRemove);
        map.remove(toRemove.key);
        size--;
    }

    private void printList(){
        System.out.print("The current list:");
        Node node = dummyHead;
        while (node != null) {
            System.out.print("["+node.key+","+node.val+"]"+"->");
            node = node.next;
        }
        System.out.println();
        System.out.println("Current Head:"+ dummyHead.next == null ? "null" : "["+dummyHead.next.key+","+dummyHead.next.val+"]");
        System.out.println("Current Tail:"+ dummyTail.prev == null ? "null" : "["+dummyTail.prev.key+","+dummyTail.prev.val+"]");
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



###**LC 460. LFU Cache (LFU 缓存机制)**

- **简介：** LRU 的终极加强版。`get` 和 `put` 均为 O(1)。需 O(1) 驱逐“使用频率最低”的元素。如果频率相同，则驱逐“最久未使用”的元素。
- **设计：** `Map<Key, Node>` + `Map<Freq, DoublyLinkedList<Node>>`。这是一个“双层”指针哈希图，一个 `Map` 存频率桶，每个频率桶是 `LRU` 结构。

#### 问题本质和分析：双层LRU实现

##### 关于驱逐策略

###### 第一层：按照频率高低进行驱逐

这个需要我们记录每一个节点的访问频率。

###### 第二层： 按照访问时间进行驱逐

题目要求在**频率相同的情况下** 则驱逐**最久未使用**的元素。

```Java
class Node{
    int key;
    int val;
    Node prev;
    Node next;
    int freq;

    public Node(int key, int val){
        this.key = key;
        this.val = val;
        this.freq = 1;
    }
}

class DoubleLinkedList{
    Node dummyHead;
    Node dummyTail;
    int size ;
    public DoubleLinkedList(){
        this.dummyHead = new Node(-1, -1);
        this.dummyTail = new Node(-1, -1);
        this.dummyHead.next = this.dummyTail;
        this.dummyTail.prev = this.dummyHead;
        this.size = 0;
    }

    public void addFirst(Node node){
        Node next = dummyHead.next;
        node.next = next;
        next.prev = node;

        node.prev = dummyHead;
        dummyHead.next = node;
        this.size++;
    }

    public void removeLast(){
        Node last = dummyTail.prev;
        remove(last);
    }

    public void remove(Node node){
        if(size == 0){
            return;
        }
        Node next = node.next;
        Node prev = node.prev;

        prev.next = next;
        next.prev = prev;
        this.size--;
    }

    public Node getLast(){
        return dummyTail.prev;
    }

    public boolean isEmpty(){
        return this.size == 0;
    }
}

class LFUCache {
    Map<Integer, Node> nodeMap;
    TreeMap<Integer, DoubleLinkedList> freqMap;
    int capacity;
    int size;

    public LFUCache(int capacity) {
        this.nodeMap = new HashMap<>();
        this.freqMap = new TreeMap<>();
        this.capacity = capacity;
        this.size = 0;
    }
    
    public int get(int key) {
        if (capacity <= 0) return -1;
        if(!nodeMap.containsKey(key)){
            return -1;
        }
        Node node = nodeMap.get(key);
        incrFreq(node);
        return node.val;
    }

    private void incrFreq(Node node){
        DoubleLinkedList list = freqMap.get(node.freq);
        list.remove(node);
        if(list.isEmpty()){
            freqMap.remove(node.freq);
        }
        int newFreq = node.freq+1;
        node.freq = newFreq;
        DoubleLinkedList newList = freqMap.getOrDefault(newFreq, new DoubleLinkedList());
        newList.addFirst(node);
        freqMap.put(newFreq, newList);
    }

    
    public void put(int key, int value) {
        if (capacity <= 0) return ;
        if(nodeMap.containsKey(key)){
            Node node = nodeMap.get(key);
            node.val = value;
            incrFreq(node);
            return;
        }

        if(size >= capacity){
            evict();
        }
        Node node = new Node(key, value);
        add(node);
    }

    private void add(Node node){
        
        nodeMap.put(node.key, node);

        DoubleLinkedList list = freqMap.getOrDefault(node.freq, new DoubleLinkedList());
        list.addFirst(node);
        freqMap.put(node.freq, list);

        size++;
    }

    private void evict(){
        Map.Entry<Integer, DoubleLinkedList> firstEntry =  freqMap.firstEntry();
        DoubleLinkedList list = firstEntry.getValue();
        int freq = firstEntry.getKey();
        Node last = list.getLast();
        list.remove(last);
        nodeMap.remove(last.key);
        if(list.isEmpty()){
            freqMap.remove(freq);
        }
        size--;
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```







###**LC 432. All O(1) Data Structure (全 O(1) 的数据结构)**

- **简介：** `inc(key)`, `dec(key)`, `getMaxKey()`, `getMinKey()` 均 O(1)。
- **设计：** `Map<Key, BucketNode>` + `DoublyLinkedList<BucketNode>`。链表按 `count` 排序，`BucketNode` 内部包含一个 `Set<String>` 存储所有该 `count` 的 `key`。`inc/dec` 操作就是将 `key` 从一个桶 `Set` 移动到相邻的桶 `Set`，并处理桶的创建/删除。

#### 问题要点

你需要实现一个数据结构，支持以下五个操作，并且**所有操作的平均时间复杂度都必须是 $O(1)$**：

1. `AllOne()`: 初始化数据结构。
2. `inc(String key)`: 插入一个新 key（值为 1）或将一个现有 key 的值（计数）加 1。
3. `dec(String key)`: 将一个现有 key 的值（计数）减 1。如果减 1 后值为 0，则将该 key 从数据结构中**完全移除**。
4. `getMaxKey()`: 返回一个具有**最大**计数的 key。如果没有任何 key，返回 `""`。
5. `getMinKey()`: 返回一个具有**最小**计数的 key。如果没有任何 key，返回 `""`。

最核心的约束是：**所有操作必须是 $O(1)$**。

#### 问题本质和分析

这个问题的本质是在 "key 的 $O(1)$ 查找" 和 "计数的 $O(1)$ 查找最大/最小值" 之间找到平衡。

##### 如果只使用HashMap记录每个字符串的频率

`inc` 和 `dec` 更新 key 的计数是 $O(1)$ 的。

**但是**，`getMaxKey` 和 `getMinKey` 需要遍历整个 Map，时间复杂度为 $O(N)$，不符合要求。

##### 如果只用排序结构（如 TreeMap 或平衡树）：

我们可以用 `TreeMap<Integer, Set<String>>` 来存储 `count -> {key1, key2}`。

这样 `getMaxKey` 和 `getMinKey` 可以通过 `map.firstKey()` 和 `map.lastKey()` 做到 $O(\log N)$（如果树是按 count 排序的）。

但是，inc 和 dec 操作会变得复杂。当一个 key 的 count 从 c 变为 c+1 时，你需要从 count=c 的 Set 中移除 key，再- - - - - -

添加到 count=c+1 的 Set 中。这个查找和更新操作是 $O(\log N)$，也不符合要求。

#####**$O(1)$ 的启示：**

- 要在 $O(1)$ 内完成 `inc` / `dec`，我们需要 **HashMap** 来快速定位 key。
- 要在 $O(1)$ 内完成 `getMaxKey` / `getMinKey`，我们必须**始终维护指向最大/最小计数的指针**。
- 当 `inc` / `dec` 发生时，一个 key 的计数只会 `+1` 或 `-1`。这意味着它只会移动到**相邻的计数**上。

#### 规律观察

`inc` 和 `dec` 只会导致计数 `c` 变为 `c+1` 或 `c-1`。

这个 "相邻" 的特性是本题的突破口。

这启发我们使用一个**有序的数据结构**来组织这些**计数**。

为了在 $O(1)$ 时间内在这个有序结构中插入和删除节点，**双向链表**是完美的选择。

我们可以把**具有相同计数的 key** 组织在一起，称为一个 "桶" (Bucket)。然后我们把这些 "桶" 按照它们所代表的 `count` 值，从小到大串在一个**双向链表**中。

- `count = 1` 的桶 <-> `count = 2` 的桶 <-> `count = 5` 的桶 ...

当一个 key（例如 `key="a"`）的 `count` 从 2 变为 3 时：

1. 我们将 `"a"` 从 `count=2` 的桶中移除。
2. 我们将 `"a"` 添加到 `count=3` 的桶中。
3. 如果 `count=3` 的桶原先不存在，我们就**创建**这个新桶，并将其插入到 `count=2` 的桶之后。
4. 如果 `count=2` 的桶因此变空了，我们就**移除**这个桶。

#### 套路模式匹配

这和 LeetCode 146 (LRU 缓存) 的套路几乎一样，但应用方式不同：

- **LRU (LRU Cache):**
  - **HashMap** 存储 `key -> Node`，用于 $O(1)$ 查找。
  - **Doubly Linked List** 存储 `Node`，按 "最近使用" 排序。`inc` (即 `get` 或 `put`) 会把节点移到链表头部。
- **All-O-One (This Problem):**
  - **HashMap** 存储 `key -> Bucket`，用于 $O(1)$ 查找 key 所在的 "桶" (Bucket)。
  - **Doubly Linked List** 存储 `Bucket`，按 "计数值 (count)" 排序。`inc` / `dec` 会把 key 从一个 `Bucket` 移动到**相邻的** `Bucket`。

#### 核心思想和套路

#####**`Bucket` 节点 (内部类)：**存放频率相同的字符串

- `int count`: 这个桶代表的计数值。
- `Set<String> keys`: 存储所有计数为此 `count` 的 key。使用 `Set` (如 `LinkedHashSet` 或 `HashSet`) 保证 key 的 $O(1)$ 插入和删除。
- `Bucket prev`, `Bucket next`: 双向链表指针。

#####**`keyMap` (哈希表)：**存放字符串所在的Bucket

- `Map<String, Bucket> keyMap`
- 它提供 $O(1)$ 的能力，让我们通过 `key` 字符串直接找到它所在的 `Bucket` 节点。**这是实现 $O(1)$ 的关键**。

#####**`head` 和 `tail` (哨兵节点)：**简化链表操作

- 我们使用两个哨兵节点 `head` 和 `tail` 来简化链表操作，避免处理 `null`。
- `head`: 虚拟的 "0 计数" 桶。
- `tail`: 虚拟的 "无穷大计数" 桶。
- **`head.next` 永远指向计数值最小的桶。**
- **`tail.prev` 永远指向计数值最大的桶。**
- `getMaxKey()`: $O(1)$ 实现，只需返回 `tail.prev.keys` 里的任意一个 key。
- `getMinKey()`: $O(1)$ 实现，只需返回 `head.next.keys` 里的任意一个 key。

#### 实现代码

```Java
class Bucket{
    int count;
    Set<String> set;
    Bucket prev;
    Bucket next;

    public Bucket(int count){
        this.count = count;
        this.set = new HashSet<>();
    }

    public boolean add(String str){
        return this.set.add(str);
    }

    public boolean remove(String str){
        return this.set.remove(str);
    }

    public boolean isEmpty(){
        return this.set.isEmpty();
    }
}

class BucketList{
    private Bucket dummyHead;
    private Bucket dummyTail;
    private int size;

    public BucketList(){
        this.dummyHead = new Bucket(0);
        this.dummyTail = new Bucket(0);

        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;

        this.size = 0;
    }

    public void addFirst(Bucket bucket){
        Bucket next = dummyHead.next;
        bucket.next = next;
        next.prev = bucket;

        dummyHead.next = bucket;
        bucket.prev = dummyHead;
        size++;
    }

    public void remove(Bucket bucket){
        Bucket next = bucket.next;
        Bucket prev = bucket.prev;

        next.prev = prev;
        prev.next = next;
        size--;
    }

    public Bucket getFirst(){
        if(size == 0){
            return null;
        }
        return dummyHead.next;
    }

    public Bucket getLast(){
        if(size == 0){
            return null;
        }
        return dummyTail.prev;
    }

    public void addAfter( Bucket bucket, Bucket prev){
        Bucket next = prev.next;
        bucket.next = next;
        next.prev = bucket;
        bucket.prev = prev;
        prev.next = bucket;
        size++;
    }

    public void addBefore(Bucket bucket, Bucket after){
        Bucket prev = after.prev;
        bucket.next = after;
        after.prev = bucket;

        prev.next = bucket;
        bucket.prev = prev;
        size++;
    }

    public boolean isEmpty(){
        return size <=0;
    }
}
class AllOne {
    Map<String, Bucket> map;
    BucketList bucketList;
    public AllOne() {
        this.map = new HashMap<>();
        this.bucketList = new BucketList();
    }
    
    public void inc(String key) {
        if(!map.containsKey(key)){
            Bucket first = bucketList.getFirst();
            if(first == null || first.count != 1){
                Bucket bucket = new Bucket(1);
                bucket.add(key);
                map.put(key, bucket);
                bucketList.addFirst(bucket);
            }else{
                first.add(key);
                map.put(key, first);
            }
           
        }else{
            Bucket bucket = map.get(key);
            int newCount = bucket.count+1;
            Bucket next = bucket.next;
            bucket.remove(key);

            if(next.count != newCount){
                Bucket newBucket = new Bucket(newCount);
                newBucket.add(key);
                map.put(key, newBucket);
                bucketList.addAfter(newBucket, bucket);
            }else{
                next.add(key);
                map.put(key, next);
            }

            if(bucket.isEmpty()){
                bucketList.remove(bucket);
            }
        }
    }
    
    public void dec(String key) {
        if(!map.containsKey(key)){
            return;
        }

        Bucket bucket = map.get(key);
        if(bucket.count == 1){
            bucket.remove(key);
            if(bucket.isEmpty()){
                bucketList.remove(bucket);
            }
            map.remove(key);

        }else{

            int newCount = bucket.count -1;
            Bucket prev = bucket.prev;
            if(prev.count == newCount){
                prev.add(key);
                map.put(key, prev);
            }else{
                Bucket newBucket = new Bucket(newCount);
                newBucket.add(key);
                map.put(key, newBucket);
                bucketList.addBefore(newBucket, bucket);
            }

            bucket.remove(key);
            if(bucket.isEmpty()){
                bucketList.remove(bucket);
            }

        }
    }
    
    public String getMaxKey() {
        if(bucketList.isEmpty()){
            return "";
        }
        return bucketList.getLast().set.iterator().next();
    }
    
    public String getMinKey() {
        if(bucketList.isEmpty()){
            return "";
        }
        return bucketList.getFirst().set.iterator().next();
    }
}

/**
 * Your AllOne object will be instantiated and called as such:
 * AllOne obj = new AllOne();
 * obj.inc(key);
 * obj.dec(key);
 * String param_3 = obj.getMaxKey();
 * String param_4 = obj.getMinKey();
 */
```



###**LC 716. Max Stack (最大栈)**

- **简介：** `push`, `pop`, `top`, `peekMax`, `popMax` 均为 O(logN) 或更优。`popMax` 是难点。
- **设计：** `DoublyLinkedList` (模拟栈) + `TreeMap<Val, List<Node>>`。`TreeMap` 提供了 O(logN) 找到最大值的能力，`List<Node>` 处理值重复的情况。`popMax` 时，通过 `TreeMap` 找到最大值对应的 `Node`，再通过 `Node` 的 `prev/next` 指针 O(1) 从链表中删除。

#### 重要组件和成员

##### 双向链表：维护全局的第一个和最后一个元素（Pop时使用）

###### 双向链表节点定义

```Java
class ListNode{
    int val;
    ListNode next;
    ListNode prev;
    public ListNode(int val){
        this.val = val;
    }
}
```

###### 双向链表定义

```Java
class CustomizedList{
    ListNode dummyHead;
    ListNode dummyTail;
    int size;
    public CustomizedList(){
        this.dummyHead = new ListNode(-1);
        this.dummyTail = new ListNode(-1);
        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;
        this.size = 0;
    }

    public void remove(ListNode node){
        ListNode prev = node.prev;
        ListNode next = node.next;

        prev.next = next;
        next.prev = prev;
        size--;
    }

    public void addLast(ListNode node){
        ListNode prev = dummyTail.prev;
        prev.next = node;

        node.prev = prev;
        node.next = dummyTail;

        dummyTail.prev = node;

        size++;
    }

    public ListNode getFirst(){
        if(size == 0){
            return null;
        }

        return dummyHead.next;
    }
		//注意这里在pop的时候会使用
    public ListNode getLast(){
        if(size == 0){
            return null;
        }

        return dummyTail.prev;
    }
}
```

####最大栈的实现

##### 成员定义

###### 双向链表： 维护全局最后一个元素和所有数据

###### TreeMap: 便于快速找打最大值和节点

```Java


class MaxStack {
		//双向链表，维护全局数据和last节点
    CustomizedList list;
		//TreeMap，维护值和节点列表的对应关系
    //TreeMap会按照Key自动排序
    //map.lastKey()能够直接找到值最大的节点列表，从而在O(1)时间内快速找到max 
    TreeMap<Integer, List<ListNode>> map;
    public MaxStack() {
        list = new CustomizedList();
        maxStack = new Stack<>();
        map = new TreeMap<>();
    }
    
    public void push(int x) {
        ListNode node = new ListNode(x);
        //更新map， 将节点加入值对应的节点列表
        List<ListNode> nodes = map.getOrDefault(x, new LinkedList<>());
        nodes.add(node);
        map.put(x, nodes);
        //更新双向链表，将节点插入到最后
        list.addLast(node);
    }
    
    public int pop() {
       //双向链表的最后一个节点就是栈顶节点
        ListNode last = list.getLast();
        //更新链表，模拟弹出操作，将最后一个节点删除
        list.remove(last);
        //更新Map，同时更新值对应的节点，将节点从节点列表中删除
        List<ListNode> nodes = map.get(last.val);
        nodes.removeLast();
      	//如果节点列表为空，从Map中删除这个key
        //防止在下次调用lastKey的时候污染数据
        if(nodes.isEmpty()){
            map.remove(last.val);
        }
        //返回值
        return last.val;
    }
    //查询栈顶的节点
    
    public int top() {
      	//即获取双链表的最后一个节点
        ListNode last = list.getLast();
        return last.val;
    }
    //查询最大值节点
  	//即获取map中的lastKey
    public int peekMax() {
        return map.lastKey();
    }
    //弹出最大值
    //即找到map的lastKey
  	//根据lastKey找到节点列表
  	//从map和list中删除最后一个节点
    public int popMax() {
        int key = map.lastKey();

        List<ListNode> nodes = map.get(key);
        ListNode node = nodes.removeLast();
        if(nodes.isEmpty()){
            map.remove(key);
        }

        list.remove(node);
        return key;
    }
}
```

##