##2. 核心模式：O(1) 增删 + O(1) 随机 (索引哈希表)



**挑战：** 需要 O(1) 插入、 O(1) 删除**指定元素**，并 O(1) **随机获取**一个元素。 **应对策略：** `HashMap<Value, Index>` + `ArrayList<Value>`。

###**LC 380. Insert Delete GetRandom O(1) (O(1) 时间插入、删除和获取随机元素)**

- **简介：** 实现 `insert(val)`, `remove(val)`, `getRandom()` 均为 O(1)。
- **设计：** `ArrayList` 负责 O(1) `getRandom`。`HashMap` 负责 O(1) 查找 `val` 在 `ArrayList` 中的索引。`remove` 时使用 **Swap-and-Pop 技巧**：将要删除的元素与列表末尾元素交换，然后删除末尾元素，实现 O(1) 删除。

#### 实现代码

```Java
class RandomizedSet {
    Map<Integer, Integer> indexMap;
    List<Integer> list;

    public RandomizedSet() {
        indexMap = new HashMap<>();
        list = new ArrayList<>();
    }
    
    public boolean insert(int val) {
        // System.out.println("Insert:"+ val);
        if(indexMap.containsKey(val)){
            return false;
        }

        list.add(val);
        indexMap.put(val,list.size()-1);
        // print();
        return true;
    }
    
    public boolean remove(int val) {
        // System.out.println("Remove:"+val);
        if(!indexMap.containsKey(val)){
            return false;
        }
        int index = indexMap.get(val);

        int lastIndex = list.size()-1;
        int lastVal = list.get(lastIndex);
        list.set(index, lastVal);

        indexMap.put(lastVal,index);
        indexMap.remove(val);

        list.removeLast();
        // print();
        return true;
    }
    
    public int getRandom() {
        int size = list.size();
        Random random = new Random();
        int randomIndex = random.nextInt(0, size);
        return list.get(randomIndex);
    }

    private void print(){
       String s = String.join(",", list.stream().map(String::valueOf).toList());
       System.out.println("List content:"+s);
    }
}
```



###**LC 381. Insert Delete GetRandom O(1) - Duplicates allowed**

- **简介：** `LC 380` 的加强版，允许重复元素。
- **设计：** `ArrayList<Value>` + `HashMap<Value, Set<Index>>`。`remove` 时，从 `Set` 中任取一个索引执行 Swap-and-Pop。

#### 需要特别注意的删除过程: swap-and-pop

##### Swap-and-pop的核心思想： 最后一个元素换到删除位置

在接收到元素删除请求时，根据题目的要求，我们需要找到元素的位置并且删除它。

**swap-and-pop**的最重要的优点就是可以在$O(1)$的时间内实现这个过程。

它借助我们预先构建和维护的**IndexMap<value,Index>**快速找到元素的索引。

为了避免删除该元素而引发的后继元素移动问题，我们选择删除最后一个位置（注意不是最后一个元素）。

将列表的最后一个元素放入待删除元素的索引位置，然后将列表的最后一个位置删除。

#####情况一：待删除元素就是最后一个元素

这种情况下，只需要删除最后一个元素并且更新IndexMap就可以了

##### 情况二：待删除元素不是最后一个元素

这种情况下，我们分三个步骤：

1. 用最后一个元素替换待删除元素的位置
2. 删除最后一个元素
3. 更新IndexMap

#### 实现代码

```Java
class RandomizedCollection {
    Map<Integer,Set<Integer>> indexMap;
    List<Integer> list;

    public RandomizedCollection() {
        indexMap = new HashMap<>();
        list = new ArrayList<>();
    }
    
    public boolean insert(int val) {
        System.out.println("Insert:"+val);
        boolean existed = false;
        if(indexMap.containsKey(val)){
            existed = true;
        }
        list.add(val);
        Set<Integer> indexes = indexMap.getOrDefault(val, new HashSet<>());
        indexes.add(list.size()-1);
        indexMap.put(val, indexes);
        // printList();
        return !existed;
    }
    
    public boolean remove(int val) {
        System.out.println("Remove:"+val);
        if(!indexMap.containsKey(val)){
            return false;
        }

        Set<Integer> currentValIndexes = indexMap.get(val);
        if(currentValIndexes.isEmpty()){
            indexMap.remove(val);
            return false;
        }

        System.out.println("Before remove, num of "+val + ":"+ currentValIndexes.size());

        int currentIndex = currentValIndexes.iterator().next();
        //待删除元素可能有好几个索引
        //我们只需要删除其中之一就可以了
        currentValIndexes.remove(currentIndex);
        
        //找到最后一个元素的值和索引
        int lastIndex = list.size() - 1;
        int lastVal = list.get(lastIndex);
        //如果要删除的元素不是最后一个元素
        //用最后一个元素替换待删除的元素
        if(currentIndex != lastIndex){
            //将当前位置的值设置为最后一个元素的值
            list.set(currentIndex, lastVal);
            //找到最后一个元素的索引列表
            Set<Integer> lastValIndexes = indexMap.get(lastVal);
            //删除最后一个索引
            lastValIndexes.remove(lastIndex);
            //加入当前索引
            lastValIndexes.add(currentIndex);
        }
        //如果待删除元素就是最后一个元素，则没有必要做上述操作了
        //删除最后一个元素
        list.removeLast();
       
        

        
        if(currentValIndexes.isEmpty()){
            indexMap.remove(val);
        }
        System.out.println("Remove a :" + val);
        // printList();
        return true;
    }

    
    public int getRandom() {
        Random random = new Random();
        int index = random.nextInt(0, list.size());
        return list.get(index);
    }

    private void printList(){
        String s = String.join(",", list.stream().map(String::valueOf).toList());
        System.out.println("List content:"+s);
    }
}

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```



