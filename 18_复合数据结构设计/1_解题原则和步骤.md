## 复合数据结构设计问题的解题原则和步骤

### 原则一：需求驱动

这是第一步。不要立刻去想“我该用什么数据结构”，而是先**列出所有操作及其时间复杂度约束**。

- **例子 (LRU Cache)：**
  - `get(key)`: $O(1)$
  - `put(key, value)`: $O(1)$
  - `evict_least_recent()`: (隐含在`put`中) $O(1)$

### 原则二：瓶颈分析 (Bottleneck Analysis)

拿一个基础数据结构，看它**为什么失败**。

- **场景 (LRU Cache)：**
  - 只用 `HashMap`？`get` 和 `put` 是 $O(1)$，但无法在 $O(1)$ 内找到“最久未使用”的元素（需要 $O(N)$ 遍历）。**瓶颈：无序。**
  - 只用 `LinkedList`？可以 $O(1)$ 移除队尾，但 `get(key)` 需要 $O(N)$ 查找。**瓶颈：查找慢。**

### 原则三：组合互补

这是解决“查找”与“顺序”冲突的**万能钥匙**。

- **套路：** `HashMap` + (一种有序结构，通常是**双向链表**)。
- **蓝图：**
  1. `HashMap<Key, Node>`：`Key` 映射到双向链表中的 `Node` 节点。
  2. `DoublyLinkedList`：`Node` 节点存储 `(key, value)`，并维护“顺序”。
- **协同工作：**
  - `get(key)`：通过 `HashMap` 在 $O(1)$ 找到 `Node`，然后操作 `Node` (及其 `prev/next` 指针) 在 $O(1)$ 内将其移到链表头部。
- **应用：** `LC 146 (LRU Cache)`, `LC 460 (LFU Cache)`, `LC 432 (All O(1) Data Structure)` (这是该模式的终极复杂版)。

### 原则四：辅助追踪

当主数据结构无法 $O(1)$ 提供某个“属性”（如最小值、随机值）时，使用一个**辅助数据结构**专门追踪这个属性。

- **套路：** `MainStructure` + `AuxiliaryStructure`
- **应用 (Min Stack)：**
  - `MainStructure`：一个 `Stack` 存储所有元素。
  - `AuxiliaryStructure`：一个**额外的 `Stack`** (`minStack`)，`minStack` 的栈顶**永远**存储着 `mainStack` *当前状态下* 的最小值。
  - `push(x)`: `mainStack.push(x)`, `minStack.push(min(x, minStack.peek()))`。
  - `pop()`: `mainStack.pop()`, `minStack.pop()`。
  - `getMin()`: $O(1)$ 返回 `minStack.peek()`。

### 原则五：层级分解

当问题本身具有“嵌套”或“路径”特性时，使用 `Stack` 或 `Trie`。

- **套路 (Trie)：** 用于**路径依赖**型问题，如文件系统。
- **应用 (File System)：**
  - `/a/b/c` 天然就是 `Trie` 结构。
  - `createPath("/a/b/c", 1)`：从 `root` 查找 `a`，再查找 `b`。如果 `b` 的 `children` 中没有 `c`，则创建 `c`。
- **套路 (Stack)：** 用于**递归展开**型问题，将递归（DFS）迭代化。
- **应用 (Nested Iterator)：**
  - 用 `Stack` 存储迭代器。
  - `hasNext()` 的职责就是**不停地 `pop` 栈顶迭代器并展开其子列表（`push` 新迭代器），直到栈顶是一个整数**。