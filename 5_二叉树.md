

| 类别             | 关键词                            | 示例题            |
| ---------------- | --------------------------------- | ----------------- |
| ✅ 遍历类         | 前序、中序、后序、层序、递归/迭代 | 94, 144, 145, 102 |
| ✅ 属性计算       | 高度、深度、节点数、直径          | 104, 111, 543     |
| ✅ 判断结构       | 是否平衡/对称/相同                | 100, 101, 110     |
| ✅ 路径类         | 路径和、最大路径、所有路径        | 112, 113, 124     |
| ✅ 转换类         | 构建树、扁平化、链表化            | 105, 106, 114     |
| ✅ 查找类         | 最近公共祖先、搜索路径            | 235, 236, 98      |
| ✅ 二叉搜索树专属 | 中序性质、大小关系                | 98, 700, 701, 230 |
| ✅ 变种结构       | 多叉树、完全/满/平衡树            | 222, 116, 117     |

# 遍历类

## 深度优先搜索 DFS

首先我们需要明确一下归属，二叉树的前序/中序/后序遍历都可以看作是**深度优先搜索**。

其核心在于明确**递归函数的定义**：这个函数在当前节点上需要做什么？

在当前节点，先处理一部分逻辑，然后将剩下的问题交给左右子树去解决（递归调用），最后根据子问题的结果汇聚成当前节点的最终结果。

###前序遍历： 根 - 左 - 右

遍历二叉树，按照**根 - 左 - 右**的顺序输出左右节点

####核心思想

- 使用**DFS**，递归遍历节点
- 访问当前节点，递归访问左子树，再递归访问右子树

####难点分析和应对

递归顺序需要严格控制

####代码套路模板

```java
public List<Integer> preorderTraversal(TreeNode root){
  List<Integer> res = new ArrayList<>();
  preorder(root,res);
  return res;
}

private void preorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  res.add(root.val);
  
  preorder(root.left,res);
  
  preorder(root.right,res);
}
```

###中序遍历：左 - 根 - 右

遍历二叉树，按照中序顺序（左子树 -> 根 -> 右子树）输出所有节点。

####核心思想

- 使用DFS
- 递归遍历左子树，访问根节点，再递归访问右子树

####难点分析和应对

递归时要保证左根右的顺序

####代码实现

```java
private void inorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  
  //左节点调用递归
  inorder(root.left, res);
  //处理根节点
  res.add(root.val);
  //处理有节点
  inorder(root.right,res);
}
```

###后序遍历： 左 -  右 - 根

遍历二叉树，按照左-右-根的方式输出所有节点

####核心思想 - DFS

- 使用DFS 
- 递归遍历左右子树，最后访问根节点

####难点分析和应对

根节点的处理要确保放在左右节点之后

####代码实现

```java
private void postorder(TreeNode root, List<Integer> res){
  if (root == null) return;
  
  //递归调用左子树
  postorder(root.left, res);
  //递归处理右子树
  postorder(root.right,res);
  //处理根节点
  res.add(root.val);
}
```

###Leetcode 1038: [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)[逆中序遍历累加和]

这道题目要求将一个二叉搜索树（BST）转化为一个大于或等于它自身的累加树（Greater Sum Tree）。

这意味着树的每个节点的值将变为**大于等于它的节点**的所有节点的值之和。

具体地，树的每个节点的值将替换为**该节点及其右侧子树中所有节点**的值的总和。

####BST 特性 - 左 < 中 < 右

对于任意节点，左子树小于该节点，右子树的值大于该节点

目标是将节点的值修改为**该节点**以及**右子树所有节点**的和

####考察点 - 树的遍历和反向累加

通常情况下，我们使用中序遍历来处理BST相关的问题，但是由于这里需要修改为比当前节点大的和，因此需要使用**逆中序遍历**

####核心思想和套路： 逆中序 + 累加过程

需要注意的是，并不是要将每个节点的值 = 节点的值 + 其右子节点的值。

因为Greater节点的范围包含了：

- 右子节点
- 父祖辈节点

所以并不是简单的将节点重置为右子节点+当前节点就完事了。

正确的做法是维护一个**全局变量**或通过**引用传递**的变量来记录到目前为止所有已访问过节点（也就是所有值比当前节点大的节点）的**累加和**。

#####**逆中序过程**： 通过逆中序遍历来处理问题：

- 在遍历过程中，**当前节点需要先访问到它的右节点**，从而保证当前节点已经累加了右子树及其所有后代的值
- 通过这种方式，我们可以在遍历过程中实现累加的操作

#####**累加过程：**

在逆中序过程中，每次访问一个节点时，需要

- 将当前值与前一个累加变量相加
- 更新当前节点的值

这样可以保证节点的值逐渐变成原树的总和。

####实现原理和步骤

- 使用 **逆中序遍历（右-根-左）** 来遍历整个树。
- 维护一个**全局变量 `sum`** 来存储当前的累加和。(这一点是非常重要的实践)
- 对于每个节点
  - 将 `sum`累加到该节点上
  - 更新`sum`为该节点的累加
- 当遍历完成之后，树的每个节点就变成了累加树

####代码实现

```java
private int sum = 0;
public TreeNode bstToGst(TreeNode root){
  //右，中，左的树序
  if (root == null) return;
  //处理右节点
  bstToGst(root.right);
  
  //处理root节点
  sum += root.val;
  root.val = sum;
  
  //处理左节点
  bstToGst(root.left);
}
```

**`sum`**：用来保存当前累加和的全局变量。

**`bstToGst(TreeNode root)`**：采用递归的方式进行逆中序遍历。

- 先递归遍历右子树，使得我们能够处理当前节点之后的所有节点。
- 累加当前节点的值到 `sum` 上，并更新当前节点的值为 `sum`。
- 然后递归遍历左子树。

####时间复杂度

时间复杂度是 **O(n)**，其中 `n` 是树的节点数。因为每个节点都会被访问一次，且我们使用的是递归遍历

####空间复杂度

空间复杂度是 **O(h)**，其中 `h` 是树的高度。递归调用栈的最大深度为树的高度，因此空间复杂度为树的高度。对于平衡二叉树，`h` 是 **O(log n)**；对于退化树，`h` 是 **O(n)**。

####注意事项

需要小心处理树的结构，确保递归调用时不破坏树的结构。

本题的关键点在于逆中序遍历，而不是简单的中序遍历，因为我们需要对比当前节点和右子树的值进行累加。

####经验总结

**逆中序遍历** 是解决此类问题的常用技巧，尤其在处理需要从大到小的顺序累加时，非常有效。

需要理解题目中的转换过程，本题并非传统的递归求解问题，而是基于当前节点和右子树的值的累加，适合使用递归来避免手动维护栈。

##层序（BFS）- 按层遍历二叉树，输出每一层的节点

#### 核心思想和套路 - 广度优先搜索

使用队列逐层遍历树，每次处理当前层的所有节点。

#### 难点分析和应对

队列的管理要确保每一层的节点都被正确处理。

#### 代码实现

```java
public List<List<Integer>> levelOrder(TreeNode root){
  List<List<Integer>> result = new ArrayList<>();
   if (root == null) return result;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(currentLevel);
    }
    return result;
}
```

#属性计算

###LeetCode 104: 求树的最大深度

####核心思想和套路 - DFS(max(leftDepth,rightDepth) + 1)

使用DFS，递归计算左右子树的最大深度，返回最大深度

####难点分析和应对 - 空节点处理

递归需要处理空节点，确保深度计算无误。

####代码套路模板

```java
public int maxDepth(TreeNode root){
  if (root == null) return 0;
  
  int leftDepth = maxDepth(root.left);
  int rightDepth = maxDepth(root.right);
  
  return Math.max(leftDepth, rightDepth) + 1;
}
```

###求树的最小深度 - LC - 111

#### 问题要点

给定一个二叉树，找出其最小深度。

最小深度是从根节点到**最近叶子节点**的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例 1:**

- 输入: `root = [3,9,20,null,null,15,7]`
- 输出: `2`
- 解释: 节点 3 -> 9 是最短路径，长度为 2。

##### 最小深度的定义 - 必须到叶子节点结束

路径必须从根节点开始，到 **叶子节点** 结束。

##### 叶子节点定义 - 必须同时没有左右节点

一个节点如果同时没有左孩子和右孩子，它才是叶子节点。

#####关键陷阱 - 只有一个子节点的节点不是叶子节点

如果一个节点只有一个孩子（比如只有左孩子），那么这个节点**不是**叶子节点。

因此，不能简单地认为它的深度是 1。

必须继续沿着那个唯一的孩子路径向下寻找叶子节点。

#### 问题的本质和分析

这个问题的本质是在一个树形结构中，寻找从起点（根节点）到满足特定条件（是叶子节点）的终点的**最短路径**。

#####最短路径问题优先考虑BFS实现

对于图论和树中的“最短路径”问题，我们应该立刻想到**广度优先搜索 (BFS)**。

BFS 的特性是按层级进行遍历，它能够保证第一次找到目标节点时，所经过的路径就是最短的。

这与本题“最小深度”的要求完美契合。

##### 如果非要使用DFS的话需要注意的事项 - 避免关键陷阱

当然，**深度优先搜索 (DFS)** 也可以解决这个问题，但需要对递归逻辑进行特殊处理，以避免上面提到的“关键陷阱”。

在 DFS 中，你需要遍历到每一个叶子节点，记录下它们的深度，然后返回所有深度中的最小值。

相比之下，BFS 一旦找到第一个叶子节点就可以立即停止，因此在某些树形结构下（比如一个很深的“链表”状树，但其根节点旁边有一个很浅的叶子节点），BFS 的效率会高得多。

#### 模式套路匹配

##### 广度优先搜索 - 天然适合寻找最短路径

- **模式**: 在树或图中寻找最短路径。
- **信号**: 题目中出现“最小”、“最短”、“最近”、“层”等关键词。
- **匹配原因**: BFS 按层遍历，天然地适合寻找最短距离。找到的第一个符合条件的节点，其所在的层级就是最小深度。

##### 深度优先搜索/递归

**模式**: 任何涉及树的遍历、路径查找、属性计算的问题。

**信号**: 问题的解可以通过子问题的解来构建。例如，一个节点的最小深度与其子树的最小深度有关。

**匹配原因**: 树的结构天然具有递归性。但需要注意，**本题的递归关系不是简单的 `1 + min(left, right)`**，需要特殊处理。

####核心思想和套路 

##### 基于BFS的实现 - 最佳解法

一层一层地遍历树。在遍历过程中，记录当前的层数（也就是深度）。

当我们第一次遇到一个叶子节点时，当前的层数就是最小深度，直接返回即可。

###### 算法流程

- 如果根节点 `root` 为 `null`，返回深度 0。

- 创建一个队列 `queue`，并将根节点 `root` 入队。

- 初始化深度 `depth = 1`。

- 进入循环，只要队列不为空： 

  - a.  记录当前层的节点数量 `levelSize`。 

  - b.  遍历当前层的所有节点（循环 `levelSize` 次）： 

    - i.  从队列中取出一个节点 `currentNode`。

    -  ii. **判断是否为叶子节点**: 如果 `currentNode.left == null` 并且 `currentNode.right == null`，说明我们找到了第一个叶子节点，它是最近的。直接返回当前深度 `depth`。 

    - iii. 如果有左孩子，将左孩子入队。

    -  iv. 如果有右孩子，将右孩子入队。 
  - c.  当前层的所有节点处理完毕后，深度加一 `depth++`。


##### 基于DFS的实现

通过递归计算每个节点的最小深度。关键在于处理**只有一个子树**的情况。

###### Base Case - 当前节点为null

如果当前节点 `node` 为 `null`，返回 0。这表示空树的深度为 0。

###### 递归分解

- 递归计算左子树的最小深度 `leftDepth = minDepth(node.left)`。

- 递归计算右子树的最小深度 `rightDepth = minDepth(node.right)`。

###### 结果合并处理

- 如果左子树为空 (`leftDepth == 0`)，而右子树不为空，说明当前节点不是叶子节点，且路径必须经过右子树才能找到叶子。此时最小深度是 `1 + rightDepth`。
- 同理，如果右子树为空 (`rightDepth == 0`)，而左子树不为空，最小深度是 `1 + leftDepth`。
- **合并这两个条件**: 如果 `leftDepth == 0` 或 `rightDepth == 0`，说明至少有一个子树为空，我们必须走非空的那条路，所以结果是 `1 + leftDepth + rightDepth` (因为其中一个为0) 或者 `1 + max(leftDepth, rightDepth)`。
- 如果左右子树都**不为空** (`leftDepth > 0 && rightDepth > 0`)，说明左右两边都有叶子节点，我们应该选择路径更短的那一边。此时最小深度是 `1 + min(leftDepth, rightDepth)`。

#### 代码套路模板- BFS

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;

        while(!queue.isEmpty()){
            depth++;
            int size = queue.size();
            for(int i=0; i < size; i++){
                TreeNode node = queue.poll();
                if(node.left == null && node.right == null){
                    return depth;
                }
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
        }
        return depth;
    }
}
```



####代码套路模板 -DFS

```java
public int minDepth(TreeNode node){
  if (root == null) return 0;
  if (root.right == null && root.left == null) return 1;
  if (root.left == null) return minDepth(root.right) + 1;
  if (root.right == null) return minDepth(root.left) + 1;
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

###求二叉树的节点数量

可以采用遍历方法计算节点数量。

### Leetcode 543: 求二叉树的直径

#### 问题要点

- **定义**: "二叉树的直径" 是指树中**任意两个节点**之间最长路径的**长度**。

- **路径长度**: 这里的长度指的是路径上所包含的**边的数量**。

- **关键约束**: 这条最长路径**可能穿过根节点，也可能不穿过根节点**。它可能完全存在于左子树或右子树中。

#### 问题的本质和分析

##### 误区：直径 = 左子树的最大深度 + 右子树的最大深度

初看此题，很多人会陷入一个误区：直径 = 左子树的最大深度 + 右子树的最大深度。

这个想法只考虑了**穿过根节点**的情况。

但实际上，最长的路径可能完全隐藏在某一侧的子树中。

##### 正确的想法：计算穿过任意一个节点的最长路径长度

正确的思考方式是，对于树中的**任意一个节点**，我们可以计算出**穿过该节点**的最长路径长度。

这个长度等于它的 `左子树深度` + `右子树深度`。

那么，整棵树的直径，就是**所有节点**的“穿过该节点的最长路径长度”中的**最大值**。

这个分析将一个全局的问题（整棵树的直径）分解成了在每个节点上进行的局部计算（穿过该节点的最长路径），然后取全局最大值。

这自然地引出了使用深度优先搜索（DFS）来遍历所有节点，并在遍历过程中进行计算和更新。

#### 模式套路匹配

##### 深度优先搜索

解决此问题的核心是遍历每一个节点，并获取其子树的信息。DFS (特别是后序遍历) 是处理这类问题的标准方法。

##### 后序遍历 - 先计算左右子树的深度

为了计算以某个节点为“拐点”的路径长度，我们必须先知道其左、右子树的深度。

这意味着我们需要先处理完左子树和右子树，然后再处理当前节点。

这正是后序遍历的 `左 -> 右 -> 根` 的思想。

##### 分治思想

我们可以将问题分解为：

- 左子树的直径
- 右子树的直径
- 穿过当前根节点的最长路径
- 最终结果是这三者中的最大值。我们的解法虽然没有显式计算前两者，但通过在每次递归中更新全局最大值，隐式地覆盖了所有情况。

##### 递归函数的双重功能

递归函数既需要向上返回一个值（子树的深度），又需要在递归过程中更新一个全局状态（最大直径）。

这是树形DP或递归问题中一个非常常见的技巧。

#### 核心思想和套路 - 整棵树的直径等于**所有节点**的 `左子树深度 + 右子树深度` 这个值的最大值。

我们设计一个递归函数（例如 `depth()`），这个函数主要做两件事：

1. **主要任务 (返回值)**: 计算并**返回**以当前节点为根的子树的**最大深度**。这个返回值是给它的父节点使用的。
2. **副作用 (更新全局变量)**: 在计算深度的过程中，我们顺便得到了当前节点的 `左子树深度` 和 `右子树深度`。利用这两个值，我们计算出**穿过当前节点**的路径长度 (`左深度 + 右深度`)，并用它来更新一个全局的（或成员）变量，该变量用于记录迄今为止发现的最大直径。

通过这种方式，我们只需要对树进行一次遍历，就可以同时完成深度的计算和直径的更新，非常高效。

#### 实现原理

**初始化一个成员变量**: 在类中定义一个变量 `maxDiameter`，并初始化为 0。这个变量将跨越递归的边界，用于存储全局的最大直径。

**主函数入口**: `diameterOfBinaryTree(TreeNode root)` 作为主函数。它调用递归辅助函数，并最终返回 `maxDiameter`。

**设计递归辅助函数**: 创建一个私有辅助函数 `depth(TreeNode node)`。

- **功能**:
  - 返回以 `node` 为根的子树的最大深度。
  - 在过程中更新 `maxDiameter`。
- **实现**:
  - **基本情况 (Base Case)**: 如果 `node` 为 `null`，说明到达了叶子节点的下一层，其深度为 0，直接 `return 0`。
  - **递归分解 (Recursive Step)**:
    - 递归调用 `depth(node.left)` 计算左子树的最大深度，记为 `leftDepth`。
    - 递归调用 `depth(node.right)` 计算右子树的最大深度，记为 `rightDepth`。
  - **处理当前节点 (Process Current Node)**:
    - **更新直径**: 计算穿过当前节点的路径长度 `currentDiameter = leftDepth + rightDepth`。然后更新全局最大值 `maxDiameter = Math.max(maxDiameter, currentDiameter)`。
    - **返回深度**: 根据深度的定义，以当前节点为根的子树的深度是 `1 + Math.max(leftDepth, rightDepth)`。将这个值返回给上一层调用。

**启动与返回**: 在主函数中，调用 `depth(root)` 来启动整个递归过程。递归结束后，`maxDiameter` 中就保存了最终结果，返回它即可。

#### 实现代码

```Java
 //求二叉树的直径的长度
 //直径是二叉树中最长的路径，这条路径可能经过根节点，也可能不经过根节点
 //路径的长度是指路径两个端点之间的边的数量
 //求每个子树的左右子树的最大高度，该节点的直径就是左子树的最大高度+右子树的最大高度
class Solution {
    int diameter = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return diameter;
    }

    private int depth(TreeNode node){
        if(node == null) return 0;
        //计算左子树的深度
        int leftDepth = depth(node.left);
        //计算右子树的深度
        int rightDepth = depth(node.right);
        //更新最大直径
        diameter = Math.max(diameter, leftDepth + rightDepth);
        //返回当前树的高度
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

#### 注意事项

**路径长度与节点数**: 题目要求的是**边的数量**。我们计算的 `leftDepth + rightDepth` 正好是穿过当前节点的路径上的边数，无需转换。例如，左边一条边（深度1），右边两条边（深度2），总路径是3条边。

**全局变量的使用**: 在Java中，由于基本类型是按值传递的，递归函数无法直接修改上层函数栈中的 `maxDiameter` 变量。因此，通常将其设为成员变量（如本例），或者使用一个长度为1的数组 `int[]` 或其他可变对象来传递引用。

**后序遍历的本质**: 请务必理解代码中 `maxDiameter` 的更新发生在 `depth(node.left)` 和 `depth(node.right)` 调用**之后**，这体现了后序遍历的核心思想：处理完子问题后，再处理当前节点的问题。

**深度与高度**: 在这个问题中，我们将叶子节点的深度定义为1，空节点的深度定义为0。这个定义可以根据习惯调整（比如高度从0开始），但只要在计算中保持一致，结果就是正确的。这里的定义 `1 + max(...)` 是最直观且最常见的。

#### 经验总结

**一题多解，举一反三**: LeetCode 543 是一个典型的树形问题，其解法思想可以应用于许多其他问题，例如：

- LeetCode 124. 二叉树中的最大路径和 (Binary Tree Maximum Path Sum) - 思路极其相似，只是从计算深度和变成了计算路径和。
- LeetCode 687. 最长同值路径 (Longest Univalue Path) - 同样是在递归中同时返回值和更新全局变量。

**识别递归的双重任务**: 当你发现一个树的问题，需要的信息（如深度、子树和）和最终要求解的目标（如直径、最大路径和）不完全一致时，就要考虑使用这种“**递归函数返回A，顺便更新全局变量B**”的套路。这是一个非常强大且通用的技巧。

**不要陷入局部最优**: 要时刻提醒自己，全局最优解（整棵树的直径）不一定和根节点的局部最优解（穿过根的路径）是一回事。解决方案必须能覆盖所有节点，确保找到真正的全局最优。我们的算法通过遍历每个节点并将其作为潜在的“拐点”来计算路径，保证了这一点。

#判断结构

###Leetcode 110: 判断一颗二叉树是否是平衡树

#### 问题描述

给定一个二叉树，判断它是否是高度平衡的。

对于本题，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1

#### 问题要点

##### 平衡的定义 - 树中每一个节点的左右子树高度差都不超过1

**不是指根节点的左右子树高度差**，而是指**树中每一个节点**的左右子树高度差都不超过1。

上面的问题是我容易犯的错误。

##### 递归性

这个定义天然具有递归性。一棵树是平衡的，当且仅当：

- 它的左子树是平衡的。
- 它的右子树是平衡的。
- 它自身的左右子树高度差不超过1。

##### 高度的计算 - 需要一个计算高度的方法

树的高度定义为从根节点到最远叶子节点的最长路径上的节点数。

`1 + max(left_height,right_height)`，空树的高度通常认为是0

#### 问题的本质 - 收集子树的高度来判断当前节点的平衡性

##### 自顶向下的思路

个直接但效率不高的思路是“自顶向下”（Top-down）：

1. 判断根节点是否平衡：
   - 计算左子树的高度 `h_left`。
   - 计算右子树的高度 `h_right`。
   - 检查 `abs(h_left - h_right) <= 1` 是否成立。
2. 如果成立，再递归地去判断左子树 `isBalanced(root.left)` 和右子树 `isBalanced(root.right)` 是否都为平衡二叉树。

##### 自顶向下的方式效率低下

当我们计算当前节点的高度时，会遍历其所有子节点。

而在递归判断子节点是否平衡时，又会重复计算其子孙节点的高度。

例如，计算根节点高度时已经遍历了整个树，之后又要对 `root.left` 再次遍历以判断其平衡性，存在大量的重复计算。

其时间复杂度最坏情况下（链状树）为 $O(N^2)$，最优情况下（完全二叉树）为 $O(NlogN)$。

#####自底向上的方法

为了优化，我们需要一种方法，在一次遍历中既能得到子树的高度，又能知道子树是否平衡。

这就引出了更优的“自底向上”（Bottom-up）的解法。

#### 模式匹配

##### 深度优先搜索

问题的定义本身就是递归的，因此很自然地想到使用递归来解决。

##### 后序遍历 - 解决问题的关键套路

这是解决此类问题的关键套路。

想一想，为了判断当前节点 `node` 是否平衡，你需要先知道它的左子树和右子树的信息（即它们的高度和它们本身是否平衡）。

这种**先处理子节点，再根据子节点的信息处理父节点**的模式，正是后序遍历（左 -> 右 -> 根）的核心思想。

####核心思想与套路 - DFS后序遍历

核心思想是采用**自底向上(Bottom-up)的后序遍历**。

我们不对每个节点重复计算高度，而是在计算高度的过程中就进行平衡性检查。

##### 核心思想

###### 检查左右子树是否平衡

创建一个递归辅助函数，比如`checkHeight(node)`:

- 如果以`node`为根的子树是**平衡**的，返回该子树的真实高度
- 如果以`node`为根的子树是**不平衡**的，则返回一个特殊标记`-1`，表示此路不同，已经发现不平衡了

###### 计算当前树是否平衡

在接下来的遍历过程中，对于当前节点`curr`:

- 我们先递归调用 `checkHeight(curr.left)` 和 `checkHeight(curr.right)` 获取左右子树的结果。
- 拿到结果后，首先检查它们是否为 `-1`。只要有一个是 `-1`，就意味着子树已经不平衡了，那么整棵树也就不可能平衡，我们立即向上返回 `-1`，这个 `-1` 会像一个中断信号一样一直传递到顶层。
- 如果左右子树都是平衡的（返回值都不是`-1`），我们再比较它们的高度差。如果高度差大于1，说明当前节点 `curr` 破坏了平衡，我们同样返回 `-1`。
- 如果当前节点也满足平衡条件，我们就返回它真实的高度 `1 + max(left_height, right_height)`，供上层节点使用。

通过这种方式，我们只对每个节点访问一次，就完成了高度计算和平衡性检查两项任务。

#### 实现原理

#####**主函数 `isBalanced(root)`**：

- 调用辅助函数 `checkHeight(root)`。
- 判断辅助函数的返回值。如果它不等于 `-1`，说明整棵树都是平衡的，返回 `true`。否则，返回 `false`。

#####**辅助函数 `checkHeight(TreeNode node)`**：

- **Base Case (递归出口)**：如果 `node` 为 `null`，表示空树。空树是平衡的，其高度为 `0`。所以返回 `0`。
- **递归下降 (后序遍历)**：
  - 调用 `leftHeight = checkHeight(node.left)` 递归处理左子树。
  - **剪枝**：如果 `leftHeight == -1`，说明左子树已经不平衡，无需继续，直接返回 `-1`。
  - 调用 `rightHeight = checkHeight(node.right)` 递归处理右子树。
  - **剪枝**：如果 `rightHeight == -1`，说明右子树已经不平衡，无需继续，直接返回 `-1`。
- **处理当前节点**：
  - 检查当前节点的平衡性：`if (Math.abs(leftHeight - rightHeight) > 1)`，如果不平衡，返回 `-1`。
  - 如果平衡，计算并返回当前节点的高度：`return 1 + Math.max(leftHeight, rightHeight)`。

####代码套路模板

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }
    //计算二叉树的高度
    //如果不平衡返回-1
    //如果平衡，返回树的真实高度
    private int height(TreeNode node){
        if(node == null) return 0;
        //计算左子树的高度
        int leftHeight = height(node.left);
        //计算右子树的高度
        int rightHeight = height(node.right);
        //如果左子树或者右子树不平衡，返回-1
        if(leftHeight == -1 || rightHeight == -1) return -1;
        //如果左子树和右子树的高度差大于1，返回-1
        if(Math.abs(leftHeight - rightHeight) > 1) return -1;
        //返回当前树的高度差
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

###Leetcode 101: 判断二叉树是否对称

判断二叉树是否对称，即左右子树是镜像关系。

##### 核心思想和套路 - DFS

使用 **DFS**，递归判断左右子树是否互为镜像。

##### 难点分析和应对

递归比较节点时，需要考虑对称的镜像性质。

##### 实现代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        if(root.left == null && root.right == null){
            return true;
        }
        return isSymmetric(root.left,root.right);
    }

    private boolean isSymmetric(TreeNode p, TreeNode q){
        if(p == null && q == null) return true;
        if(p== null && q != null){
            return false;
        }
        if(p != null && q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return isSymmetric(p.left,q.right) && isSymmetric(p.right,q.left);
    }
}
```

###Leetcode 100 : 判断两颗二叉树是否相同

判断两棵二叉树是否完全相同，节点结构和节点值都要相同。

##### 核心思想 - DFS（前序遍历）

使用DFS，递归判断左右子树是否相同

##### 难点分析与应对

递归过程中，节点值和子树结构需要完全匹配

##### 代码套路模板

```java
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p== null && q != null){
            return false;
        }
        if(p != null && q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
```

#路径类

##求二叉树的路径和

###Leetcode 124: 求二叉树中的最大路径和

#### 问题要点

#####路径 (Path) 的定义：

路径被定义为从树中任意节点开始，沿着父-子连接，达到任意节点的序列。

#####路径的灵活性 - 任意节点开始任意节点结束

- 路径**不一定**需要经过根节点。
- 路径可以**从任意节点开始，到任意节点**结束。
- 路径中每个节点最多只能出现一次。
- 路径至少包含一个节点。

#####节点值 (Node Values) - 可能是负数

节点的值可能是正数、负数或零。这一点非常重要，因为它意味着我们可能需要“放弃”某些子树的路径来获得更大的和。

##### 目标 - 路径最大和

找到所有可能的路径中，路径和最大的是多少。

#### 问题的本质和分析 - 最大路径可能出现在任何位置

这个问题的核心难点在于，最大路径可能出现在树的任何位置。

##### 以某个节点为拐点的路径

对于任意一个节点 `node`，以它为“拐点”或“最高点”的路径是什么样的？

这条路径会包含 `node` 本身，并可能连接其左子树中的一条向下的路径和右子树中的一条向下的路径。

这条路径形如一个“拱形” (arch) 或者倒 'V' 形。

##### 最大路径可能存在于左子树或者右子树中

最大路径也可能完全存在于 `node` 的左子树中，或者完全存在于 `node` 的右子树中，而与 `node` 本身无关。

这种结构天然地指向了**递归**。

我们可以对每个节点进行分析，计算出穿过它的最大路径和，并在所有节点的计算结果中取一个全局最大值。

##### 给自己计算的值和返回给父节点的值不一致

这就引出了一个核心矛盾：

- **对于当前节点 `node`**：我们想计算 `node.val + (来自左子树的贡献) + (来自右子树的贡献)`，这个值可能成为全局最大路径和。
- **对于 `node` 的父节点**：它不关心以 `node` 为拐点的“拱形”路径。它只关心从 `node` 出发，**单向往下**延伸能提供的最大路径和（即 `node.val + max(左子树贡献, 右子树贡献)`），因为只有这样的单向路径才能和父节点连接起来，继续向上延伸。

这个“为自己计算的值”和“向上返回给父节点的值”不一致，是解决本题的关键。

#### 套路模式匹配

##### 深度优先搜索

问题结构具有递归性，对一个树的操作可以分解为对左右子树的相同操作。

##### 后序遍历

在处理当前节点之前，我们必须先知道其左、右子树能提供的信息（即从左右子树出发向下的最大路径和）。这正是后序遍历的特点（左 -> 右 -> 根）。

##### 全局变量 VS 递归返回值 - 非常经典的模式

这是一个非常经典的模式。递归函数本身返回一个值（给上一层递归调用使用），同时在递归过程中更新一个全局变量（用于记录整个过程中的最优解）。

- **全局变量**：记录全局的最大路径和。
- **递归返回值**：记录从当前节点出发向下的“单边”最大路径和。

#### 核心思想与套路

我们的核心策略是设计一个递归函数，例如 `maxGain(node)`，并维护一个全局变量 `maxSum`。

##### 全局变量 - 维护最大路径和

它负责记录到目前为止发现的全局最大路径和。

在遍历每个节点时，我们都会计算以该节点为“拐点”的路径和，并用这个值来尝试更新 `maxSum`。

初始化为 `Integer.MIN_VALUE`，因为最大路径和可能是负数。

##### 递归函数（maxGain(node)）

**定义**：该函数计算并返回从 `node` 节点开始，**向下延伸的单边最大路径和**。这个路径要么进入左子树，要么进入右子树，不能同时进入。

**作用**：这个返回值是提供给 `node` 的父节点使用的。

**计算过程：**

- 计算左子树最大深度：`leftGain = Math.max(0, maxGain(node.left))`
- 计算右子树最大深度：`rightGain = Math.max(0, maxGain(node.right))`
- 更新最大路径值： `maxSum = Math.max(maxSum, node.val + leftGain + rightGain)`
- 返回最大深度：Return value for parent: `return node.val + Math.max(leftGain, rightGain)`

#### 实现原理和步骤

##### 主函数流程

- **初始化**：在主函数 `maxPathSum` 中，声明一个成员变量或一个单元素数组 `maxSum`，并将其初始化为 `Integer.MIN_VALUE`。

- **调用递归**：从 `root` 节点开始调用递归辅助函数 `maxGain(root)`。

- **返回结果**：递归结束后，`maxSum` 中存储的就是最终答案，返回 `maxSum`。

#####辅助函数**`maxGain(TreeNode node)` 辅助函数的详细步骤：**

1. **处理基线条件 (Base Case)**：如果 `node` 为 `null`，返回 0。
2. **递归计算左右子树**：
   - `int leftGain = Math.max(0, maxGain(node.left));`
   - `int rightGain = Math.max(0, maxGain(node.right));`
   - 这里使用 `Math.max(0, ...)` 是为了剪枝。如果子树的单边路径和为负，则不采纳它，视其贡献为 0。
3. **更新全局最大路径和**：
   - 计算以当前 `node` 为“拐点”的路径和：`int currentPathSum = node.val + leftGain + rightGain;`
   - `maxSum = Math.max(maxSum, currentPathSum);`
4. **返回单边最大路径和**：
   - 向父节点返回从当前 `node` 向下延伸的单边最大路径和。
   - `return node.val + Math.max(leftGain, rightGain);`

#### 实现代码

```Java
class Solution {
    //初始化为最小值，因为可能有负数路径
    int maxPathSum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxPathSum;
    }

    private int maxGain(TreeNode node){
        if(node == null) return 0;
        //排除负数路径，使用Math.max(0,maxGain(node.left))
        int leftGain = Math.max(0,maxGain(node.left));

        int rightGain = Math.max(0, maxGain(node.right));
        //计算当前路径和
        int pathSum = leftGain + rightGain + node.val;
        //更新最大路径和
        maxPathSum = Math.max(pathSum, maxPathSum);
        //返回当前子树深度和
        return Math.max(leftGain,rightGain) + node.val;
    }
    
}
```

#### 注意事项

- **`maxSum` 的初始化**：必须是 `Integer.MIN_VALUE`，而不是 0。因为树中可能全是负数节点，这种情况下最大路径和就是一个负数。例如，对于只有一个节点 `[-3]` 的树，答案是 `-3`。

- **`max(0, ...)` 的使用**：这是算法的精髓之一。它体现了“如果一条路是亏钱的（路径和为负），那我就不走”的思想，即剪枝。

- **区分全局更新和返回值**：一定要清晰地区分 `maxSum = max(maxSum, node.val + leftGain + rightGain)` 和 `return node.val + max(leftGain, rightGain)`。前者是尝试更新最终答案，后者是为递归的上一层提供计算材料。这是两个完全不同的目的。

- **路径的定义理解**：要反复确认自己理解了“任意节点到任意节点”的含义。我们的算法之所以正确，就是因为它隐式地在以每个节点为路径“最高点”的情况下都计算了一遍，从而覆盖了所有可能性。

#### 经验总结

- **识别模式是关键**：当你遇到一个需要在树中找最优解（最大/最小/最长等）且这个最优解不一定与根节点有关的问题时，就要立刻想到“全局变量 + 递归辅助函数”这个模式。

- **明确递归函数的语义**：在动手写代码前，一定要用一句话清晰地定义你的递归函数是做什么的，它的输入是什么，输出（返回值）代表什么。对于本题，`maxGain(node)` 的定义就是“返回以 `node` 为起点，向下延伸的单边最大路径和”。定义清晰了，代码的逻辑自然就清晰了。

- **分解问题**：将一个复杂的问题（全局最大路径）分解成在每个节点上的两个小问题：

  1. 以我为根的子问题，对我自己（全局 `maxSum`）的贡献是什么？

  1. 我能为我的父节点提供什么价值（返回值）？

- **画图模拟**：对于复杂的树问题，拿一个例子，在纸上画出递归的调用栈和每个节点的计算、更新、返回过程，可以极大地帮助理解算法的执行流程。

###判断路径和是否等于目标值

判断从根到叶的路径和是否等于目标值

####核心思想与套路 - DFS

使用DFS，递归遍历每条路径并累加路径

####难点分析和应对

需要确保路径的累加值不出错

####代码模板

```java
public boolean hasPathSum(TreeNode root, int sum){
  if (root == null) return false;
  if (root.left == null && root.right == null){
    return root.val == sum;
  }
  return hasPathSum(root.left,sum - root.val)
    || hasPathSum(root.right, sum = root.val);
}
```

### Leetcode 113:列举所有路径和为Target的路径[中序+回溯]

#### 一个错误的解实现

```
 //回溯+先序遍历
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path, targetSum);
        return res;
    }

    private void backtrack(TreeNode node, List<Integer> path, int currentTargetSum){
        if(currentTargetSum == 0 && node == null){
            res.add(new ArrayList<>(path));
            return;
        }
        if(node == null){
            return;
        }

        int newCurrentTarget = currentTargetSum - node.val;
        path.add(node.val);
        backtrack(node.left, path, newCurrentTarget);
        backtrack(node.right, path, newCurrentTarget);
        path.remove(path.size() - 1);
    }
}
```

现在来说错在哪里了？

#####回溯算法上两个最关键的节点

######终止条件(Base Case): 什么时候此路不通或者走到头了？

回溯算法本质上是在一个“决策树”上进行深度优先搜索（DFS）。

终止条件就是告诉程序什么时候应该停止向下探索，然后返回上一层。

在你的代码里，`if(node == null)` 就是一个正确的终止条件。

因为在树的遍历中，走到 `null` 节点就意味着这条分支到头了，必须返回。

###### 关键的错误：混淆了找到了一个解和搜索到终点的两种情况

`if(currentTargetSum == 0 && node == null)` 这个条件试图把“找到解”和“分支结束”合二为一，但它的逻辑是：“当我们走过一个节点，发现路径和对了，并且下一步是 `null` 时，就算成功”。

这显然是错的，因为成功的判断点应该是节点本身，而不是它下面的 `null`。

**思考诀窍**：问自己，“对于当前的节点/状态，我还能往下走吗？” 如果不能（比如节点为 `null`，或者数组越界），那就应该 `return`。这是最纯粹的终止条件。

##### 回溯算法的两种视角 

###### 方式一：做选择的视角：站在当前节点，决定下一步要走哪

这种方式通常适用于排列组合等场景。

这种方式我们称之为**站在当前节点，决定下一步要走哪**。

这就像你站在一个十字路口，前面有几条路（选项）。

你的思考过程是：

- **遍历所有选项：**查看所有可走的路
- **做出选择：**选中其中一条路，然后**把这条路（选项）加入到你的路径记录中**
- **前进:**沿着这条路走到下一个路口（递归调用）
- **回溯：**从下一个路口回来后，把刚刚那条路从你的路径记录中划掉，然后尝试其他的路。

用代码来描述这个过程，通常会有一个** `for` 循环**：

```Java
void backtrack(当前路径, 其他状态参数) {
    // ----------------------------------------------------
    // 1. 终止条件 (成功找到解)
    // ----------------------------------------------------
    // 这是算法正确性的基础。
    if (当前路径已经构成一个完整的解) {
        res.add(new ArrayList<>(path)); // 收集结果
        return;
    }

    // ----------------------------------------------------
    // 2. 终止条件 (当前路径已不可能构成解 -> 剪枝)
    // ----------------------------------------------------
    // 这个检查点是可选的，用于优化。它判断整个当前路径是否已经“跑偏”了。
    if (当前路径已确定无法通向任何有效解) {
        return; // 提前返回，砍掉整个无效分支
    }

    // ----------------------------------------------------
    // 3. 循环遍历所有“原始”选项
    // ----------------------------------------------------
    for (选项 item : 所有选项列表) {
        // ------------------------------------------------
        // 4. 剪枝 (跳过当前这个不合法的选项)
        // ------------------------------------------------
        // 这个检查点也是可选的，用于优化。它判断“当前这个选项”是否值得去尝试。
        if (选项 item 不合法或会产生重复) {
            continue; // 跳过这个选项，继续循环下一个
        }

        // 5. 做出选择
        // 将当前选项加入路径，并更新状态
        path.add(item);
        // ... 其他状态更新 (例如 used[i] = true)

        // 6. 递归
        // 进入下一层决策
        backtrack(更新后的路径, 更新后的状态参数);

        // 7. 撤销选择 (回溯)
        // 将刚才的选项从路径中移除，并恢复状态，以便下一次循环
        path.remove(path.size() - 1);
        // ... 其他状态恢复 (例如 used[i] = false)
    }
}
```

**关键点**：`add` 和 `remove` 操作是**围绕着递归调用**的，通常在 `for` 循环内部。我们添加的是“下一步的选择”。

###### 方式二：走路径的视角：到达了一个新节点，先记录下来

更直观，常见于树和图的深度优先搜索。

这种方式我们称之为 **“到达了一个新节点，先记录下来”**。

这就像你已经在探索一条路了，每次到达一个新的城市以后，你做的第一件事：

- **记录当前位置：**拿出地图，在当前的城市画个圈
- **判断状态：**看看这个城市是不是你的目的地
- **探索前方：**看看从这个城市除法，有哪些路可以走，然后沿这些路继续前进
- **离开此地：** 当你从这个城市出发的所有路径都探索完并返回后，说明这个城市对你没用了。你在地图上将刚刚画的圈擦掉，然后

在 Path Sum II 问题中看到的实现：

```Java
// 伪代码：树的路径问题
void backtrack(当前节点) {
    if (当前节点 == null) return; // 此路不通

    // 1. 记录当前位置 (把当前节点加入路径)
    path.add(当前节点.val);

    // 2. 判断状态
    if (当前节点是叶子 && 满足路径和条件) {
        res.add(new ArrayList<>(path));
        // 注意：这里不能直接return，因为还需要执行最后的remove操作
    }

    // 3. 探索前方
    backtrack(当前节点.left);
    backtrack(当前节点.right);

    // 4. 离开此地 (撤销选择)
    path.remove(path.size() - 1);
}
```

###### 两种方法的总结 - 基于当前节点

我们将当前地点成为当前节点，选项点成为选项

- 方法一：选项节点加入path
  - 判断路径是否满足条件，**满足条件加入结果，并返回**
  - 判断是否满足终止条件，满足则返回
  - 对于当前位置的**下一批选项中的每一个选项**
    - 查看**选项**是否合法或者可能造成重复，不合法continue
    - 将**选项**加入path
    - 递归调用选项
    - 回溯**选项节点**：从path中删除选项节点
- 方法二： 当前节点加入Path
  - 先判断**当前节点是**否达到终止条件，到达终止个条件返回
  - **当前节点**加入path
  - 判断路径是否满足条件，**满足条件了加入结果，但是不要返回**
  - 递归调用**子节点**
  - 回溯**当前节点**：从path中删除当前节点

###### 收集结果： 什么时候“Bingo！找到一个答案了”？

这是回溯算法的另一个核心，也是你代码出错的关键。**收集结果的判断，必须与题目要求的目标状态完全匹配。**

对于 LeetCode 113，目标状态是什么？

- 条件A：当前节点必须是 **叶子节点** (`node.left == null && node.right == null`)。
- 条件B：从根到 **当前这个叶子节点** 的路径和，必须等于 `targetSum`。

这两个条件必须同时满足，才能把当前路径 `path` 加入最终结果 `res`。

**你的错误在于：**

1. **判断时机过早/过晚**：你在 `node == null` 的时候判断，时机太晚了，已经走过了叶子节点。
2. **判断条件不完整**：你只判断了 `sum`，完全忽略了“必须是叶子节点”这个至关重要的约束。

**思考诀竅**：在递归函数的开头，紧接着处理完终止条件之后，就应该问自己：“当前的状态（节点、路径、剩余值等），是否已经构成了一个符合题目要求的完整解？” 如果是，就把当前路径的**一个拷贝** (`new ArrayList<>(path)`) 存入结果集。

####正确的实现

```Java

class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, targetSum, path);
        return res;
    }

    private void backtrack(TreeNode node, int targetSum, List<Integer> path){
      //1.判断当前节点是否满足终止条件
        if(node == null) return;
        //2. 将当前节点加入path
        path.add(node.val);
      //3.判断当前path是否满足条件
        if(targetSum == node.val && node.left == null && node.right == null){
          //满足条件则加入结果集，但是不要return
            res.add(new ArrayList<>(path));
            // return; 这里不能执行return， 因为还需要执行最后的remove操作
        }
				//4. 递归调用子节点
        backtrack(node.left, targetSum - node.val, path);
        backtrack(node.right, targetSum - node.val, path);
				//5. 回溯当前节点
        path.remove(path.size() - 1);
    }
}
```



### Leetcode: 列举二叉树中所有的从根节点到叶子节点的路径

#### 问题要点

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

####核心思想 - 基于当前节点的回溯算法

使用上述方法二中，基于当前节点的回溯方法

- 判断当前节点是否满足终止条件，满足则返回
- 将当前节点加入路径
- 判断路径是否满足条件，若满足则加入结果，但是不返回
- 递归调用子节点
- 回溯当前节点，将当前节点从路径中删除

#### 实现代码

```Java
 //DFS 回溯
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path);
        return res;

    }

    private void backtrack(TreeNode node, List<Integer> path){
        if(node == null){
            return;
        }
        path.add(node.val);
        if(node.left == null && node.right == null){
            String result = path.stream()
                            .map(String::valueOf)
                            .collect(Collectors.joining("->"));
            res.add(result);
            //不要return
        }
        backtrack(node.left, path);
        backtrack(node.right, path);

        path.remove(path.size() - 1);
    }


}
```

###Leetcode 1372:求二叉树中最长的Z形路径

#### 问题要点

给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。

请你返回给定树中最长 **交错路径** 的长度。

####问题本质和分析

- 锯齿路径从树的**任意节点**开始，每次交替方向，左 -> 右 或 右 -> 左。

- 路径的长度是指**从一个节点到达另一个节点所经过的边数**。

- 路径的方向**必须交替**，即从一个节点到下一个节点时，**必须沿着不同的子树（左或右）移动**。

- 本题是典型的**二叉树深度优先遍历（DFS）**题目。
- 深度优先遍历需要通过递归来搜索树的所有路径，记录当前的路径长度，并对路径的方向进行判断。

#### 模式套路匹配

这个问题非常符合**树的深度优先搜索 (DFS)** 或**树形动态规划 (Tree DP)** 的模式。

##### 深度优先搜索

我们需要遍历树中的每一个节点。

对于每个节点，我们需要根据其子节点的信息来计算某些值。

递归（DFS）是解决这类问题的最自然、最直接的方法。

函数的返回值或参数需要携带额外的信息来帮助父节点做决策。

##### 后序遍历思想

子问题的解（子树中的最长交错路径信息）可以用来构建父问题的解。

具体来说，一个节点的左子树向右延续的交错路径长度，可以用来计算当前节点向左走能得到的交错路径长度。

这体现了动态规划中“最优子结构”的思想。

我们可以定义一个递归函数 `dfs(node)`，它不仅要处理子树，还需要返回一些信息给调用者。具体来说，它需要返回从 `node` 出发，分别向左和向右走的最长交错路径长度。

#### 核心思想与套路

##### 定义递归函数的契约

首先，明确你的DFS递归函数是用来做什么的。

我们的 `dfs(node, length, isLeft)` 的契约（contract）就是： **“探索从 `node` 节点出发的所有可能性，并假设到达 `node` 的交错路径长度为 `length`，且这一步是通过 `isLeft` 方向完成的。”**

##### 延续当前路径或者重启一个新路径

这是整个套路最关键的一步。

当你站在一个节点上，你有两个孩子节点可以选择。

对于每一个选择，你都要考虑两种可能性：

###### 延续当前路径

如果这个选择的方向与你来的方向**相反**，那么恭喜你，交错路径得以延续。

- **操作**: 路径长度 `length + 1`，同时**翻转**方向标志，然后继续递归。
- *例如：从左边来的 (`isLeft == true`)，那么选择右孩子就是延续路径。*

###### 重启一个新的路径

如果这个选择的方向与你来的方向**相同**，那么抱歉，交错路径中断了。

但没关系，我们可以从这里开启一段**全新的交错路径**。

- **操作**: 路径长度**重置为 1**，并将方向标志设为**当前选择的方向**，然后继续递归。

- *例如：从左边来的 (`isLeft == true`)，你还选择左孩子，那么这就是一条长度为1的新路径的开始。*

通过在每个节点的左右两个方向上都执行这个“延续或重启”的判断，我们就能确保**不漏掉任何一条可能的交错路径**。

这个“重启”操作，天然地覆盖了“最长路径可以从任意节点开始”这个题目要求。

##### 使用全局变量实时打擂 - 最大值和最小值的常见套路

对于寻找“最大/最小”值的问题，一个常见的套路就是设置一个全局变量（如 `maxLength`），在遍历的每一步都进行“打擂台”式的更新。

- **更新时机**: 在递归函数的入口处，就用当前传入的 `length` 来更新 `maxLength`。
- **原因**: 因为到达当前节点的这条长度为 `length` 的路径本身就是一条完整的、有效的交错路径。最长的路径可能在这里就结束了，不一定非要走到叶子节点。所以每走一步，都要回头看看自己刚走过的路是不是已经创造了新纪录。

##### 总结：DFS + （延续/重启二元决策） + 全局变量

这个模式不仅适用于本题，也广泛适用于其他需要在树中寻找满足特定“历史路径”限制条件的题目，例如“寻找路径总和等于某值的路径”、“寻找最长同值路径”等。它将复杂的路径约束问题，简化为了在每个节点上基于“历史状态”的简单、局部决策。

####实现原理和步骤

##### 递归函数的设计：`dfs(node,length,isLeft)`

这个函数是整个算法的核心，它的三个参数定义了当前“行走”的状态：

- `TreeNode node`: 你现在站在哪个节点上。

- `int length`: 你走到当前这个节点，已经走了多远（路径长度）。

- `boolean isLeft`: 你是**如何到达**当前这个节点的？

  - `true`: 你是从父节点的**左边**走过来的。

  - `false`: 你是从父节点的**右边**走过来的。

##### 算法的启动

最长的交错路径可能从任何地方开始，我们的算法通过遍历所有节点和所有可能性来覆盖这一点。

- 我们无法从 `root` 节点“到达”它自己，所以真正的路径是从 `root` 的孩子开始的。
- `dfs(root.left, 1, true)`: 启动第一条探索路径。我们从 `root` 走到 `root.left`，这条路径长度为 **1**，并且它是通过**向左**走实现的。
- `dfs(root.right, 1, false)`: 启动第二条探索路径。我们从 `root` 走到 `root.right`，路径长度为 **1**，通过**向右**走实现。
- `maxLength` 初始为0，用来在整个探索过程中记录我们遇到的最长路径。

##### 递归过程中的决策

######先更新维护全局最大长度

在做任何决策以前，我们先用当前的路径长度`length`更新全局最大值。

这是因为**到达当前节点**本身就形成了一条有效的交错路径，它可能就是最长的那一条，所以不能错过。

`maxLength = Math.max(maxLength,length)`

###### 如果你是从左边过来的 

如果你是从左边来的，那么你现在是有两个选项：

- **继续交错 (Zig-Zag!):** 你必须向**右**走。我们调用 `dfs(node.right, length + 1, false)`。

  - `node.right`: 移动到右孩子。
  - `length + 1`: 路径长度加一。
  - `false`: 告诉下一个节点，你是从右边过来的。

- **打破规则重新开始：**如果你偏要向左走，那么交错路径就断了。

  不过没关系，从`node.left`这里可以开启一条**全新的路径**。

  这条全新路径的第一步是`node -> node.left`

  - `node.left`: 移动到左孩子。
  - `1`: 新路径的长度从1开始。
  - `true`: 告诉下一个节点，你是从左边过来的。

###### 如果你是从右边走过来的

逻辑完全对称。

1. **继续交错:** 必须向**左**走。调用 `dfs(node.left, length + 1, true)`。
2. **重新开始:** 如果向**右**走，则开启新路径。调用 `dfs(node.right, 1, false)`。

####实现代码

```java
class Solution {
    int maxLength = 0;

    public int longestZigZag(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 开启DFS，分别从根节点的左孩子和右孩子开始
        // 路径从 root->left 构成，长度为1，方向为“左”
        dfs(root.left, 1, true); 
        // 路径从 root->right 构成，长度为1，方向为“右”
        dfs(root.right, 1, false);
        return maxLength;
    }

    /**
     * 深度优先搜索
     * @param node 当前节点
     * @param length 到达当前节点时，已经形成的交错路径的长度
     * @param isLeft 一个布尔标记，true表示到达当前节点node的这一步是“向左”走的
     */
    private void dfs(TreeNode node, int length, boolean isLeft) {
        // 1. Base Case: 如果节点为空，路径结束
        if (node == null) {
            return;
        }

        // 2. 更新全局最大值
        //    一条有效的交错路径已经形成了（长度为length），尝试更新最大值
        maxLength = Math.max(maxLength, length);

        // 3. 核心递归逻辑：根据上一步的方向，决定下一步怎么走
        if (isLeft) {
            // 上一步是向左来的 (parent -> left -> node)
            // a) **延续路径**: 下一步必须向右走。
            //    路径长度增加1，方向变为“右”(false)
            dfs(node.right, length + 1, false);
            
            // b) **中断并重启路径**: 如果也从左边走，交错路径中断。
            //    从当前节点的左孩子开启一条全新的路径，长度为1，方向为“左”(true)
            dfs(node.left, 1, true);
        } else { // 上一步是向右来的 (parent -> right -> node)
            // a) **延续路径**: 下一步必须向左走。
            //    路径长度增加1，方向变为“左”(true)
            dfs(node.left, length + 1, true);
            
            // b) **中断并重启路径**: 如果也从右边走，交错路径中断。
            //    从当前节点的右孩子开启一条全新的路径，长度为1，方向为“右”(false)
            dfs(node.right, 1, false);
        }
    }
}
```

#### 注意事项

##### 路径长度的正确定义

题目要求的是“边的数量”。

我们的算法逻辑——延续路径时 `length + 1`，重启路径时设为 `1`——完全符合这个定义。

这是一个常见的细节陷阱，**如果误解为节点数量，会导致结果偏差1**。

##### 状态参数的清晰定义

`dfs(node, length, isLeft)` 中，布尔标志 `isLeft` 的含义必须非常清晰且在整个递归中保持一致。

我们将其定义为“**到达当前 `node` 的上一步**是向左走的”。

混淆其含义（例如，误解为“下一步应该向左走”）是导致逻辑错误的主要原因。

##### 全局最大值的更新时机

`maxLength` 必须在递归函数的**入口处**立即更新。

因为一条长度为 `length` 的有效路径在调用 `dfs(node, length, ...)` 时已经形成。

最长路径完全可能在树的中间节点结束，而不是在叶子节点。

如果只在 `node == null` 时更新，就会遗漏所有非叶子节点结尾的最长路径。

##### 递归的正确启动

真正的交错路径是**从根节点的子节点**开始计算的。

因此，主函数中需要分别从 `root.left` 和 `root.right` 启动DFS，并将初始长度设为 `1`，同时正确设置初始方向。

这是将问题从抽象的“树”转化为具体的“第一步路径”的关键。

##### 重启逻辑的重要性

在递归中，除了“延续”路径，另一个分支“重启”路径（即`dfs(..., 1, ...)`）至关重要。

它不仅是处理交错中断的情况，更重要的是，它隐式地实现了“**从树中任意节点开始**”这一要求。

每当路径中断并重启时，就相当于将当前节点视为一个新的起始点，从而保证了对所有可能路径的完全覆盖。

#### 经验总结

#####**识别信息流方向：**前序或者后序

**选择前序或后序遍历 (Pre-order vs. Post-order)** 这是解决所有树路径问题的核心决策点。

- **前序遍历 (参数传递，Top-Down)**: 当一个节点的决策依赖于**从根到它的路径信息**时（如本题的方向、到此的路径和、当前深度），应选择前序遍历。将状态作为参数自顶向下传递，逻辑清晰直接。
- **后序遍历 (返回值，Bottom-Up)**: 当一个节点的决策依赖于其**左右子树的计算结果**时（如子树高度、子树节点数、左右子树的最大路径），应选择后序遍历。让子节点将信息汇总返回给父节点。

##### 将路径问题转化为状态机

这个解法本质上是把树的遍历看作一个状态机。

递归函数 `dfs(node, length, isLeft)` 就是这个状态机，它的参数定义了所有必要的状态。

每一步递归调用，都是一次状态转移。

这个思想可以把一个看似宏大的问题，分解为在每个节点上进行的、定义清晰的局部状态转移，极大地降低了心智负担。

##### 掌握延续/重启的通用模式

在处理带约束的路径问题时，“延续或重启”是一个非常强大的子模式。在每个节点做决策时，主动思考两种可能性：

- 如何操作才能**满足约束**，并延续当前状态？ (`length + 1`)
- 如果**违反约束**，应该如何处理？通常是重置状态，开启一个新的计数。 (`length = 1`) 这个模式确保了算法的完备性。

##### 代码即思想

参数传递式的DFS写法，其代码结构几乎就是我们思考问题时的“内心独白”：“我现在在`node`，我是从`isLeft`方向走了`length`步过来的。

下一步，如果我走右边，就是延续；如果我走左边，就是重启...”。

让代码逻辑与思考过程同步，是写出优雅、不易错代码的关键。

###Leetcode 988: 从叶结点开始的最小字符串 

###### 问题要点

给定一个二叉树，每个节点的值是一个 `0` 到 `25` 之间的整数，分别对应字母 `'a'` 到 `'z'`。

我们需要从**叶子节点**开始，向上到**根节点**，形成一个字符串。在所有可能的从叶子到根的路径中，找到字典序最小的那个字符串。

**示例**

假设树的结构如下，节点中的数字代表其值：

```java
    0 (a)
   / \
  1 (b) 2 (c)
 / \   / \
3 (d) 4 (e) 5 (f) 6 (g)
```

- 从叶子节点 `d` (3) 到根节点 `a` (0) 的路径是 `d -> b -> a`，形成的字符串是 "dba"。
- 从叶子节点 `e` (4) 到根节点 `a` (0) 的路径是 `e -> b -> a`，形成的字符串是 "eba"。
- 从叶子节点 `f` (5) 到根节点 `a` (0) 的路径是 `f -> c -> a`，形成的字符串是 "fca"。
- 从叶子节点 `g` (6) 到根节点 `a` (0) 的路径是 `g -> c -> a`，形成的字符串是 "gca"。

在 "dba", "eba", "fca", "gca" 中，字典序最小的是 "dba"。因此，函数应返回 "dba"。

###### 问题的本质和分析

此问题的核心在于两个操作的结合：

1. **遍历所有从根到叶的路径**: 为了构建从叶子到根的字符串，我们必须首先能够识别出树中所有的完整路径。
2. **字符串的构建与比较**: 在遍历过程中，我们需要按照“从叶到根”的顺序构建字符串，并持续追踪迄今为止找到的字典序最小的字符串。

一个常见的误区是试图自底向上（从叶子到根）进行遍历。然而，在标准的树结构中，节点只有指向子节点的指针，而没有指向父节点的指针，这使得自底向上的遍历非常困难。

因此，更自然的方法是采用**自顶向下**的遍历方式，例如深度优先搜索 (DFS)。

在从根向叶遍历的过程中，我们可以记录下路径上的节点。

当到达一个叶子节点时，我们就拥有了一条完整的从根到叶的路径。

此时，我们再将这条路径反转，即可得到题目所要求的“从叶到根”的字符串，然后进行比较。

###### 背景知识

**二叉树 (Binary Tree)**: 一种基础的数据结构，每个节点最多有两个子节点，通常称为左子节点和右子节点。

**深度优先搜索 (Depth-First Search, DFS)**: 一种用于遍历或搜索树或图的算法。

DFS 会沿着一条路径尽可能深地搜索，直到到达该路径的末端，然后回溯到上一个节点，继续探索其他未访问过的路径。

递归是实现DFS的常用且自然的方式。

**字典序 (Lexicographical Order)**: 也称为字母序或词典序，是一种基于字母表的排序方法。在比较两个字符串时，从第一个字符开始逐个比较。第一个出现差异的字符决定了两个字符串的顺序。例如，"apple" < "apply" 因为在第四个字符处 'l' < 'p'。在Java中，`String` 类的 `compareTo()` 方法就是用来进行字典序比较的。

###### 考察点

- **树的遍历**: 熟练掌握二叉树的深度优先搜索（DFS）遍历，特别是递归的实现方式。
- **递归思想**: 理解如何通过递归函数的参数来传递路径信息，以及递归的终止条件（基准情况）。
- **字符串操作**: 能够在遍历过程中高效地构建和比较字符串。
- **算法设计**: 能够将问题分解为“遍历路径”和“比较结果”两个子问题，并设计出正确的算法流程。

###### 模式匹配

这个问题符合一个非常经典的算法模式：**在树的所有根到叶路径中寻找最优解**。

这类问题的通用解法模式通常是：

1. 使用深度优先搜索（DFS）来遍历所有路径。
2. 在递归函数中，维护一个“当前状态”的变量（在本题中，即为当前路径形成的字符串）。
3. 当遍历到叶子节点时，意味着一条完整的路径已经形成。此时，根据问题要求处理这条路径的结果（在本题中，是与全局最小字符串进行比较和更新）。
4. 在递归回溯时，需要相应地恢复“当前状态”，以确保不影响对其他路径的遍历。

###### 核心思想和套路

核心思想是**使用深度优先搜索（DFS），在遍历的同时构建从当前节点到根的字符串**。

套路如下:

1. **定义一个全局变量或引用**：用于存储当前找到的最小字符串。

   可以初始化为一个字典序非常大的字符串，或者在找到第一个叶子路径时再进行初始化。

2. **设计一个递归辅助函数**：`dfs(TreeNode node, String currentString)`

   - `node`: 当前遍历到的节点。
   - `currentString`: 从根节点到 `node` 的**父节点**所形成的路径字符串（注意顺序）。

3. **递归逻辑**

   **处理当前节点**: 将当前节点的值对应的字母加到路径字符串的前面。

   因为我们是从根向下遍历，而题目要求从叶到根的顺序，所以在每一步都将新字符加在最前面，可以巧妙地在遍历结束时直接得到逆序的字符串。

   ```java
   char ch = (char) ('a' + node.val);
   String path = ch + currentString;
   ```

   **判断叶子节点 (基准情况)**: 如果当前节点是叶子节点（`node.left == null && node.right == null`），说明我们找到了一条完整的路径。

   - 将当前形成的路径字符串 `path` 与全局最小字符串进行比较。
   - 如果 `path` 更小，则更新全局最小字符串。
   - 递归终止，返回。

   **递归调用 (Recursive Step)**: 如果当前节点不是叶子节点，则对其非空的子节点继续进行DFS。

   - `if (node.left != null) dfs(node.left, path);`
   - `if (node.right != null) dfs(node.right, path);`

###### 实现原理和步骤

**主函数 `smallestFromLeaf`**:

- 创建一个成员变量 `smallestString`，并初始化为一个特殊值或 `null`。
- 调用递归辅助函数 `dfs`，从根节点开始，初始路径字符串为空字符串 `""`。
- 返回 `smallestString`。

**递归函数 `dfs(TreeNode node, String currentPath)`**:

- **参数**: `node` 是当前节点，`currentPath` 是从根到 `node` 父节点的路径（字符顺序是从叶到根）。
- **边界检查**: 如果 `node` 为 `null`，直接返回。
- **构建新路径**: 将当前节点的值 `(char)('a' + node.val)` 拼接到 `currentPath` 的**开头**，形成新的路径字符串 `newPath`。
- **叶子节点判断**: 检查 `node` 是否为叶子节点。
  - 如果是，则将 `newPath` 与全局的 `smallestString` 比较。
  - 如果 `smallestString` 尚未初始化或者 `newPath` 的字典序更小，则更新 `smallestString = newPath`。
- **继续遍历**: 对 `node` 的左子节点和右子节点（如果存在）递归调用 `dfs`，并传入 `newPath`。

###### 实现代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    String smallestString = null;

    public String smallestFromLeaf(TreeNode root) {
        if (root == null) {
            return "";
        }
        dfs(root, new StringBuilder());
        return smallestString;
    }

    private void dfs(TreeNode node, StringBuilder currentPath) {
        // 将当前节点的值对应的字符插入到路径的开头
        currentPath.insert(0, (char) ('a' + node.val));

        // 检查当前节点是否是叶子节点
        if (node.left == null && node.right == null) {
            String pathStr = currentPath.toString();
            // 如果是第一个找到的路径，或者当前路径字典序更小
            if (smallestString == null || pathStr.compareTo(smallestString) < 0) {
                smallestString = pathStr;
            }
        }

        // 递归访问子节点
        if (node.left != null) {
            dfs(node.left, currentPath);
        }
        if (node.right != null) {
            dfs(node.right, currentPath);
        }

        // 回溯：在返回到父节点之前，将当前节点添加的字符移除
        // 这样可以确保兄弟节点的路径计算不受影响
        currentPath.deleteCharAt(0);
    }
}
```

###### 注意事项

**字符串构建方向**: 题目要求是从叶子到根，而遍历是从根到叶子。务必在构建字符串时进行逆序处理，即每次将新字符加在字符串的**最前面**。

**全局最小值的初始化**: 全局最小字符串 `smallestString` 的初始值需要妥善处理。可以设为 `null`，在找到第一条路径时直接赋值；或者设为一个字典序上不可能出现的“最大”字符串（例如用 `~` 字符组成的字符串）。

**回溯 (Backtracking)**: 如果使用可变对象（如 `StringBuilder`）来传递路径状态，必须在递归返回后进行状态的回溯，以避免对其他分支的计算产生干扰。使用不可变的 `String` 可以简化代码，避免手动回溯。

**空树处理**: 注意处理根节点为 `null` 的边界情况。

###### 经验总结

LeetCode 988 是一个很好的练习题，它将树的遍历与具体的业务逻辑（字符串比较）结合在了一起。解决此问题的关键在于选择合适的遍历策略并正确处理路径的构建。

- **优先选择DFS**: 对于求解所有路径相关的问题，深度优先搜索通常是更直观和易于实现的选择。
- **理解递归中的状态传递**: 思考在递归调用中需要传递哪些信息来维持算法的正确性。在本题中，就是 `currentPath`。
- **注意可变与不可变对象**: 在递归中使用 `StringBuilder` (可变) vs `String` (不可变) 有着重要的区别。前者效率可能更高但需要手动回溯，后者代码更简洁但可能创建更多对象。在算法竞赛中，除非性能瓶颈非常明显，否则优先选择代码简洁、不易出错的方案。
- **触类旁通**: 掌握了这种“DFS + 路径追踪”的模式后，可以轻松解决一系列类似问题，例如 "路径总和 II" (Path Sum II, LeetCode 113)、"二叉树的所有路径" (Binary Tree Paths, LeetCode 257) 等。这些问题都遵循着相似的递归遍历和路径记录的解题范式。

#构建类问题

| 策略                              | 场景                 | 核心思想                               |
| --------------------------------- | -------------------- | -------------------------------------- |
| 1. 前序 + 中序 构造唯一二叉树     | Leetcode 105         | 前序确定根，中序划分左右子树           |
| 2. 后序 + 中序 构造唯一二叉树     | Leetcode 106         | 后序确定根，中序划分左右子树           |
| 3. 前序 + 后序 构造可能不唯一的树 | Leetcode 889         | 前序根 + 后序划分左右（带不确定性）    |
| 4. 层序构造                       | 自定义题、序列化场景 | 使用队列构造，逐层添加左右子节点       |
| 5. BST构建                        | Leetcode 1008 等     | 利用 BST 性质：左 < 根 < 右            |
| 6. 序列化 / 反序列化              | Leetcode 297/449     | 用特殊分隔符 + DFS/BFS 编码/解码树结构 |

#### 构建套路详解

####前序+中序构建唯一二叉树

###### 核心思想：前序确定根+中序确定边界

- 前序第一个一定是根
- 在中序中找到该根的位置，左边是左子树，右边是右子树
- 递归构建左右子树

###### 实现原理

- 使用一个**哈希表**快速查找中序中某个值的位置
- 用前序的索引控制根位置推进
- 中序的区间划分控制左右子树范围

###### 代码套路模板

1. 找到并构建根节点：**根节点就是`preorder[0]`**
2. 构建**中序索引映射HashMap**
3. 分割左右子树的前序和中序子数组
   1. 找到根节点在中序数组中的位置`rootIndex`
   2. 构建左右子树的中序数组
      1. **左子树的中序数组为inorder[0,rootIndex]**
      2. **右子树的中序数组为inorder[rootIndex,inreder.length-1]**
   3. 构建左右子树的前序数组
      1. **左子树的前序数组为preorder[1,左子树size]**
      2. **右子树的前序数组为preorder[左子树size+1, preorder.length-1]**
4. 利用左右子树的中序和前序数组，递归构建左右子树
   1. `root.left = build(leftPreorder,leftInorder)`
   2. `root.right = build(rightPreorder, rightInorder)`

```java
TreeNode build(int[] preoder, int[] inorder){
  if (preorder.length ==0 ) return null;
  
  //找到root节点
  int rootVal = preorder[0];
  TreeNode root = new TreeNode(rootVal);
  
  // 使用Map快速查找中序中某个值的位置
	Map<Integer, Integer> indexMap = new HashMap();
  for (int i = 0; i< inorder.length;i++){
    indexMap.put(inorder[i],i);
  }
  
  //在中序数组中找到当前根的位置
  int rootIndex = indexMap.get(rootVal);
  
  //划分左右子树的中序和前序数组
  int[] leftInOrder = Arrays.copyOfRange(inorder,0,rootIndex);
  int[] rightInorder = Arrays.copyOfRange(inorder,rootIndex+1, inorder.length);
  
  //左子树的前序数组为 preorder[1...左子树size]
  int[] leftPreorder = Arrays.copyOfRange(preorder,1,1+leftInorder.length);
  //右子树的前序数组为 preorder[左子树size+1,右子树size]
  int[] rightPreorder = Arrays.copyOfRange(preorder,1+leftInorder.length,preorder.length);
  
  //递归构建左右子树
  root.left = build(leftPreoder,leftInorder);
  root.right = build(rightPreorder,rightInorder);
 
  return root;
}
```

####中序+后序构建唯一二叉树

###### 核心思想

- 后序第一个是根
- 中序划分左右子树
- 递归构建

###### 实现原理

- 使用一个**哈希表**保存中序数组的索引映射
- 通过**后序数组**寻找并构建根节点
- 通过**根节点**在中序数组中的位置：
  - **切割**左子树和右子树的**中序数组**
    - `leftInorder = inorder[0....rootIndex]`
    - `rightInorder = inorder[rootIndex+1,end]`
  - 计算**左子树和右子树的节点数量**
- 通过左子树和右子树的**节点数量**，切割**后序数组**
  - `leftPorstorder = postorder[0....leftTreeSize]`
  - `rightPostOrder = porstorder[leftTreeSize+1,postorder.length-2]`

###### 实现代码

```java
public TreeNode build(int[] postorder, int[] inorder){
  if (inorder.length ==0 ) return null;
  int n = postorder.length;
  int rootVal = postorder[n-1];
  
  TreeNode root = new TreeNode(rootVal);
  
  Map<Integer, Integer> map = new HashMap<>();
  
  for (int i=0; i<n; i++){
    map.put(inorder[i],i);
  }
  
  int rootIndex = map.get(rootVal);
  
  int[] leftInorder = Arrays.copyOfRange(0,rootIndex);
  int[] rightInorder = Arrays.copyOfRange(rootIndex+1,n);
  
  int leftSize = leftInorder.length;
  int[] leftPostorder = Arrays.copyOfRange(0,leftSize);
  int[] rightPostorder = Arrays.copyOfRange(leftSize,n-1);
  
  root.left = build(leftPostorder,leftInorder);
  root.right = build(rightPostOrder,rightInorder);
 
}
```

#### 利用中序构建平衡搜索二叉树

##### 平衡二叉搜索树的特性有哪些？

- 对于任何一个节点而言，左子树和右子树的深度差不超过1
- 搜索二叉树的特性 左 < 中 < 右

##### 中序数组的特性-升序 

按照升序排列

##### 问题分析

###### 怎么保证左子树和右子树的高度差不超过1？

确保对于每一个节点而言，**其左子节点数量和右子节点的数量差不超过1**

##### 核心思想和套路 - 二分

取数组的中点，构建当前节点：

- 递归调用构建函数，利用数组的左半段构建左子树
- 递归调用构建函数，利用数组的右半段构建右子树

##### 实现代码

```java
    public TreeNode sortedArrayToBST(int[] nums) {
        int n = nums.length;
        return buildTree(nums,0,n-1);
    }

    private TreeNode buildTree(int[] nums, int i, int j){
        if (i > j) {
        return null;  // Base case: return null when the range is invalid
        }
        int mid = (i + j) /2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = buildTree(nums, i, mid-1);
        node.right = buildTree(nums,mid+1,j);
        return node;
    }
```

##### 注意事项

- 注意Base condition条件为`i > j`

#### Leetcode 95 不同的二叉搜索树II

給定一個整數 `n`，請生成並返回所有由 `1` 到 `n` 這 `n` 個數字作為節點值，且結構上互不相同的 **二元搜尋樹 (Binary Search Tree, BST)**。

##### 问题要点

**輸入 (Input)**: 一個整數 `n`。

**輸出 (Output)**: 一個 `List<TreeNode>`，其中包含所有可能的、以 `1...n` 為節點值的唯一結構的二元搜尋樹的根節點。

**核心限制 (Constraint)**: 生成的樹必須是「二元搜尋樹 (BST)」，意味著對於任何節點：

- 其左子樹中的所有節點值都小於該節點值
- 右子樹中的所有節點值都大於該節點值

##### 问题本质和分析

問題的本質是**構造所有可能**的組合，而不是像 LeetCode 96 那樣僅僅是**計數**。

這意味著我們必須實際建立每一棵樹。

對於一個 BST，一旦我們選定了根節點 `i`，那麼根據 BST 的性質：

- 所有小於 `i` 的數字 (`1, 2, ..., i-1`) 必須全部位於其**左子樹**。
- 所有大於 `i` 的數字 (`i+1, ..., n`) 必須全部位於其**右子樹**。

這就巧妙地將一個大問題分解成了兩個完全獨立的子問題：

1. 用 `1, ..., i-1` 這些數字構造所有可能的左子樹。
2. 用 `i+1, ..., n` 這些數字構造所有可能的右子樹。

最終，以 `i` 為根的全部 BST 組合，就是將第一步得到的所有左子樹和第二步得到的所有右子樹進行**笛卡爾積 (Cartesian Product)** 組合的結果。



舉例 `n=3`，如果選擇 `2` 作為根：

- 左子樹必須由 `{1}` 構成。只有一種可能。
- 右子樹必須由 `{3}` 構成。也只有一種可能。
- 組合起來，以 `2` 為根的樹就只有一種。



如果選擇 `1` 作為根：

- 左子樹是空的。
- 右子樹由 `{2, 3}` 構成。這本身又是一個子問題，它有兩種可能的樹結構。
- 組合起來，以 `1` 為根的樹就有兩種。

##### 模式匹配 - 分治 + 动态规划

###### 分治递归

这是最核心的模式。

选择一个元素作为当前问题的“分割点”（即根节点），将问题分解为更小的、独立的子问题（左右子树），递归解决子问题，最后合并子问题的解。

###### 动态规划

在递归过程中，我们会发现许多子问题被重复计算。

例如，在`n=5`时，计算`[1, 2]`范围的子树，会在选择`3`为根时（作为左子树）和选择`4`为根时（也作为左子树的一部分）被重复调用。

这提示我们可以用**记忆化 (Memoization)**来存储子问题的解，避免重复计算，这是**自顶向下DP**的典型特征。

###### 组合而成

问题的目标是生成所有可能的组合（这里是树结构），而不是简单计数。

这类问题通常通过递归回溯或分治来穷举所有可能性。



##### 核心思想与套路 

定义一个函数，比如 `build(start, end)`，它的功能是生成由 `start` 到 `end` 范围内的所有数字构成的全部可能的BST。

###### 核心套路 - 分治

1. **选择根节点**: 遍历 `i` 从 `start` 到 `end`，让 `i` 依次作为当前范围的根节点。

2. **划分并递归**:

   对于每一个根 `i`，左子树的节点范围是 `[start, i-1]`。

   我们递归调用 `build(start, i-1)` 来获取所有可能的左子树列表（`List<TreeNode> leftSubtrees`）。

   右子树的节点范围是 `[i+1, end]`。

   我们递归调用 `build(i+1, end)` 来获取所有可能的右子树列表（`List<TreeNode> rightSubtrees`）。

3. **组合结果 (Cartesian Product)**: 这是一个笛卡尔积的计算过程

   我们得到了所有可能的左子树和所有可能的右子树。

   现在需要将它们组合起来。

   使用嵌套循环，遍历 `leftSubtrees` 中的每一个左子树 `leftNode`，再遍历 `rightSubtrees` 中的每一个右子树 `rightNode`。

   对于每一对 `(leftNode, rightNode)`，创建一个新的根 `new TreeNode(i)`，并将其左右孩子分别指向 `leftNode` 和 `rightNode`。

   将这个新生成的树加入到当前 `build(start, end)` 的结果列表中。

4. **处理递归边界：**

   - 当 `start > end` 时，表示这是一个空区间，无法构成节点。此时应该构建一棵“空树”。在程序中，我们用 `null` 来表示空树。

   - **一个至关重要的细节**: `build` 函数应该返回一个列表。对于空区间，我们不应该返回一个空列表 `[]`，而应该返回一个**包含 `null` 元素的列表 `[null]`**。

     **为什么？** 思考一下：当 `i=start` 时，左子树范围是 `[start, start-1]`，是空区间。

     如果 `build` 返回空列表 `[]`，那么 `for (TreeNode leftNode : leftSubtrees)` 这个循环将一次都不会执行，我们就无法生成“只有右子树”的树。

     如果返回 `[null]`，循环会执行一次，`leftNode` 取值为 `null`，正确地与所有可能的右子树进行组合。

###### 为什么可以使用动态规划解决？

從動態規劃的角度看，這個問題的本質是它具備了兩個核心特性：

1. **最優子結構 (Optimal Substructure)**: 一個大問題的解可以由其子問題的解來構造。

   具體來說，使**用數字 `[i, j]` 構造的所有 BST，可以由其子區間 `[i, k-1]`（左子樹）和 `[k+1, j]`（右子樹）的所有 BST 組合而成**。

2. **重疊子問題 (Overlapping Subproblems)**: 在計算過程中，同一個子問題會被多次需要。

   例如，在計算 `n=5` 時，構造 `[1, 3]` 區間的樹和構造 `[2, 4]` 區間的樹，都會依賴於構造 `[2, 2]` 這個子問題的解。

- **識別特徵**:
  - 問題的狀態可以用一個區間 `[i, j]` 來定義。
  - 最終目標是求解整個區間 `[1, n]`。
  - 狀態轉移通常是通過枚舉區間 `[i, j]` 內的一個「分割點」`k`，將問題分解為更小的子區間（如 `[i, k-1]` 和 `[k+1, j]`）來實現。

這是一個非常典型的區間 DP 模式，其解法通常是通過一個二維 `dp` 陣列來存儲區間解，並按區間長度從小到大的順序進行迭代。

###### 怎样使用动态规划解决？

1. **状态定义：** `dp[i][j]`是一个`List<TreeNode>`，存储了由数字`i`到`j`构成的所有BST
2. **确定迭代顺序**：我们的目标是**从小区间的解构建大区间的解**，因此最外层的遍历必须是**区间的长度**，从1到n.
3. **初始化：**
   - 创建`dp`表：`dp[n+2][n+2]`
   - 为所有`dp[i][i-1]`即（空区间）初始化一个包含`null`的表。这是所有递推的起点。
4. **状态转移：**
   - 遍歷**長度 `len`** (從 1 到 n)。
   - 遍歷**起始點 `i`** (從 1 到 n-len+1)。
   - 計算**終點 `j`** (`j = i + len - 1`)。
   - 遍歷**根節點 `k`** (從 i 到 j)。
     - 從 `dp` 表中取出已計算好的左子樹列表 `dp[i][k-1]` 和右子樹列表 `dp[k+1][j]`。
     - 通過雙重迴圈將**左右子樹進行笛卡爾積**組合，生成以 `k` 為根的新樹，並添加到 `dp[i][j]` 中。
5. **獲取結果**: 整個 DP 表填充完畢後，`dp[1][n]` 即為最終答案。

##### 难点分析和应对

###### 难点一：迭代顺序的确定

**問題**: 很多初學者會習慣性地從 `i` 和 `j` 開始迴圈，但這樣會發現在計算 `dp[i][j]` 時，其依賴的子問題（如 `dp[i+1][j]`）可能還未被計算。

**應對**: 深刻理解區間 DP 的核心——**按長度迭代**。始終將區間長度 `len` 作為最外層迴圈，確保在計算任何長度為 `len` 的區間時，所有長度小於 `len` 的區間都已經計算完畢。

###### 難點 2: 邊界條件和空子樹的處理

**問題**: 當根為 `k=i` 時，左子樹為空；當根為 `k=j` 時，右子樹為空。如何統一處理這些情況？

**應對**: 在初始化階段，就將所有代表「空區間」的 `dp[i][i-1]` 設置為一個包含 `null` 的列表 `[null]`。

這樣，在狀態轉移的迴圈中，無論子區間是否為空，都能從 DP 表中取出一個非空列表（至少包含 `null`），讓雙重迴圈邏輯保持統一和簡潔。

###### 难点三： 索引管理

- - **問題**: 涉及 `len`, `i`, `j`, `k` 四個變數，很容易在索引計算和迴圈邊界上出錯。

  - **應對**:

    1. 思路清晰：牢記每個變數的含義。

    2. 使用稍大一點的 DP 表（如 `n+2` x `n+2`）可以避免很多邊界 `if` 判斷，讓代碼更乾淨。

    3. 動手在紙上模擬 `n=3` 的情況，可以幫助理清索引關係。

       

##### 实现原理和步骤

###### 主函数`generateTrees(n)`

- 处理 `n=0` 的特殊情况，返回一个空列表。

- 调用递归辅助函数 `build(1, n)`。

###### 递归辅助函数`build(start,end)`

- **定义DP数组** 

  创建一个二维数组 `dp[n+1][n+1]`，类型为 `List<TreeNode>`，用于缓存计算结果。

  在函数开头，检查 `dp[start][end]` 是否已经计算过，如果计算过，直接返回缓存的结果。

- **创建结果列表**: `List<TreeNode> res = new ArrayList<>();`

- **处理Base Case**: 如果 `start > end`，向 `res` 中添加 `null`，然后返回 `res`。

- **主循环**: `for (int i = start; i <= end; i++)`

  - `List<TreeNode> leftSubtrees = build(start, i - 1);`
  - `List<TreeNode> rightSubtrees = build(i + 1, end);`

- **组合循环**:

  - `for (TreeNode left : leftSubtrees)`
  - `for (TreeNode right : rightSubtrees)`
    - `TreeNode root = new TreeNode(i);`
    - `root.left = left;`
    - `root.right = right;`
    - `res.add(root);`

- **缓存并返回**: 在函数末尾，将 `res` 存入 `memo[start][end]`，然后返回 `res`。

##### 实现代码

```java
class Solution {
    // 使用一个二维数组作为备忘录，缓存计算过的子问题的结果
    private List<TreeNode>[][] memo;

    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new ArrayList<>();
        }
        // 初始化备忘录，大小为 (n+1) x (n+1)
        memo = new ArrayList[n + 1][n + 1];
        return build(1, n);
    }

    /**
     * 递归函数，用于构建由 [start, end] 范围内数字组成的所有唯一BST
     * @param start 范围的起始值
     * @param end 范围的结束值
     * @return 一个列表，包含所有可能的BST的根节点
     */
    private List<TreeNode> build(int start, int end) {
        // Base Case: 如果范围无效，返回一个包含 null 的列表
        if (start > end) {
            List<TreeNode> res = new ArrayList<>();
            res.add(null);
            return res;
        }

        // 检查备忘录，如果已经计算过，直接返回结果
        if (memo[start][end] != null) {
            return memo[start][end];
        }

        List<TreeNode> result = new ArrayList<>();

        // 1. 遍历所有可能的根节点
        for (int i = start; i <= end; i++) {
            // 2. 递归构建所有可能的左子树
            List<TreeNode> leftSubtrees = build(start, i - 1);
            
            // 3. 递归构建所有可能的右子树
            List<TreeNode> rightSubtrees = build(i + 1, end);
            
            // 4. 组合左右子树
            for (TreeNode left : leftSubtrees) {
                for (TreeNode right : rightSubtrees) {
                    // 创建根节点
                    TreeNode root = new TreeNode(i);
                    // 连接左右子树
                    root.left = left;
                    root.right = right;
                    // 将新构建的树加入结果列表
                    result.add(root);
                }
            }
        }
        
        // 将当前范围的结果存入备忘录
        memo[start][end] = result;
        
        return result;
    }
```

##### 注意事项

1. **Base Case 的 `[null]` 返回值**：再次强调，这是此题最关键的技巧。返回空列表 `[]` 会导致逻辑错误，无法生成只有单侧子树的结构。
2. **记忆化的必要性**：若不使用记忆化，纯粹的递归解法会因为大量重复计算而严重超时（Time Limit Exceeded）。子问题 `build(start, end)` 的重复性非常高。
3. **指针和对象**: 在组合左右子树时，我们是直接将 `left` 和 `right` 指针赋给新 `root` 的 `left` 和 `right` 字段。我们不需要深拷贝子树，因为这些子树结构在一次组合中是固定的，这既高效又正确。
4. **备忘录的索引**: 备忘录数组 `memo` 的大小设为 `[n+1][n+1]` 是为了让数字范围 `1` 到 `n` 能直接用作数组索引，代码更直观。

##### 经验总结

**从计数到构造**: 许多算法问题都有“计数”和“构造”两个版本。计数问题通常可以用DP求解，状态是数值。构造问题也常用DP（或记忆化递归），但状态是构造出的对象集合（如本题的 `List<TreeNode>`）。

**分治是生成组合结构的利器**: 当一个复杂对象可以由“一个选择 + 多个子问题对象的组合”定义时，分治法就是天然的解法。本题的“一个根 + 左子树集合 + 右子树集合”就是典型模式。

**识别递归中的重复**: 在写递归解法时，要时刻思考“这个函数会不会被同样的参数重复调用？”。如果会，那么记忆化就是必不可少的优化手段，能将指数级复杂度降低到多项式级。

**`null` 的妙用**: 在树的递归构造中，`null` 不仅仅是“无”，它也是一种合法的结构（空树）。在需要返回集合的场景下，用 `[null]` 来代表“所有可能的空树集合”（这个集合里只有一个成员，就是`null`本身），是一个非常优雅的处理方式。

#### Leetcode 96: 不同的二叉搜索树

##### 问题要点

**输入**: 一个正整数 `n`。

**目标**: 计算由 `1, 2, ..., n` 这 `n` 个节点，可以构成多少种**结构上唯一**的二叉搜索树 (BST)。

**输出**: 一个整数，代表 BST 的总数量。

与 Leetcode95的核心区别：

**LC 95 (构造)**: 要求生成所有可能的树结构。

**LC 96 (计数)**: 只要求计算出总共有多少种结构，无需生成它们。这通常意味着问题可以用更简单的DP状态（数值而非对象列表）来解决。

##### 问题本质和分析

这是一个组合计数问题。其本质与 LeetCode 95 的分析完全相同：一棵BST的结构由其根节点唯一确定地划分为左右子树。

令 `G(n)` 为用 `n` 个不同节点（例如 `1...n`）可以构成的不同BST的数量。

我们来分析如何计算 `G(n)`。

我们可以依次选择 `1, 2, ..., n` 中的每一个数 `i`作为根节点：

**当 `i` 作为根节点时**:

- 其左子树必须由所有小于 `i` 的数构成，即 `{1, 2, ..., i-1}`。这共有 `i-1` 个节点。用这 `i-1` 个节点能构成的不同左子树的数量是 `G(i-1)`。
- 其右子树必须由所有大于 `i` 的数构成，即 `{i+1, ..., n}`。这共有 `n-i` 个节点。用这 `n-i` 个节点能构成的不同右子树的数量是 `G(n-i)`。

**一个关键的抽象**: 

BST的结构数量只与节点的**数量**有关，与节点的**具体数值**无关。

例如，用 `{1, 2}` 构成的BST数量，和用 `{5, 6}` 构成的BST数量是完全一样的。

因此，由 `n-i` 个数 `{i+1, ..., n}` 构成的BST数量就是 `G(n-i)`。

根据**乘法原理**，当根为 `i` 时，总的BST数量是 $G(i-1) * G(n-i)$。

最后，根据加法原理，我们将所有可能的根节点 `i` (从 `1` 到 `n`) 的情况相加，就得到了 `G(n)` 的总数。

于是，我们得到了一个递推公式：

$G(n) = \sum_{i=1}^n G(i-1) \times G(n-i)$



##### 模式匹配 - 动态规划

上述的递推公式 `G(n)` 依赖于 `G(0), G(1), ..., G(n-1)` 的解。

这是一个完美的DP问题。我们可以创建一个DP数组，自底向上地计算出 `G(0), G(1), ..., G(n)`。



##### 核心思想

**核心思想**：利用动态规划，将 `n` 个节点的问题，分解为求解更少节点（`0` 到 `n-1` 个）的子问题。

######**定义 DP 状态**:

- `dp[i]` 表示：用 `i` 个节点能够构成的不同二叉搜索树的总数量。
- 我们的目标是求解 `dp[n]`。

###### 确定状态转移方程

- 根据上面的分析，`dp[i]` 的值是通过枚举根节点，然后将左右子树的可能性相乘再相加得到的。
- 如果我们有 `i` 个节点，让 `j` (`1 <= j <= i`) 作为根节点。
- 左子树有 `j-1` 个节点，可能性为 `dp[j-1]`。
- 右子树有 `i-j` 个节点，可能性为 `dp[i-j]`。
- 因此，$dp[i] = \sum_{j=1}^{i} dp[j-1] \times dp[i-j]$。

###### 确定Base cases

- `dp[0] = 1`。

  这是一个至关重要的、非直观的 base case。

  它代表一个**空集**只能构成**一种**树结构，

  即“空树”（`null`）。

  这保证了当子树为空时（例如根为`1`，左子树有`0`个节点），公式 `dp[0] * dp[i-1]` 能够正确计算。

  如果 `dp[0]=0`，所有计算结果都会是0。

- `dp[1] = 1`。**但是不需要初始化！**

  1个节点只能构成一种树（就是它自己）。

  我们可以用公式验证：`dp[1] = dp[0] * dp[0] = 1 * 1 = 1`。

  `dp` 数组在 `new int[n+1]` 时，所有元素默认初始化为 `0`。

  让我们再精确地跟踪一次：

  - `int[] dp = new int[n+1];`  -> `dp` 数组所有值为 `0`
  - `dp[0] = 1;` -> `dp[0]` 变为 `1`
  - `dp[1] = 1;` -> `dp[1]` 变为 `1`
  - **进入循环 `i=1`:**
    - `j=1` 时，执行 `dp[1] += dp[0] * dp[0];`
    - 此时 `dp[1]` 的值是 `1`，`dp[0]` 的值是 `1`。
    - 这行代码变成了 `dp[1] = 1 + (1 * 1)`，结果 `dp[1]` 会被错误地计算成 `2`。

###### 确定计算顺序

我们显然需要从 `dp[0]` 开始，依次计算 `dp[1], dp[2], ...` 直到 `dp[n]`。

这是一个标准的**自底向上**的计算过程。

##### 实现原理和步骤

1. **处理特殊情况**: 如果 `n=0`，返回1（或者根据题意，如果 `n` 保证为正，则可忽略）。

2. **创建 DP 数组**: `int[] dp = new int[n + 1];`

3. **初始化 Base Case**: `dp[0] = 1;`

4. **外层循环**: 遍历我们要计算的DP状态，`for (int i = 1; i <= n; i++)`。这个 `i` 代表当前要计算的节点总数。

5. **内层循环**: 遍历所有可能的根节点选择，`for (int j = 1; j <= i; j++)`。

   这个 `j` 代表根节点在 `1...i` 序列中的位置（也可以理解为左子树的节点数+1）。

6. 在 `dp[i]` 的计算中，累加 `dp[j-1] * dp[i-j]`。

7. `dp[i] += dp[j-1] * dp[i-j];`

8. **返回结果**: 循环结束后，`dp[n]` 中存储的就是最终答案，返回 `dp[n]`。

##### 实现代码

```java
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        
        return dp[n];
    }
```

##### 注意事项

**`dp[0] = 1`的理解**: 这是整个DP能够正确工作的基石。你可以这样理解：当 `n=1` 时，根是`1`，左子树有0个节点，右子树有0个节点。其总数是 `dp[0] * dp[0]`。我们知道 `n=1` 时只有1种树，所以 `dp[0] * dp[0]` 必须等于 `1`，因此 `dp[0]` 必须是 `1`。

**循环的含义**: 外层循环 `i` 是在填充DP表，从 `dp[1]` 一直计算到 `dp[n]`。内层循环 `j` 是在应用DP递推公式，通过枚举所有可能的根节点位置来计算当前的 `dp[i]`。

**数据类型**: `n` 的最大值是19，`n=19` 时的卡特兰数是 `1,767,263,190`，在 `int` 的范围内。如果 `n` 更大，需要使用 `long`。

##### 经验总结

- **从构造到计数是降维**: 比较 LC95 和 LC96，可以深刻体会到，当问题从“构造所有解”简化为“计算解的数量”时，DP的状态通常可以“降维”。我们不再需要存储 `List<TreeNode>`，只需要一个 `int` 就够了，这大大简化了问题。
- **识别核心递推关系**: 很多DP问题的关键在于找到问题规模 `n` 与 `n-1`, `n-2`... 等更小规模问题之间的数学关系。本题的 `G(n) = Σ G(i-1) * G(n-i)` 就是这个核心。
- **重视`dp[0]`**: 在动态规划中，`dp[0]` 或类似的基础状态的定义往往是解决问题的关键。一定要仔细思考 "0个物品"、"空字符串"、"空树" 等情况的价值，它通常是递推公式的起点。

# 树形动态规划

在树上进行的最优决策问题，当前节点的决策依赖其子节点的多种状态。

这是分治思想的升级版。递归函数**返回一个包含多种状态的数组或对象**，而非单一值。

例如，返回 `[状态A的最优解, 状态B的最优解]`，父节点根据子节点的这些状态组合，计算出自己的状态数组。



二叉树上的动态规划（简称“树形DP”）是动态规划算法在树形结构上的一种扩展。

它通过自底向上的方式，从子树的最优解逐步推导出整个树的最优解。

对于二叉树，其结构相对简单，使得树形DP的模式和套路也更加清晰。

## 场景和目标

#### 树形动态规划问题的特征

树形DP通常用于解决在二叉树上寻找最优解的问题。这些问题往往具有以下特征：

- **最优子结构**: 整个树的最优解可以由其左右子树的最优解推导出来。
- **重叠子问题**: 在计算过程中，某些子树的状态会被多次计算。DP通过记忆化（或自底向上递推）来避免重复计算。

##常见的场景

### 路径问题

- 寻找二叉树中的最长路径（直径）。

- 寻找从根节点到叶子节点的最大/最小路径和。

- 寻找任意两个节点之间的最大/最小路径和。

### 选择/组合问题

- **打家劫舍III**: 在二叉树中选择节点，使得相邻（父子）节点不能同时被选中，求选中节点值的最大和。

- **二叉树的着色问题**: 对节点进行染色，要求相邻节点颜色不同，求方案数或最小代价。

- **监控二叉树**: 在节点上放置摄像头来监控所有节点，求最少需要多少个摄像头。

### 计数问题

- 计算满足特定条件的二叉搜索树（BST）有多少种。
- 计算满足某种形态的子树有多少个。

### 核心目标

通过定义清晰的 **状态**，并找出 **状态转移方程**，利用递归（通常是深度优先搜索, DFS）遍历树的每个节点，在后序遍历的位置（即处理完左右子树之后）完成当前节点的状态计算，最终得到根节点的状态作为整个问题的解。

## 模式套路匹配

### 问题求解依赖子树问题

问题的答案需要综合考虑当前节点的左右子树的信息。例如，求树的直径，需要知道左子树的深度和右子树的深度。

### 局部最优解可以推导全局最优解

通过计算每个子树的局部最优解，可以最终推导出整棵树的全局最优解。

### 无后效性

一个节点的状态一旦确定，就不会再被其祖先节点的状态所改变。计算只依赖于其子节点。

### 问题通常出现的形式

**问题通常以“最大/最小”、“计数”、“可行性”等形式出现**。

**典型例题匹配：**

- **“求最大/小...”** -> LeetCode 124. 二叉树中的最大路径和, LeetCode 337. 打家劫舍 III
- **“求数量/方案数...”** -> LeetCode 96. 不同的二叉搜索树
- **“求最少/最小代价...”** -> LeetCode 968. 监控二叉树

## 核心思想和套路 - 后序自底向上的遍历

树形DP的核心在于 **递归** 和 **状态定义**。

### 核心思想：自底向上的后序遍历

- 我们通过递归函数（DFS）深入到树的最底部（叶子节点）。

- 叶子节点作为递归的边界条件，其状态通常很容易确定。

- 在递归返回的过程中，利用已经计算好的左右子节点的状态，来计算当前节点的状态。这个过程恰好符合 **后序遍历** 的顺序（左 -> 右 -> 根）。

#### 核心套路：定义递归函数的返回值

- 思考**为了计算当前节点 `u` 的状态，你需要从其子节点 `v` 获取哪些信息**？

- 将这些需要的信息定义为递归函数的返回值。

  返回值通常是一个数组、元组(Tuple)或哈希表(Map)，包含了计算父节点状态所需的所有子节点信息。

  **这是树形DP最关键的一步**。状态定义是否清晰、全面，直接决定了问题能否解决。

### 举例：打家劫舍III

#### 问题要点

不能同时偷窃直接相连的父子节点，求最大偷窃金额。

#### 状态思考：偷不偷当前节点？

对于任意一个节点 `u`，我们有两种选择：**偷** 或 **不偷**。

- 如果 **偷** `u`，那么它的左右子节点 `left` 和 `right` 都 **不能偷**。
- 如果 **不偷** `u`，那么它的左右子节点 `left` 和 `right` **既可以偷，也可以不偷**（取其最大值）。

#### 返回值定义：偷或者不偷的结果

递归函数 `dfs(node)` 需要返回一个包含两个值的数组或元组 `[stolen_max, not_stolen_max]`。

- `stolen_max`: 表示 **偷** `node` 节点时，以 `node` 为根的子树能得到的最大金额。
- `not_stolen_max`: 表示 **不偷** `node` 节点时，以 `node` 为根的子树能得到的最大金额。

## 实现原理

### DFS递归函数的定义

实现树形DP的主要载体。函数签名通常是 `dfs(TreeNode node)`。

### 基准情况

 递归的终止条件。对于二叉树，通常是 `if node is None:`，此时返回一个表示空状态的值（如 `[0, 0]` 或 `0`）。

### 递归下降

 对当前节点的左右子节点调用递归函数，获取它们的状态信息。

```
left_status = dfs(node.left)
right_status = dfs(node.right)
```

### 状态计算

在后序遍历的位置，根据从左右子节点获取的状态 `left_status` 和 `right_status`，以及当前节点 `node` 自身的值，计算出 `node` 节点的状态。

```
# 伪代码：以打家劫舍III为例
stolen_at_current = node.val + left_status[1] + right_status[1]
not_stolen_at_current = max(left_status) + max(right_status)
```

### 返回状态

```
return [stolen_at_current, not_stolen_at_current]
```

### 主函数

调用递归函数，并从返回的根节点状态中提取最终答案。

##注意事项

### 状态定义要清晰

必须明确递归函数返回的每一个值代表什么物理意义。这是避免逻辑混乱的关键。

### 返回值的设计

返回值必须包含计算父节点状态所需的所有信息，不多也不少。

### 全局变量 VS 返回值

- 如果最终答案必然是由根节点的状态决定的（如“打家劫舍III”），那么可以直接从主函数调用`dfs(root)`的返回值中提取。

- 如果最终答案可能出现在树的任何一个局部，而不仅仅是根节点（如“二叉树最大路径和”，最大和可能不过根节点），那么通常需要一个全局变量（或作为类成员变量）在递归过程中不断更新。

### 空节点的处理

确保基准情况（`node is None`）返回的状态值是正确的，不会影响父节点的计算。

例如，对于求和，空节点返回0；对于求最大值，可能返回一个极小值。

### 避免重复计算

树形DP天然地通过递归避免了对同一个节点的重复处理。但如果题目是图而非树（存在环），则需要额外的 `visited` 集合来防止死循环。

## 经验总结

**先从简单例子入手**: 从“求树的最大深度”这类最简单的题目开始理解递归和后序遍历如何传递信息。

**多画图分析**: 当状态定义不清晰时，在纸上画一个简单的二叉树，手动模拟计算过程。从叶子节点开始，一步步计算父节点的状态，看看需要哪些信息，自然就能想清楚返回值的结构。

**刻意练习，分类归纳**: 将做过的树形DP问题进行分类（路径类、选择类、计数类等）。总结每一类问题在状态定义上的共同点和不同点。

**学习经典模型**:

- **最大路径和模型**: 递归函数返回“以当前节点为端点的最大向下路径和”。
- **打家劫舍模型**: 递归函数返回“偷/不偷当前节点”的两种状态下的最大收益。
- **监控摄像头模型**: 递归函数返回当前节点及其子树的三种状态（被覆盖但无摄像头、被父节点覆盖、自身有摄像头）的最小代价。

**不要畏惧复杂的返回值**: 有些困难的问题可能需要返回包含3个甚至更多值的状态数组。只要每个值的物理意义清晰，并且状态转移逻辑正确，问题就能迎刃而解。

## Leetcode 337: 打家劫舍III

### 问题要点 - 二叉树上的打家劫舍问题

这是一个在二叉树结构上进行的“打家劫舍”问题。

1. **数据结构**: 房屋的连接方式是一个二叉树，而不是一个线性的数组。
2. **约束条件**: 不能同时抢劫两个**直接相连**的房屋。这里的“直接相连”指的是父节点和其直接的子节点。
3. **目标**: 在满足约束条件的情况下，计算出能够抢劫到的**最大**金额。

### 问题本质和分析

这个问题的本质是在一个树形结构上进行带有约束的决策，以求得全局最优解。

这是一个典型的**树形动态规划 (Tree DP)** 问题。

####我们面临的两种选择：偷不偷？

##### 偷当前节点 - 不能偷它的直接子节点

如果我们抢劫了当前节点 `node`，根据规则，我们就不能抢劫它的直接子节点 `node.left` 和 `node.right`。

此时，我们能获得的最大金额是 `node.val` 加上**不抢劫**左子节点所能获得的最大金额，再加上**不抢劫**右子节点所能获得的最大金额。

##### 不偷当前节点 - 那偷不偷它的子节点呢？

如果我们不抢劫当前节点 `node`，那么对于它的子节点 `node.left` 和 `node.right`，我们没有任何限制。

我们可以选择抢劫它们，也可以选择不抢劫它们。为了使总金额最大化，我们应该取抢劫或不抢劫其子节点所能得到的最大值。

所以，总金额是**左子树能提供的最大金额**加上**右子树能提供的最大金额**。

最终，对于 `node` 这个节点（以及其构成的子树），我们能获得的最大金额就是上述两种选择中较大的一个。

$maxMoney(node)=max(抢劫node,不抢劫node)$

这个递推关系清晰地表明了我们可以使用递归来解决，并且**子问题的解可以被父问题复用**，这是动态规划的典型特征。

### 模式套路匹配

#### 树形动态规划 - 后序遍历

问题的状态（能抢到的最大金额）依赖于其子树的状态。

我们需要从叶子节点开始，自底向上地计算每个节点的状态，直到根节点。

这通常通过**后序遍历 (Post-order Traversal)** 的方式实现。

#### 递归 + 记忆化搜索 - 避免重复计算

一个朴素的递归会产生大量的重叠子问题，导致时间复杂度过高。

通过返回一个包含多种状态信息的结构，我们可以避免重复计算，这本质上就是动态规划的思想。

### 核心思想和套路

单村的递归函数如果只返回一个值（该子树能够抢到的最大值）是不够的。

因为我们在计算父节点`P`的状态的时候，如果要决定抢劫`P`，我们就需要知道其子节点`C`不被抢劫时的最大金额。

而不仅仅是`rob(c)`的返回值（`rob(c)`可能是抢了`c`也可能是没抢`c`）。

因此，核心思想是让递归函数返回一个包含两种状态的数组或者对象。

- 状态0: **不抢劫**当前节点时，该子树能获得的最大金额。

- 状态1: **抢劫**当前节点时，该子树能获得的最大金额。

我们定义一个递归函数 `dfs(node)`，它返回一个长度为 2 的数组 `int[] result`：

- `result[0]`: 代表**不抢劫** `node` 时，`node` 子树能抢到的最大金额。
- `result[1]`: 代表**抢劫** `node` 时，`node` 子树能抢到的最大金额。

通过这种方式，我们在一次遍历中就能获得解决父问题所需的所有信息。

### 实现原理和步骤

#### 定义递归函数

创建一个辅助函数，例如 `int[] dfs(TreeNode node)`。

#### 设置基准情况 - 当前节点为null

如果当前节点 `node` 为 `null`，那么无论抢或不抢，金额都是 0。因此返回 `new int[]{0, 0}`。

#### 递归下降

- 对左子节点进行递归调用: `int[] leftStatus = dfs(node.left);`

- 对右子节点进行递归调用: `int[] rightStatus = dfs(node.right);`

#### 计算状态

##### 抢劫当前节点

如果抢劫 `node`，则不能抢劫其子节点。

所以最大金额是 `node.val` 加上左子节点**不被抢劫**时的金额 (`leftStatus[0]`) 和右子节点**不被抢劫**时的金额 (`rightStatus[0]`)。

`robCurrent = node.val + leftStatus[0] + rightStatus[0];`

##### 不抢劫当前节点

如果不抢劫 `node`，那么其左右子节点可以被抢，也可以不被抢。

我们取它们各自能产生的最大金额即可。

左子树的最大金额是 `max(leftStatus[0], leftStatus[1])`，右子树同理。

`notRobCurrent = Math.max(leftStatus[0], leftStatus[1]) + Math.max(rightStatus[0], rightStatus[1]);`

#### 返回结果

 将当前节点计算出的两个状态打包成数组返回: `return new int[]{notRobCurrent, robCurrent};`

#### 主函数调用

在主函数 `rob(TreeNode root)` 中，调用 `dfs(root)`，得到根节点的两个状态。最终答案就是这两个状态中的最大值。

### 实现代码

```Java
 //树形打家劫舍
 //不能抢劫一条路径上的连续两个节点
 //抢了node,就不能抢node.left和node.right
 //
class Solution {
    public int rob(TreeNode root) {
        int[] res = robRoom(root);
        return Math.max(res[0],res[1]);
    }

    private int[] robRoom(TreeNode node){
        if(node == null){
            return new int[]{0,0};
        }
        int[] left = robRoom(node.left);
        int[] right = robRoom(node.right);

        int[] res = new int[2];
        //抢劫当前节点，不能抢劫子节点
        res[0] = left[1] + right[1] + node.val;
        //不抢劫当前节点，可以抢劫或者不抢劫左右子节点
        res[1] = Math.max(left[0], left[1]) + Math.max(right[0],right[1]);
        return res;
    }
}
```

### 注意事项

#### 避免朴素递归 - 避免重复计算

千万不要写成 `rob(node) = max(node.val + rob(node.left.left) + ..., rob(node.left) + rob(node.right))` 这种形式。因为它会产生大量的重复计算（例如 `rob(node.left.left)` 会被多次调用），导致时间复杂度达到指数级别，从而超时。

#### 状态定义的清晰性

理解为什么需要返回一个包含两个状态的数组是解决此问题的关键。

如果只返回一个值，父节点将无法根据自己的决策（抢或不抢）来正确地利用子节点的信息。

#### 空间换时间

这种树形 DP 的方法利用了额外的空间（递归栈和返回的数组）来存储中间状态，从而将时间复杂度优化到线性 O(N)，其中 N 是节点的数量。

#### 遍历顺序 - 自底向上

算法的内在逻辑是后序遍历。必须先得到子节点的状态，才能计算父节点的状态。

### 经验总结

#### 识别模式

当遇到在树/图上求最优解（最大/最小/计数等）的问题，且一个节点的决策会影响其相邻节点的决策时，要优先考虑树形动态规划。

#### 定义状态

树形 DP 的核心是为每个节点定义清晰的状态。

思考一下：“为了让父节点做出决策，我需要从子节点那里获得哪些信息？” 在本题中，就是“抢”和“不抢”两种状态。

#### 自底向上

树形 DP 的计算过程是自底向上（从叶到根）的，这天然地与**后序遍历**的递归实现相契合。

#### 举一反三

这个“返回一个数组/对象来表示多种状态”的技巧在很多树形 DP 问题中都非常有用。

例如，求解树的最大路径和、树的直径等问题时，虽然状态定义不同，但思想是相通的。

掌握了这个套路，就能解决一大类树形 DP 问题。

## Leetcode 968: 监控二叉树

### 问题要点

给定一个二叉树的根节点 `root`，我们需要在树的节点上安装摄像头。

每个摄像头都能监控其所在的节点、其父节点和其左右两个**直接子节点**。

目标是计算并返回覆盖整棵树所有节点所需的**最小**摄像头数量。

**核心限制:**

- 树的节点数量在 `[1, 1000]` 范围内。
- 每个节点的值 `Node.val` 均为 0，这意味着节点值本身不提供有用信息。

**理解监控范围：** 一个摄像头的作用范围是一个“十字形”区域，覆盖了节点本身和其上下左右的邻居。

### 问题本质和分析

此问题的本质是在一棵树上进行决策，以最小的成本（摄像头数量）达成全局目标（所有节点被覆盖）。

对于任何一个节点，我们都有两种选择：**放置摄像头** 或 **不放置摄像头**。

#### 放置摄像头

该节点、其父节点和其子节点都会被覆盖。这是一个局部最优决策，因为它一次性覆盖了多个节点。

#### 不放置摄像头

该节点必须依赖其父节点或其子节点上的摄像头来被覆盖。

这种局部决策会影响全局结果的特点，以及寻求最优解（最小数量），强烈暗示了动态规划或贪心算法。

由于问题结构是树，因此这自然地导向了**树形动态规划 (Tree DP)** 的思路。

关键的观察点是：一个节点的状态，不仅取决于它自身，还与其子树的状态和其父节点的状态紧密相关。

为了做出最优决策，一个节点需要从其子节点获取信息。

这种自底向上的信息传递过程，天然地契合了**后序遍历 (Post-order Traversal)**。

#### 进一步分析可以发现一个贪心策略

##### 叶子节点最不划算

在叶子节点放置摄像头只能覆盖它自己和它的父节点。

而在其父节点放置摄像头，不仅能覆盖父节点、叶子节点，还能覆盖父节点的另一个子节点（如果存在）以及父节点的父节点。

因此，将摄像头放置在叶子节点的父节点，通常是更优的选择。

##### 延迟放置 - 尽可能的向上推迟放置摄像头

遵循第一点的思想，我们应该尽可能地“向上”推迟放置摄像头。

换言之，除非一个节点必须被覆盖，且无法由其子节点覆盖，我们才在其父节点处放置摄像头。

这个贪心策略是本题的核心，它指导我们从树的底部向上做出最优决策。

### 模式套路匹配

#### 树形动态规划特征

- 问题定义在一棵树上。
- 要求一个全局最优解（最小/最大/计数等）。
- 一个节点的解依赖于其子节点的解。
- 通过递归（通常是深度优先搜索，DFS）来计算，并在递归返回时合并子问题的解。

#### 与常规动态规划的区别

树形DP的状态定义通常与节点本身相关，并且状态转移沿着树的边进行，而不是像线性DP那样沿着数组索引。

此题的解法是树形DP的一个非常优雅的应用，通过为每个节点定义清晰的状态，并利用后序遍历自底向上地解决问题。

### 核心思想和套路

解决本题的核心是为每个节点定义一组状态，这组状态能够充分表达其子树的情况，并为父节点提供做出决策所需的全部信息。

一个节点 `u` 在其子树被处理完毕后，对于其父节点 `p` 来说，有以下三种可能的状态：

#### 状态 0 (State 0): 未被覆盖 (Uncovered)

- 含义：节点 `u` 自身未被任何摄像头覆盖。

- 对父节点 `p` 的要求：`p` **必须**放置一个摄像头来覆盖 `u`。

#### 状态 1 (State 1): 已放置摄像头 (Has a Camera)

- 含义：节点 `u` 自身安装了一个摄像头。

- 对父节点 `p` 的要求：`p` 已经被 `u` 覆盖，无需额外操作。`p` 的决策将基于其另一个子节点的情况。

#### **状态 2 (State 2): 已被覆盖但无摄像头 (Covered, No Camera)**

- 含义：节点 `u` 自身没有摄像头，但它被其子节点上的摄像头覆盖了。

- 对父节点 `p` 的要求：`p` 未被 `u` 的子树覆盖，`p` 仍需等待其父节点或其另一个子树来覆盖它。

#### 决策逻辑（后序遍历）

我们使用一个返回值为节点状态的 `dfs` 函数进行后序遍历。对于当前节点 `cur`：

##### 递归处理左右子树

- `left_state = dfs(cur.left)`
- `right_state = dfs(cur.right)`

##### 根据子节点状态做出决策

###### 情况一：只要有一个子节点是“状态0 (未被覆盖)”

```
if (left_state == 0 || right_state == 0)
```

- 那么当前节点 `cur` **必须**放置一个摄像头。

- 放置后，摄像头数量加一 (`count++`)。

- 当前节点 `cur` 的状态变为“状态1 (已放置摄像头)”，返回 `1`。

###### **情况二：如果两个子节点都被覆盖了，且其中至少一个子节点自身有摄像头**

```
if (left_state == 1 || right_state == 1)
```

- 这意味着当前节点 `cur` 已经被其子节点上的摄像头覆盖了。

- `cur` 自身不需要再放摄像头，也不需要父节点来覆盖它。

- 当前节点 `cur` 的状态变为“状态2 (已被覆盖但无摄像头)”，返回 `2`。

###### 情况三：两个子节点都是“状态2 (已被覆盖但无摄像头)”

```
if (left_state == 2 && right_state == 2)
```

- 这意味着 `cur` 的两个子节点都被它们各自的子节点覆盖了，但它们自身没有摄像头。

- 因此，当前节点 `cur` 自身没有被覆盖。

- `cur` 将这个“未被覆盖”的状态传递给它的父节点。

- 当前节点 `cur` 的状态变为“状态0 (未被覆盖)”，返回 `0`。

##### 特殊处理的根节点

当 `dfs` 遍历完成后，根节点 `root` 可能返回状态 `0` (未被覆盖)。

这意味着整棵树的根部需要一个摄像头来覆盖。

因此，如果 `dfs(root)` 的结果是 `0`，我们需要额外再加一个摄像头。

### 实现原理和步骤

#### 定义全局变量记录摄像头总和

定义一个全局变量 `cameras` 用于记录摄像头的总数。

#### 主函数的定义:`minCameraCover`

- 初始化 `cameras = 0`。

- 调用 `dfs` 辅助函数，获取根节点的状态。

- 如果 `dfs(root)` 返回 `0`（根节点未被覆盖），则说明根节点需要一个摄像头，将 `cameras` 加一。

- 返回 `cameras` 的值。注意处理只有一个节点的特殊情况。

#### 辅助函数`dfs(TreeNode node)`

##### Base Case:节点为null

- 如果节点为 `null`，它不需要被覆盖，也不提供覆盖。
- 可以认为它处于一个“已被覆盖”的状态，因为它不会对父节点产生“必须放摄像头”的要求。因此返回状态 `2`。

##### 调用递归

 递归调用 `dfs` 处理左右子节点，获取它们的状态 `left` 和 `right`。

##### 状态判断

- 如果 `left == 0 || right == 0`，则当前节点必须放摄像头。`cameras++`，并返回状态 `1`。
- 如果 `left == 1 || right == 1`，则当前节点已被子节点覆盖。返回状态 `2`。
- 如果 `left == 2 && right == 2`，则当前节点未被覆盖，需要父节点来覆盖。返回状态 `0`。
- （注意：上述判断顺序是固定的，确保了逻辑的正确性）。

####最终返回：

主函数根据根节点的最终状态决定是否需要额外增加一个摄像头，并返回总数。



### 代码实现

```Java
class Solution {
    private int cameras = 0;

    /**
     * 定义节点的三种状态:
     * 0: 该节点未被覆盖 (Uncovered)
     * 1: 该节点已安装摄像头 (Has a Camera)
     * 2: 该节点已被覆盖，但自身没有摄像头 (Covered, No Camera)
     */
    private static final int UNCOVERED = 0;
    private static final int HAS_CAMERA = 1;
    private static final int COVERED_NO_CAMERA = 2;

    public int minCameraCover(TreeNode root) {
        // 如果根节点是叶子节点，必须放一个摄像头
        if (root.left == null && root.right == null) {
            return 1;
        }

        // dfs返回根节点的状态。如果根节点是UNCOVERED，说明它需要一个摄像头。
        // 这个摄像头可以放在它自己身上。
        if (dfs(root) == UNCOVERED) {
            cameras++;
        }
        return cameras;
    }

    private int dfs(TreeNode node) {
        // Base Case: 空节点，可以认为是“已被覆盖”的状态，
        //因为它不需要被监控，也不会对父节点产生任何“需要被覆盖”的要求。
        if (node == null) {
            return COVERED_NO_CAMERA;
        }

        // 后序遍历
        int leftState = dfs(node.left);
        int rightState = dfs(node.right);

        // 情况1: 子节点中有一个是“未被覆盖”状态
        // 那么当前节点必须放置摄像头，来覆盖子节点。
        if (leftState == UNCOVERED || rightState == UNCOVERED) {
            cameras++;
            return HAS_CAMERA;
        }

        // 情况2: 子节点中有一个装了摄像头
        // 那么当前节点已经被子节点覆盖了。
        if (leftState == HAS_CAMERA || rightState == HAS_CAMERA) {
            return COVERED_NO_CAMERA;
        }

        // 情况3: 左右子节点都处于“已被覆盖但无摄像头”的状态
        // 意味着当前节点未被覆盖，需要父节点来覆盖它。
        // 此处返回UNCOVERED，将需求传递给父节点。
        // 注意：这个 `if (leftState == COVERED_NO_CAMERA && rightState == COVERED_NO_CAMERA)` 
        // 其实可以省略，因为前面的if已经排除了其他所有情况。
        return UNCOVERED;
    }
}
```

### 标准DP解法

#### 问题的本质和分析 - 动态规划的视角

从动态规划的角度看，这个问题的核心特征是**最优子结构**。

也就是说，一棵树的最小摄像头问题，可以由其左右子树的最小摄像头问题来推导解决。



当我们考察一个节点 `u` 时，为了计算包含 `u` 的整棵子树的最小摄像头数，我们仅仅需要知道其左子树 `l` 和右子树 `r` 的最优解信息。

我们不需要知道 `l` 和 `r` 的孙子节点具体是如何放置的，只需要知道 `l` 和 `r` 在各自的最优策略下处于什么“状态”即可。

这种自底向上（从子树到父树）构建最优解的模式，正是树形动态规划的用武之地。

#### 核心思想 - 严格的动态规划范式

##### 状态的定义

是DP的核心。

对于树上的任意一个节点 `u`，我们需要定义一组状态，这组状态需要能够完全描述 `u` 所在子树的情况，并且足以让 `u` 的父节点做出决策。

我们定义一个数组 `dp[u]` 或者一个函数返回值，它包含三个值，分别对应节点 `u` 的三种状态：

- **`dp[u][0]`**: 节点 `u` 处于**未被覆盖**状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  要让 `u` 不被覆盖，它的子节点 `l` 和 `r` 必须都不能放摄像头。

  同时，`l` 和 `r` 必须被它们各自的子节点覆盖。

- **`dp[u][1]`**: 节点 `u` 处于**放置了摄像头**的状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  这个状态的成本包括在 `u` 上放置的1个摄像头，以及其左右子树在任意状态下的最小摄像头数（因为 `u` 上的摄像头可以覆盖所有情况）。

- **`dp[u][2]`**: 节点 `u` 处于**被子节点覆盖，但自身无摄像头**的状态。要达到这个状态，`u` 的子树所需要的最少摄像头数量。

  要达到这个状态，`u` 的左子树或右子树中，必须至少有一个放置了摄像头。

##### 状态转移方程

假设我们已经通过后序遍历，计算出了节点 `u` 的左子节点 `l` 和右子节点 `r` 的DP状态数组 `dp[l]` 和 `dp[r]`。现在我们要计算 `dp[u]`。

###### 计算`dp[u][1]`(在`u`处放置摄像头)

这是最简单的。因为 `u` 自己放了摄像头，它的子节点 `l` 和 `r` 就都被覆盖了。

为了总摄像头数最少，我们应该为 `l` 和 `r` 的子树选择成本最低的状态。

$dp[u][1] = 1 + min(dp[l][0], dp[l][1], dp[l][2]) + min(dp[r][0], dp[r][1], dp[r][2]) $

###### 计算 `dp[u][0]` ( `u` 未被覆盖):

要让 `u` 不被覆盖，`u` 自身不能放摄像头，其父节点也不能放（这是从父节点视角看），其子节点也不能放。

所以，`l` 和 `r` 必须处于“被它们自己的子节点覆盖”的状态，也就是状态2。

$dp[u][0] = dp[l][2] + dp[r][2] $

果某个子节点无法达到状态2（例如叶子节点），那么 `u` 也无法达到状态0。

在这种情况下，我们可以将 `dp[u][0]` 设为一个极大值（代表不可能）。

###### 计算 `dp[u][2]` ( `u` 被子节点覆盖):

这意味着 `l` 或 `r` 中至少有一个节点放了摄像头。我们希望总数最少，所以分两种情况取最小值：

- **左子节点放置摄像头**

  成本是 `dp[l][1]`。

  此时右子节点 `r` 已被 `u` 覆盖（虽然我们这里不关心父节点），它只需要满足自身子树最优即可，所以取 `min(dp[r][1], dp[r][2])`。

  （注意：`r` 不能是状态0，因为它必须被覆盖）。

  更严谨地说，`r`可以被`u`覆盖，所以它取`min(dp[r][...])`。

- **右子节点放置摄像头**

  右子节点 `r` 放摄像头：成本是 `dp[r][1]`，左子树同理。

为了覆盖 `u`，要么左孩子放摄像头，要么右孩子放摄像头。

- 如果左孩子 `l` 放摄像头，那么右孩子 `r` 的状态可以是任意的，因为它已经被 `u` 的父亲角色 `l` 覆盖了（实际上是被u的摄像头覆盖）。所以 `r` 取其子树的最小值。

- 所以，总成本是 `min(左孩子放摄像头成本 + 右子树总成本, 右孩子放摄像头成本 + 左子树总成本)`

  $dp[u][2] = min(dp[l][1] + min(dp[r][0], dp[r][1], dp[r][2]), \quad dp[r][1] + min(dp[l][0], dp[l][1], dp[l][2])) $

##### Base Case

对于一个空节点 `null`：

- 它不需要被覆盖，也不能放摄像头。
- `dp[null][0] = 0` （0个摄像头，是未覆盖状态）
- `dp[null][1] = \infty` （不可能放摄像头，用极大值表示）
- `dp[null][2] = 0` （0个摄像头，可视作已被覆盖状态，因为它不产生“需要覆盖”的需求）

##### 最终结果

对于根节点 `root`，它不能处于“未被覆盖”的状态。

所以最终答案是 `min(dp[root][1], dp[root][2])`。

#### 实现原理和步骤

1. **定义递归函数：** 设计一个递归函数 `dfs(node)`，它返回一个长度为3的数组 `int[]`，分别代表 `dp[node][0]`, `dp[node][1]`, `dp[node][2]`。
2. **后序遍历：** 在函数内部，首先递归调用 `dfs(node.left)` 和 `dfs(node.right)` 获取左右子节点的DP数组。
3. **处理Base Case：** 如果 `node` 是 `null`，返回 `{0, Integer.MAX_VALUE / 2, 0}`。除以2是为了防止加法溢出。
4. **状态计算：** 根据上面推导的状态转移方程，利用子节点的DP数组计算当前节点的DP数组。
5. **返回结果：** `dfs` 函数返回计算出的当前节点的DP数组。
6. **主函数调用：** 在主函数中，调用 `dfs(root)` 得到根节点的DP数组 `root_dp`，最终结果就是 `min(root_dp[1], root_dp[2])`。

#### 实现代码

```Java
class Solution {
    /**
     * 本解法严格遵循树形DP范式
     * 定义一个递归函数，返回一个数组 res, 长度为3
     * res[0]: 代表node节点【未被覆盖】时，其子树所需的最少摄像头数
     * res[1]: 代表node节点【放置摄像头】时，其子树所需的最少摄像头数
     * res[2]: 代表node节点【被子节点覆盖，自身无摄像头】时，其子树所需的最少摄像头数
     */
    public int minCameraCover(TreeNode root) {
        int[] rootDp = dfs(root);
        // 根节点不能是“未被覆盖”的状态，所以从另外两种状态中取最小值
        return Math.min(rootDp[1], rootDp[2]);
    }

    private int[] dfs(TreeNode node) {
        // Base Case: 空节点
        if (node == null) {
            // [未覆盖, 放摄像头, 已覆盖]
            // 未覆盖：0个摄像头
            // 放摄像头：不可能，设为极大值
            // 已覆盖：0个摄像头，因为它不需要被覆盖
            return new int[]{0, Integer.MAX_VALUE / 2, 0};
        }

        // 后序遍历，先获取左右子节点的DP状态数组
        int[] leftDp = dfs(node.left);
        int[] rightDp = dfs(node.right);

        // 状态转移方程

        // 状态0: node未被覆盖。
        // 那么其子节点必须是被它们自己的子节点覆盖的状态。
        int dp0 = leftDp[2] + rightDp[2];

        // 状态1: node放置摄像头。
        // 成本为1 (node自身) + 左右子树在任何状态下的最小成本。
        int minLeft = Math.min(leftDp[0], Math.min(leftDp[1], leftDp[2]));
        int minRight = Math.min(rightDp[0], Math.min(rightDp[1], rightDp[2]));
        int dp1 = 1 + minLeft + minRight;
        
        // 状态2: node被子节点覆盖。
        // 那么必须是左子节点放摄像头，或者右子节点放摄像头。取两者中的较小值。
        // Case A: 左孩子放摄像头, 右孩子取最小值
        int caseA = leftDp[1] + minRight;
        // Case B: 右孩子放摄像头, 左孩子取最小值
        int caseB = rightDp[1] + minLeft;
        int dp2 = Math.min(caseA, caseB);

        return new int[]{dp0, dp1, dp2};
    }
}
```

#### 从DP视角看第一个解法

现在您再看第一个解法，就会豁然开朗。

- 第一个解法中，`dfs` 函数返回一个整数 `0, 1, 2`，这其实就是代表当前节点在**其父节点看来**应该处于哪种状态才能达成最优。
- `return 0` 对应 `dp[u][0]` 的情况，告诉父节点：“我没被覆盖，你必须放摄像头！”
- `return 1` 对应 `dp[u][1]` 的情况，告诉父节点：“我放了摄像头，你被覆盖了。”
- `return 2` 对应 `dp[u][2]` 的情况，告诉父节点：“我被我的孩子覆盖了，你不用管我。”
- 全局变量 `cameras` 的累加，则是在发生 `dp[u][1]` 状态转移时（即决定放置摄像头时）进行的。

第一个解法是一个**状态压缩**和**过程优化**的版本。

它没有显式地计算每种状态的最小摄像头数，而是通过返回一个状态标记，隐式地引导整个决策过程朝着最优解进行。

这种实现方式更简洁，但理解起来需要从贪心的角度切入。

而我们刚刚详细分析的严格DP版本，则清晰地展示了其背后完整的动态规划逻辑。

两者殊途同归，内核思想完全一致。

## 树形动态规划的核心框架

### 识别问题模式

- 场景： 发生在一棵树上
- 目标：要求一个全局最优解（最大值/最小只/总方案数）
- 约束：一个节点的决策会影响或者受与其直接相连的节点的决策所限制
- 结论： 这个问题具备最优子结构的特性，即父问题的最优解依赖于子问题的最优解。

### 确定信息流和遍历方式

- 由于父节点的决策需要依赖其子树的计算结果，信息流是**自底向上**的

- 在树的遍历中，唯一能实现**先处理子节点再处理父节点**的就是后序遍历

  因此实现上几乎总是采用递归的深度优先搜索来模拟后序遍历。

### 状态推导和转移方程

#### 父节点需要知道子树的哪些信息？

当我们处理完一个节点 `u` 的子树后，为了让 `u` 的父节点 `p` 能够做出最优决策，`p` 需要从 `u` 这里知道哪些**最关键的信息**？

将这些“关键信息”设计成一个状态数组（或元组、对象等）。

递归函数/DFS的返回值就应该是这个状态数组。

这个状态数组的**维度**和**每个维度的含义**是区分不同问题的关键。

### 确定最终答案

当整个遍历结束，我们得到根节点的最终状态数组。

根据问题的整体约束，从根节点的状态数组中选取一个或多个状态的值，计算出最终答案

## Leetcode 337和968在树形DP框架下的对比

| 抽象套路步骤        | LeetCode 337 (打家劫舍 III)                                  | LeetCode 968 (监控二叉树)                                    |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 识别问题模式** | 在树上求最大偷窃金额。约束：不能同时偷父子节点。是典型的树形DP。 | 在树上求最小摄像头数。约束：所有节点必须被覆盖。摄像头覆盖范围是父、子、自身。是典型的树形DP。 |
| **2. 遍历方式**     | 后序遍历（DFS递归）。                                        | 后序遍历（DFS递归）。                                        |
| **3. 定义节点状态** | **父节点 `p` 需要知道什么？** 如果 `p` 决定偷，那么它必须知道不偷 `u` 能得到的最大金额。如果 `p` 决定不偷，那么它可以从偷或不偷 `u` 中选择一个最大值。 **结论**: `p` 需要知道 `u` 在“偷”和“不偷”两种情况下的最优解。 **状态数组 `int[2]`**: `res[0]`: 不偷 `u` 时，`u` 子树的最大金额。`res[1]`: 偷 `u` 时，`u` 子树的最大金额。 | **父节点 `p` 需要知道什么？** `p` 需要知道 `u` 的覆盖情况来决定自己是否要放摄像头。具体来说：1. `u` 是否**没被覆盖**，强制 `p` 必须放摄像头？ 2. `u` 是否自己**放了摄像头**，从而把 `p` 也顺便覆盖了？ 3. `u` 是否**被自己的孩子覆盖了**，既不麻烦 `p` 也不帮助 `p`？ **结论**: `p` 需要知道 `u` 的三种覆盖状态。 **状态数组 `int[3]`**: `res[0]`: `u` 未被覆盖时的最小摄像头。`res[1]`: `u` 放了摄像头的最小摄像头。`res[2]`: `u` 被孩子覆盖的最小摄像头。 |
| **4. 状态转移方程** | 设 `left` 和 `right` 为左右子节点返回的状态数组。`// 计算u不偷的情况` `res[0] = max(left[0], left[1]) + max(right[0], right[1]);` `// 计算u偷的情况` `res[1] = u.val + left[0] + right[0];` | 设 `left` 和 `right` 为左右子节点返回的状态数组。 `// 计算u放摄像头` `res[1] = 1 + min(left) + min(right);` `// 计算u未被覆盖` `res[0] = left[2] + right[2];` `// 计算u被孩子覆盖` `res[2] = min(left[1] + min(right), right[1] + min(left));` |
| **5. 确定最终答案** | 根节点没有父节点，所以它既可以被偷，也可以不被偷。取两者最大值。 **`max(root_res[0], root_res[1])`** | 根节点不能处于“未被覆盖”的状态。所以只能从“放摄像头”或“被孩子覆盖”中选。 **`min(root_res[1], root_res[2])`** |



### 
