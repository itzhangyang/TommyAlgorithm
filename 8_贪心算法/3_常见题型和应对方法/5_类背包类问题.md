# 找零钱问题 

找零钱问题有好几种不同的类型，典型的找零钱问题I和找零钱II都只能使用动态规划算法解决，只有柠檬水找零钱适合使用贪心算法。

这个问题是算法中非常经典的一个对比。

零钱兑换（Coin Change）问题是动态规划（DP）和贪心算法（Greedy）的一个绝佳“试金石”。

很多初学者（包括我）在学习时，都会用贪心算法去解 LeetCode 322（最少硬币数），然后发现 `[1, 3, 4]` 凑 `6` 这样的反例，从而领悟到 DP 的必要性。

我为你整理了 LeetCode 上最相关的三道“零钱问题”，它们分别代表了 **DP求最值**、**DP求组合数** 和 **贪心求可行性** 三种典型场景。

##问题一：LeetCode 322. Coin Change (零钱兑换 - 求最值)

这道题是“零钱问题”中最经典的一道，也是贪心算法的“陷阱题”。

###场景 + 目标: 求最少硬币个数

给定一个整数数组 coins，表示不同面额的硬币，和一个整数 amount，表示总金额。

####目标 (Objective):求最少硬币个数

计算并返回可以凑成总金额 amount 所需的 最少的 硬币个数。

####**限制 (Constraints):** 硬币个数是无限的

- 每种硬币的数量被认为是无限的。
- 如果没有任何一种硬币组合能组成总金额，返回 -1。

### 问题本质和分析 - 完全背包问题（顺序不敏感）

这是一个完全背包问题，每一种硬币是可以重复选择的。

#### [复习]完全背包问题（顺序不敏感）的套路

##### 完全背包问题的定义 - 每个物品不限制选择次数

- 有`n`种物品

  - 物品的定义如下：

  ```Java
  class Item{
    //物品价值
    int val;
    //物品重量
    int weight;
    
    public Item(int val, int weight){
      this.val = val;
      this.weight = val;
    }
  }
  ```

  

- 背包的容量限制是`capacity`

- 目标是求容量限制下的最大价值

#####状态定义:`dp[i][j]`表示组成容量`j`限制下的的最大价值

- `i`表示前`i`种物品
- `j`表示当前容量的限制

##### 遍历逻辑：外层容量/内层物品

```Java
for(int j = 0; j <= capacity; j++){
  for(int i = 1; i <= n; i++){
    Item item = items[i-1];
    //不考虑物品i的情况
    dp[i][j] = dp[i-1][j];
    //考虑物品i的情况，前提必须是j >= item.weight
    if(j >= item.weight){
      dp[i][j] = Math.max(dp[i][j], dp[i][j-item.weight]+item.val);
    }
  }
  
  return dp[n][capacity];
}
```

##### 状态转化方程

###### 不考虑物品i:

`dp[i][j] = dp[i-1][j];`

###### 考虑物品i

` dp[i][j] = Math.max(dp[i][j], dp[i][j-item.weight]+item.val);`

#### 为什么本题不适用贪心算法？

核心难点在于 **贪心算法不成立**。

贪心策略（每次都尽可能使用面额最大的硬币）在某些情况下无法得出全局最优解。

**反例 (Counterexample):** `coins = [1, 3, 4]`, `amount = 6`。

- **贪心解：** $4 + 1 + 1$ (3 枚硬币)
- **最优解：** $3 + 3$ (2 枚硬币)

###核心思想和套路:完全背包问题

- **套路：** 完全背包问题 (Unbounded Knapsack) 的“求最小值”变种。

- **状态定义：** `dp[i]` 表示凑成金额 `i` 所需的*最少*硬币数量。

- 状态转移方程 (State Transition Equation):

  $$dp[i] = \min(dp[i - coin] + 1) \quad \forall coin \in coins \text{ 且 } i \ge coin$$

  - **含义：** 凑成金额 `i` 的最少硬币数，等于 "凑成金额 `i-coin` 的最少硬币数 + 1" (这个1是面额`coin`的硬币) 的最小值。

###**实现原理和步骤:**

1. 创建一个 DP 数组 `dp`，大小为 `amount + 1`。

2. **初始化：** 将 `dp` 数组所有元素初始化为一个“极大值”（例如 `amount + 1` 或 `float('inf')`)，表示初始时都无法凑成。

3. **Base Case：** 设置 `dp[0] = 0` (凑成金额 0 需要 0 个硬币)。

4. **外层循环：** 遍历金额 `i` 从 1 到 `amount`。

5. **内层循环：** 遍历 `coins` 数组中的每个硬币 `coin`。

6. 状态转移： 如果 i - coin >= 0 (即当前金额 i 至少能放下这枚硬币)，则更新 dp[i]：

   dp[i] = min(dp[i], dp[i - coin] + 1)

7. **结果：** `dp[amount]`。如果 `dp[amount]` 仍然是初始的“极大值”，说明无解，返回 -1。

###代码套路模板

```Java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] dp = new int[n+1][amount+1];
        //dp[0][j] = max
        //dp[i][0] = 0;
        //dp[0][0] = 0;
        for(int j = 1; j<= amount; j++ ){
            dp[0][j] = Integer.MAX_VALUE;
        }

        for(int j = 0; j <= amount; j++){
            for(int i = 1; i <= n; i++){
                int coin = coins[i-1];
                dp[i][j] = dp[i-1][j];

                if(j >= coin && dp[i][j-coin] != Integer.MAX_VALUE){
                    dp[i][j] = Math.min(dp[i][j], dp[i][j-coin] + 1);
                }
            }
        }

        return dp[n][amount] == Integer.MAX_VALUE ? -1 : dp[n][amount];
    }
}
```

###**注意事项:**

- `dp` 数组的初始化值是关键。`amount + 1` 是一个很好的“无效”标记，因为它比任何可能的有效答案（硬币数）都要大。
- `dp[0] = 0` 是所有状态转移的起点，必须正确设置。

###经验总结:

遇到“凑金额”、“求最值”问题时，首先要怀疑贪心，并尝试举一个反例。

如果贪心失效，99% 的情况是动态规划。dp[i] = **凑成 i 的最XXX** 是最常见的状态定义。

##问题二：LeetCode 518. Coin Change 2 (零钱兑换 II - 求组合数)

这道题是“零钱问题”的另一个 DP 变种，目标从“求最值”变成了“求方法数”。

### 场景和目标：求组合数量

1. 场景 (Scenario):

   给定一个整数数组 coins 和一个整数 amount。

2. 目标 (Objective):

   计算并返回可以凑成总金额 amount 的 硬币组合 总数。

3. **限制 (Constraints):**

   - 每种硬币的数量无限。
   - 假设答案不会超过 32 位整数范围。

### 问题本质和分析 - 完全背包问题的组合计数变种

这属于一道求计数的题目。

按照我们之前根据计数类型的DP的总结：

`dp[当前状态] = dp[前置状态1]+dp[前置状态2]+dp[前置状态3]...`

###**难点 (Why DP?):**

- 这不是求最值，而是 **计数问题 (Counting Problem)**。
- 核心难点在于区分 **组合 (Combination)** 和 **排列 (Permutation)**。
- 例如 `coins = [1, 2]`, `amount = 3`。
  - 排列：`(1, 1, 1)`, `(1, 2)`, `(2, 1)` (共 3 种)
  - 组合：`(1, 1, 1)`, `(1, 2)` (共 2 种)
- 题目要求的是“组合”，意味着 `(1, 2)` 和 `(2, 1)` 被视为同一种。

###**核心思想和套路:**

- **套路：** 完全背包问题 (Unbounded Knapsack) 的“求组合数”变种。

- **状态定义：** `dp[j]` 表示凑成金额 `j` 的*组合*总数。

- 状态转移方程:

  $$dp[j] = dp[j] + dp[j - coin]$$

  **含义：** 凑成金额 `j` 的方法数，等于 (不使用 `coin` 凑成 `j` 的方法数) + (使用 `coin` 凑成 `j` 的方法数)。

###**实现原理和步骤:**

1. 创建一个 DP 数组 `dp`，大小为 `amount + 1`。
2. **初始化：** 将 `dp` 数组所有元素初始化为 0。
3. **Base Case：** 设置 `dp[0] = 1` (凑成金额 0 只有一种方法：什么都不选)。
4. **外层循环：** 遍历 `coins` 数组中的每个硬币 `coin`。 (!!!)
5. **内层循环：** 遍历金额 `j` 从 `coin` 到 `amount`。 (!!!)
6. **状态转移：** `dp[j] = dp[j] + dp[j - coin]`
7. **结果：** `dp[amount]`。

###**代码套路模板 :**

```Java

class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n+1][amount+1];
        //dp[0][0] = 1;
        dp[0][0] = 1;
        //dp[0][j] = 0;
        //dp[i][0] = 1;
        for(int i = 1; i <= n; i++){
            dp[i][0] = 1;
        }

        for(int j = 0; j <= amount; j++){
            for(int i = 1; i <= n; i++){
                int coin = coins[i-1];
                dp[i][j] = dp[i-1][j];
                if(j >= coin){
                    dp[i][j] += dp[i][j-coin];
                }
            }
        }
        return dp[n][amount];
    }
}
```

###**注意事项:**

- **循环顺序至关重要！**
- **求组合数 (本题):** 必须 **外层遍历 `coins`**，**内层遍历 `amount`**。这确保了硬币是按固定顺序（例如，先用 1，再用 2，再用 5）被添加的，从而避免了 `(1, 2)` 和 `(2, 1)` 这样的重复。
- **求排列数 (如果题目要求):** 则需要 **外层遍历 `amount`**，**内层遍历 `coins`**。
- `dp[0] = 1` 是所有累加的起点。

###经验总结:

这是“求方法数”的经典 DP。核心难点是理解为什么“外层遍历物品，内层遍历背包”的循环顺序可以正确地计算“组合”而不是“排列”。

##问题三：LeetCode 860. Lemonade Change (柠檬水找零 - 贪心)

### 场景 + 目标

这道题是真正的“找零”问题，它完美地展示了贪心算法的适用场景。

1. 场景 (Scenario):

   你在卖柠檬水，每杯 5 美元。顾客按顺序排队，只买一杯，他们会支付 5、10 或 20 美元的钞票。

2. 目标 (Objective):

   你需要给每位顾客正确找零。判断你是否能给 所有 顾客正确找零。

3. **限制 (Constraints):**

   - 你一开始没有任何零钱 (5, 10, 20)。
   - 必须 **按顺序** 处理顾客。

### 问题的本质和分析 - 需要贪心的计算每一个步骤

因为你手头上有的硬币种类和数量是在**动态变化**的。

你只是需要关心当前能否找零，而不是需要求全局的最值或者总数。

因此动态规划在这里是不适用的。

###**难点 (Why Greedy?):**

#### 只关心当前问题 - DP不适用

 这是一个线性的、有顺序的决策过程，没有复杂的子问题依赖。

你只需要关心“当前”是否能找零，而不需要求解一个全局的“最值”或“总数”。

####**贪心适用理由：**

##### 问题具有 **贪心选择性质**。

在找零时，你总是希望保留“更万能”或“更灵活”的零钱。

#####**分析：**

- 5 美元钞票：最灵活。可以用于 10 美元 (找 5) 和 20 美元 (找 15)。
- 10 美元钞票：次灵活。只能用于 20 美元 (找 15)。
- 20 美元钞票：最不灵活。不能用于找零。

#####**贪心策略：** **优先使用面额大的钞票**

- 例如：顾客付 20 美元，需要找零 15 美元。
  - 你有 `[10, 5]` 和 `[5, 5, 5]` 两种选择。
  - 你应该 **优先使用 `[10, 5]`**。因为 10 美元钞票的唯一用途就是给 20 找零，而 5 美元钞票还可以留给付 10 美元的顾客。如果你用掉了 3 张 5 美元，下一个付 10 美元的顾客你就无法找零了。

###**核心思想和套路:**

- **套路：** 模拟 + 贪心。
- **核心思想：** 维护你手中 5 美元和 10 美元的数量。

###**实现原理和步骤:**

1. 初始化 `five_count = 0`, `ten_count = 0`。

2. 遍历 `bills` 数组中的每个 `bill`。

3. `if bill == 5`: `five_count++`。

4. `if bill == 10`:

   - `if five_count > 0`: `five_count--`, `ten_count++`。
   - `else`: `return False` (没有 5 块找不开)。

5. `if bill == 20`:

   - if ten_count > 0 and five_count > 0: (贪心：优先用 10+5)

     ten_count--, five_count--。

   - elif five_count >= 3: (备选：用 5+5+5)

     five_count -= 3。

   - `else`: `return False` (两种都凑不齐 15)。

6. 遍历结束，`return True`。

###**代码套路模板 :**

```Java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        TreeMap<Integer,Integer> coinMap = new TreeMap<>((a,b) -> b-a);

        for(int bill : bills){
            coinMap.put(bill, coinMap.getOrDefault(bill,0) + 1);
            if(!change(bill - 5, coinMap)) return false;
        }
        return true;
    }

    private boolean change(int amount, TreeMap<Integer, Integer> coinMap){
        if(amount == 0) return true;
        int leftAmount = amount;
        while(leftAmount >= 20 && coinMap.getOrDefault(20,0) > 0){
            leftAmount -= 20;

            coinMap.put(20, coinMap.get(20) - 1);
        }
        if(leftAmount == 0) return true;

        while(leftAmount >= 10 && coinMap.getOrDefault(10,0) > 0){
            leftAmount -= 10;

            coinMap.put(10, coinMap.get(10) - 1);
        }
        if(leftAmount == 0) return true;

        while(leftAmount >= 5 && coinMap.getOrDefault(5,0) > 0){
            leftAmount -= 5;
            coinMap.put(5, coinMap.get(5) - 1);
        }
        if(leftAmount == 0) return true;
        return false;
    }
}
```

###**注意事项:**

- 20 美元找零的贪心顺序是核心。必须先尝试 `10+5`，再尝试 `5+5+5`。
- 我们不需要 `twenty_count`，因为 20 美元钞票永远不会用来找零。

###经验总结:

贪心算法的关键在于证明 “局部最优能够导出全局最优”。在本题中，“局部最优”就是“尽可能保留 5 美元这种最灵活的钞票”。这个策略在每一步都适用，最终保证了全局的可行性。

##总结对比

| **特征**     | **LeetCode 322 (零钱兑换)**       | **LeetCode 518 (零钱兑换 II)** | **LeetCode 860 (柠檬水找零)**        |
| ------------ | --------------------------------- | ------------------------------ | ------------------------------------ |
| **目标**     | 求 **最少** 硬币数 (最值)         | 求 **组合** 总数 (计数)        | 求 **是否可行** (布尔)               |
| **算法**     | 动态规划 (DP)                     | 动态规划 (DP)                  | 贪心 (Greedy)                        |
| **核心**     | **贪心失效** (e.g., [1,3,4] 凑 6) | **区分组合/排列** (循环顺序)   | **贪心成立** (优先用大面额找零)      |
| **DP状态**   | `dp[i]` = 凑 `i` 的*最少*个数     | `dp[j]` = 凑 `j` 的*组合*数    | (不适用)                             |
| **DP转移**   | `dp[i] = min(dp[i-c]+1)`          | `dp[j] += dp[j-c]`             | (不适用)                             |
| **贪心策略** | (不适用)                          | (不适用)                       | 找 15 时，优先用 `10+5` 再用 `5+5+5` |

# 可以切割的背包问题 - 贪心算法

| Item     | Value                                          | Comments |
| -------- | ---------------------------------------------- | -------- |
| 场景描述 | 物品可分割，装最大总价值                       |          |
| 排序逻辑 | 按单位价值降序                                 |          |
| 选择逻辑 | 优先选单位价值高的，按比例取用                 |          |
| 实现原理 | 每个单位容量都装入“性价比最高”的物品，直至装满 |          |
| Leetcode |                                                |          |

##注意事项-可分割物品才适用贪心

可分割物品前提下，贪心才适用。

## 核心思想 - 优先取单位价值高的物品

### 贪心算法排序： 按照单位价值对物品进行排序

### 贪心算法选择策略： 优先选择单位价值高的物品

#### 如果物品重量不超限则全部取走

```Java
capacity -= item.weight;
res += item.value;
```

#### 如果物品超限则取走`capacity - leftCapacity`

```Java
res += double(item.value)*capacity/item.wight;
    break;
```

##套路模板

```Java
//1. 按照单位价值进行排序
Arrays.sort(items,(a,b)->Double.compare((double)b.value/b.weight,(double)a.value/a.weight));

for (Item item :items){
  //如果能将物品整个装下，就拿走整个物品
  if (capacity >= item.weight){
    capacity -= item.weight;
    res += item.value;
  }else{
    //如果不能装下整个物品，拿走部分物品
    res += double(item.value)*capacity/item.wight;
    break;
  }
}
```

