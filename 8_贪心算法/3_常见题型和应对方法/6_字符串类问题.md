# 字符串类问题

##Leetcode 316 去除重复字母

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。

需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

 

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

###问题解析

####什么是字典排序最小？

字典序和字典一样，按从小到大排列，比如：

- `"abc"` < `"acb"` < `"bac"` < `"bca"`

所以我们要找的是**所有可能的去重子序列中**，**最小的那一个字典序**。

###什么是`不能打乱其他字符的相对位置`？

> ✅ 你可以从原字符串中挑字符（删掉一些），但不能**重新排列**字符。挑出来的字符之间**在原字符串中必须保持顺序**。

也就是说，我们只能从字符串中选出一个**子序列**，不能做排序。

####举个例子更清楚

输入字符串：`"cbacdcbc"`

我们要从中选出不重复的字符，构成结果字符串。所有字符都要：

- 出现一次（去重）
- 保留原字符串的相对顺序（子序列）
- 构成的结果字典序最小

####❌错误的理解 - 把所有字母取出来然后比较排序？

你可能会想：“是不是把所有字母取出来，然后按字典序排序？”

比如：`"cbacdcbc"` 去重是 `a, b, c, d`，排序得 `"abcd"`？

**错！** 原因是 `abcd` 并不是原字符串的子序列。

####正确的方式 - 取非重复子序列！

我们在 `"cbacdcbc"` 中找去重的、相对顺序不变的、字典序最小的结果。

最后的正确答案是：`"acdb"`

解释：

- `a` 在 `c` 后面没关系，因为 `a` 是最小的，先出现。
- 后面再选 `c`，然后 `d`，最后 `b`，形成字典序最小的合法子序列。

####总结

| 条件               | 含义                                               |
| ------------------ | -------------------------------------------------- |
| 每个字母只出现一次 | 不能重复出现字符                                   |
| 字典序最小         | 选择的子序列在字典顺序上尽可能靠前                 |
| 不打乱相对位置     | 挑出的字符顺序必须是原字符串中的顺序，不能乱序重排 |

###基本原理（去重+保序+字典序最小）

我们想从`s` 中挑出若干个字符，要求：

- 每个字符只出现一次
- 字符顺序不能打乱
- 结果字典序最小

####怎样用栈维护字典序？

我们想要结果字符字典序最小，那么必须在构建过程中做出`排序上的决策`。

如果当前字符比栈顶小，且栈顶字符后面还会出现，就可以弹出栈顶字符。

因为我们子后还可以加回来。

####贪心逻辑

在保证结果合法的前提下，每一步都选当前字典序最小的字符，并把后续更大的字符延后处理。

#### 保存跟踪每一个字符的剩余频率

我们使用一个数组`count[]`来保存每一个字母的**剩余频率**。

剩余频率大于0，说明该字母后续还会出现。

剩余频率为0，说明该字母后续不会出现了。

#### 套路步骤

##### 初始化剩余频率

我们统计所有字母的出现频率，并构建一个**剩余频率**数组，存放每一个字母在字符串中出现的次数。

##### 构造字典序最小的不重复序列

我们使用**栈**来保存**已经选中的字母**。

我们需要遍历每一个字符，对于每一个字符：

1. 将剩余频率-1;

2. 检查字符是否已经被加入子序列，如果已经在子序列中（栈）中，则跳过；

3. 删除栈顶**比当前字符大**并且**后面还会出现**的字符。

4. 将当前字符入栈

#####组装结果 - 从栈中遍历字母

从前到后遍历栈中的字符并组装成字符串即可，注意不是弹出。

###实现代码

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        for(char c : s.toCharArray()){
            count[c-'a'] += 1;
        }

        Stack<Character> stack = new Stack<>();
        
        for(char c : s.toCharArray()){
            count[c-'a'] -= 1;
            
            if(stack.contains(c)) continue;

            while(!stack.isEmpty()
                  && stack.peek() > c
                  && count[stack.peek() - 'a'] > 0){
                    stack.pop();
                  }
            stack.push(c);
        }

        StringBuilder sb = new StringBuilder();
        for( char c : stack){
            sb.append(c);
        }
        return sb.toString();
    }
}
```

