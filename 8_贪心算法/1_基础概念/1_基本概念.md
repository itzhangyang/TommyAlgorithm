#贪心算法解决的问题类型

贪心算法通常用来解决**最优化问题**，也就是在一系列备选方案中选择最优解。常见问题类型有：

| 类型                  | 描述                                   |
| --------------------- | -------------------------------------- |
| 最小/最大权重问题     | 如最小生成树、最短路径                 |
| 最少/最多资源使用问题 | 如活动选择、区间覆盖、任务调度、找零钱 |
| 排序/调度问题         | 如区间调度、任务安排、Huffman编码      |

#核心原理： 贪心选择性质+最优子结构

贪心算法能成立的两个核心前提：

##贪心选择性质（Greedy Choice Property）- 局部最优能够导致全局最优

###**`局部最优选择`能导致`全局最优解`**

> 每一步最初的最优选择不会影响最终结果的全局最优性

###最优子结构

一个问题的最优解包含其字问题的最优解

> 当前问题的最优解由子问题的最优解构成

#贪心算法的核心流程

##将问题抽象为一组元素

抽象为选择一组元素，使某种代价为最小或者收益最大

##将元素按照某种标准进行排序

通常先根据某个标准对元素排序（权重，结束时间，单位收益）

##贪心选择-按照排序结果从前往后选择

按照排序结果，从前往后逐个选择，符合条件就选

##每次选择时记得验证合法性

每次选择时，判断是否满足约束条件

##终止条件

通常遍历完整个元素集合或者达到约束上限

# 常见的贪心算法题型

| 问题类型       | 问题示例                                          | 贪心策略                          |
| -------------- | ------------------------------------------------- | --------------------------------- |
| 区间调度问题   | **活动选择问题**（Activity Selection）            | 结束时间最早的优先选择            |
| 背包问题       | **分数(可分割的)背包问题（Fractional Knapsack）** | 单位价值高的先装                  |
| 图的最小生成树 | **Kruskal / Prim 算法**                           | 每次选择**权重最小**的边，不成环  |
| 找零问题       | **找零最少硬币数**                                | 每次选择**面值最大**、可用的硬币  |
| 哈夫曼编码     | **Huffman编码构造**                               | 每次合并最小频率的两个节点        |
| 字符串问题     | **最小字典序子序列**                              | 保证剩下的字符足够+当前字典序最小 |
| 合并区间       | **区间覆盖/合并问题**                             | 按起始点排序+贪心合并             |

#贪心算法与动态规划的区别

| 特点     | 贪心算法                     | 动态规划                           |
| -------- | ---------------------------- | ---------------------------------- |
| 策略     | 每一步局部最优               | 穷举所有子问题，取最优             |
| 解空间   | 通常只考虑一种可能           | 构建**整个解空间**                 |
| 是否回溯 | 否                           | 可能要回溯查找子问题结果           |
| 适用条件 | 具备贪心选择性质和最优子结构 | 只需要最优子结构                   |
| 速度     | 一般比动态规划快             | 可能会较慢，需要记忆化/表格优化    |
| 举例     | 活动选择、找零钱、哈夫曼编码 | 0-1 背包、最长公共子序列、路径计数 |

#贪心算法的适用场景

##能排序的场景

比如按照结束时间、价值密度、字典排序等

##有明确的局部最优策略

并且该策略能够保证全局最优

##解的构成具备重叠字问题，但没有后效性

即**未来选择不受过去影响**, 这一点和动态规划完全不一样

##目标是最大化/最小化

不是判断是否存在解

#套路模板

```python
function greedyAlgorithm(elements):
    # Step 1: 按照某个贪心策略对元素排序
    sort(elements, by=greedy_criteria)

    # Step 2: 初始化结果（根据问题而定）
    result = initialize_result()

    # Step 3: 逐个遍历元素，做出选择
    for element in elements:
        if is_valid_choice(element, result):
            result = make_choice(result, element)

    # Step 4: 返回最终结果
    return result
```

##各个步骤解释

| 步骤                  | 内容                                                         |
| --------------------- | ------------------------------------------------------------ |
| `sort()`              | 根据题目要求的“贪心标准”排序（如最小结束时间、最大价值比等） |
| `initialize_result()` | 初始化状态，比如选中的集合、总价值、当前时间等               |
| `is_valid_choice()`   | 判断当前元素是否满足问题约束条件                             |
| `make_choice()`       | 如果满足条件，就选择它并更新状态                             |

##使用技巧

1. 找到排序策略（贪心标准）
2. 初始化状态
3. 遍历并做出选择（要不要选，怎么更新状态）
4. 输出结果（最大值、最小值、路径、集合等）



### 例题解析

| 问题类型   | LeetCode题号             | 题名                                           |
| ---------- | ------------------------ | ---------------------------------------------- |
| 活动选择   | #435                     | Non-overlapping Intervals                      |
| 分数背包   | GFG题                    | Fractional Knapsack                            |
| 最小生成树 | #1584 / #1135            | Min Cost to Connect All Points                 |
| 找零问题   | #322（DP）/ #860（贪心） | Coin Change / Lemonade Change                  |
| 哈夫曼编码 | GFG题                    | Huffman Coding                                 |
| 最小字典序 | #316 / #1081             | Remove Duplicate Letters                       |
| 合并区间   | #56 / #452               | Merge Intervals / Min Arrows to Burst Balloons |

# 