# 回溯

回溯算法（Backtracking）是算法中一种经典的“**系统搜索**”方法，常用于在**搜索空间树**中找出所有可能的解，或者找出符合特定约束条件的解。

## 核心思想：试错+回撤

回溯的本质是`尝试走一条路，如果走不通就回退（撤销）并尝试下一条路`，就像迷宫求解或者排列组合。

### 类比过程

1. 从一个起点开始尝试做决策；
2. 如果某个决策**不满足条件**，就**撤销**这个决策（回溯）；
3. 然后尝试下一个可能的决策，继续向下深入搜索；
4. 直到找到一个解，或者所有选择都尝试过后回退到上一个决策点；

## 基本原理

```python
def backtrack(路径，选择列表)：
	if (满足条件):
    记录结果；
    return；
  
  for 选择 in 选择列表：
  
  	if 不合法：
    	continue;
      
    做选择;
    backtrack(路径，选择列表)
    撤销选择
```

### 关键点

#### 已经选中的选项-路径（path）

当前**已经做出的选择的集合**

#### 待选择的选项-选择列表（candidates）

当前**还可以做的选择**

#### 满足条件-结束并返回： 

是否满足问题的要求（排列长度，搜索目标等）

#### 不满足条件-剪枝： 

在某些条件下提前跳过无效分支，提升效率

## 应用场景

| 场景     | 示例题目                       |
| -------- | ------------------------------ |
| 组合问题 | 从 1~9 中选出和为 7 的所有组合 |
| 排列问题 | 给定数组求所有可能排列         |
| 子集问题 | 给定数组求所有子集             |
| 分割问题 | 回文字符串分割                 |
| 棋盘问题 | N皇后、数独                    |
| 迷宫路径 | 是否能走到终点                 |
| 恢复解码 | IP地址恢复                     |

## 回溯算法小技巧

1. **路径用 `List<>` 管理**，递归中使用 `new ArrayList<>(path)` 保存`当前状态`。
2. **状态标记用 `boolean[]`**，如排列中是否使用过该元素。
3. **剪枝条件尽早判断**，比如排序后跳过重复元素 `if (i > start && nums[i] == nums[i - 1]) continue;`
4. **回溯 + 排序** 常用于避免重复解（如组合总和）。

## 常见问题和套路模板

### 回溯法所涉及到的leetcode题目

| 类型     | 常见题目                                 |
| -------- | ---------------------------------------- |
| 子集     | 78. Subsets、90. 子集 II                 |
| 排列     | 46. Permutations、47. 含重复数字的全排列 |
| 组合     | 77. Combinations、39. 组合总和           |
| 分割类   | 131. 回文串分割、93. 复原 IP 地址        |
| 图搜索   | 79. 单词搜索、200. 岛屿数量              |
| 棋盘类   | 51. N 皇后、37. 解数独                   |
| 博弈类   | 老鼠走迷宫、解谜题                       |
| 拓展问题 | K Sum、全排列路径恢复等                  |

### 子集问题（不考虑顺序，无重复）-Leet code 78

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

#### 解题思路

每个元素都有两个选择：**要或者不要**

我们从头开始遍历数组的每个元素，在每个元素的位置上，递归选择：

- 包含当前元素
- 不包含当前元素

从而构造出所有可能的组合

#### 应用于子集问题

- **路径（path）**：当前已经做出的选择（一个子集）
- **选择列表**：当前可以从哪里开始选（为了避免重复）
- **结束条件**：我们在每一层都要加入当前路径到结果中（因为任何一条路径都是一个合法子集）

#### 回忆一下回溯的套路模板

```python
def backtrack(路径，选择列表)：
	if (满足条件):
    记录结果；
    return；
  for 选择 in 选择列表：
  	if 不合法：
    	continue;
    左选择;
    backtrack(路径，选择列表)
    撤销选择,注意到每一层递归都会负责删除自己添加的内容
```

#### 代码实现

可以尝试记忆下列套路模板

```java
    private  List<List<Integer>> paths = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0, new ArrayList<>());
        return paths;
        
    }
    //回溯的套路模板
    private void backtrack(int[] nums, int start,List<Integer> path){
        // 当前Path加入到paths中-这里是不管path中包含什么，因为没有条件
        paths.add(new ArrayList<>(path));
        // 将从start...n之间的元素加入到path;
        for (int i = start;i<nums.length;i++){
            path.add(nums[i]);//
            backtrack(nums, i+1, path);
            // 撤销选择
            path.remove(path.size()-1);
        }
    }
```

#### 回溯树分析

初始状态 `start=0`,`path=[]`,`nums=[1,2,3]`

```
Start: 0, Path: []
├── Choose 1 → Path: [1]
│   ├── Choose 2 → Path: [1, 2]
│   │   ├── Choose 3 → Path: [1, 2, 3]
│   │   └── Backtrack → Path: [1, 2]
│   └── Backtrack → Path: [1]
│   ├── Choose 3 → Path: [1, 3]
│   └── Backtrack → Path: [1]
└── Backtrack → Path: []

├── Choose 2 → Path: [2]
│   ├── Choose 3 → Path: [2, 3]
│   └── Backtrack → Path: [2]
└── Backtrack → Path: []

├── Choose 3 → Path: [3]
└── Backtrack → Path: []

```

#### 有重复元素的情况分析-Leetcode 90

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

如果依然使用原来的回溯方法生成path的话，假设`nums=[1,2,2]`则生成树情况如下

```
Start:0, Path:[]
|--choose nums[0]=1 -> path:[1]
|     |--> Choose nums[1]=2-> path:[1,2]
|     |      |--> Choose nums[2]=2 path->[1,2,2]
|     |      |--> Backtrack nums[2] path->[1,2]
|     |--> Backtrack nums[1] Path ->[1]
|     |--> Choose nums[2]=2 -> path=[1,2] //在前面的一个循环已经处理过了，所以这里应该跳过，防止重复的子集
|     |--> Backtrack nums2 -> path=[1]
｜--> Backtrack nums[0] path ->[]

|--Choose nums[1] path->[2]
|    |--> Choose nums[2] path->[2,2]
|    |--> Backtrack nums[2] path->[2]
|--Backtrack nums[1] path->[]

|--Choose nums[2] path->[2] //重复
|--Backtrack nums[2] path->[]

```

**如果上一个值和当前值一样，而且是在同一层，说明这个值已经处理过了，就跳过它**。

所以要处理重复的情况，需要在每一轮循环的开始检查当前元素`nums[i]`与前一个元素`nums[i-1]`是否相同，如果相同则应该跳过。

```java
if(i>start && nums[i]==nums[i-1]){
                continue;
            }
```



### 排列问题：leetcode 46:全排列

给定一个`不含重复数字`的数组 `nums`，返回它的所有可能的全排列。

####回溯解法思路

回溯的核心逻辑是：做选择->递归->撤销选择（回溯）

#### 定义path

使用`List<Integer> path` 来表示当前已经做出的选择路径。

-  它保存了`当前排列`中`已经选择的元素`
-  每进入下一层递归，表示我们`选择了一个新的数字加入path`
-  每当`path`的长度等于`nums.length`,说明我们构造出一个完整的排列，把它加入到结果集中

#### 递归与回溯过程

根据下面的回溯树的推导我们可以看出来，回溯的逻辑：

1. 如果符合返回条件，返回，否则
2. 遍历所有的nums中的元素，并运行回溯过程：
   1. 将当前元素加入`path`和`visited`
   2. 递归调用，目的是将`剩余的节点`加入到`path`中
   3. 将当前的节点从path中`删除`(回溯)

#####选择当前的节点

检查当前的节点是否已经被加入`path (visited[i]==true)`

- 如果是，直接跳过当前节点（`continue`）
- 如果没有
  - 将当前节点加入`path`和`visited`
  - 递归调用，生成以`[...i]`为前缀的path
  - [回溯]递归调用返回后，从`path` 和`visited` 中删除掉`当前节点`

#####撤销对当前节点的选择

从回溯树来看，每一次递归过程中删除的都是`当前递归阶段`加入的节点。

#####充分了解了回溯的特性之后，根据问题场景定义path

需要充分关注求子集和全排列中path的不同之处。引入`visited`数组是一个最佳实践。



```java
Start: path = []                        （初始）

├── Choose 1 → path = [1]              （选择1）
│   ├── Choose 2 → path = [1,2]        （选择2）
│   │   └── Choose 3 → path = [1,2,3]  ✅ 收录 [1,2,3]
│   │       └── Backtrack: remove 3 → path = [1,2]
│   └── Backtrack: remove 2 → path = [1]
│   ├── Choose 3 → path = [1,3]        （选择3）
│   │   └── Choose 2 → path = [1,3,2]  ✅ 收录 [1,3,2]
│   │       └── Backtrack: remove 2 → path = [1,3]
│   └── Backtrack: remove 3 → path = [1]
└── Backtrack: remove 1 → path = []

├── Choose 2 → path = [2]              （选择2）
│   ├── Choose 1 → path = [2,1]        （选择1）
│   │   └── Choose 3 → path = [2,1,3]  ✅ 收录 [2,1,3]
│   │       └── Backtrack: remove 3 → path = [2,1]
│   └── Backtrack: remove 1 → path = [2]
│   ├── Choose 3 → path = [2,3]        （选择3）
│   │   └── Choose 1 → path = [2,3,1]  ✅ 收录 [2,3,1]
│   │       └── Backtrack: remove 1 → path = [2,3]
│   └── Backtrack: remove 3 → path = [2]
└── Backtrack: remove 2 → path = []

├── Choose 3 → path = [3]              （选择3）
│   ├── Choose 1 → path = [3,1]        （选择1）
│   │   └── Choose 2 → path = [3,1,2]  ✅ 收录 [3,1,2]
│   │       └── Backtrack: remove 2 → path = [3,1]
│   └── Backtrack: remove 1 → path = [3]
│   ├── Choose 2 → path = [3,2]        （选择2）
│   │   └── Choose 1 → path = [3,2,1]  ✅ 收录 [3,2,1]
│   │       └── Backtrack: remove 1 → path = [3,2]
│   └── Backtrack: remove 2 → path = [3]
└── Backtrack: remove 3 → path = []

End: 回溯完成，res 包含所有 6 个排列
```

####代码实现

本题目也算是非常标准的backtrack套路

```java
List<List<Integer>> res = new ArrayList<>();
public List<List<Integer>> permute(int[] nums){
  List<Integer> path = new ArrayList<>();
  boolean[] visited = new int[nums.length];
  backtrack(nums, visited, path);
}

private void backtrack(int[] nums, boolean[] visited, List<Integer> path){
  // 全排列的情况
  // Base condition: 当前path长度和数组长度一致，就是一次排列完成
  if (path.size() == nums.length){
    res.add(new ArrayList<>(path));
    return;
  }
  
  for(int i=0;i<nums.length;i++){
    if (visited[i]){
      continue;
    }
    
    path.add(nums[i]);
    visited[i] = true;
    
    backtrack(nums,visited,path);
    
    path.remove(path.size()-1);
    visited[i]=false;
  }
  
  
}
```

#### 有重复的元素全排列-Leetcode 47

给定一个*可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

##### 回溯树分析

假设`nums=[1,2,2]`,按照非去重的算法进行分析回溯树，可以得到：

```
nums=[1,2,2],  path=[]
|-- choose nums[0]: path=[1]
|     |--> skip nums[0]
|     |--> choose nums[1]: path=[1,2]
|     |      |-->skip nums[0]
|     |      |-->skip nums[1]
|     |      |-->choose nums[2]:path=[1,2,2]
|.    |--> choose nums[2]: path=[1,2]//出现重复
|     |      |-->skip nums[0] and nums[1]
|     |.     |-->choose nums[2] path=[1,2,2]
.... backtrack....

|-- choose nums[1]:path=[2]
|     |-- choose nums[0]: path=[2,1]
|     |.    |-- skip nums[0] and [1]
|     |.    |-- choose nums[2] path=[2,1,2]
....backtrack

|-- choose nums[2]: path=[2]
|     |-- choose nums[0] path=[2,1]
|     |.    |--skip nums[0] and nums[2]
|.    |.    |--choose nums[1]: path =[2,1,2] //出现重复了，从这个逻辑来看，后面的反而先排列了，因此是不是应该每次去取nums[i+1]
....
```

##### 处理方式

```
if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])
```

| 条件                     | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `nums[i] == nums[i - 1]` | 当前数字和前一个一样，有重复的可能                           |
| `!visited[i - 1]`        | **前一个重复数字没有被使用**，说明你现在是「在同一层」尝试用第二个一样的数字（会导致重复） |

##### 代码实现

```java
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] visited = new boolean[nums.length];
        List<Integer> path = new ArrayList<>();
        Arrays.sort(nums);
        backtrack(nums, visited, path);
        return res;
    }

    private void backtrack(int[] nums,boolean[] visited, List<Integer> path){
        //符合条件，记录并返回
        //求全排列的情况
        if (path.size()==nums.length){
            res.add(new ArrayList<>(path));
            return;
        }
				// 排列的情况，从0开始，不是从start开始（没有所谓的start）
        for(int i=0;i<nums.length;i++){
          	//visited的情况的处理
            if(visited[i]){
                continue;
            }
            //如果根上一个元素一样，则跳过当前元素（剪枝）
            //有重复元素的情况处理
            if (i>0 && nums[i]==nums[i-1] && !visited[i-1]){
                continue;
            }
            //选择和回溯过程
            path.add(nums[i]);
            visited[i]=true;
            backtrack(nums, visited, path);

            path.remove(path.size()-1);
            visited[i]=false;
        }
    }
```



### Leetcode 39 组合总和 - 元素可以重复选择！

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

##### 题目分析

这是一个求组合的问题，所以应该选择类似求`子集`的算法来实现，需要注意**求子集要求在同一个集合当中不能够重复使用某个元素**, 但是本题说明同一个数字可以被**无限重复被选取**, 并且一个数字的选取数量不同，这两种组合是**不同**的。

##### 明确问题的解空间

> **组合总和的解空间**不是排列树，而是**组合树**。

对于一个长度为 *n* 的数组 `candidates`，每个元素可以被选任意次。

解空间是一棵**无序组合树**：

- 每一层从当前下标 `start` 开始选择（为了避免重复组合）
- 每条路径代表一个组合
- 路径上的数字之和要等于 target

示例（candidates = [2, 3], target = 5）的一部分解空间树结构如下：

- 可以使用当前元素，并且一直重复到剪枝或者符合条件为止

```
[]
├── [2]
│   ├── [2,2]
│   │   └── [2,2,2] (sum > 5, 剪枝)-->这种情况是允许使用当前的元素的
│   └── [2,3] ✅
└── [3]
     |--[3,3] (sum>5,剪枝)
```

##### 设计回溯函数

```java
private void backtrack(int[] candidates, int start, int target, List<Integer> path)
```

- `candidates`: 原始数组

- `start`: 当前搜索起点，控制组合不重复

- `target`: 当前`剩余`目标值

- `path`: 当前组合

- 不需要 `used` 数组（和排列问题不同），因为可以重复选，且组合顺序不重要。

#####  确定终止条件

```java
if (target == 0) {
    res.add(new ArrayList<>(path));
    return;
}
if (target < 0) return; // 返回， base condition 2
```

若 `target == 0`，说明当前路径是合法解，加入结果

若 `target < 0`，提前终止这条路径（剪枝）

##### 选择列表-从start开始遍历

求组合的情况，从`start` 开始遍历：

```java
for (int i = start; i < candidates.length; i++) {
```

从 `start` 到末尾遍历

不使用已使用元素标记（区别于排列问题）

从 `start` 开始是为了避免重复组合，例如避免 [2,3] 和 [3,2] 同时出现

##### 做出选择

```java
path.add(candidates[i]);
```

- 把当前数字加入 path，表示选择这个数字

##### 递归调用 - 传递 i 而不是i+1!

```java
backtrack(candidates, i, target - candidates[i], path);
```

**关键点是传 `i` 而不是 `i+1`**，表示**当前数字可以重复使用**

状态减少为 `target - candidates[i]`

##### 撤销选择

```java
path.remove(path.size() - 1);
```

回溯时将最后一个添加的元素移除，恢复状态

##### 代码实现

```java
    List<List<Integer>> res = new ArrayList<>();
    // 并不是背包问题，注意区分动态规划和回溯
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> path = new ArrayList<>();
        backtrack(candidates, 0, path, target);
        return res;
    }

    private void backtrack(int[] candidates, int start,List<Integer> path, int target){
        if (target < 0){
            return;
        }
        if (target == 0){
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i< candidates.length; i++){
            path.add(candidates[i]);
            //当前元素可以重复，则传递 i，不传递i+1
            //元素不可以重复，则传递i+1,不传递i
            backtrack(candidates, i, path, target - candidates[i]);
            path.remove(path.size()-1);
        }
    }
```



### 回文串切割- Leetcode 131

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。返回所有可能的分割方案。

#### 组合（子集）回溯套路模板

```Java
private List<List<Integer>> res = new ArrayList<>();

private void backtrack(int nums[], int start, List<Integer> path){
  res.add(new ArrayList<>(path));
  
  for (int i=start;i<nums.length;i++){
    path.add(nums[i]);
    backtrack(nums,i+1,path);
    path.remove(path.size()-1);
  }
}
```

#### 可能的解空间

注意到题目给出的例子：

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

题目返回的是多个`集合`，每一个集合中的字符串元素拼接起来就是原来的字符串`s`,也就是说每一个集合都是一个`切割方案`.

这一点上和求子集合的算法是不一样的，子集和的算法是返回所有的子集，这里要求**每一个子集都包含`s`中的所有字符**， 也就是说每一个`path`都应该包括`s` 中所有的字符。

注意每一个字符串，实际上都可以切割为所有子串都为回文串的集合，比如 `s="abcd"`，可以切割为`["a","b","c","d"]`。

#### 回溯树的分析

```java
s=aab, path =[]
- 起点：start = 0
  - 尝试 s[0:0]="a" 是回文，进入递归 path=["a"]
    - start = 1(end=0+1)
      - 尝试 s[1:1]="a" 是回文，path=["a", "a"]
        - start = 2
          - 尝试 s[2:2]="b" 是回文，path=["a", "a", "b"]
            - start = 3 => 终止，加入结果集
      - 尝试 s[1:2]="ab" 不是回文 -> 剪枝
  - 尝试 s[0:1]="aa" 是回文，path=["aa"]
    - start = 2
      - 尝试 s[2:2]="b" 是回文，path=["aa", "b"]
        - start = 3 => 终止，加入结果集
  - 尝试 "aab" 不是回文 -> 剪枝
```

```
s=aab,path=[],start=0;
|
|-- start=0,end=0,s[0:0]="a",path=["a"]
|     |--start=end+1=1,end=1,s[1:1]="a", path=["a","a"]
|     |    |--start=end+1=2,end=2,s[2:2]="b",path=["a","a","b"]
|     |    |   |--start=end+1=3==s.length,条件终止,加入结果集，return
|     |    |-- backtrack s[2:2], path =["a","a"]
|     |--backtrack s[1:1]="a", path=["a"]
|-- backtrack s[0:0]="a", path=[]


|-- start=0,end=1,s[0:1]="aa", path=["aa"]
|.   |-- start=end+1=2,end=2,s[2:2]=["b"], path=["aa","b"]
|    |     |--start=end+1=3,条件终止，加入结果集，return
|    |-- backtrack s[2:2]="b", path=["a"]
|-- backtrack s[0:1]=["aa"], path=[]

|-- start=0, end=2,s[0:2]="aab",剪枝
|-- 递归结束，返回（for 循环结束）
```

#### 确定终止条件

当`start` 遍历完成一次`s` 的情况下，应当终止本次递归，将path 添加到结果集，返回到上一层。

```java
if (start==s.length()){
  res.add(new ArrayList<>(path));//注意深拷贝的做法
  return;
}
```

#### 选择列表

注意可以选择的列表是`s`的所有子串，当前`path`是按照当前的切割逻辑所产生的子串。

注意非技术的描述方式如下：

```
s=aab,path=[]
|
|-- start=0,end=0,s[0:0]="a", path=["a"]
|     |-- start=1,end=1,s[1:1]="a",path=["a","a"]
|     |     |-- start=2,end=2,s[2:2]="b",path=["a","a","b"]
|     |     |     |--start=3,满足条件，记录结果，返回
|     |     |-- backtrack s[2:2], path=["a","a"]
|     |     |---end=3,循环退出条件满足，返回
|     |-- backtrack s[1:1],path=["a"]     
|     |-- start=1,end=2,s[1:2]="ab",不满足条件，剪枝（continue）
|     |-- start=1,end=3,循环条件满足，返回递归
|-- backtrack s[0:0], path=[]

|--start=0,end=1,s[0:1]="aa",path=["aa"]
|    |--start=2,end =2,s[2:2]="b", path=["aa","b"]
|    |.   |--start=3,满足条件，记录结果，返回
|    |--backtrack s[2:2],path=["aa"]
|.   |-- start=2,end=3,循环条件满足，返回递归
|--backtrack s[0:1],path=[]

|--start=0,end=2,s[0:2]="aab",不满足条件，剪枝
```



#### 做出选择

如果当前的子串是回文串，则将当前的子串添加至`path`

#### 递归调用

每一次回归调用，都将`start=end+1`作为参数传入回溯函数。

```java
backtrack(nums,end+1,path);
```

#### 撤销选择

和其他的回溯函数一样，需要在一次递归完成之后，撤销选择，删除本次循环中添加的元素。

```java
path.remove(path.size()-1);
```

#### 设计回溯函数

```java
public void backtrack(String s,int start, List<String> path);
```

##### 实现代码

```java
    List<List<String>> result = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        backtrack(s, 0);
        return result;
    }

    // 回溯函数：从 start 开始切割字符串
    private void backtrack(String s, int start) {
        if (start == s.length()) {
            result.add(new ArrayList<>(path)); // 终止条件：切完了
            return;
        }
        //判断[start，start+1],[start,start+2],[start,...],[start,n-1]是否是回文串
        //如果[start....x]是回文串，中间去检查[x+1,y](y=[x+1...n-1])是否是回文串
        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) {//如果当前字符串是回文串
                // 做出选择
                path.add(s.substring(start, end + 1));
                // 递归调用
                backtrack(s, end + 1);
                // 撤销选择
                path.remove(path.size() - 1);
            }
        }
    }

    // 判断是否为回文串
    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) return false;
        }
        return true;
    }
```



### 复原IP地址：Leetcode 93

给定一个只包含数字的字符串 `s`，要将其拆分成合法的 IP 地址格式（共 4 段，每段 0~255，不能有前导 0）。

本题目中体现了回溯的三个重要的要点：

##### 如何遍历解空间以及元素？

###### 求子集合的情况

- 遍历的起点`start`, 遍历的空间为`[start....n-1]`

- 内部递归的start=外部递归的(`i+1`,`i=[start+1....n-1]`)-不允许重复使用

  ```java
  backtrack(nums,i+1,path)
   
  ```

- 内部递归的start=外部递归的`(i,i=[start,start+1...n-1])`-允许重复使用元素

  ```
  backtrack(nums,i,path);
  ```

  

###### 求全排列的情况

- 每一次递归都遍历`[0...n-1]`,基于`visited` 判定是否跳过当前元素

###### 求子串的情况

- IP地址复原：每次在从[start+1....len\] 范围之内取子串
- 回文串切割：每次在`[start...s.length-1]` 取字符串

##### 如何求元素

- 子集以及全排列的情况，集合中的元素就是元素空间
- 子串的情况，字符串中的每一个子串就是元素空间（注意需要关注元素的定义，比如IP复原的情况）

##### 如果判定终止条件

- `Path`长度超过场景规定的集合的长度或者不符合格式，应当终止，然后终止返回
- `Path`长度为场景规定的集合长度并且符合格式，应该先`将path加入到结果集`，然后终止返回

##### 如何终止遍历？

当前需要遍历的空间小于集合剩余的空间，应当`跳出(break)`遍历

##### 如何判定应当跳过当前元素

#### 解空间说明

**解空间**是一棵**4 层的回溯树**，每层表示我们要构造的第几段 IP。

每个节点尝试截取 1～3 个字符作为 IP 地址的一段。

我们要**找到所有合法路径**：共 4 段且用完所有字符。

```
s=25525511135
                          []
                   /      |      \
              [2]        [25]     [255]
             / | \        ...
      [2,5] [2,55] ...
```

每层最多 `3` 个分支，表示尝试截取 `1、2、3` 位子串。

#### 回溯函数设计

定义一个递归函数：

```java
void backtrack(String s,int start,List<String> path)
```

- `s`：输入字符串
- `start`：当前截取子串的起始索引
- `path`：当前已构造好的 IP 段（最多 4 个）

#### 终止条件

```java
if(path.size()==4 && start==s.length){
  //找到合法IP，加入结果集
  return;
}
```

枝场景：

- 如果段数已满 4 段但字符串还没用完，直接 return。
- 如果当前段是非法（如前导 0、>255），跳过。

#### 选择列表

每次可以截取：

- `s[start,start+1]`
- `s[start,start+2]`
- `s[start,start+3]`

前提是`别越界`，且`是合法 IP 段`。

#### 左选择->递归->撤销

```java
path.add(segment);
backtrack(s,start+len,path);
path.remove(path.size()-1);
```

#### 代码实现

```java
    private List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {

        List<String> path = new ArrayList<>();
        backtrack(s, 0, path);
        return res;

    }

    private void backtrack(String s, int start, List<String> path){
        //收集到的数字大于4，不符合条件
        if (path.size()>4){
            return;
        }
        //收集完了，并且正好收集到四个数字
        if (start==s.length() && path.size()==4){
          //添加新的IP地址
            res.add(String.join(".", path));
            return;
        }
        //从start开始，遍历一位数/二位数/三位数
        for (int len=1; len<=3;len++){
            //如果越界，剪枝
            if(start+len>s.length()) break;
          
            String str = s.substring(start,start+len);
            //如果str长度>=2并且以0开头，则直接跳过
            //换句话说，如果不是一位数，并且还以0开头了，应该剪枝
            if (str.startsWith("0") && str.length()>1){
                continue;
            }
            //如果大于255了，剪枝
            if (Integer.parseInt(str)>255){
                continue;
            }
						//选择+回溯
            path.add(str);
          	//继续计算start+len开始的字符串是否符合条件
            backtrack(s, start+len, path);
            path.remove(path.size()-1);
        }
    }
```

### 单词搜索-Leetcode 79

给定一个二维字符网格和一个目标字符串，判断是否可以从某个起点出发，按上下左右移动，在网格中拼出这个字符串。

#### 解空间是什么？

解空间是一棵`树` 或者是`图`，每个节点代表当前位置`[i,j]`和当前匹配的字符`word[k]`。

我们可以把问题堪称是在矩阵上构建一条长度为`word.length()`的路径，路径上的每个格子**不能重复**。

#### 设计回溯函数的三个要素

我们使用`dfs`+`回溯函数`来实现.

##### 函数定义

```java
boolean dfs(char[][] board,int i,int j,int k){
...
}
```

这个函数含义是：从`board[i][j]` 出发，判断是否可以匹配`word[k]` 到 `word[word.length()-1]`

##### 终止条件

- 如果`k==word.length()`,说明**已经匹配完所有字符**，返回`true`;
- 如果当前位置越界，或者字符不匹配，或者该位置已经使用过，返回`false`;

##### 回溯过程设计

- 当前位置匹配后，尝试上下左右四个方向递归匹配下一个字符;
- 为避免重复方位当前壳子，可以临时将其匹配为特殊字符（例如`#`）,搜索完成以后回复原值；

#### 代码实现

```java
public boolean exist(char[][] board, String word){
  int rows = board.length;
  int cols = board[0].length;
  
  for(int i=0;i<rows;i++){
    for(int j=0;j<cols;j++){
      if (dfs(board,word,i,j,0)){
        return true;
      }
    }
  }
  return false;
}
/**
* word的第k...n-1个字符是否和board[i...m][j...n]匹配
*/
private boolean dfs(char[][] board, String word,int i,int j,int k){
  // 越界，返回
  if (i<0||i>=board.length||j<0||j>=board[0].length) return false;
  // 不匹配，返回
  if(board[i][j] != word.charAt(k)) return false;
  //如果匹配并且是最后一个字符，返回true
  if (k==word.length()-1) return true;
  
  //做选择：标记为已访问
  char temp = board[i][j];
  board[i][j]='#';
  //上下左右四个方向分别匹配
  boolean result = dfs(board,word,i+1,j,k+1)
    || dfs(board,word,i,j+1,k+1)
    || dfs(board,word,i-1,j,k+1)
    || dfs(board,word,i,j-1,k+1);
  //回溯，恢复原值
  board[i][j]=temp;
  return result;
}
```











### 总结：组合和排列问题的异同

| 回溯维度        | 组合总和                      | 全排列                          |
| --------------- | ----------------------------- | ------------------------------- |
| 解空间结构      | 组合树（无序，数字可重复）    | 排列树（有序，数字不可重复）    |
| 是否可重复选    | ✅ 是                          | ❌ 否                            |
| 是否需要 used[] | ❌ 不需要                      | ✅ 需要                          |
| 控制重复方式    | 用 `start` 控制从当前位置继续 | 用 `used[i]` 控制元素是否使用过 |
| 终止条件        | `target == 0`                 | `path.size() == nums.length`    |

# 回溯法解题思路

## 先问自己几个问题

#### 解空间是什么（排列/组合/子集）？

#### 是否有重复元素？ 是否需要去重？

##### 从start开始遍历放防止出现重复的组合或者子集

`for i in range(start, len(nums))` → 用来防止重复组合

##### 怎样跳过重复的元素？

`if i > start and nums[i] == nums[i - 1]` → 组合/子集去重的关键

#### 每一层选哪个范围（start or 全部）？

#### 顺否有顺序要求？

##### 没有顺序要求-从当前元素开始遍历

##### 有顺序要求-从第一个元素开始遍历

#### 何时收集结果？（路径长度？target？全用完？）

**调试卡住时加打印：**

- `print("path:", path, "start:", start)`
- 很多时候一看路径或剪枝条件就明白 bug 在哪了。

##回溯法解题思路

对于求数组的全排列问题，回溯法是一种非常合适的解决方法。回溯法的核心思想是通过深度优先搜索的方式，逐步构建可能的排列，当发现当前构建的排列不符合要求或者已经构建出一个完整的排列时，就回溯到上一步，尝试其他的选择。

#### 1. 明确问题的解空间

对于一个长度为 *n* 的数组 `nums`，其全排列的解空间是由所有可能的 *n* 个元素的排列组合构成的。可以将这个解空间看作是一棵排列树，树的每个节点代表一个部分排列，从根节点到叶子节点的路径就构成了一个完整的排列。

#### 2. 设计回溯函数

设计一个递归的回溯函数 `backtrack`，该函数需要以下几个参数：

- `path`：用于存储当前已经构建好的部分排列。
- `used`：一个布尔数组，用于标记数组 `nums` 中的每个元素是否已经在当前排列中被使用过。
- `result`：用于存储最终的所有全排列结果。

#### 3. 确定终止条件

当 `path` 的长度等于数组 `nums` 的长度时，说明已经构建出一个完整的排列，将这个排列添加到 `result` 中。

#### 4. 选择列表

对于当前的部分排列 `path`，选择列表是数组 `nums` 中还未被使用过的元素。通过遍历 `nums` 数组，根据 `used` 数组来判断元素是否可用。

#### 5. 做出选择 - 也是为下一层递归准备现场！

在选择列表中选择一个元素，将其添加到 `path` 中，并将该元素对应的 `used` 标记设为 `True`，表示该元素已被使用。

#### 6. 递归调用

对选择后的 `path` 进行递归调用，继续构建排列。

#### 7. 撤销选择 - 完成下一层递归以后恢复现场！

在递归返回后，撤销上一步的选择，即将该元素从 `path` 中移除，并将该元素对应的 `used` 标记设为 `False`，以便尝试其他可能的选择。

##常见题型应对策略

**回溯算法是一种暴力枚举所有解的思想，但通过“剪枝”避免无效路径，从而提升效率。**

其本质是：

- 在解空间树中**深度优先搜索（DFS）**所有可能的解法路径；
- 如果当前路径不合法则**回退**；
- 并**继续尝试其他可能性**；

| 问题类型          | 场景描述            | 目标                   | 顺序限制 | 解空间结构         | 遍历逻辑                       | 终止条件                            | 剪枝条件                     | 状态记录方式                   | 结果存储方式             |
| ----------------- | ------------------- | ---------------------- | -------- | ------------------ | ------------------------------ | ----------------------------------- | ---------------------------- | ------------------------------ | ------------------------ |
| 子集 Subsets      | 给定集合求所有子集  | 所有子集               | 无       | 树（选/不选）      | 从 index 起递归                | 遍历完所有元素                      | 可选：跳过重复元素           | path                           | 每一层都加入 path        |
| 组合 Combinations | 选 k 个不重复元素   | 所有大小为 k 的组合    | 无       | 树（index 控制）   | for (i = start...)             | path.size == k                      | 剩余元素不足 k               | path + start                   | 满足大小为 k 时加入      |
| 排列 Permutations | 所有排列方式        | 所有长度为 n 的排列    | 有       | 树（每层选择一个） | 枚举所有未使用元素             | path.size == n                      | used[i] == true 或跳重       | boolean[] used                 | 满足条件加入 path        |
| 分割 Partition    | 字符串合法切割      | 所有满足条件的切割方式 | 有       | 树（substring）    | 尝试所有 substring(start, i+1) | start == s.length()                 | 子串不满足条件（如不是回文） | start + path                   | 完成切割加入 path        |
| 棋盘 N皇后/数独   | 棋盘放置棋子/填数   | 所有合法放置方案       | 有       | 网格（二维）       | 每一行/空格递归                | 所有行/格子处理完                   | 位置冲突/数独不合法          | col/diag/row/九宫格            | 构造棋盘或原地填充       |
| 路径 Path         | 迷宫/图中找路径     | 判断路径存在/列出路径  | 有       | 网格/图            | DFS四方向或邻接点              | 达到目标位置/路径长度够             | 越界、重复访问               | visited 或原地标记             | 满足路径后加入 res       |
| 数字填充 Sudoku   | 数独等填数字        | 找到一个合法填法       | 有       | 网格               | 从左上到右下填数字             | 全部格子填完                        | 数字冲突                     | 行列宫的合法性                 | 修改 grid 原地填         |
| 构造表达式        | 表达式求值为 target | 所有结果为目标的表达式 | 有       | 树（字符串组合）   | 每次切出子串+符号              | index == num.length 且 calc==target | 前导 0、溢出等非法情况       | 递归参数中记录 calc 和 prevNum | 满足目标加入表达式字符串 |

##排列类-找出所有的排列

在给定集合中，生成所有的排列方式（**元素有顺序**）

##### 元素的顺序限制

全排列中的元素内容是一样的，但是元素的顺序不一样。

因此如果两个排列中的元素顺序不一样，他们应该被视为两个不同的解。

###### 如何确保有顺序要求的情况？

##### 遍历逻辑： 从`nums[0]`开始！不需要记录start

元素的遍历**从第一个元素**开始，而不是从**当前元素**。

##### 解空间：每一层可以选择任意还未使用的元素

##### 终止条件：path size == length

`path.size == nums.length`

##### 状态记录方式 - 必须使用visited来防止重复访问！

`boolean[] used`

##### 结果存储

满足条件加入`res`

##### 代码套路模板

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> permute(int[] nums){
  boolean[] used = new boolean[nums.length];
  backtrack(nums, new ArrayList<>(), used);
  return res;
}

private void backtrack(int[] nums,List<Integer> path, boolean[] used){
  if (path.size == nums.length){
    res.add(new ArrayList<path>);
    return;
  }
  //排列的情况下每一次都从元素0开始遍历
  for (int i=0; i<nums.length; i++){
    //如果元素i已经使用过了，剪枝
    if (used[i]) continue;
    
    //回溯过程
    //加入当前元素
    used[i] = true;
    path.add(nums[i]);
    //递归调用回溯
    backtrack(nums[], pathm used);
    //删除当前元素
    used[i] = false;
    path.remove(path.size()-1);
  }
}
```

##### 判定continue

- 元素已经被使用过`used[i]==true` 跳过
- 如果有元素重复，通常加入去重条件`i>0 and nums[i]==nums[i-1] and !used[i-1]`

##组合类-选择符合条件的子集合

- 从集合中选择 k 个元素组成所有组合（无重复）
- 从集合中选择总和为某个数字的所有组合

##### 顺序限制：无

没有顺序限制的情况下说明，**元素内容相同但是顺序不同的子集，将会视为同一个解**。

没有顺序要求的情况下，**不需要记录元素是否已访问visited[]**

这种情况下，需要从**当前元素开始遍历**：

```java
for (int i= start; i< nums.length; i++){
//...
}
```

##### 终止条件 

`path.size == k`

##### 剪枝条件

剩余元素数量不足时候，可以跳过。

`k-path.size()`

##### 状态记录方式

- **当前元素的位置：** `start`
- **当前的路径:**`path`

##### 注意看元素是否可以选择多次

- 如果可以选择多次，则传递`i`作为回溯参数
- 如果不能够选择多次，则传递`i+1`作为回溯参数

##### 代码套路模板

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> combine(int[] nums, int k){
  backtrack(0,nums,k,new ArrayList<>());
  return res;
}

private void backtrack(int start, int nums, int k, List<Integer> path){
  if (path.size() == k){
    
    res.add(new ArrayList<>(path));
    return;
  }
  //没有顺序要求，从当前元素开始遍历
  //本质上是每一次从元素[start]开始向后寻找剩余的几个元素
  //因此准备现场的做法是在循环内处理的
  //也不需要标记visited
  for (int i=start; i< nums.length; i++){
    path.add(nums[i]);
    backtrack(i+1, nums,k,path);
    path.remove(path.size()-1);
  }
}
```

### 注意事项和经验总结

#### 怎样防止重复问题？

##### 对元素进行预先排序

##### 对于重复元素进行剪枝

```java
for(int i = start; i < candidates.length;i++){
  //去重剪枝逻辑
  if(i > start && candidates[i] == candidates[i-1]) continue;
  //其他逻辑
  ...
}
```



## 子集类-生成所有子集

生成所有子集，包括**空集和全集**。

##### 顺序限制：无

**没有顺序限制**的情况下：

- 从当前元素开始遍历

  ```java
  for (int i=start; i< nums.length; i++){
  //....
  }
  ```

- 不需要**已访问记录visited**

##### 终止条件：已经遍历到集合结束

##### 剪枝条件：无

##### 状态记录方式：path

##### 套路模板代码

```java
List<List<Integer>> res = new ArrayList<>();

private backtrack(int start, int nums,List<Integer> path){
  //将当前path加入结果，无需终止
  res.add(new ArrayList<>(path));
  
  for (int i= start; i< nums.length; i++){
    path.add(nums[i]);
    
    backtrack(i+1,nums,path);
    
    path.remove(path.size()-1);
  }
}
```

##分割类（回文串分割，字符串分割）

将字符串分割为多个子串，每个子串满足特定性质（如是回文）。

目标为：**找出所有合法分割方式。**

##### 解空间选择

每一层尝试所有的切割位置

##### 顺序限制：不算有？

##### 遍历逻辑

**遍历逻辑**：尝试每一个 `substring(start, i+1)`。

```java
for(int i=start+1;i<s.length();i++){
	String currentStr = s.substring(start,i+1);
  ...
}
```

##### 判定剪枝

当前子串不满足要求（不是回文），则剪枝

##### 判定终止

`start==s.length()`时字符串被切万，加入结果

##### 代码套路模板

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> partition(String s){
  backtrack(s,0,new ArrayList<>());
  return res;
}

private void backtrack(String s, int start, List<String> path){
  // 一轮切割完成，加入结果
  if (start == s.length()){
    res.add(new ArrayList<>());
    return;
  }
  // 从当前位置开始遍历
  for (int i=start; i < s.length; i++){
    //获取当前子串
    String substrate = s.substring(start,i+1);
    //如果当前子串是回文，回溯
    if (isPalindrome(substr)){
      path.add(substr);
      backtrack(s,i+1,path);
      path.remove(path.size()-1);
    }
  }
}
```

### Leetcode 93: 复原IP地址

#### 问题描述

给定一个只包含数字的字符串 `s`，返回所有可能的有效 IP 地址组合。有效的 IP 地址由四个整数组成，每个整数位于 0 到 255 之间，且不能有前导零（除了数字 0 本身）。四个整数之间用点 `.` 分隔。

**示例:**

- **输入:** `s = "25525511135"`
- **输出:** `["255.255.11.135"]`
- **输入:** `s = "0000"`
- **输出:** `["0.0.0.0"]`
- **输入:** `s = "101023"`
- **输出:** `["1.0.10.23", "1.0.102.3", "10.1.0.23", "10.10.2.3", "101.0.2.3"]`

#### 问题要点

- **输出格式：** 最终结果是所有合法IP地址字符串的列表
- **IP地址结构：** `A.B.C.D`，**由4个段组成**
- **段的有效性：**
  - 每一个段是一个0到255之间的整数
  - **无前导0:**`01`/`007`都是非法的
  - **唯一的例外：**单个`0`是合法的
- **完整性：**必须用完输入的字符串`s`中的所有数字，不多不少
- 输入的字符串约束：
  - 只包含数字`0-9`
  - 长度`s.length()`必须在4到12之间。如果长度小于4或者大于12，不可能构成合法的IP地址，这是一个重要的剪枝条件

#### 问题的本质和分析

这个问题属于**字符串的分割问题**。我们需要在给定的数字字符串`s`中插入3个点，将其分割成4个部分，并验证这4个部分是否都满足IP地址段的规则。

由于我们需要找到**所有可能的组合**，而不是仅仅一个，这强烈暗示了需要使用**搜索算法**，特别是**深度优先搜索**或者是**回溯**。

我们可以把这个问题想象成在一个**决策树**上进行搜索。

- 在字符串的开头，我们决定第一段的长度（1、2或者3）
- 做出选择以后，我们对剩余的字符串递归的进行同样的操作，决定第二段的长度
- 以此类推，直到找到4段或者发现当前路径不合法

#### 模式识别 - DFS + 回溯

- **求所有的组合/解集：**问题要求返回所有可能的组合
- **分步骤决策：**解决问题的过程可以分解为一些列的步骤/选择，在这里，每一步是**确定IP地址的一个段**
- **约束条件：**每一步的选择都收到严格的约束（0-255，没有前导0）

这和Leetcode上的其他经典回溯题非常相似，例如

- 求子集
- 全排列
- 组合总数
- N皇后

它们的共同套路都是通过一个递归函数来探索所有可能的路径，并在路径不合法时“退回”一步（即回溯），尝试其他选择。

#### 考察点

**算法设计:** 对回溯算法的理解和实现能力。

**递归思维:** 将大问题分解为小规模的相同子问题的能力。

**字符串处理:** 熟练使用字符串的截取 (`substring`)、转换 (`Integer.parseInt`) 和字符访问 (`charAt`)。

**逻辑严谨性:** 对各种边界条件和约束（特别是前导零）的处理是否周全。

**代码实现能力:** 能否将算法思想清晰、无误地转换为代码。

#### 核心思想和套路： DFS + 回溯

##### 定义一个回溯函数backtrack

`private void backtrack(startIndex, path)`

- `startIndex`:当前处理的字符串在原字符串中的**起始索引**
- `path`: 一个列表，用于存储已经确定的IP地址段

##### 设置递归的终止条件

**成功条件:** 如果已经找到了 4 个段 (`path.size() == 4`) **并且** 已经用完了整个字符串 (`startIndex == s.length()`)，说明找到了一个合法的 IP 地址。将其格式化（用 `.` 连接）后加入结果集。

**失败条件:** 如果 `path.size() == 4` 但 `startIndex < s.length()`，或者 `startIndex == s.length()` 但 `path.size() < 4`，说明当前路径无效，直接返回。

##### 实现递归循环与选择

- 从`startIndex`开始，遍历所有可能的**段结束位置**，一个段的长度可以是1、2或者3.
- 循环`i`从`startIndex`到`startIndex+2`，并且`i`不能越界
- 在循环中，截取字符串`segment = s.substring(startIndex,i+1)`。
- 验证选择：检查`segment`是否合法：
  - 长度大于1且以`0`开头，非法
  - 解析为整数后大于255，非法
- 做出选择：如果`segment`合法：
  - 将segment加入path
  - 深入搜索:递归调用`backtrack(i+1,path)`，从下一个位置继续寻找下一段
- 撤销选择： 递归调用返回以后，必须将`segment`从path中移除，以搜索其他可能性:`path.remove(path.size()-1)`

#### 难点分析和应对

##### 难点一：处理前导零

**描述:** 这是最容易出错的地方。"0" 是合法的，但 "01", "010", "00" 都是非法的。

**应对:** 在验证段的有效性时，增加一个明确的检查：如果段的长度大于 1 并且第一个字符是 `'0'`，则该段无效。

##### 难点二：确定递归的终止条件和剪枝

**描述:** 如何确保在正确的时间停止搜索，并且避免不必要的计算。

**正确终止:** 如上所述，成功和失败的 base case 要定义清晰。

**有效剪枝 (Pruning):**

- 在递归函数的开头，可以加入一个剪枝逻辑：如果剩余的字符数量对于构成剩余的段来说太多或太少，就直接返回。
  - 剩余字符数：`s.length() - startIndex`
  - 剩余段数：`4 - path.size()`
  - 如果 `s.length() - startIndex > (4 - path.size()) * 3` (剩余字符太多)，剪枝。
  - 如果 `s.length() - startIndex < (4 - path.size()) * 1` (剩余字符太少)，剪枝。

##### 难点三： 循环边界的控制

**描述:** 在 for 循环中截取子串时，很容易出现索引越界 (`StringIndexOutOfBoundsException`)。

**应对:** 循环条件必须同时检查 `i` 是否小于 `s.length()`。例如，`for (int i = startIndex; i < startIndex + 3 && i < s.length(); i++)`。

#### 实现原理和详细步骤

##### 步骤1: 主函数的设计

- 初始化一个 `List<String> result` 用于存放最终结果。

- 进行初步检查：如果 `s` 的长度不在 `[4, 12]` 区间内，直接返回空的 `result`。

- 调用回溯辅助函数 `backtrack(s, 0, new ArrayList<>(), result)`。

- 返回 `result`。

##### 回溯函数的设计

###### Base condition : 剪枝/终止

- 如果 `path` 中已经有 4 个段：
  - 如果 `startIndex` 正好等于 `s.length()`，说明找到了一个完整合法的 IP。用 `String.join(".", path)` 格式化并添加到 `result`。
  - 然后 `return`，因为不能再添加更多段了。
- 如果 `startIndex` 已经到达字符串末尾但 `path` 不足 4 段，也直接 `return`。

###### 循环和选择

- 设置一个循环，尝试从 `startIndex` 开始截取长度为 1、2、3 的段。

  `for (int i = startIndex; i < startIndex + 3 && i < s.length(); i++)`

###### 截取和验证

- `String segment = s.substring(startIndex, i + 1);`
- 验证`segment`:
  - **前导零检查:** `if (segment.length() > 1 && segment.charAt(0) == '0') { break; }` (如果以'0'开头，那么所有更长的段也都会以'0'开头，可以直接跳出循环)。
  - **数值范围检查:** `if (Integer.parseInt(segment) > 255) { continue; }` (如果当前段无效，继续尝试下一个短一点的段)。

###### 递归和回溯

如果 `segment` 验证通过：

1. `path.add(segment);` // 做出选择
2. `backtrack(s, i + 1, path, result);` // 深入探索
3. `path.remove(path.size() - 1);` // 撤销选择

#### 实现代码

```java
    private List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        int n = s.length();
        if(n < 4 || n > 12) return new ArrayList<>();

        List<String> path = new ArrayList<>();
        backtrack(s, 0, path);
        return res;
    }

    private void backtrack(String s, int start, List<String> path){
        if(start == s.length() && path.size() == 4){
            String ip = String.join(".", path);
            res.add(ip);
            return;
        }
        if(path.size() > 4) {
            return;
        }
        if (start >= s.length()){
            return;
        }

        for(int i = start; i < start + 3 && i < s.length(); i++ ){
            String segment = s.substring(start, i+1);
            //前导0检查
            if (segment.length() > 1 && segment.startsWith("0")){
                continue;
            }
            //验证是否大于255
            int num = Integer.parseInt(segment);
            if(num > 255) continue;

            path.add(segment);
            backtrack(s, i+1, path);
            path.remove(path.size() - 1);
        }
    }
```

#### 注意事项

1. **字符串与整数转换:** `Integer.parseInt()` 会抛出 `NumberFormatException`，但在此题的约束下（输入只包含数字），且我们已经限制了段长，几乎不会发生。
2. **数据结构选择:** 使用 `ArrayList<String>` 来存储路径 (`path`) 是一个不错的选择，因为它提供了方便的 `add` 和 `remove(index)` 操作，非常适合回溯。
3. **结果格式化:** `String.join(".", path)` 是一个非常优雅和高效的方式来将路径列表转换为最终的点分十进制字符串。
4. **剪枝的威力:** 虽然没有剪枝也能得到正确答案，但加上剪枝（特别是检查剩余字符数的剪枝）可以显著减少不必要的递归调用，提高算法效率，是面试中的加分项。

#### 经验总结

LeetCode 93 是一个典型的、标准的回溯问题。它完美地展示了回溯算法“选择-探索-撤销”的核心思想。

- **识别模式是关键:** 一旦识别出这是回溯问题，就可以套用通用的回溯模板来解决。
- **细节决定成败:** 问题的难点不在于算法思想，而在于对各种约束条件的细致处理，尤其是“前导零”和“0-255”这两个规则。
- **举一反三:** 彻底理解此题的解法，有助于解决一大类组合、分割、排列问题。练习的重点是：
  - 如何定义递归函数的状态（参数）。
  - 如何确定递归的终止条件。
  - 如何在循环中做出选择和验证。
  - 如何进行回溯（撤销选择）。

##棋盘类/约束类（N皇后、数独）：排列+约束

### 问题要点

**输入：** 一个整数`n`，表示一个大小为$N\times N$的正方形棋盘，并且需要放置N个皇后

**输出：** 一个`List<List<String>>`,每一个`List<String>`表示一个有效的棋盘布局。

**约束：**

- **行約束**: 每一行只能有一個皇后。
- **列約束**: 每一列只能有一個皇后。
- **對角線約束**: 每一條主對角線和副對角線上最多只能有一個皇后。

### 问题的本质和分析 - 带约束的组合搜索问题

我们需要在巨大的可能性中(在N个个字中选择$N\times N$ 个位置)，找出所有满足约束条件的组合。

如果使用暴力方法，从$N^2$个格子中找出N个位置，则总共有$C_{N^2}^N$ 中组合，这个数组算天文数字级别的，会导致超时。

因此我们需要一种聪明的搜索方法，能够在搜索过程中动态的剪枝无效的分支。

这正是回溯算法的用武之地。

### 模式识别 - DFS回溯算法

**求解所有可能的解，而非單一解或最優解**：題目要求返回所有解決方案。

**涉及決策序列 (Sequence of Choices)**：我們需要為第一行決定一個皇后的位置，然後為第二行決定，以此類推。

**約束條件 (Constraints)**：每做一個決策，都需要檢查是否違反了約束。如果違反，則此路不通，需要退回上一步，嘗試其他選擇。

這類問題的常規套路就是使用深度優先搜索（DFS）的思想，結合 "選擇 -> 遞歸 -> 撤銷選擇" 的回溯框架。N-Queens 是回溯算法最經典的教學案例之一。

### 考察点

1. **算法識別能力**: 能否識別出這是一個典型的回溯問題。
2. **遞歸思維**: 能否熟練地設計和實現遞歸函數，包括定義遞歸的參數、終止條件和遞歸邏輯。
3. **狀態管理**: 如何有效地表示和更新棋盤的狀態（例如，哪些列、哪些對角線已被佔用）。這是優化性能的關鍵。
4. **問題分解能力**: 能否將「在 N x N 棋盤放 N 個皇后」這個複雜問題，分解為「在第 `k` 行放一個皇后」這個子問題。
5. **代碼實現細節**: 能否處理好棋盤的表示、結果的格式化、以及回溯時狀態的正確還原。

### 核心思想和套路

核心思想是按照行进行放置，从第0行还是，尝试在该行的每一列放置一个皇后。

- 如果当前位置`(row,col)`是有效的（不与之前放置的任何皇后冲突），我们就将皇后放在这里。
- 然后递归的解决下一行(`row+1`)的问题
- 如果下一行的所有尝试都**失败**了，说明当前放置`(row,col)`是死路一条，我们需要
  - 回溯，即撤销在`(row,col)`放置的皇后，
  - 然后尝试在`row`行的下一列进行尝试

#### 具体的套路

1. **終止條件 (Base Case)**: 如果 `row == n`，說明我們已經成功地在 0 到 `n-1` 行都放置了皇后。這是一個有效的解決方案。將當前棋盤佈局格式化後加入結果集，然後返回。
2. **遍歷選擇 (Iterate through Choices)**: 在當前行 `row`，從第 0 列到第 `n-1` 列進行遍歷 `for (int col = 0; col < n; col++)`。
3. **做出選擇 (Make a Choice)**:
   - 檢查在 `(row, col)` 放置皇后是否合法。
   - 如果合法：
     - 將皇后放置在 `(row, col)`。
     - 更新狀態（標記該列和相關的對角線為已佔用）。
     - 遞歸調用 `backtrack(row + 1)` 進入下一行決策。
4. **撤銷選擇 (Undo the Choice / Backtrack)**:
   - 將 `(row, col)` 的皇后移除。
   - 還原狀態（取消對該列和對角線的佔用標記），以便為當前行的下一個 `col` 或者上層遞歸的其他分支做準備。

### 难点分析和应对

#### 难点 1: 如何高效地檢查位置合法性？

使用額外的空間來記錄狀態，將檢查時間降至 O(1)

#####**列 (Columns)**:

 用一個布爾數組 `boolean[] cols`，大小為 `n`。`cols[j] = true` 表示第 `j` 列已被佔用。

#####**如何判断格子所在的主对角线？**

观察之后会发现：

- 处于同一个对主角线的格子`(r,c)`， 它们的`r-c`值是固定的；
- 一个$N\times N$的正方形有`2N-1`条主对角线
- 为了防止出现负数的索引，我们使用`row-col+(n-1)`表示当前格子所在的主对角线的索引。
- 我们可以使用一个数组来`boolean diag1[2n-1]`来表示每个主对角线是否已经有皇后了

##### 如何判断格子所在的副对角线？

处于同一个副对角线上的格子，它们的`(r+c)`是固定的。

我们可以使用一个数组`boolean diag2[2n-1]`来表示每个副对角线是否已经有皇后了。

每一个格子`(row,col)`对应的副角线索引为`row+col`

#### 难点 2: 结果的格式化

- 在递归过程中，我们通常使用`char[][]`来表示棋盘，方便修改
- 在找到一个解（`row == n`）时，需要将`char[][]`转换为`List<String>`的格式，这需要一个辅助函数完成

###实现原理和步骤

#### 初始化

```java
//初始化棋盘
char[][] board = new char[n][n];
//所有格子初始化为.
for(int i = 0; i < n; i++){
  Arrays.fill(board[i],'.');
}

//初始化列 cols[i]表示第i列是否已经有皇后
boolean[] cols = new boolean[n];

//初始化主对角线,diag1[i]表示对角线i是否已经有皇后
boolean[] diag1 = new boolean[2n-1];

//初始化副对角线,diag2[i]表示副对角线i是否已经有皇后
boolean[] diag2 = new boolean[2n-1];
```

#### 回溯函数的设计

**Base Case**: 如果 `row == n`，表示找到一個完整解。

- 調用一個輔助函數 `generateSolution(board)` 將 `char[][]` 轉換為 `List<String>`。
- 將該解 `add` 到 `result` 中。
- 返回。

**遍歷當前行的所有列**: `for (int col = 0; col < n; col++)`

- 計算對角線索引：`d1 = row - col + n - 1`, `d2 = row + col`。
- **檢查合法性**: 如果 `cols[col]`, `diags1[d1]`, `diags2[d2]` 全都是 `false`，說明 `(row, col)` 位置可用。
- **做選擇**:
  - `board[row][col] = 'Q'`。
  - `cols[col] = true`, `diags1[d1] = true`, `diags2[d2] = true`。
  - **遞歸**: `backtrack(row + 1, ...)`。
- **撤銷選擇 (Backtrack)**:
  - `board[row][col] = '.'`。
  - `cols[col] = false`, `diags1[d1] = false`, `diags2[d2] = false`。

**返回結果**: 所有遞歸結束後，返回 `result`。

```java
    private void backtrack(char[][] board, int row, boolean[] cols, boolean[] diag1, boolean[] diag2){
        int n = board.length;
        if(row == n){
            res.add(constructBoard(board));
            return;
        }

        for(int col = 0; col < n ; col ++){
            if(cols[col] || diag1[row-col+n-1] || diag2[row + col]) {
                continue;
            }

            board[row][col] = 'Q';
            cols[col] = true;
            diag1[row - col + n - 1] = true;
            diag2[row + col] = true;
            backtrack(board, row+1, cols, diag1, diag2);

            board[row][col] = '.';
            cols[col] = false;
            diag1[row - col + n - 1] = false;
            diag2[row + col] = false;
        }
    }
```

### 实现代码

```java
class Solution {
    //属于DFS回溯方法
    //枚举所有的放置方案，n个皇后放完为止
    private List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for(int i = 0; i < n; i++){
            Arrays.fill(board[i], '.');
        }

        boolean[] cols = new boolean[n];
        boolean[] diag1 = new boolean[2*n-1];
        boolean[] diag2 = new boolean[2*n - 1];
        backtrack(board, 0, cols, diag1, diag2);
        return res;
    }
    private void backtrack(char[][] board, int row, boolean[] cols, boolean[] diag1, boolean[] diag2){
        int n = board.length;
        if(row == n){
            res.add(constructBoard(board));
            return;
        }

        for(int col = 0; col < n ; col ++){
            if(cols[col] || diag1[row-col+n-1] || diag2[row + col]) {
                continue;
            }

            board[row][col] = 'Q';
            cols[col] = true;
            diag1[row - col + n - 1] = true;
            diag2[row + col] = true;
            backtrack(board, row+1, cols, diag1, diag2);

            board[row][col] = '.';
            cols[col] = false;
            diag1[row - col + n - 1] = false;
            diag2[row + col] = false;
        }
    }

    private List<String> constructBoard(char[][] board){
        List<String> res = new ArrayList<>();
        for (int i = 0; i < board.length; i++){
            res.add(new String(board[i]));
        }
        return res;
    }
}
```

### 注意事项

**状态的恢复**: 回溯的核心在於「撤銷選擇」。在遞歸調用返回後，一定要將對狀態數組和棋盤所做的修改完全恢復，否則會影響後續的搜索路徑。

**對角線索引**: 理解 `row - col` 和 `row + col` 作為對角線唯一標識的原理是優化的關鍵。同時，要小心處理 `row - col` 可能產生的負數索引，通過加上一個偏移量 `n - 1` 將其映射到非負整數域。

**解的複製**: 在找到一個解並將其加入結果列表時，必須創建一個新的 `List<String>` 對象。不能直接添加 `board` 的引用，因為 `board` 在後續的回溯過程中會被修改。`generateSolution()` 函數自然地處理了這個問題，因為 `new String(charArray)` 會創建新的字符串對象。

| 点               | 说明                                             |
| ---------------- | ------------------------------------------------ |
| 列不能重复       | 因为一行只能放一个皇后，所以列冲突要避免         |
| **主对角线计算** | `row - col + n`，加上偏移 n 是为了防止负数索引   |
| **副对角线计算** | `row + col`，范围 [0, 2n-2]                      |
| 回溯撤销顺序     | 撤销顺序必须和选择顺序完全一致，确保路径正确还原 |

### 经验总结

- 属于典型的**排列型回溯**，每一行对应一次选择
- 三个冲突判断可以提升效率（列/对角线剪枝）
- 面试中常问 follow-up：
  - 如何统计所有解的数量（修改返回类型，略去保存路径）
  - 如何用位运算优化空间和速度（进阶技巧）
- **解空间大小为 O(n!)**，但通过剪枝大大减少无效尝试
- **N-Queens 是回溯算法的 "Hello World"**: 掌握了它，就等於掌握了回溯算法的基本框架。這個框架可以應用於其他許多組合搜索問題，如解數獨 (Sudoku Solver)、排列 (Permutations)、組合 (Combinations)、子集 (Subsets) 等。

  **空間換時間**: 使用 `cols`, `diag1`, `diag2` 數組是典型的「空間換時間」策略。它將每次 O(N) 的合法性檢查降至 O(1)，極大地提升了算法的效率。

  **可視化思考**: 在腦中或草稿紙上畫出 4times4 的棋盤，手動走一遍回溯的過程，有助於深刻理解遞歸和回溯的每一步是如何工作的。

## 路径问题-DFS+回溯

从网格中找出是否存在给定路径或者单词。

##### 顺序限制：有

##### 解空间结构

网格 DFS 遍历。

##### 遍历逻辑

从每个点向上下左右搜索。

##### 终止条件

**终止条件**：当前路径长度等于目标长度。

##### 剪枝条件

访问越界或重复访问。

##### 状态记录方式

visited 数组或原地修改

##### 结果记录

找到完整路径后立即返回/记录

##### 代码套路模板

```java
public boolean exist(char[][] board, String word){
  int m = board.length; 
  int n = board[0].length;
  
  for (int i=0; i<m; i++){
    for (int j = 0; j < n; j++){
      if (dfs(board,word, i,j,0)) return true;
    }
  }
  
  return false;
}

private boolean dfs(char[][] board, String word,int i, int j, int k){
  //如果越界了则终止，返回 false
  if (i<0 || i>= board.length || j<0 || j>= board[0].length
     || board[i][j] != word.charAt(k)){
    return false;
  }
  //找到单词了,终止，返回true;
  if (k== word.length()-1){
    return true;
  }
  
  int dirs = {{0,1},{1,0},{0,-1},{-1,0}};
  //通过修改值的方式将board[i][j]标记为visited
  char temp = board[i][j];
  board[i][j] = '#';
  
  boolean res = false;
  for (int[] dir : dirs){
    int ni = i + dir[0];
    int nj = j + dir[1];
    res = res || dfs(board,word,ni,nj,k+1);
  }
  
  board[i][j] = temp;

  return res;
  
}
```

###Leetcode 756 金字塔矩阵转换 - 双重回溯

#### 问题要点

##### 输入数据

- 一个字符串`bottom`: 代表金字塔的底层
- 一个字符串列表`allowed`, 其中每个字符串都是长度为3的规则

##### 规则

`allowed`中的一个字符串代表一个规则，比如`ABC`代表`A`和`B`的方块，可以支撑起一个`C`方块在它们上面。

即`C`可以放在`AB`的上面。

##### 构建过程 - 自底向上

- 从`bottom`层开始，逐层向上构建
- 上一层的长度会比当前层少1
- 对于当前层的每个相邻的方块`(cur[i],cur[i+1])`，我们需要根据`allowed`规则找到**所有可能的顶层方块**

#### 一个例子

```
bottom = "BCD"` `allowed = ["BCC", "CDE", "CEA", "FFF"]
```

- **第一层**: "BCD"
- **构建第二层**:
  - 对于 "BC"，规则 "BCC" 允许我们在上面放 'C'。
  - 对于 "CD"，规则 "CDE" 允许我们在上面放 'E'。
  - 所以第二层**唯一可能**是 "CE"。
- **构建第三层**:
  - 对于 "CE"，规则 "CEA" 允许我们在上面放 'A'。
  - 所以第三层是 "A"。
- 我们成功到达了顶层，所以返回 `true`。

#### 问题本质和分析 - 状态空间搜索 - 转化为图

#####**状态（State）定义** - 图的节点定义

金字塔的某一层可以用一个字符串来表示，这就是一个状态，注意同一个层是可能会有多个状态的，这取决于底层的字符串值和`allowed`规则

##### 状态转移 - 节点的邻居是什么？以及怎么计算获取？

从当前层`cur`根据`allowed`规则，生成的所有的可能的上一层（新的状态集合，你可以理解为上一个状态的所有**邻接点**）

##### 初始状态 - BFS或者DFS的起点

`bottom`字符串即图的DFS或者BFS的起点

##### 目标状态 - 任何长度为1的字符串

任何长度为1的字符串就是要查询的目标终点

由于从一层到上一层可能存在多种组合方式（例如，`AB` 可能对应 `C` 或 `D`），这会形成一个**搜索树**。

我们需要探索这个树，看是否**存在任何一条路径能够从初始状态到达目标状态**。



这个问题非常适合使用**深度优先搜索 (DFS) + 回溯 (Backtracking)** 来解决

我们尝试构建上一层，如果构建成功，就基于新的上一层继续递归搜索；

如果某条路走不通（比如某两个相邻方块找不到任何合法的上层方块），就回溯到上一步，尝试其他的可能性。

#### 考察点

**算法识别能力**: 能否识别出这是一个典型的搜索问题，并选择合适的算法（DFS/BFS）。

**回溯算法**: 这是解决组合、排列、搜索类问题的核心技能。你需要理解如何进行决策、递归、以及撤销决策（回溯）。

**数据结构设计**: 如何高效地存储和查询 `allowed` 规则？如果每次都遍历 `allowed` 列表，效率会非常低。正确的做法是使用哈希表（`Map`）进行预处理，实现 O(1) 的平均查找效率。

**递归思想**: 将大问题（能否从 `bottom` 构建金字塔）分解为小问题（能否从 `next_level` 构建金字塔）。

**剪枝与优化 (Memoization)**: 能否发现搜索过程中可能存在大量重复的子问题（例如，多次判断同一个中间层字符串是否能搭成金字塔），并使用记忆化搜索来优化，避免重复计算。

#### 核心思想和套路 - DFS回溯 + 笛卡尔积全回溯

我们在本题中将会在不同的地方用**到两种不同的回溯方法**。

##### DFS回溯方法是否能够达到目标节点

我们已经通过上面的分析将问题转化为一个**图的模型**。

并且我们已经意识到，现在我们需要做的是用DFS或者BFS遍历，判断是否可以最终达到**长度为1的状态即可**。

现在我们可以认为每一个**层状态**就是一个节点，每一个节点的邻居节点就是通过**当前状态 + Allowed规则**所生成的所有的字符串。

还有一个规则，就是每一个节点的所有的邻居节点的长度都比当前节点的长度少1.

1. **预处理**: 将 `allowed` 规则列表转换为一个 `Map<String, List<Character>>`。
   - `Key`: 长度为 2 的字符串，代表下层的两个方块（如 "AB"）。
   - `Value`: `List<Character>`，代表所有可能的上层方块（如 `['C', 'D']`）。
   - 这一步是性能优化的关键。
2. **定义递归函数**: 设计一个 `dfs(currentLevel)` 函数，它的作用是判断 `currentLevel` 这个字符串能否成功搭建到顶层。
3. **递归终止条件 (Base Cases)**:
   - **成功**: `if (currentLevel.length() == 1)`，说明已经到顶层，返回 `true`。
   - **失败 (通过记忆化)**: `if (memo.contains(currentLevel))`，说明之前已经计算过这个状态并且知道它无法成功，直接返回 `false`（剪枝）。

##### 笛卡尔积回溯方法计算每一个状态的邻居状态列表

我们在生成所有上一层状态时所用到的回溯方法，属于 **“笛卡尔积（Cartesian Product）的全组合生成”** 这一类经典场景和套路。

###### 笛卡尔积回溯 - 多轮独立选择

想象一个这样的场景：你在一家餐厅点餐，菜单上有固定的几类，每类有几个选项。

- **前菜**: [沙拉, 汤]  (2个选择)
- **主菜**: [牛排, 鱼, 意面] (3个选择)
- **甜点**: [蛋糕, 冰淇淋] (2个选择)

你的任务是找出所有可能的“套餐组合”，比如“沙拉-牛排-蛋糕”、“汤-鱼-冰淇淋”等等。

这个过程就是：

1. 在**第一类（前菜）**中做出一个选择。
2. 在**第二类（主菜）**中做出一个选择。
3. 在**第三类（甜点）**中做出一个选择。

每一轮的选择，都是从一个**独立的选项列表**中进行的。最终组合的总数是 $2*3 * 2$=12 种。

```python
// results: 最终存储所有组合的列表
// decisionPoints: 一个列表，其中每个元素是该步骤的选项列表。
//                 例如: [ ['D','E'], ['F'], ['G','H'] ]
// currentPath: 当前已经构建好的部分路径
// stepIndex: 当前进行到第几步决策

function backtrack(results, decisionPoints, currentPath, stepIndex) {
    // 1. 递归终止条件：所有决策都已完成
    if (stepIndex == decisionPoints.size()) {
        results.add(copy of currentPath); // 找到一个完整组合
        return;
    }

    // 2. 获取当前决策点的所有选项
    List<Choice> currentChoices = decisionPoints.get(stepIndex);
    
    // 如果当前决策点没有选项，则此路不通（可选的剪枝）
    if (currentChoices == null || currentChoices.isEmpty()) {
        return;
    }

    // 3. 遍历所有选项
    for (Choice choice : currentChoices) {
        // 做出选择
        currentPath.add(choice);
        
        // 递归到下一步
        backtrack(results, decisionPoints, currentPath, stepIndex + 1);
        
        // 撤销选择（回溯）
        currentPath.removeLast(); 
    }
}
```



这和我们生成上一层的过程完全一样：

这是本题的难点所在，因为构建下一层本身也需要一个小的回溯过程。

我们需要一个辅助函数，比如 `generateNextLevels(currentLevel, nextLevelBuilder, index)`，来生成所有可能的上一层字符串。

`generateNextLevels` 的工作方式：

- 在 `currentLevel` 的 `index` 和 `index+1` 位置取出两个字符，形成 `key`。
- 从预处理的 Map 中查找 `key` 对应的所有可能字符。
- **决策**: 对每个可能的字符 `c`：
  - 将其加入到 `nextLevelBuilder`。
  - **递归**: 调用 `generateNextLevels(..., index + 1)` 继续构建下一层的下一个位置。
  - **回溯**: 从 `nextLevelBuilder` 中移除 `c`，以便尝试其他字符。
- 当 `nextLevelBuilder` 的长度达到了 `currentLevel.length() - 1` 时，一个完整的 `nextLevel` 就构建好了。
- 对这个完整的 `nextLevel`，我们立刻调用主 `dfs(nextLevel)` 函数。如果它返回 `true`，说明找到了一条通路，立刻层层返回 `true`。

#### 实现原理和详细步骤

**主函数 `pyramidTransition(bottom, allowed)`**:

- 初始化一个 `Map<String, List<Character>> rules` 用于存储规则。
- 遍历 `allowed` 列表，填充 `rules`。对于每个 `s` (如 "ABC")，执行 `rules.computeIfAbsent(s.substring(0, 2), k -> new ArrayList<>()).add(s.charAt(2))`.
- 初始化一个 `Set<String> memo` 用于记忆化，存储无法成功的状态。
- 调用核心的 `solve(bottom, rules, memo)` 函数并返回其结果。

**核心递归函数 `solve(currentLevel, rules, memo)`**:

- **Base Case 1**: 如果 `currentLevel.length() == 1`，返回 `true`。
- **Memoization Check**: 如果 `memo.contains(currentLevel)`，返回 `false`。
- **生成下一层**: 调用一个辅助函数 `getNextLevels(...)` 获取所有可能的上一层字符串列表 `List<String> nextLevels`。
- **递归搜索**: 遍历 `nextLevels` 中的每一个 `next`：
  - 调用 `solve(next, rules, memo)`。
  - 如果返回 `true`，说明找到了一个解，立刻返回 `true`。
- **标记死路**: 如果遍历完所有 `nextLevels` 都没有找到解，说明 `currentLevel` 是死路。将 `currentLevel` 加入 `memo`。
- 返回 `false`。

**辅助函数 `getNextLevels(currentLevel, rules, ...)`**:

- 这个功能通常不直接返回列表，而是和主 `solve` 函数的回溯逻辑结合在一起，以避免生成一个巨大的列表。下面的 Java 代码将展示这种更高效的集成方式。我们将构建下一层的回溯逻辑直接嵌入到 `solve` 函数中。

#### 实现代码

```java
class Solution {
    //图的DFS+回溯
    //怎么转化为图模型
    //bottom属于起点，Bottom
    //邻居节点是什么，是遍历所有可能性，怎么遍历呢？
    private Map<String,List<Character>> allowedMap = new HashMap<>();
    private Map<String,Boolean> canArraive = new HashMap<>();
    public boolean pyramidTransition(String bottom, List<String> allowed) {
        for(String rule : allowed){
            String below = rule.substring(0,2);
            char above = rule.charAt(2);
            allowedMap.computeIfAbsent(below, x -> new ArrayList<>()).add(above);
        }
        
        return dfs (bottom);
    }

    private boolean dfs(String cur){
        if (cur.length() == 1){
            return true;
        }
        if(canArraive.containsKey(cur)){
            return canArraive.get(cur);
        }

        StringBuilder path = new StringBuilder();
        List<String> nexts = new ArrayList<>();

        generateNexts(cur,0,path,nexts);
        for (String next : nexts){
            if(dfs(next)) {
                canArraive.put(next,true);
                return true;
            }
        }

        canArraive.put(cur,false);
        return false;
    }

    //笛卡尔积回溯方式计算邻居节点
    private void generateNexts(String cur,int start, StringBuilder path, List<String> nexts){
        if (path.length() == cur.length() - 1){
            nexts.add(path.toString());
            return;
        }

        String base = cur.substring(start, start+2);
        List<Character>  candidates = allowedMap.getOrDefault(base, new ArrayList<>());

        for(char candidate : candidates){
            path.append(candidate);
            generateNexts(cur,start+1,path,nexts);
            path.deleteCharAt(path.length() - 1);
        }
    }   
}
```

#### 注意事项

1. **数据范围**: `bottom` 的长度在 `[2, 8]` 之间。这个非常小的范围是重要的提示，它暗示了指数级复杂度的算法（如回溯）是可行的，因为金字塔的深度最多只有 7 层。
2. **回溯的正确性**: 在 `generateNextLevels` 函数中，`StringBuilder` 的 `append` 和 `deleteCharAt` 操作必须成对出现，这是保证回溯正确性的关键。
3. **记忆化的 Key**: 记忆化的 key 必须是完整的 `currentLevel` 字符串，因为它唯一地定义了一个子问题。
4. **预处理的必要性**: 如果没有 `rules` 这个 Map，代码几乎一定会超时。这是一个必须的优化。

#### 经验总结

**识别模式**: "给定一些基本元素和组合规则，问能否构建出某个目标结构"，这类问题通常指向**搜索算法**，特别是**回溯 (Backtracking)**。

**优化三板斧**:

1. **预处理 (Preprocessing)**: 将输入数据转换为更利于查询的数据结构（如此题的 `List` 转 `Map`）。
2. **剪枝 (Pruning)**: 在搜索过程中，及早地发现此路不通的分支并放弃它（如此题中，当一个 `base` 在 `rules` 中找不到时，直接 `return`）。
3. **记忆化 (Memoization)**: 缓存已经计算过的子问题的结果，避免重复劳动。对于递归解法，这是一种自顶向下的动态规划。

**复合回溯**: 本题的巧妙之处在于，主体的 DFS 内部嵌套了另一个用于生成组合的回溯过程。理解这种函数的嵌套和分工是解决问题的关键。先聚焦于解决 "如何从 `currentLevel` 得到所有 `nextLevel`" 这个子问题，然后再把这个子问题的解法嵌入到主 `solve` 函数的逻辑中，思路会更清晰。

### Leetcode 140 ： 单词拆分II

#### 问题要点

##### 问题描述

给定一个非空字符串 `s` 和一个包含非空单词的字典 `wordDict`，任务是在 `s` 中添加空格，构建一个句子，使得句子中的每个单词都是字典中的有效单词。

要求返回所有可能的句子。

##### 问题关键点

###### 返回所有的结果 - 回溯

暗示了需要使用**搜索算法**，比如深度优先搜索+回溯，来穷举所有的解。

###### 字典中的单词可以重用

在拆分过程中，同一个字典单词可以使用多次

###### 顺序性

单词的组合必须严格按照`s`中的字符的原始顺序

#### 问题本质和分析

从本质上讲，这个问题是**字符串分割**问题的一种变体，要求找到所有有效的分割方案。

我们可以将字符串 `s` 想象成一个路径，从索引 `0` 开始，走到索引 `s.length()` 结束。

每一步可以**跳跃**一个**字典中存在的单词长度**。



例如，对于 `s = "catsanddog"`：

可以从索引 `0` 开始，找到单词 "cat"（长度为 3）。问题就转化为如何拆分剩下的子串 "sanddog"。

也可以从索引 `0` 开始，找到单词 "cats"（长度为 4）。问题就转化为如何拆分剩下的子串 "anddog"。

这种将一个大问题分解为性质相同、规模更小的子问题的结构，是**分治思想**和**动态规划**的典型特征。



直接使用暴力递归搜索，会遇到大量的**重叠子问题**。例如，在处理 "catsanddog" 时，可能会多次遇到需要解决如何拆分 "dog" 这个子问题。为了避免重复计算，提高效率，我们需要使用**记忆化搜索 (Memoization)**，这也就是自顶向下的动态规划。



#### 模式匹配 - 回溯 + 记忆化

#####**回溯 (Backtracking)**: 系统地探索所有可能的分割方案

用于系统地探索所有可能的分割方案。

我们尝试在每个可能的点进行分割（只要前半部分是一个有效单词），然后递归地对后半部分进行处理。

如果后半部分无法成功分割，我们就“回溯”到上一个分割点，尝试其他的分割方案。

##### 记忆化 - 用于存储已经计算过的子问题的结果

用于存储已经计算过的子问题的结果。

我们用一个**哈希表（`Map`）**来存储以某个索引开始的子串所能构成的所有句子列表。

当再次遇到同一个子串时，直接从哈希表中返回结果，避免了重复的递归计算。

这大大降低了时间复杂度。



此题与 **LeetCode 139: 单词拆分 (Word Break I)** 紧密相关。Word Break I 只问“是否”可以拆分，而 Word Break II 要求返回所有具体的拆分“方案”。因此，Word Break I 是本问题的简化版，其动态规划解法可以作为本问题的一个重要优化（详见注意事项）。

#### 问题的本质和分析

此问题的本质是一个**组合搜索问题**。我们可以将其想象成在一个决策树上进行**深度优先搜索（DFS）**。

**树的根节点**：代表完整的字符串 `s`。

**树的边**：代表一个决策——从当前字符串的开头，选择一个字典中的单词作为第一部分。

**树的子节点**：代表做出决策后，剩下的待解决的子字符串。

**从根到叶节点的路径**：代表一种完整的、有效的拆分方案。



例如，对于 `s = "catsanddog"`，决策树的顶层是这样的：

- **决策1**: 选择 "cat"。进入子问题，解决 "sanddog"。
- **决策2**: 选择 "cats"。进入子问题，解决 "anddog"。



这个决策过程会一直持续下去，直到子字符串为空。

暴力地构建并遍历这棵决策树，就是最原始的回溯。

但我们会发现，树中存在**大量结构完全相同的子树**（例如，很多不同路径最后都需要解决如何拆分 "dog" 的问题）。

如果不加处理，就会导致巨大的重复计算，这也是单纯回溯法会超时的根本原因。

因此，我们需要一种方法来避免进入已知的“死胡同”。



#### 模式匹配

这个问题完美匹配了 **“经典回溯 + 剪枝优化”** 的算法模式。

- **经典回溯 (Classic Backtracking)**: 我们采用最标准的回溯模板，通常包含一个记录当前路径的参数 `path`。算法的流程遵循“**选择 -> 递归 -> 撤销选择**”的黄金法则。

  1. **选择**: 从当前位置 `start` 开始，找到一个合法的单词 `word`，并将其加入 `path`。
  2. **递归**: 以该单词的结尾位置为新的 `start`，继续向下搜索。
  3. **撤销选择**: 当从下一层的递归调用返回后，将 `word` 从 `path` 中移除，以便尝试从当前位置 `start` 开始的其他单词选择（即探索树的下一个兄弟分支）。

- **剪枝优化 (Pruning)**: 这是让经典回溯变得高效的关键。

  在深入一个递归分支之前，我们先进行一次“预判”，判断这个分支有没有可能最终走到终点。

  如果预判结果是“此路不通”，就直接“剪掉”这个树枝，不再进行任何探索。

  这个预判机制，本质上就是 **LeetCode 139: 单词拆分 I** 的动态规划解法。

#### 核心思想和套路

本方案的核心思想可以概括为：**“先用DP探路，再用回溯找路”**。

##### 利用动态规划构建导航地图 - 记录s[start...n]能否生成句子

- 我们创建一个布尔类型的动态规划数组 `dp`，长度为 `s.length() + 1`。

- `dp[i]` 的含义是：原字符串 `s` 从索引 `i` 开始的后缀子串 `s.substring(i)` **是否有可能**被成功拆分。

- 我们从后向前填充这个 `dp` 数组。`dp[s.length()]` 初始化为 `true`（空字符串总能“成功拆分”）。

- 递推关系为：`dp[i] = true` 的条件是，存在一个 `j > i`，使得 `dp[j]` 为 `true` **并且** `s.substring(i, j)` 是一个字典单词。

- 这个 `dp` 数组就是我们的“剪枝地图”。

##### 沿着可行路径搜索 - 回溯

- 使用 `backtrack(start, path)` 的标准回溯函数。

- 在函数入口，立刻查询地图：

  - 如果`s[start...n]`不能生成句子，立即返回：`if (!dp[start]) { return; }`。

    如果地图显示从 `start` 开始的后半段压根无法拆分，则直接返回，避免无效搜索。

- 如果 `start` 到达终点，说明找到一个解，根据 `path` 构建句子并存入最终结果。

- 循环遍历，做出选择，递归调用，然后撤销选择。

#### 实现原理和步骤

#####主函数 `wordBreak`:

- 将 `wordDict` 转为 `HashSet` 以提高查询效率。

- 调用生成DP函数
- 初始化一个 `List<String>` 作为最终结果集 `finalResult`。
- 如果 `dp[0]` 为 `false`，说明整个字符串都无法拆分，直接返回空的 `finalResult`。
- 调用回溯辅助函数 `backtrack(s, 0, new LinkedList<>(), dp)`。
- 返回 `finalResult`。

##### 构建DP数组的过程

- 我们创建一个布尔类型的动态规划数组 `dp`，长度为 `s.length() + 1`。

- `dp[i]` 的含义是：原字符串 `s` 从索引 `i` 开始的后缀子串 `s.substring(i)` **是否有可能**被成功拆分。

- 我们**从后向前**填充这个 `dp` 数组。`dp[s.length()]` 初始化为 `true`（空字符串总能“成功拆分”）。

- 递推关系为：`dp[i] = true` 的条件是，存在一个 `j > i`，使得 `dp[j]` 为 `true` **并且** `s.substring(i, j)` 是一个字典单词。

- 这个 `dp` 数组就是我们的“剪枝地图”。



##### 回溯生成句子的过程

**剪枝**: 首先检查 `if (!dp[start]) return;`。（虽然在主函数检查了`dp[0]`，但递归中对每个`start`的检查依然是必要的，确保逻辑的完备性）。

**递归终止条件**: 如果 `start == s.length()`，表示成功找到一条完整路径。

因为所有我们在第一部已经排除了**任何`[i...n]`之间不能构成句子的情况**。

使用 `String.join(" ", path)` 将 `path` 中的单词组合成句子，并添加到 `finalResult` 中，然后 `return`。

**循环与递归**:

- 从 `start` 开始，向后遍历，截取子串 `word = s.substring(start, end)`。
- 如果 `word` 在字典中： 
  - a. **选择**: `path.add(word)`。 
  - b. **递归**: `backtrack(s, end, path, dp)`。
  - c. **撤销选择**: `path.removeLast()`。


#### 实现代码

```java
    List<String> res = new ArrayList<>();
    boolean[] reachable ;

    Set<String> wordSet;

    public List<String> wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        wordSet = new HashSet<>(wordDict);
        reachable = new boolean[n+1];
        checkReachability(s, wordSet);

        if(!reachable[0]){
            return new ArrayList<>();
        }

        List<String> path = new ArrayList<>();
        backtrack(s, 0, path, wordSet);
        return res;
        
    }
    //检查每对于每一个位置i， s[i...n]是否可以组成句子
    private boolean[] checkReachability(String s, Set<String> wordSet){
        int n = s.length();
        //空字符串是能够到达的
        reachable[n] = true;
        for(int i = n-1; i >= 0; i--){
            for(int j = i + 1; j <= s.length(); j++){
                String word = s.substring(i,j);
                if(wordSet.contains(word) && reachable[j]){
                    reachable[i] = true;
                    break;
                }
            }
        }
        return reachable;
    }

    private void backtrack(String s, int start, List<String> path,Set<String> wordSet){
        if(start == s.length()){
            res.add(String.join(" ", path));
            return;
        }

        if(!reachable[start]) return;

        for(int end = start+1; end <= s.length(); end++){
            String word = s.substring(start,end);
            if(wordSet.contains(word) && reachable[end]){
                path.add(word);
                backtrack(s, end, path, wordSet);
                path.remove(path.size() - 1);
            }
        }
    }
```

#### 注意事项

**剪枝的必要性**: 如果没有 `dp` 数组进行剪枝，纯粹的经典回溯会在很多用例上超时。这里的剪枝不是锦上添花，而是**保证算法可行性的核心**。

**DP数组的计算顺序**: `dp` 数组必须**从后向前**计算，因为 `dp[i]` 的值依赖于它后面的 `dp[j]` 的值。

**数据结构选择**: `path` 使用 `LinkedList` 是因为它提供了高效的 `addLast` 和 `removeLast` 操作，完美契合回溯中“在路径末尾添加/删除”的需求。

**两次剪枝**: 代码中实际上有两次剪枝。第一次是在主函数中检查 `dp[0]`，如果整个字符串无解就直接退出。第二次是在 `backtrack` 函数内部，对每一个子问题都检查 `dp[end]`，确保下一步有路可走。

#### 经验总结 - 

**识别模式**: “求所有解” -> **回溯**。“回溯有重复计算” -> **剪枝或记忆化**。

**组合的力量**: 本题是**动态规划**和**回溯**两种强大算法思想结合的典范。DP负责解决“是否可行”的判定问题，为回溯提供优化；回溯负责解决“找出所有方案”的构造问题。

**分离关注点**: 将一个复杂问题分解为两个更简单的子问题——“能否解决”和“如何解决”，是重要的解题策略。先用DP探路，再让回溯上路，使得每个部分的逻辑都更纯粹、更清晰。

**掌握标准模板**: 熟练掌握经典回溯的“选择-递归-撤销”模板，以及DP的基本递推思想，是解决这类问题的基础。在此之上，思考如何将两者结合，便能应对更复杂的挑战。

### Leetcode 1655:分配重复整数

#### 问题要点

我们再次明确一下目标：

给定一个整数数组 `nums` 和一个订单数组 `quantity`。我们要判断是否能用 `nums` 里的数，满足 `quantity` 里的所有订单。

规则是：

1. 每个订单 `quantity[i]` 必须不多不少正好满足。
2. 满足同一个订单的所有数字，必须是 **完全相同** 的。比如订单是3，你只能给 `[7,7,7]`，不能给 `[7,7,8]`。
3. 所有订单都得满足。

**关键信息**: 顾客数量 `m` (即 `quantity` 的长度) 最多只有 10 个。这个小数字是解题的关键。

#### 问题本质和分析

好的，我们换一种更直观的思路——**回溯法 (Backtracking)** 来解析这道题。这种方法不使用复杂的位运算（mask），逻辑更贴近人类的思考方式，非常适合理解问题本质。



### 1. 问题要点 (Problem Essentials)



我们再次明确一下目标：

给定一个整数数组 `nums` 和一个订单数组 `quantity`。我们要判断是否能用 `nums` 里的数，满足 `quantity` 里的所有订单。

规则是：

1. 每个订单 `quantity[i]` 必须不多不少正好满足。
2. 满足同一个订单的所有数字，必须是 **完全相同** 的。比如订单是3，你只能给 `[7,7,7]`，不能给 `[7,7,8]`。
3. 所有订单都得满足。

**关键信息**: 顾客数量 `m` (即 `quantity` 的长度) 最多只有 10 个。这个小数字是解题的关键。



### 2. 问题本质和分析 (Problem Essence and Analysis) - 决策和分配

这道题的本质是 **决策和分配** 问题。

想象你是一个仓库管理员，手上有各种数量的货物（`nums` 中不同数字的个数），面前站着 `m` 个顾客，每人拿着一个订单（`quantity` 中的一个值）。你需要决定：

- 先满足哪个顾客？
- 用哪种货物去满足他？
- 如果满足了他，剩下的货物是否能满足剩下的顾客？

这是一个典型的 **“可行性”** 搜索问题，答案只有 `true` 或 `false`。

回溯法是解决这类问题的经典方法。

它通过尝试所有可能的决策路径来寻找一个可行的方案。

我们的决策过程可以这样设计：**按顺序一个一个地去满足顾客**。

 从第 0 个顾客开始，尝试用仓库里的一种存货去满足他。

如果成功，就递归地去处理第 1 个顾客；如果第 1 个顾客也能被满足，就继续处理第 2 个... 直到所有顾客都被满足，那就找到了一个可行方案，返回 `true`。

如果在任何一步，发现无论如何都无法满足当前的顾客，或者满足当前顾客后，剩下的顾客无法被满足，那就说明这条决策路径是死胡同。我们需要 **“回溯”**——撤销上一步的决定，换一种货物再试试。

如果所有货物都试过了还是不行，那就说明此路不通。

#### 背景知识 - 回溯法

回溯法是一种通过探索所有可能的候选解来找出所有解的算法。

如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即回溯至上一步。

它本质上是一种**深度优先搜索 (DFS)**。

其核心结构通常是一个**递归函数**，函数中包含一个循环，用于遍历当前状态下的所有可能选择。

- **选择 (Choose)**: 在当前步骤中，做一个选择。
- **探索 (Explore)**: 基于这个选择，递归地进入下一步。
- **撤销 (Unchoose/Backtrack)**: 如果下一步的探索失败了，撤销刚才的选择，回到当前步骤，尝试下一个选择。

#### 模式匹配

- **排列组合/全排列问题**: 我们需要为每个顾客找到一种合适的“货物”。这有点像为每个位置选择一个元素，但这里的约束更复杂。

- **深度优先搜索 (DFS)**: 回溯法的实现就是深度优先搜索树的遍历。

- **分配问题 (Assignment Problem)**: 将一组资源（数字的计数）分配给一组任务（顾客的订单）。

#### 核心思想和套路

使用回溯法的核心思想是定义一个递归函数，模拟“为顾客分配货物”的过程。

**递归函数设计**: `canSolve(customerIndex, availableCounts)` 这个函数表示：“当前要为第 `customerIndex` 号顾客服务，仓库里各类货物的存量是 `availableCounts`，请问**能否最终满足从这个顾客开始到最后一个顾客的所有人**？”

##### 递归过程

###### 终止条件

- 如果 `customerIndex` 已经等于顾客总数 `m`，说明所有顾客都已成功满足。这是一个成功的终点，返回 `true`。

###### 为当前的顾客做选择

- 获取当前顾客的订单量 `currentQuantity = quantity[customerIndex]`。
- 遍历仓库里 **每一种** 存货 `availableCounts[i]`。
- 对于第 `i` 种存货，检查其存量是否足够满足当前订单，即 `availableCounts[i] >= currentQuantity`。
  - 如果足够
    - a. **做选择**: 假设我们就用第 `i` 种存货来满足他。更新存量：`availableCounts[i] -= currentQuantity`。 
    - b. **探索**: 递归调用 `canSolve(customerIndex + 1, availableCounts)`，去看一看基于这个选择，后续的顾客能否被满足。 
    - c. **判断结果**: 如果递归调用返回 `true`，太好了！说明这条路走得通。我们立刻向上返回 `true`，任务完成。 
    - d. **撤销选择 (回溯)**: 如果递归调用返回 `false`，说明这条路是死胡同。我们必须撤销刚才的决定，恢复存量：`availableCounts[i] += currentQuantity`。然后继续尝试用下一种存货来满足当前顾客。

- 失败的情况

  - 如果遍历了所有种类的存货，都无法满足当前的 `customerIndex` 号顾客（或者满足后后续顾客无法被满足），那么这个函数就应该返回 `false`，告诉上一步的决策者：“你刚才那个决定是错的”。

- 优化剪枝

  一个非常关键的优化是：**将订单 `quantity` 从大到小排序**。 

  为什么？因为大额订单最“挑剔”，最难满足。

  优先处理它们，如果它们都无法被满足，我们就可以更早地发现某条搜索路径是行不通的，从而提前剪枝，避免大量不必要的计算。

#### 实现原理和步骤

##### 准备初始化工作

- **统计 `nums` 频率**: 使用哈希表统计 `nums` 中每个数字的出现次数。将这些次数存入一个数组 `counts`。
- **对 `quantity` 排序**: 将 `quantity` 数组 **从大到小** 排序。这是重要的剪枝步骤。

##### 回溯函数的调用和工作原理

- **定义回溯函数**: 定义主回溯函数 `backtrack(customerIndex, counts)`。

- **调用入口**: 从第 0 个顾客开始调用 `backtrack(0, counts)`。

- **实现回溯逻辑：**

  - **Base Case**: `customerIndex == quantity.length` 时，返回 `true`。
  - **循环尝试**: 遍历 `counts` 数组中的每一种数字存量 `counts[i]`。
  - **检查与选择**: 如果 `counts[i] >= quantity[customerIndex]`，则：
    - `counts[i] -= quantity[customerIndex]`
    - 调用 `backtrack(customerIndex + 1, counts)`
    - 如果递归调用成功，直接返回 `true`。
    - 如果失败，则 `counts[i] += quantity[customerIndex]` (回溯)。

  - 去重剪枝

    一个额外的剪枝。

    如果 `counts[i]` 和 `counts[i-1]` 的存量相同，那么用 `counts[i]` 去尝试的结果会和用 `counts[i-1]` 完全一样，可以跳过，避免重复搜索。

  - **返回结果**: 如果循环结束都没有找到成功的路径，返回 `false`。

#### 实现代码

```java
class Solution {
    public boolean canDistribute(int[] nums, int[] quantity) {
        //生成counts数组，具体每一个num是什么不重要
        Map<Integer,Integer> countMap = new HashMap<>();
        for(int num : nums){
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }
        int[] counts = new int[countMap.size()];
        int index = 0;
        for(int count : countMap.values()){
            counts[index] = count;
            index++;
        }
        //注意数组sort的方法，默认不需要传递comparator
        Arrays.sort(quantity);
        //反转数组
        int[] reversedQuantity = reverse(quantity);
        
        return canSolve(counts, reversedQuantity, 0);
    }

    private boolean canSolve(int[] counts, int[] quantity,int start){
        if(start == quantity.length){
            return true;
        }
        for(int i = 0; i < counts.length; i++){
            int count = counts[i];
            if(count < quantity[start]) continue;

            counts[i] -= quantity[start];
            if(canSolve(counts, quantity, start+1)){
                return true;
            }
            counts[i] += quantity[start];
        }
        return false;
    }

    private int[] reverse(int[] quantity){
        int m = quantity.length;
        int[] reversed = new int[m];
        for(int i = m-1; i >= 0; i--){
            reversed[m-1 -i] = quantity[i];
        }
        return reversed;
    }
}
```

#### 注意事项

**回溯的状态传递**: 在Java中，数组是引用传递。这意味着在递归调用中对 `counts` 数组的修改会影响到所有层级的调用。因此，**“撤销选择”** 这一步至关重要，必须确保在递归返回后，将状态恢复到做选择之前的样子。

**排序的重要性**: 对 `quantity` 降序排序是这个回溯解法能否通过的关键。若不排序，搜索空间会大很多，导致超时 (Time Limit Exceeded)。

**重复计数的剪枝**: 在代码中 `if (i > 0 && counts[i] == counts[i-1])` 这一行是另一个小剪枝。如果仓库里有两堆数量相同的货物（比如都有8个），那么先用第一堆去尝试和先用第二堆去尝试，对于后续决策来说是完全等价的。跳过可以减少重复的搜索分支。为了让这个剪枝生效，通常需要先对`counts`数组排序，不过即使不排序，它也能在一定程度上起作用。

#### 经验总结

**化繁为简**: 相比于状态压缩DP，回溯法的代码逻辑更贴近思考过程：`for` 循环代表“尝试所有选择”，递归调用代表“进入下一步”，状态恢复代表“撤销选择”。

**剪枝是灵魂**: 纯粹的暴力回溯通常会超时。回溯算法的威力在于其“剪枝”能力。解决这类问题时，要不断思考：“在什么情况下，我可以确定当前这条路肯定走不通，从而提前返回？” 本题中的“大订单优先”就是一个绝佳的剪枝策略。

**识别回溯信号**: 当你看到问题是要求一个“是/否”的可行性解，数据规模中有一个维度特别小，并且问题可以被分解为一系列连续的决策步骤时，就应该优先考虑回溯法（或DFS）。

**练习状态管理**: 回溯问题的调试难点往往在于状态管理是否正确。**一定要确保每次“选择”和“撤销”是成对、对称的操作**，保证在尝试完一个分支后，状态能完美地恢复。

## 数字填充（数独）

> 编写一个程序，通过填充空格来解决数独问题。
>  一个数独的解法需**遵循如下规则**：
>
> - 数字 1-9 在每一行只能出现一次
> - 数字 1-9 在每一列只能出现一次
> - 数字 1-9 在每一个 3x3 的宫格中只能出现一次

在数独格子中填数字，满足横竖九宫格无重复。

输入是一个 9x9 的二维字符数组 `board`，空格用 `'.'` 表示。

##### 问题分析与本质-满足约束性问题-回溯+剪枝

这是一个**典型的“约束满足问题（Constraint Satisfaction Problem, CSP）”**，我们需要在大量可能的组合中找到满足所有规则的一个解。

###### 难点

- 约束条件较多（行/列/宫）
- 剪枝策略设计是高效解题关键
- 不仅找是否存在，而是要求直接填写出解

##### 核心思想-回溯+剪枝优化

###### 回溯-依次尝试填写每个数字

- 递归的尝试在每个空格填入1-9中的某个数字
- 每次尝试时，检查这个数字是否满足数独的规则
- 如果满足，就继续递归尝试下一个空格
- 如果走不通，就回溯（撤销这个填入操作）

###### 剪枝优化-依赖三个标记数组-ROW+COL+BOX

使用三个`boolean`数组记录当前哪些数字已经被使用

- `row[i][num]`:第`i`行使用过数`num`
- `col[j][num]`第`j`列使用过数字`num`
- `box[i/3][j/3][num]`，`[i,j]`所属的`box`是否用过数字`num`

##### 实现原理

###### 初始化

- 遍历整个`board`
- 把已经填写的数字更新到`row/col/box`表中

######回溯递归

- 从做到右、从上到下的寻找下一个`.`(空格子)
- 枚举`1-9`，检查是否合法
- 合法则修改`board`和状态表，递归
- 回溯恢复状态

##### 代码实现

###### 初始化状态表

```java
//row[i][num] = true 表示num在第i行出现
private boolean[][] row = new boolean[9][10];
//col[i][num] = true 表示num在第i列出现
private boolean[][] col = new boolean[9][10];
//box[i][num] = true 表示num在第i个box中出现
private boolean[][] box = new boolean[9][10];
private char[][] board;
```

###### 如何计算box？

```java
private getBoxIndex(int i, int j){
  return (i/3)*3 + (j/3);
}
```



###### 初始化状态表和board

```java
this.board = board;

for (int i=0; i<9; i++){
  for (int j=0; j<9;j++){
    char c = board[i][j];
    if (c != '.'){
      int num = c-'0';
      row[i][num] = true;
      col[j][num] = true;
      box[getBoxIndex(i,j)][num] = true;
    }
  }
}

//调用backtrack填写
backtrack(0, 0);
```

###### 回溯函数

```java
private boolean backtrack(int i, int j){
  if (i==9) return true;// 如果已经填写完成，返回
  if (j==9) return backtrack(i+1,0);// 当前行已经填写完毕，填写下一行
  
  //当前数字已经填写完毕，填写下一个（第[i,j+1]个）
  if(board[i][j] != '.'){
    return backtrack(i,j+1);
  }
  
  //填写当前格子，采用回溯
  for (int num = 1; num <=9; num++){
    if (isValid(i,j,num)){
      //填写数字
      placeNum(i,j,num);
      //回溯填写下一个数字，在这里换列
      if (backtrack(i,j+1)) return true;
      removeNum(i,j,num);
    }
  }
  return false;//无解
}
```

######  怎样判断数字是否可以放到某个格子里？

```java
private boolean isValid(int i, int j, int num){
  int boxIndex = getBoxIndex(i,j);
  return !row[i][num] && !col[j][num] && !box[boxIndex][num];
}
```

###### 填写数字都某个格子中

```java
private void placeNum(int i, int j, int num){
  board[i][j] = (char)(num+'0');
  row[i][num] = true;
  col[j][num] = true;
  box[getBoxIndex(i,j)][num] = true;
}
```

###### 怎样移除数字？

```java
private void removeNum(int i, int j, int num){
  board[i][j] = '.';
  row[i][num] = false;
  col[j][num] = false;
  box[getBoxIndex(i,j)][num] = false;
}
```

##### 注意事项

| 注意点                        | 描述                                                        |
| ----------------------------- | ----------------------------------------------------------- |
| 数组范围                      | 数组用 `1~9` 而不是 `0~8` 是为了方便直观映射数字            |
| 终止条件                      | 回溯终止是 `i == 9`，不是找完一个点就返回                   |
| Box 计算                      | `boxIndex = (i / 3) * 3 + (j / 3)` 表示 9 个 3x3 宫格的编号 |
| 不要同时改原 `board` 与状态表 | 保持回溯结构清晰：**尝试 → 递归 → 回溯恢复**                |

##### 经验总结

**本题是面试回溯经典题之一**，考察点不只是实现，而是**剪枝与状态记录方式的优化**；

回溯题一定要：

- 明确**搜索空间（空格位置）**
- 明确**选择列表（1~9）**
- 设计**合法性判断机制（row/col/box）**
- 正确书写**撤销操作（回溯）**

面试优化加分项：

- 尝试记录所有空格的位置提前排序，提升效率；
- 用 bitmask 替代 boolean 数组，进一步压缩空间（进阶）；

一定要做到代码**递归结构清晰 + 状态一致性强**；

对于状态回退务必要小心，**只回退当前这一层的修改部分**，避免遗漏或越界。

##### 填写完成每个格子以后都会回溯，那么是不是整个过程完成以后，等于什么也没填？

不会的，回溯只是**在尝试路径失败时撤回**。当找到一条“完整可行解”时，不再回溯，这个解就保留在原始 `board` 上了。

###### 回溯 不等于 撤销

回溯是**枚举所有可能**，并**逐步剪去无效路径**，最终**留下一个合法解**。

###### 回溯的三个步骤： 尝试 + 递归 + 回撤（失败才会）

1. 尝试填一个数字（**尝试选择**）
2. 如果合法就继续递归（**继续搜索**）
3. 如果递归失败（找不到解），才撤销这个选择（**回退选择**）

######数独中怎么体现？

- 每次尝试填一个数字，如果后续能找到一个完整解（填满所有空格且符合规则）：
  - **这个解会一直保留在 board 上**，递归返回 true，程序结束。
- 如果这个填法最终走不通（后面没数字能合法填），就：
  - 撤销这步，尝试下一个数字（回溯）

###### 最终成功的路径不会被回溯！

- 最终成功的路径不会被回溯！
- 而你修改的 `board[i][j] = (char)(num + '0')` 是直接在输入上操作的。
- 当你找到第一个可行解（Leetcode 37 只要求一个），递归立即结束，此时 `board` 就是那个解。

#### 构造问题 - 表达式生成

给定一个只包含数字的字符串 `num` 和一个目标值 `target`，在 `num` 中添加加号（`+`）、减号（`-`）或乘号（`*`），使得所形成的数学表达式的计算结果等于目标值。返回所有有效表达式的列表。

```
输入: num = "123", target = 6  
输出: ["1+2+3", "1*2*3"]
```

##### 问题本质-构造类回溯问题

- 枚举每个位置添加哪一种运算符
- 构造所有合法表达式
- 对每个表达式进行求值

难点在于**处理乘法的优先级**，即`1+2*3`不能直接从做到右左加法再乘法，而是要再构造过程中实时处理乘法的结合。

##### 核心思想 - 回溯 + 字符串分割 + 记录前一段乘积

- 回溯每一步的时候尝试选择当前的数字段（可能是多位数），并加上运算符
- 用递归函数`dfs(index,path,evaluated,lastFactor)`来逐步构造表达式
  - `index`: 当前处理到字符串的哪一个位置了？
  - `path`:当前构造的表达式
  - `evaluated`:当前字表达式的累计值
  - `lastFactor`：上一个运算因子，用于处理乘法(乘法要回退上一个加/减项再乘)

##### 实现原理与步骤

###### 构造所有的数字段组合

- 利用一个`for`循环，从`index`开始到末尾，去`num.substring(index,i+1)`作为当前数字段
- 注意跳过**前导为0**的数字

###### 对每一个数字段尝试三种运算符

- **加号：** 直接将当前数字加到`evaluated`上，同时记录`lastFactor = cur`
- **减号：**同上，`evaluted -= cur`，`lastFactor = cur`
- **乘号：**
  - Tricky, 不能直接乘，因为要满足优先级
  - 必须做`evaluted - lastFactor + lastFactor * cur`

###### 终止条件

- `index == nuts.length()`， 并且
- `evaluated == target`
- 将表达式加入`path`

 ##### 实现代码

```java
List<String> result = new ArrayList<>();

public List<String> addOperators(String num, int target) {
        if (num == null || num.length() == 0) return result;
        dfs(num, target, 0, "", 0, 0);
        return result;
}

private void dfs (String num, int target, int index,String path.long evaluated,long lastFactor){
  //如果满足条件，将path 加入到结果集
  if (index == nums.length()){
    if (evaluted == target){
      res.add(path);
    }
    return;
  }
  
  for(int i=index; i<num.length();i++){
    //前导0的情况， 这里的break会导致函数调用结果并返回上一层递归
    //从而继续执行index = index + 1的情况
    if (i != index && num.charAt(index) == '0') break;
    
    String currentStr = num.substring(index, i+1);
    long currentNum = Long.parseLong(currentStr);
    
    if (index == 0){
      //第一个数字不能添加符号
      dfs (num, target, i+1, currentStr, currentNum,currentNum);
    }else{
      // 添加加号
      dfs (num, target,i+1, path + "+" + currentStr. evaluated + currentNum, currentNum);
      // 添加减号
      dfs (num, target, i+1, path + "-" + currentStr, evaluated - currentNum, -currentNum);
      //添加乘号
      dfs(num,target, i+1, path + "*" + currentStr,  evaluated - lastFactor + lastFactor * currentNum, lastFactor * currentNum);
    }
  }
}
```

##### 为什么实现代码中看不到撤销操作？

是的，它就是回溯，虽然你看不到“手动撤销”，但它具备：

| 维度     | 是否存在  | 表现形式                                                     |
| -------- | --------- | ------------------------------------------------------------ |
| 有选择？ | ✅         | `for (i = index; i < num.length(); i++)` 枚举数段；每段尝试 `+ - *` |
| 有探索？ | ✅         | `dfs(...)`                                                   |
| 有撤销？ | ✅（隐式） | 通过参数传值 + 递归回退（没有副作用）- 递归之间没有共享修改的变量 |



> 换句话说：这是一个**函数式回溯结构**，每一层递归都独立、不需要显式恢复状态。

##### 注意事项

1. **前导0**：
   - 遇到形如 `"05"` 的段落时，应该跳过
   - 判断：`if (i != index && num.charAt(index) == '0') break;`
2. **整型溢出**：
   - 所有中间值（包括 `evaluated`、`lastFactor`）都用 `long` 避免 `int` 溢出
3. **不能用 eval 求表达式值**：
   - 因为每一步都要控制优先级，需要手动计算每一步结果，特别是乘法的结合顺序
4. **乘法逻辑的设计是核心难点**：
   - `evaluated - lastFactor + lastFactor * currentNum` 是用于在已有加减法基础上回滚上一步的结果再做乘法（遵守运算顺序）

##### 经验总结

- 本题是 **回溯 + 字符串构造 + 表达式求值** 的组合经典题；
- 理解“中间状态”传递的含义比写代码更重要，特别是：
  - `lastFactor` 记录的是最后一个数项，为了支持乘法正确计算；
- 对乘法的处理技巧非常典型，可以迁移到类似的表达式构造问题；
- 实战中面试考察此题，会重点考查你如何**维护中间状态与表达式的语义一致性**，以及是否能意识到表达式优先级问题。

##NP完全问题 - 能否将数组划分为和相同的K个子集？

给定一个正整数数组 `nums` 和一个整数 `k`，判断能否将 `nums` 严格划分为 `k` 个**不相交的子集**，每个子集的和都相等。

###问题本质分析

- **组合问题 + 子集划分**
- **NP 完全问题**，和子集和问题类似
- 适合使用 **回溯 + 剪枝** 或 **状态压缩 + 记忆化**

###核心思想与应对套路

- 总和必须能够整除`k`，`sum(nums) % k == 0`
- **回溯**的尝试将每个数放入K个**桶**中
- 每个桶的目标是`sum/k`，若全部成功填满，则返回true
- 使用`boolean[] used`记录哪些数据已经被使用
- 使用**排序 + 剪枝**优化搜索路径

###难点分析和应对方法

| 难点             | 应对策略                                     |
| ---------------- | -------------------------------------------- |
| 搜索空间过大     | 对数组排序（降序）+ 剪枝加速失败分支         |
| 子集组合状态重复 | 使用 `used[]` 数组或 `bitmask` 压缩状态      |
| 子集和超过目标   | 当前桶和 + 当前数 > target 时剪枝            |
| 超时             | 优先选择大的数，加快失败判断；必要时加记忆化 |

###实现原理和步骤

1. 计算总和，判断是否能够整除K
2. 计算每个子集的目标和`target = sum / k`
3. 将`nums`按照**降序**排序
4. 初始化回溯函数，尝试将每个数放入桶中
5. 成功划分所有的桶即返回true

###实现代码

####回溯函数的设计

```java
private boolean backtrack(int[] nums, boolean[] used, int k, int bucketSum,int start, int target){
  if (k == 0) return true;
  
  if (bucketSum == target){
    return backtrack(nums,used, k-1,0,0,target);
  }
  
  for (int i = start; i< nums.length;i++){
    if (used[i]) continue;
    if (backetSum + nums[i] > target) continue;
    
    used[i] = true;
    if (backtrack(nums,used,k,bucketSum + nums[i], i+1, target)){
      return true;
    }
    used[i] = false;
    
    //剪枝优化
    if (bucketSum == 0) return false;
    //有重复元素的情况？
    while(i+1 < nums.length && nums[i] == nums[i+1]) i++;
  }
  
  return false;
}
```

####调用回溯函数

```java
 int total = Arrays.stream(nums).sum();
        if (total % k != 0) return false;
        int target = total / k;
        Arrays.sort(nums);
        int n = nums.length;

        if (nums[n - 1] > target) return false;

        boolean[] used = new boolean[n];
        return backtrack(nums, used, k, 0, 0, target);
```

###注意事项

| 点        | 说明                                   |
| --------- | -------------------------------------- |
| 输入限制  | nums 元素为正整数；数组不为空；k ≥ 1   |
| 排序优化  | 降序排序可以加速回溯剪枝失败           |
| used 数组 | 用于记录哪些数字已被分配，不可重复使用 |
| target    | 每个子集必须精确等于 target            |

###经验总结

- 本题是典型的**集合划分 + 和等性约束**问题，搜索空间很大但结构清晰
- 合理排序 + 剪枝是降低复杂度的关键
- 不要把“组合”和“划分”混为一谈：划分要求不重不漏
