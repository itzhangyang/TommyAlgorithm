



# 什么是二分查找？

## 最初的用途 - 在有序数组中查找目标值

我们给定一个**有序的数组**，要求你能够快速的从数组中查找`target`的索引，如果不存在，就返回-1；

## 二分查找的核心思想：猜中间，丢一半

二分查找的核心思想非常简单，可以概括为：**“猜中间，扔一半”**。

它就像一个我们都玩过的“猜数字”游戏：

1. **前提**：我从 1 到 100 之间想一个数字，你来猜。这个游戏能玩的前提是数字是**排好序**的 (1, 2, 3... 100)。
2. **你的第一猜**：你不会从 1 开始猜，你最聪明的猜法是**猜中间数：50**。
3. **我给你反馈**：我告诉你“太小了”。
4. **你“扔一半”**：你**立刻就知道了**，答案必定在 51 到 100 之间。你把 1 到 50 这**整整一半**的范围都排除了（扔掉了），再也不用管它们。
5. **重复过程**：现在你的搜索范围是 [51, 100]。你再次**猜中间数：75**。
6. **我给你反馈**：我告诉你“太大了”。
7. **你再“扔一半”**：你**立刻又知道了**，答案必定在 51 到 74 之间。你又把 75 到 100 这一半范围扔掉了。

### 二分查找的限制： 数组必须有序

二分查找就是这个过程：**它只适用于已经排好序的数据**。

它通过每次检查中间的元素，来准确地判断出目标值是在左半边还是右半边，然后**毫不犹豫地扔掉另一半**，从而使搜索范围每次都缩小一半。

这种“砍一半”的策略效率极高。

查找 100 个元素最多只需要 7 次，而查找 10 亿个元素，最多也只需要 30 次左右。

## 二分查找的实现原理：基于有序序列的分治思想

二分查找（Binary Search）的基本原理是基于**有序序列**的**分治思想**。

它利用了数据的有序性，通过比较中间元素和目标值来不断缩小搜索区间。

### 必要前提：数组必须是有序的

数据必须存储在**有序**的数据结构中（例如，一个升序排列的数组）。

### 二分查找的核心要素

#### 左指针 - 搜索区间的起始位置

指向搜索区间的起始位置。

#### 右指针 - 搜索区间的结束位置

指向搜索区间的结束位置。

#### 中间索引(mid):指向中间的元素

- 通过 `(left + right) / 2` 计算得出，指向区间的中间元素。

### 搜索的执行步骤

####情况一：找到了 - 返回mid索引

- 如果 `nums[mid] == target`，说明找到了目标值，返回 `mid` 索引。

####情况二：猜大了（中间值 > 目标值）- 右指针左移至mid前一个元素

- 如果 `nums[mid] > target`，因为数组是升序的，这说明 `target` 如果存在，必定在 `mid` 的**左侧**。
- 我们“扔掉”右半部分，将搜索区间缩小为 `[left, mid - 1]`。
- **操作**：`right = mid - 1`

####情况三：猜小了（中间值 < 目标值）- 左指针右移至mid后一个元素

- 如果 `nums[mid] < target`，因为数组是升序的，这说明 `target` 如果存在，必定在 `mid` 的**右侧**。
- 我们“扔掉”左半部分，将搜索区间缩小为 `[mid + 1, right]`。
- **操作**：`left = mid + 1`

####**结束**：

- 如果循环结束（此时 `left > right`），意味着搜索区间为空，但仍未找到 `target`。
- 返回 `-1`，表示目标值在数组中不存在。

这个过程的时间复杂度为 $O(\log n)$，因为每一步都将搜索空间缩小了一半。

# 场景速查

| 类别编号 | 类别类型         | 高频题号（Leetcode） | 场景关键词             |
| -------- | ---------------- | -------------------- | ---------------------- |
| 1        | 基本查找         | 704                  | 有序数组中查找         |
| 2        | 左边界查找       | 34, 35, 300（LIS）   | 第一个满足条件         |
| 3        | 右边界查找       | 34                   | 最后一个满足条件       |
| 4        | 插入位置查找     | 35                   | 插入位置               |
| 5        | 峰值查找         | 162                  | 局部最大               |
| 6        | 旋转数组查找     | 33, 81, 153, 154     | 有序但旋转             |
| 7        | 搜索最小可行解   | 875, 1011, 410, 1482 | 找最小满足条件的“答案” |
| 8        | 二维数组二分查找 | 74, 240              | 有序矩阵               |
| 9        | 分割+答案搜索型  | 410（K段最小和）     | 分割题，最大值最小化   |

# 基本查找 - 有序数组中查找目标值

## 场景和目标 - 有序数组中查找目标值

- 在有序数组中查找某个目标值是存在
- 返回该数值的索引，若不存在返回`-1`

## 核心思想 - 比较大小并移动左右指针

每次与**中心点**比较，决定向左还是向右缩小范围

## 实现原理

- 初始化`left = 0, right = nums.length -1`
- 当`left <= right`时：
  - `mid = left + (right - left) / 2`
  - 如果`nums[mid] == target`， 返回`mid`
  - 如果`nums[mid] < target` ,说明目标在右边，移动左指针`left = mid + 1`
  - 如果`nums[mid] > target`， 说明目标在左边，移动右指针`right = mid - 1`

## 代码套路模板

```java
int binarySearch (int[] nums, int target){
  int left = 0;
  int right = nums.length - 1;
  
  while (left <= right){
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) return mid;
    if (nums[mid] > target){
      left = mid + 1;
    }else{
      right = mid - 1;
    }
  }
  
  return -1;
}
```

## 注意事项

### **注意边界：**`left <= right`

### 防止整数溢出：`left + (right -left) / 2`

## 经验总结

最基本的套路，位其他变种打下基础

# 查找左边界 - 查找 >= target的最小索引

## 场景与目标

- 数组中有重复目标，返回第一个**等于或者大于**Target的索引

## 核心思想 - 继续往左压缩范围

即使找到目标要不要立刻返回，继续**向左压缩**

## 实现原理

1. `left = 0; right = nums.length -1`
2. 当`while(left <= right)`
   - `mid = left + (right - left) / 2`;
   - 如果`nums[mid] >= target`， 则说明结果在左边，向左移动右指针:`right = mid -1`
   - 否则，则说明结果在右边`[mid....right]`，**注意mid也在范围之内**,向右移动左指针：`left = mid`(~**注意不是`mid+1`**~)

## 代码实现模板

```java
int leftBound (int[] nums, int target){
  int left = 0;
  int right = nums.length -1;
  int result = -1;
  //注意循环条件是left <= right
  while (left <= right){
    int mid = left + (right -left) / 2;
    if(nums[mid] >= target){
      //记录答案
      result = mid;
      //尝试寻找更小答案
      right = mid - 1;
    }else{
      left = mid + 1;
    }
  }
  return result;
}
```

## 注意事项

### 左闭右开区间`[left,right)`

## 经验总结 - 多用于查找第一个符合条件的元素

# 查找右边界 - 查找最后一个<=目标值的元素

## 场景和目标

- 返回最后一个**小于或者等于**target的位置

## 核心思想 - 继续往右压缩查找范围

找到符合条件的元素之后，继续往右查找，直到找到最右目标

不是一旦相等就停，而是要继续向左检查是否还有更左位置满足条件.

## 实现原理

实际上等价于“查找左边界”，因为插入点是第一个 `>= target` 的位置。

### 初始化左右指针

`left = 0; right = nums.length -1`

### 遍历逻辑 - `while left <= right`

- `mid = left + (right - left) / 2`

- 如果 `nums[i] > target`， 说明目标在左边，向左移动右指针

  `right = mid -1`

- 如果`nums[i] <= target`， 说明目标在右边，向右移动左指针

  `left = mid+1`
  
- **记录每一次符合条件的结果**

## 代码套路模板

```java
int rightBound(int[] nums, int target){
    int left = 0, right = nums.length - 1;
    int result = -1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target){
            result = mid;         // 记录当前满足条件的位置
            left = mid + 1;       // 尝试更靠右的位置
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

## 注意事项

- 使用右偏中点是**防止死循环**

- 注意是否超出数组范围

## 经验总结

- 和左边界查找常一起使用，适合区间计数题

##计算整数的算数平方根[LC 69]

###场景与目标

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

例子：

- 輸入: `x = 4`，輸出: `2`
- 輸入: `x = 8`，輸出: `2` (因為$\sqrt{8} \approx2.828$，取整數部分為 2)

###问题的本质和分析 - 计算符合条件的右边界

问题要求计算

$\lfloor \sqrt{x} \rfloor$

即找到一个**最大的整数**`k`，使得

- K的平方小于或者等于`x`.
- 这属于求**符合条件的右边界**的算法，适用于**二分查找**

我們可以將這個問題轉化為一個**搜尋問題**。

我們要在一個有序的整數序列 `[0, 1, 2, ..., x]` 中，找到這個特定的 `k`。

對於這個序列中的任何一個數 `m`：

- 如果 `m*m > x`，那麼 `m` 以及所有比 `m` 大的數都不是我們要找的答案。
- 如果 `m*m <= x`，那麼 `m` 可能就是我們要找的答案，或者答案可能是一個比 `m` 更大的數。

這種特性——能夠根據一個猜測值（`m`）將搜尋範圍一分為二——是使用**二分搜尋法 (Binary Search)** 的典型標誌。

###核心思想 - 二分查找右边界

#### 模式识别 - 二分查找计算右边界

由于数字是非负整数，那么0的平方根是0，1的平方根是1.

对于大于1的数字，其平方根的最小值无限接近1，最大值无限接近其本身。

在这个基础上使用二分查找。

**識別模式:**

1. **有序性 (Monotonicity):** 雖然沒有給定一個實體陣列，但我們的搜尋範圍 `[0, x]` 是天然有序的。更重要的是，目標函數 f(k)=k2 是單調遞增的。
2. **邊界尋找 (Boundary Finding):** 我們不是要尋找一個精確值，而是要尋找一個**滿足條件的邊界**。具體來說，我們要找的是滿足 `k^2 <= x` 這個條件的**最大**的 `k`。

### 考察点

1. **演算法思維:** 能否將一個數學問題抽象並轉化為一個標準的演算法模型（二分搜尋）。
2. **二分搜尋的實現:** 能否準確無誤地實現二分搜尋，特別是邊界條件的處理。
3. **程式碼的健壯性:** 能否考慮到潛在的邊界問題，尤其是**整數溢位 (Integer Overflow)**

### 核心思想和套路

#### 定义搜索区间

 答案一定在 `[0, x]` 的範圍內。我們定義 `left = 0`，`right = x`。

#### 循环搜索 

當 `left <= right` 時，持續進行搜尋。

#####**計算中間值 `mid`:**

採用 `mid = left + (right - left) / 2` 來有效防止 `left + right` 可能導致的溢位

##### 比较和缩小范围

检查$mid^2$ 与 `x`的关系。

- 如果$mid^2 \le x$： 说明mid为一个**可能的解**，但是我们应该继续尝试寻找**更大的解**。

  因此，我们先将`mid`记录为**候选答案**，然后**将搜索区间的左边界移动到`mid`的右侧**：`left = mid + 1`

- 如果$mid^2 \gt x$ ： 说明`mid`**太大了**，它和所有比它大的数都**不可能是解**。

  因此我们需要**缩小搜索范围的右边界：**`right = mid - 1`

##### 返回结果

遍历结束时，记录的最后一个候选答案就是满足条件的最大整数。

### 难点分析和应对

#### 整数溢出问题 - 使用long类型

当`x`很大时，计算$mid ^ 2$ 可能会溢出，导致计算结果出现错误

 ##### 使用Long类型防止溢出

在做乘法運算前，將 `mid` 轉換為 `long` 類型，即 `(long)mid * mid`。這是最直接、最清晰的方法。

##### 使用除法防止溢出

將比較 `mid * mid <= x` 轉換為 `mid <= x / mid`。

這樣可以避免乘法，但需要注意 `mid` 不能為零。

在我們的演算法中，當 `mid` 為 0 時，`x/mid` 會拋出異常。

雖然可以透過特判 `mid == 0` 來解決，但不如使用 `long` 來得簡潔。

#### 二分搜索的边界处理 - left < right 还是left <= right?

`while` 迴圈的條件用 `left <= right` 還是 `left < right`？邊界更新是 `right = mid` 還是 `right = mid - 1`？這些細節容易出錯導致死迴圈或錯誤答案。

**採用固定且可靠的模板:** 本題是尋找滿足條件的**右邊界（最大值）**。

推薦以下模板：

- 迴圈條件: `while (left <= right)`，確保搜尋區間不為空。
- 當 `check(mid)` 成功時 (即 `mid*mid <= x`)：記錄答案 `ans = mid`，並嘗試更大的，`left = mid + 1`。
- 當 `check(mid)` 失敗時 (即 `mid*mid > x`)：`mid` 太大，`right = mid - 1`

這個模板的邏輯清晰：只要 `mid` 滿足條件，就先接受它作為答案，然後更大膽地去右邊探索；如果不滿足，就必須往左邊縮小範圍。

### 实现原理和详细步骤

#### Edge Case 处理

 如果 `x` 為 0，其平方根就是 0。

直接返回 0。 (這一步可以省略，因為後續演算法也能正確處理，但顯式處理更清晰)。

#### 初始化搜索范围和结果

```java
int left = 0;
int right = x;
int ans = 0;
```

#### 执行二分查找逻辑

判斷 `(long)mid * mid <= x`

**如果為 `true`:**

- `mid` 是個合法的解。將其記錄下來：`ans = mid;`
- 繼續向右搜尋更大的可能解：`left = mid + 1;`

**如果為 `false`:**

- `mid` 太大了。向左搜尋：`right = mid - 1;`

```java
while(left <= right){
 int mid = left + (right -left) / 2;
 if((long)mid*mid <= x){
   //可能是一个答案
   //但是题目求的是最大的整数
   //因此我们需要继续尝试在mid右边查找下一个更大的
   ans = mid;
   left = mid + 1;
 }else{
   //如果超过了，说明mid大了
   //我们需要将搜索范围缩小至mid左边
   right = mid - 1;
 }
}
```

#### 返回结果

遍历结束以后，`ans`中存储的就时**最后一次满足`(long)mid * mid <= x`的`mid`值，即为所求的最大`k`，返回`ans`即可。

### 实现代码

```java
    //二分查找方法
    public int mySqrt(int x) {
        if (x == 0 || x == 1) return x;
        int left = 1;
        int right = x;
        int ans = 0;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if((long)mid*mid <= x){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return ans;
    }
```

### 注意事项

- **溢位問題是第一要務:** `mid * mid` 是最容易出錯的地方，必須處理。
- **理解 `ans` 變數的作用:** 在這個模板中，`ans` 的作用是「跟蹤」最後一個有效的解。因為 `left` 指標會不斷向右移動，`ans` 儲存的始終是 `left` 移動前那個符合條件的位置。
- **`right` 的初始值:** 將 `right` 初始化為 `x` 是最穩健的選擇。雖然對於較大的 `x`，`x/2` 似乎是個更緊的上限，但這會讓 `x=0,1` 等情況需要特殊處理，直接用 `x` 作為上界則對所有非負 `x` 都適用。

### 经验总结

LeetCode 69 是從一個簡單的數學問題通往**二分搜尋思想**的絕佳橋樑。它教會我們，二分搜尋不僅能用在具體的陣列上，還能用在任何具有**單調性**的**解空間**中。

**掌握問題抽象能力:** 識別出問題背後的「在有序集合中尋找邊界」的模式，是解決這類問題的關鍵。

**形成自己的模板:** 對於二分搜尋的各種變體（尋找第一個、尋找最後一個、尋找最接近的），形成自己一套可靠的程式碼模板，可以極大地提高解題速度和準確率。

**細節決定成敗:** 在演算法問題中，像整數溢位這樣的工程細節，往往是區分程式碼能否通過所有測試案例的關鍵。時刻保持對數據範圍的警惕性。

## 搜索边界时，while条件到底是 left < right 还是 left <= right?

你又提出了一个关于二分搜索最核心、最精髓、也最容易混淆的问题！非常棒！

简单的回答是：**两种写法都可以，但它们是两种不同的“模板”，对应着不同的区间定义和更新逻辑。**

**`while (left <= right)` 是最常见、最不容易出错的模板，尤其适合初学者。**

### 核心区别： 区间的定义

#### 闭区间模板: `while(left <= right)`- 通过记录和比较找到答案

- **区间定义**: 搜索范围是 `[left, right]`，这是一个**闭区间**，意味着 `left` 和 `right` 都是**有效的候选答案**。

- **循环条件**: `left <= right` 的意思是，只要区间里**至少还有一个元素**（当 `left == right` 时），循环就应该继续。

- **循环终止**: 当 `left > right` 时，例如 `left = 5, right = 4`，区间 `[5, 4]` 变为空集，循环终止。

- **区间更新**: 因为 `mid` 在循环体中已经被检查过了，所以下一次搜索的区间**必须把 `mid` 排除掉**。

  - `right = mid - 1`
  - `left = mid + 1`

  这样做可以保障每次循环过程中，区间至少可以缩小1，从而**避免死循环**。

#### 开/半开区间： `while(left < right)` - 逼近答案

- **区间定义**: 这个模板的目的是将一个包含多个元素的区间，最终缩减为**恰好一个元素**。

- **循环条件**: `left < right` 的意思是，只要区间里**至少还有两个元素**，循环就应该继续，以进一步缩小范围。

- **循环终止**: 当 `left == right` 时，区间里只剩下一个元素，循环终止。此时 `left`（或 `right`）就是最终的候选答案。

- **区间更新**: 这是最需要小心的地方。因为我们的目标是**逼近**，所以有时候不能排除 `mid`。

  - 如果要将答案保留在 `mid` 或其左侧，我们会用 `right = mid`。

  - 如果要将答案保留在 `mid` 右侧，我们会用 `left = mid + 1`。

  - **注意**: 

    如果你用了 `right = mid`，那么另一分支必须用 `left = mid + 1`。

    如果你用了 `left = mid`，另一分支必须用 `right = mid - 1`。

    否则，当区间只剩两个元素时，可能会导致 `mid` 不变，从而陷入死循环。

#### 两者内在核心逻辑的本质不同点

##### 模板1（while(left <= right)）: 检查与排除

**问题本质：** "我要找的**特定值 `target`** 在数组的哪个位置？" (或者，"它在不在？")

######**目标：** 遍历所有**可能的**答案区间 `[left, right]`。

######**`mid` 的角色：**检查点 。

在循环的每一步，你都要对 `mid` 元素进行**裁决**："你是不是我要的 `target`？"

######**裁决结果 (三向分支)：**

- `nums[mid] == target`：找到了！(可以直接 `return`，或者记录 `ans` 并继续搜索"第一个/最后一个")。
- `nums[mid] < target`：`mid` **肯定不是** 答案。而且 `mid` 左边的所有元素也都太小，**也不是** 答案。所以，下一个搜索区间是 `[mid + 1, right]`。
- `nums[mid] > target`：`mid` **肯定不是** 答案。而且 `mid` 右边的所有元素也都太大，**也不是** 答案。所以，下一个搜索区间是 `[left, mid - 1]`。

######**指针移动的本质：** 排除mid

`left = mid + 1` 和 `right = mid - 1`。在这两种情况下，`mid` 本身都**被明确地排除了**。我们**丢弃**了 `mid`。

######**循环终止：** `left > right`。

这意味着搜索区间 `[left, right]` 变为**空集**

我们已经检查了所有可能的元素，但都没找到 (或者已经记录了 `ans`)。

##### 模板2(while(left < right))：收敛和逼近

**问题本质：** "我要找的那个**满足特定属性的边界**在哪里？" 

(例如："峰值"、"第一个坏版本"、"旋转点的最小值")

###### 目标：不断收敛答案区间

 维护一个**始终包含**答案的区间 `[left, right]`，并不断**收缩**这个区间，直到它的大小为 1。

###### **`mid` 的角色：** `mid` 是一个 "分割点"

它将当前区间 `[left, right]` 分割成两半：`[left, mid]` 和 `[mid + 1, right]`。

######**裁决结果 (二向分支)：**

- 你**不是**在问 " `mid` 是不是答案"，而是在问："答案（那个边界）在 `mid` 的左半边还是右半边？"
- `if (check(mid))` (例如 `nums[mid] < nums[mid+1]`)：这个条件告诉你，答案（峰值）**必定**在 `mid` 的**右侧** `[mid + 1, right]` 区间内。此时，`mid` 本身**肯定不是** 答案 (因为它是上坡)。
- `else` (例如 `nums[mid] > nums[mid+1]`)：这个条件告诉你，答案（峰值）**必定**在 `mid` 的**左侧**，或者 `mid` **本身就是** 答案。所以，答案在 `[left, mid]` 区间内。

######**指针移动的本质：**

- `left = mid + 1`：当你知道 `mid` 肯定不是答案时，你可以**丢弃** `mid`。
- `right = mid`：当你知道答案在 `[left, mid]` 区间时，`mid` **有可能是答案** (它可能就是那个边界！)，你**绝对不能丢弃**它。你只能把 `right` 指针移动到 `mid`，将搜索区间缩小为 `[left, mid]`。

###### **循环终止：** `left == right`。

由于你始终维护着一个**包含答案**的区间，当这个区间被收缩到只剩一个元素时，`left`（和 `right`）指向的**就是那个唯一的答案**。

#### 场景分析和代码模板

##### 场景一： 寻找一个确切的值 (例如，在一个数组里找 `target`)

使用 `while (left <= right)` 模板最直观。

```java
int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; // [left, right] 闭区间
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid; // 直接找到
        } else if (nums[mid] < target) {
            left = mid + 1; // target 在右侧
        } else { // nums[mid] > target
            right = mid - 1; // target 在左侧
        }
    }
    
    return -1; // 循环结束还没找到，说明不存在
}
```

**为什么这个好？** 因为它的逻辑非常对称和简单：找到就返回，否则就将搜索区间缩小一半（并且不包含 `mid`）。

##### 场景二： 寻找左边界

###### 写法一： 使用 `while (left <= right)`  - 需要记录迄今为止最好的答案！

这种写法需要一个额外的变量来记录**迄今为止最好的答案**。

```java
// 在 events 数组中，寻找第一个开始时间 > targetEndTime 的事件
// search space: [currentIndex + 1, n - 1]
int left = currentIndex + 1;
int right = n - 1;
int result = n; // 用一个变量记录潜在答案，默认为n(表示没找到)

while (left <= right) {
    int mid = left + (right - left) / 2;
    if (events[mid][0] > targetEndTime) {
        // mid 是一个合格的答案，但可能不是最左边的那个
        // 我们把它记录下来，然后尝试在左半部分寻找更好的答案
        result = mid; 
        right = mid - 1;
    } else {
        // mid 不合格，必须去右边找
        left = mid + 1;
    }
}
return result;
```

这种写法通过 `result` 变量来追踪边界，而循环本身的 `left`和`right` 只是用来控制范围，逻辑清晰。

###### 使用 `while (left < right)` (不断逼近最为合适的答案)

这种写法不需要额外变量，循环结束时 `left` 本身就是答案。

```java
// 在 events 数组中，寻找第一个开始时间 > targetEndTime 的事件
// search space: [currentIndex + 1, n]
int left = currentIndex + 1;
int right = n; // 注意：right 是 n，这是一个“虚拟”的右边界

while (left < right) {
    int mid = left + (right - left) / 2;
    if (events[mid][0] > targetEndTime) {
        // mid 是一个合格的答案，那么真正的左边界一定在 [left, mid] 范围内
        right = mid; 
    } else {
        // mid 不合格，那么真正的左边界一定在 [mid + 1, right] 范围内
        left = mid + 1;
    }
}
// 循环结束时, left == right，这个位置就是第一个 > targetEndTime 的索引
return left;
```

### 总结

| 特点               | `while (left <= right)`                     | `while (left < right)`                          |
| ------------------ | ------------------------------------------- | ----------------------------------------------- |
| **适用场景**       | 查找特定值 (最直观) / 查找边界 (需辅助变量) | 查找左、右边界 (最凝练)                         |
| 是否需要辅助变量？ | 是                                          | 不需要                                          |
| **区间定义**       | 闭区间 `[left, right]`                      | 通常是左闭右开 `[left, right)`                  |
| **循环条件**       | 区间不为空                                  | 区间至少有两个元素                              |
| **终止状态**       | `left > right` (区间为空)                   | `left == right` (区间剩一个元素)                |
| **核心更新**       | `left = mid + 1` / `right = mid - 1`        | ``left = mid + 1`/right = mid` / (需小心死循环) |
| **结果**           | 通常在循环内部返回，或循环后判断            | 循环结束后 `left` (或 `right`) 就是候选答案     |

# 插入位置查找 - 在数组寻找目标的插入位置[LC 35]

## 场景和目标

在数组中寻找目标的插入位置

## 核心思想，找到第一个 >= 目标值的位置（左边界）

找到第一个`>=`目标值的位置

## 实现代码

```java
int searchInsert(int[] nums, int target){
  int left = 0;
  int right = nums.length - 1;
  
  while (left < right){
    int mid = left + (right - left) / 2;
    if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  
  return left
}
```

# 搜索峰值/局部极值[LC 162]

## 场景与目标

在一个“相邻元素互不相等”的数组中，找到**任意一个局部最大**的位置。

**目标：** 在一个整数数组 `nums` 中找到一个 "峰值" 元素，并返回其**索引**。

**峰值定义：** 峰值是其值**严格大于**左右相邻元素的元素。

**多峰值：** 数组可能包含多个峰值，返回**任意一个**即可。

**关键约束 (1)：** 题目假设 `nums[-1] = nums[n] = -∞` (负无穷)。这意味着：

- 如果数组的第一个元素 `nums[0]` 大于 `nums[1]`，那么 `nums[0]` 就是一个峰值。
- 如果数组的最后一个元素 `nums[n-1]` 大于 `nums[n-2]`，那么 `nums[n-1]` 就是一个峰值。

**关键约束 (2)：** `nums[i] != nums[i+1]`，即相邻元素不相等。

**性能要求：** 算法的时间复杂度必须为 $O(\log n)$。

## 问题本质和分析

###$O(\log n)$ 意味着你得考虑二分搜索

**$O(\log n)$ 的启示：** 看到 $O(\log n)$ 的时间复杂度要求，尤其是用在数组搜索上，我们应立即想到**二分搜索 (Binary Search)**。



###**为何能用二分：** 这是一个非排序数组，为什么能用二分？（坡）

- 常规的二分搜索依赖于数组的**单调性**（递增或递减）来查找一个*特定值*。
- 本题不是查找特定值，而是查找一个满足*特定属性*（即 `> left` 且 `> right`）的元素。
- 我们的二分搜索**不是**基于 "值" 的比较，而是基于 "坡" 的比较。

### 峰值是一定存在的

由于 `nums[-1]` 和 `nums[n]` 都是**负无穷**，整个数组就像一座山脉，两端是无限低的海平面。

从海平面（`nums[-1]`）开始，数组的值必然会 "上升"（或者第一个元素就是峰值）。

只要有上升，就必然有下降的地方（因为 `nums[n]` 也是负无穷）。

这个 "上升" 转为 "下降" 的拐点，就是一个峰值。

因此，**峰值必定存在**。



## 规律观察：观察nums[mid]和nums[mid+1]

我们来看一个任意的中间点 `mid`。

由于 `nums[i] != nums[i+1]`，`nums[mid]` 和 `nums[mid+1]` 只有两种关系：

###`nums[mid] < nums[mid+1]`:峰值在(mid,right]

- [... `mid`, `mid+1` ...] 呈**上升趋势**（上坡）。

- 这意味着什么？我们从 `mid+1` 继续向右走，我们最终必然会到达一个峰值。

- **为什么？**

   因为我们正处在上坡，要么这个上坡一直持续到数组末尾（此时 `nums[n-1]` 是峰值，因为它大于 `nums[n-2]` 且大于 `nums[n] = -∞`），要么我们会在某个点 `k` 遇到 `nums[k] > nums[k+1]`。

  在这个 `nums[k] > nums[k+1]` 的点 `k`，因为它左侧是上坡（`nums[k] > nums[k-1]`），右侧是下坡，所以 `k` 本身就是一个峰值。

  **结论：** 如果 `nums[mid] < nums[mid+1]`，那么在 `mid` 的**右侧（即 `[mid + 1, n - 1]` 范围内）必然存在一个峰值**。

  `mid` 左侧可能也有，但我们不关心，我们只需要找到 *一个* 即可。

###**`nums[mid] > nums[mid+1]`**：峰值在[left,mid]

- [... `mid`, `mid+1` ...] 呈**下降趋势**（下坡）。

- 这意味着什么？`mid` 本身**可能**就是一个峰值（如果 `nums[mid] > nums[mid-1]`）。

- 即使 `mid` 不是峰值（比如 `nums[mid-1] > nums[mid]`），那么从 `mid` 向左走，也必然会遇到一个峰值。

- **为什么？** 

  因为我们正处在下坡（从左往右看），这说明我们的左侧（`mid` 或 `mid` 之前）必然有一个 "更高" 的点。

  我们顺着这个 "更高" 的方向往左找，要么找到数组开头 `nums[0]`（它是一个峰值，因为它大于 `nums[-1] = -∞`），要么找到一个拐点 `k` 使得 `nums[k] > nums[k-1]` 且 `nums[k] > nums[k+1]`。

  **结论：** 如果 `nums[mid] > nums[mid+1]`，那么在 **`mid` 本身或其左侧（即 `[0, mid]` 范围内）必然存在一个峰值**。

**观察总结：** 通过比较 `nums[mid]` 和 `nums[mid+1]`，我们总能确定哪一半区间**必定**包含一个峰值。这为二分搜索提供了完美的决策依据。

## 模式和套路匹配

- **匹配模式：** **二分搜索 (Binary Search)**。
- 本质上来看也可以看作是一个二分答案：`nums[mid] > nums[mid+1]`就是check条件。
- **具体模板：** 这不是查找特定值的标准二分，而是 "寻找边界" 或 "最小化/最大化" 类型的二分模板。
  - 我们寻找的是一个 "下降" 的起点（即 `nums[i] > nums[i+1]`）。
  - 我们要寻找满足 `nums[i] > nums[i+1]` 的**最小的 `i`** 吗？不一定。
  - 我们只是需要一个 `mid`，通过比较 `nums[mid]` 和 `nums[mid+1]` 来缩小搜索范围。
  - 最适合的模板是：`left = 0`, `right = n - 1`，循环条件 `left < right`。

## 核心思想 - 峰值两边单调

**核心思想：** 利用二分法，通过检查数组的 "坡度"（上升或下降）来不断缩小必定包含峰值的搜索区间。

**套路 (Template):**

1. 初始化 `left = 0`, `right = nums.length - 1`。
2. 循环 `while (left < right)`。
   - `left < right` 保证了区间内至少有两个元素，这使得 `mid+1` 总是在 `right` 的范围内，不会越界（当 `left` 和 `right` 相邻时，`mid = left`，`mid + 1 = right`）。
3. 计算 `mid = left + (right - left) / 2`。
4. **判断坡度：**
   - **如果 `nums[mid] < nums[mid+1]` (上坡):**
     - 峰值一定在 `mid` 的右侧。
     - 我们舍弃左半边（包括 `mid`，因为它肯定不是峰值，它比它右边的邻居小）。
     - `left = mid + 1`
   - **如果 `nums[mid] > nums[mid+1]` (下坡):**
     - 峰值在 `mid` 处或在 `mid` 的左侧。
     - `mid` **可能**就是那个峰值，所以我们不能舍弃它。
     - 我们舍弃右半边。
     - `right = mid`
5. **循环终止：** 当 `left == right` 时，循环终止。此时 `left`（或 `right`）指向的索引就是答案。

## 实现原理与详细步骤-比较`nums[mid]`和`nums[mid+1]`

### 初始化左右指针

`left = 0; right = nums.length - 1`

### 遍历 `while (left < right)`

#### 计算中间位置，下位法

- `mid = left + (right - left) / 2`

#### 比较`nums[mid]`和`nums[mid+1]`-注意~~不是比较`nums[right]`~~

- 如果`nums[mid] > nums[mid + 1]`， 说明结果在左侧，移动右指针 `right = mid`
- 如果`nums[mid] <= nums[mid + 1]`, 说明结果在右侧，移动左指针 `left = mid + 1`
- 返回`left`或者`right`

## 代码套路

```java
int findPeakElement(int[] nums){
  int left = 0 ;
  int right = nums.length -1;
  while (left < right){
    //非单调递增，结果在左边
    if (nums[mid] > nums[mid+1]){
      right = mid;//为什么是mid，因为nums[mid]也有可能是峰值
    } else{
      left = mid + 1;
    }
  }
  return left;
}
```



## 注意事项

- 数组保证至少有一个峰值。

- 防止 `mid+1` 越界。

## 经验总结

常用在“山脉数组”或“波峰波谷”场景。

# 旋转数组查找

## 旋转过的数组查询最小值[LC-153]

### 场景与目标

一个升序数组被旋转后，找其中的最小值

### 问题分析 - 左右两段各自有序

虽然整体无序，但是左右两段各自有序。

比较`mid`和`right`可以判断最小值所在半区。

现在我们的目标是找到一个最小值。

### 核心思想： 不断缩小搜查范围

我们的想法是不断的缩小搜索范围$[left...right]$， 当`left == right`的时候，我们就得到了我们想要的答案。

一般来说，在一个**升序** 数组中：$nums[left] \le nums[mid] \le nums[right]$。

但是如果一个数组旋转过，可能会出现类似$[mid, low, high]$的情况。

#### `nums[mid] > nums[right]`: 最小值在中点右边$(mid...right]$

如果`nums[mid] > nums[right]`， 说明数组旋转以后，最小值落在了区间$(mid...right]$。

类似$[4,5,6,1,2,3]$

因为这种情况下，**最小值不可能是mid**，所以最小值应该出于区间$(mid,right]$。

因此这种情况下，我们应该将**左指针向右移动**到`mid+1`。

####`nums[mid] <= nums[right]`:最小值在左边(包括中点)$[left,mid]$

如果`nums[mid] < nums[right]`， 说明数组旋转之后，最小值应当在$[left...mid]$。

比如$[1,2,3,4,5,6]$

在这种情况下，**最小值有可能是`nums[mid]`**，因此最小值应该在区间$[left,mid]$。

因此**右指针向左应该移动**到`nums[mid]`位置。

按照上面的逻辑不断的缩小搜索范围，最后我们所得到的`nums[left]`就是我们想要找的答案。

### 实现原理和步骤

#### 初始化左右指针

`left = 0; right = nums.length - 1;`

#### 遍历`while(left < right)`

- `mid = left + (right - left) /2`
- 如果`nums[mid] > nums[right]` ， 说明最小值在右边，右移左指针：`left = mid + 1`
- 如果`nums[mid] <= nums[right]`， 说明最小值在左边，左移右指针：`right = mid`

#### 返回结果left或者right

返回结果left或者right

### 代码套路模板

```java
int left = 0; right = nums.length - 1;
while (left < right){
  int mid = left + (right - left) /2;
  //说明结果在右边，右移左指针
  if (nums[mid] > nums[right]){
    left = mid + 1;
  }else{
    //否则右指针移动到mid上
    right = mid;
  }
}

return nums[left];
```

### 注意事项

如果允许重复，判断修改为`>=` ，并且可能复杂度退化为`O(N)`

### Leetcode 154 旋转数组查询最小值 - 有重复

给定一个可能包含**重复元素**的旋转排序数组 `nums`，要求在 `O(log n)` 的平均时间复杂度内找出其中的最小值。

数组最初是递增排序的，但在某个未知下标处进行了旋转，例如 `[0,1,2,4,5,6,7]` 旋转后可能变为 `[4,5,6,7,0,1,2]`；

由于允许重复元素，最坏情况下可能退化到**线性扫描**。

#### 问题本质和分析

在一个近乎有序的数组里，定位最小值的问题。

- **对比普通二分**：普通二分在全局有序数组里找特定值，这里是要找**拐点**
- **关键因素：** 数组可能存在**重复元素**，导致常规二分判断`nums[mid]`与**边界值**大小关系时出现不确定情况

####核心思想与套路 - 双指针/二分框架

##### 根据 `nums[mid]` 与 `nums[r]` 的比较结果决定收缩方向

首先我们根据Leetcode 153中的方法，比较`nums[mid]`和`nums[right]`:

- 如果`nums[mid] > nums[r]`，说明最小值在右侧`(mid,r]`,右移左指针`l = mid + 1`
- 如果`nums[mid] < nums[r]`，说明最小值在左侧`[left,mid]`， 左移右指针`r = mid`

然而如果出现`nums[mid] == nums[right]`的情况，说明`nums[mid]`和`nums[right]`在原数组中应该可能是**连在一起的一组相同值中**的两个。

这个时候我们需要跳过其中的重复元素：

##### 通过收缩右指针跳过重复元素

如果`nums[mid] == nums[r]`，无法区分左右，则**收缩右指针跳过一个重复元素**：`r--`。

注意下一轮**中点**`mid`计算就会基于新的**right**指针, **中点也会伴随右指针左移**

###### 为什么可以这么做？

当 `nums[mid] == nums[r]` 时，`nums[mid]` 和 `nums[r]` 是相同的值。

我们并不知道这个值是不是整个数组的最小值，也不知道最小值是在这两个相同值的左边还是右边。

但是，无论哪种情况，都可以“安全”地把上界 `r` 向左移动一位。

**不会丢失最小值的唯一实例**

如果这个相同的值正好是最小值，那么因为 `nums[mid] == nums[r]`，在 `[l, r]` 区间里至少有两个相同的最小值实例──一个在 `mid`，一个在 `r`。

即使丢弃 `r` 位置的那个，你依然保留了 `mid` 位置的最小值，不会把最小元素从搜索区间里抹掉。

**不会丢失区分信息**

如果这个相同的值并不是最小值，那么它既不是左边区间的所有值都比它小，也不是右边区间的所有值都比它大；

它只是一个普通的“赘余”重复。把 `r` 那个重复元素丢掉，
- 剩下的区间 `[l, r-1]` 里最小值的位置仍然保留，
- 且不会影响后续对 “>”、“<” 情况的判定。

**渐进式缩小，保持不变式**

- 算法的不变式是**最小值始终在当前区间 `[l, r]` 内**。	
- 当 `nums[mid] == nums[r]` 时，删除 `r` 端点后，新区间 `[l, r-1]` 仍然满足这一不变式：要么最小值在 `l…mid`，要么在 `mid+1…r-1`；
- 但我们并不需要立刻判断，而是让区间渐渐收窄，对数级别的效率只会略微退化（在最坏重复全相同时退化到 O(n)），却绝不会漏掉正确答案。

最终在`l == r`时，即为最小值下标，返回`nums[l]`

####难点分析与应对方法

##### 存在大量重复元素导致不确定性

当`nums[mid] == nums[r]`时，无法判断最小值在哪里，只能`r--`，最坏退化到`O(N)`

##### 二分终止条件与下标越界

使用`while(l < r)`， 而非`while( l <= r)`， 避免死循环和越界

##### 溢出风险（极端大数组）

计算`mid = l + (r-l) /2`

####代码实现

```java
   public int findMin(int[] nums) {
        int left = 0; 
        int right = nums.length - 1;
        while (left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[right]){
                // 最小值在右侧，左指针右移
                left = mid + 1;
            } else if (nums[mid] < nums[right]){
                //最小值在左侧，右指针左移
                // 最小值在左侧或 mid 处
                right = mid;
            } else{
                //如果nums[mid] == nums[right]
                //不确定最小值的区间
                //将右指针左移一步
                right--;
            }
        }

        return nums[left];
    }
```

#### 注意事项

1. **空数组与单元素**：提前校验 `nums == null || nums.length == 0`；单元素时 `l == r`，直接返回。
2. **循环与边界**：必须用 `while (l < r)`，保证最后 `l` 指向最小元素。
3. **避免溢出**：`mid = l + (r - l) / 2` 而非 `(l + r) / 2`。
4. **最坏时间复杂度**：当所有元素相等时 `while` 每次只能 `r--`，退化为 O(n)。这是题目允许的。

#### 经验总结

- **思路复用**：解决**在旋转排序数组里找极值／目标值**的题，大多沿用此类改良二分。
- **面对重复**：凡是数组可包含重复，且又要用二分区间缩减，都会出现类似 `nums[mid] == nums[r]` 的“不确定”情况，通用做法是**跳过一个重复元素**。
- **保持谨慎**：二分写法易错细节要清晰——循环条件、mid 计算、指针移动边界。
- **完善测试**：必测多种场景——无旋转、完全旋转、全部相等、少量元素等。

## 在旋转过的数组中查找目标值[LC 33]

### 场景与目标

在旋转数组中查找给定值，返回索引或者-1。

### 问题分析 - 哪一段有序？

#### 标准的二分查找依赖于数组的有序性

此问题的本质是在一个“部分有序”的数组中进行高效查找。

标准的二分查找依赖于**整个数组的单调性（完全有序）**。

但旋转破坏了数组的全局有序性，使得我们不能直接应用标准的二分查找。

##### 旋转后数组将会分类为两个有序的子数组

问题的关键在于，**虽然数组整体不是有序的，但旋转后，它必然分裂为两个有序的子数组**。

更重要的是，**当我们通过二分法选择一个中间点 `mid` 时，它会将数组分为两部分，其中至少有一部分是完全有序的**。

我们的任务就是利用这个**局部有序**的特性。

### 规律观察：`[left...mid]`和`[mid...right]`至少有一个是有序的

我们取数组的中间值 `nums[mid]`，并将其与区间的两个端点 `nums[left]` 和 `nums[right]` 进行比较。这时，一个关键的规律就出现了：

对于任意一个区间 `[left, right]`，它的中间点 `mid` 总会使得 `[left, mid]` 和 `[mid, right]` 这两个子区间中，**至少有一个是完全有序的**。

这个观察是解决问题的**基石**。

我们总能找到一个有序的子数组，从而判断 `target` 是否在该子数组内。

如果 `target` 在有序子数组内，我们就在这个子数组里继续搜索；

如果不在，我们就去另一个（可能无序的）子数组里搜索。

### 核心思想： 找到有序的部分并检查Target是否在里面

核心思想是 **“分而治之”**，利用二分法不断缩小搜索范围，但在每一步决策时，增加一个判断条件来确定局部有序性。

根据前面我们所总结的，在旋转数组中，给定任何一个中点`mid`，那么`[left...mid]`和`[mid...right]`两个区间中**至少有一个区间是有序**的（当然我们知道在旋转了个寂寞的情况下，两个区间都是有序的）。

我们的做法是先找到那个有序的区间，看看Target是不是在有序的区间里面，如果在的话，就在有序区间里按照二分查找继续寻找就可以了。

如果不在的话，我们使用相同的策略，在无序区间内再找一个中点，根据中点，再找一个有序区间，继续上述的过程。

按照上面的过程，一直找到Target为止，或者发现target不在数组里，返回-1便可。

#### 当前中点元素是不是Target($nums[mid] == target$)?

首先我们应当比较当前元素是否是我们搜索的元素，如果是的话直接返回当前中点的索引即可。

#### 左边有序？

如果`nums[mid] > nums[right]`， 就说明`[left...mid]`(左半部分)是有序的。

这说明数组的最小值应该在区间`(...right]`中间，也就是说现在`[left...mid]`是有序的。

根据旋转数组的特性，如果`nums[mid] > nums[right]`，那么`[left...mid]`应该是有序的。

##### Target在左边范围内（$[nums[left],nums[mid])$）？

###### 怎样检查Target是否在左边范围？$[nums[left]\le target \lt nums[mid])$

注意我们这里需要检查的是Target是否在区间 $[nums[left]\le target \lt nums[mid])$， 在区间内也并非是这个元素一定在数组里面。

注意这里不是$target \le nums[mid]$， 因为我们一开始就检查了这个情况。

###### 如果在的话就在`[left...mid)`进行二分搜索

如果Target在左边范围的话，我们就在`[left,mid)`进行二分搜索。

**即只需要将右指针左移到`mid-1`即可。**

```Java
//如果左半部分[left,mid)有序
if(nums[mid] > nums[right]){
  
  //如果target在[nums[left],nums[mid])区间内
  //则在区间[left,mid)进行二分查找
  if(target >= nums[left] && target < nums[mid]){
   //如果在区间内的话，我们将right收缩到区间内，就变成[left,mid)
    //下一轮我们在搜索的时候，自然就会按照
    right = mid - 1;
  //如果target不在区间中，则尝试在[mid+1,right]中查找
  }else{
    left = mid + 1;
  }
}
```



##### Target不在左边范围内？

如果不满足条件$nums[left] \le target \lt nums[mid]$， 则说明Target不在左边的有序部分内。

那么它必然在**右边的无序部分**，这个时候我们需要继续在`(mid,right]`区间内：

- 寻找新的有序和无序部分，
- 并继续查找元素。

#### 右边有序？

//和上述的情况类似

### 实现原理和步骤

#### 初始化左右指针

`left = 0; right = nums.length - 1`

#### 二分查找逻辑(while(right <= right))

- 计算中点:`mid = left + (right -left) / 2`
- 如果`nums[mid] == target`，返回mid

#####`[left...mid]`有序的情况

如果`nums[left] <= nums[mid]`，说明**左半段有序**
- 如果`nums[left] <= target < nums[mid]`， 说明结果在左边，左移右指针 ： `right = mid -1`
- 如果`target >= nums[mid]`， 说明结果在右边，右移左指针:`left = mid + 1`

- 如果`nums[left] > nums[mid]`，说明**右半段有序**
  - 如果`nums[mid] < target <= nums[right]`，说明结果在右边，右移左指针: `left = mid + 1`
  - 如果`target < nums[mid]`，说明结果在左边，左移右指针：`right = mid -1`
- 返回`-1`

### 代码实现

```java
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right){
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) return mid;

            if (nums[left] <= nums[mid]){
                if (target >=nums[left] && target < nums[mid]){
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }else{
                if (target > nums[mid] && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
```

### 注意事项

- **边界条件**: `while (left <= right)` 中的 `=` 号是必须的，否则当数组只剩一个元素时会错过检查。
- **避免溢出**: 计算 `mid` 时使用 `left + (right - left) / 2` 是一个好习惯。
- **区间判断**: 在判断 `target` 是否在有序区间时，边界的 `>=` 和 `<` 要写对。例如，在 `nums[left] <= target && target < nums[mid]` 中，`target` 可以等于 `nums[left]`，但不能等于 `nums[mid]`，因为 `nums[mid]` 等于 `target` 的情况已经在循环开始时被检查过了。
- **无重复元素**: 这个解法强依赖于数组中没有重复元素。如果有重复元素（例如 LeetCode 81. 搜索旋转排序数组 II），`nums[left] == nums[mid]` 的情况会变得复杂，无法确定哪边是有序的，需要额外的处理。

### 经验总结

**识别二分查找变体**: 任何时候看到“有序数组”（即使是部分有序）并且要求 $O(\log n)$ 复杂度，都应立刻想到二分查找。

**找到“锚点”**: 解决这类问题的关键是找到一个判断标准，能够在每一步都稳定地排除一半的元素。在这个问题中，这个“锚点”就是 `nums[mid]` 与 `nums[left]` (或 `nums[right]`) 的关系，它帮助我们识别出那个**必然存在的有序子数组**。

**画图辅助**: 对于旋转数组问题，画一个示意图非常有帮助。画出数组值随索引变化的折线图，可以清晰地看到旋转点和两个有序区间，有助于理清 `mid`、`left`、`right` 和 `target` 的相对位置关系。

**化繁为简**: 不要试图一次性考虑所有情况（比如 `target` 大于 `nums[mid]` 还是小于 `nums[mid]`）。先做一个大的分类（哪一半是有序的），然后在每个大类下再做小的分类（`target` 是否在有序的这一半里）。这种分治的思想能让逻辑更清晰。

**举一反三**: 掌握了这个问题，就可以触类旁通解决一系列相关问题，例如：

- LeetCode 153. 寻找旋转排序数组中的最小值
- LeetCode 154. 寻找旋转排序数组中的最小值 II (有重复元素)
- LeetCode 81. 搜索旋转排序数组 II (有重复元素)

### Leetcode 81 : 搜索旋转排序数组 - 有重复元素

给定一个可能包含重复元素的、经过旋转的升序数组 `nums`，判断目标值 `target` 是否存在于该数组中。

**关键难点**：重复元素导致无法明确一侧一定是单调递增的，从而破坏了经典 ROTATED BINARY SEARCH（旋转数组二分查找）中对区间有序性的判定。

#### 核心思想与套路 - 二分查找框架

##### 二分查找框架

- 采用左右指针 `lo`、`hi`，循环条件为 `lo <= hi`。
- 每次计算 `mid = lo + (hi - lo) / 2`，做对比判断或区间缩减。

##### 区间判断

- 经典做法（无重复元素）可以通过`nums[left] <= nums[mid]`判断左边是否有序，否则右边有序
- 遇到重复元素，如果`nums[left] == nums[mid] == nums[right]`， 则无法判断哪边有序，可以收缩边界，`left++`或者`right--`，跳过一个重复值

##### 收缩策略

- `nums[left] == nums[mid]`， 移动左指针进行收缩`lef++`
- `nums[right] == nums[mid]`，移动右指针进行收缩`right--`
- 这样做能够跳过无意义的判断，恢复**一侧有序**的二分结构

####难点分析和应对方法

##### 子区间有序性判断失败

因为重复值可能会掩盖升序关系，所以无法判断哪一部分是有序的。

因此当出现`nums[mid] == nums[left]`或者`nums[mid] == nums[right]`，应该移动左右指针。

##### 无限循环风险

简单`left++/right--`后依然无法分辨，每次必须保证`left`或者`right`在变动，最终`left > right`退出循环

##### 性能下降

连续大量重复收缩后，退化到 O(n)

在最坏情况（全相同元素）中无法避免，总体复杂度仍为 O(n)

#### 实现原理和步骤

**初始化**：`int lo = 0, hi = nums.length - 1;`

**循环二分**：当 `lo <= hi` 时：

- 计算中点 `mid = lo + ((hi - lo) >>> 1);`
- 若 `nums[mid] == target`，直接返回 `true`。

**判断重复并收缩**：

- 如果 `nums[lo] == nums[mid] && nums[mid] == nums[hi]`，则同时 `lo++`, `hi--`，跳过重复。

**区间有序性判断**（在非重复掩盖的情况下）：

- **左侧有序**：若 `nums[lo] <= nums[mid]`：
  - 若 `nums[lo] <= target < nums[mid]`，在左侧；否则在右侧。
- **右侧有序**：否则：
  - 若 `nums[mid] < target <= nums[hi]`，在右侧；否则在左侧。

**缩小区间**：根据上一步判断，移动 `lo = mid + 1` 或 `hi = mid - 1`。

**循环结束**：若退出循环无命中，则返回 `false`。

#### 实现代码

```java
 public boolean search(int[] nums, int target) {
        int left = 0; int right = nums.length-1;

        while (left <= right) {
            int mid = left + (right - left ) / 2;
            if (nums[mid] == target) return true;
            // 无法判断哪边有序时，收缩边界
            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
                left++;
                right--;
            }
            //说明左边[left...mid]有序
            else if (nums[left] <= nums[mid]){
                //右指针左移
                if (nums[left] <= target && target < nums[mid]){
                    right = mid - 1;
                    //不在区间里面
                }else{
                    left = mid + 1;
                }
                //右边有序
            }else { //nums[left] > nums[mid]
                //如果在区间内
                if (nums[mid] < target  && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
        }
        return false;
    }
```

####注意事项

1. **位运算计算中点**：使用 `>>> 1` 避免整数溢出；
2. **重复收缩**：务必放在「有序性判断」之前，否则会漏掉无法判断的情况；
3. **循环退出条件**：要保证 `lo`、`hi` 始终会收敛，否则会死循环；
4. **最坏时间复杂度**：当数组几乎全为相同元素时，收缩操作会退化到 O(n)，这是不可避免的；
5. **空间复杂度**：原地查找，O(1) 额外空间。

#### 经验总结

- **遇到重复元素时，优先考虑收缩边界**，恢复二分查找的单调区间特性。

- **严谨地处理边界条件**，尤其是 `nums[lo] == nums[mid] == nums[hi]` 的三等情况。

- **保持思路清晰**：先排除重复造成的歧义，再判断哪边有序，最后决定指针移动方向。

- 此套路可推广到其他「旋转 + 重复」场景的查找问题，只需在区间有序性判断前添加去重逻辑即可。

# 二分答案

## 场景和目标 - 求最小或者最大可行值

给定一个判断函数`check(x)`， 判断在`x`条件下是否可行，求最小或者最大可行x.

## 问题分析

将答案范围看作是一个单调`boolean`数组，寻找界限，即宣召上界或者下界。

## 核心思想

将判断函数的真假看作左右区间，查左边界或者查右边界即可

## 实现原理和详细步骤

### 初始化左右指针

`left = min, right = max`

### 遍历while (left < right)-最小可行解

1. 计算中点值`mid = left + (right - left) /2`
2. 如果`check(mid) == true`，说明`mid`值是可行的，但是因为我们求**最小可行解**， 我们需要尝试继续收缩尝试在左半区间中查找：`right = mid`
3. 如果`check(mid) == false`， 说明`mid`值不可行，需要移动左指针:·`left = mid + 1`
4. 遍历完成，返回`left`值即可

## 注意事项

- `check(x)` 必须单调，否则无意义。
- 边界处理要明确 `min`、`max` 是否包含。

## 经验总结

- 常见于“最少天数”“最小容量”“最小速度” 等。

## Leetcode 1011 : 在D天内运送包裹的能力

给你一个整数数组 `weights` 和一个整数 `D`。
 其中 `weights[i]` 表示第 i 件包裹的重量。
 每天，你将按顺序从第一个包裹开始装载船，装载的总重量 ≤ 船的最大运载重量 capacity 。
 你装载的包裹会当日送达。
 返回：要在 D 天内将所有包裹送达，船的最小运载能力 capacity 。

### 问题本质与分析

- **目标**：在限定的天数 `D` 内，将所有包裹按原顺序分批“划分”，使得每批（每天）重量总和不超过一个最小的 `capacity`。
- **本质**：在一条有序数组上，寻找一个最小的 “分割容量” 使得分割成至多 `D` 段，每段之和 ≤ `capacity`。
- **对应套路**：典型的「在单调可检验答案空间中，用二分查找最小可行值」＋「贪心检验」。

### 核心思想与套路

#### 答案空间

- 下界：`L=max(weight)`:任何一天至少得可以运最重的包裹
- 上界：`R = sum(weight)`: 一天内运完所有包裹的极端情况

#### 二分查找答案

- 在区间`[L,R]`内，寻找最小的`mid`，使得以`mid`为运载能力，能否在D天内运完的判定函数`check(mid)`返回`true`

#### 贪心检查函数

- 从头扫描包裹序列，累加当天已经装在的重量`sum`，一旦超出`cap`，就开启新一天，重置`sum = weight[i]`
- 最终统计天数`days`， 若`days <= D`即可

### 难点分析与应对方法

| 难点                | 应对方法                                                     |
| ------------------- | ------------------------------------------------------------ |
| **理解“二分答案”**  | 从「容量」这个「数值」角度切入，把「能否在 D 天内完成」视作对容量的可行性判定。 |
| **边界选取**        | 取 `L = max(weights)`、`R = sum(weights)`，保证答案一定落入其间。 |
| **判定函数实现**    | 按天贪心累加，每次超标即分新天；注意最后一天的计数。         |
| **细节 off-by-one** | 天数初始 `days = 1`；二分收缩条件 `while (L < R)`；`R = mid` 或 `L = mid + 1`。 |

### 实现原理和步骤

#### 计算上下界

```java
int left = 0; int right = 0;
for(int w : weights){
  left = Math.max(left,w);
  right += w;
}
```

#### 二分查找最小可行`capcity`

```java
while (left < right){
  int mid = left + (right - left) / 2;
  if (canShip(mid)) {
    right = mid;
  }else{
    left = mid + 1;
  }
}

return left;
```

#### 贪心判定函数`canShip`

```java
private boolean canShip(int[] weights, int D, int cap){
  int days = 1; sum = 0;
  for (int x : w){
    if (sum + x <= cap){
      sum + = x;
    }else{
      days++;
      sum = x;
      if (days > D) return false;
    }
  }
  return true;
}
```

### 实现代码

```java
    public int shipWithinDays(int[] weights, int days) {
      //计算左右边界
        int left = 0;
        int right = 0;
        for (int w : weights){
            left = Math.max(left, w);
            right += w;
        }
        //寻找左边界
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canShip(weights, days, mid)){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left;
        
    }
		//贪心计算是否能够运输
    private boolean canShip(int[] weights, int D, int cap){
        int days = 1;
        int sum = 0;
        for (int w : weights){
            if (sum + w <= cap){
                sum += w;
            }else{
                days++;
                sum = w;
                if (days > D) return false;
            }
        }
        return true;
    }
```

### 注意事项

1. **防止溢出**：累加 `right += w` 时若极端数据量大，可考虑用 `long`。
2. **二分边界收缩**：`right = mid`（可行则左移） vs. `left = mid + 1`（不可行则右移）。
3. **初始天数**：判定函数中，`days` 应初始为 1，而不是 0。
4. **时间复杂度**：二分 `O(log S)`（`S = sum(weights)`）× 判定 `O(n)`，整体 `O(n log S)`。

### 经验总结

- **二分答案**：当「某个数值最小化/最大化」且「可行性可判定且单调」时，可在答案空间做二分。

- **贪心检验**：先贪心做出「是否可行」判定，再二分优化答案。

- **套路迁移**：类似「划分数组最大子和最小化」问题（如 LeetCode 410、分割数组为 `m` 段的最小最大和）均可套用此法。

- **代码健壮**：注意上下界、类型、边界条件，避免 off-by-one 和溢出。

## Leetcode 875. 吃香蕉的Coco

珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，珂珂可以在 `H` 小时内吃掉所有香蕉。
 珂珂吃香蕉的方式是这样的：她选择一个速度 `K`（单位：根/小时），然后每小时会选择一堆香蕉，从中吃掉 `K` 根；如果该堆少于 `K` 根，就吃掉这一堆所有的香蕉，该小时内不会再吃其他堆。
 问：为了保证在 `H` 小时内吃掉所有香蕉，珂珂的最小吃香蕉速度 `K` 是多少？

相当于是每小时吃掉的香蕉数量 = 上一个小时没有吃完的 + 当前这堆香蕉

### 核心思想与套路 - 答案二分

1. **确定左右边界**
   - `left = 下界`，`right = 上界`
2. **中点 mid = (left+right)/2**
3. **验证函数 check(mid)**
   - 若 `check(mid)` 为真（能够在限定时间/天数内完成），则尝试更小的答案：`right = mid`。
   - 否则增大答案：`left = mid + 1`。
4. 循环直到 `left == right`，该值即为最优答案。

**应用场景**

- 只要题目问“最小的 X 使得某个单调条件成立”，都可尝试此套路。

### 难点分析和应对方法

#### 如何确定左右边界？

必须从题意推导出合理边界，避免「无限」或「过大」导致二分区间冗余。

##### 最小值为1

##### 为什么最大值为`max(piles)`

- **每小时只能选一堆吃**：不管你的速度有多快，**一小时内最多只能吃完一整堆香蕉**，吃完这一堆之后就不能再去吃别的了。
- **速度超过最大堆无额外收益**：设最大堆大小为 `M = max(piles)`。
  - 当 `K = M` 时，最大的那堆恰好一小时能吃完，其余更小的堆也都能在一小时内吃完。
  - 如果把 `K` 提得更大，比如 `K = M+100`，也依然只是每小时吃光一堆，然后停下，和 `K = M` 的效果完全一样——都只是**每小时清空一堆**。

所以再往上增大 `K`，也不会减少总共要吃的小时数。为了把答案空间限在有效范围，我们把二分右边界定为 `max(piles)` 就足够了。

#### 编写 check() 函数

需一次 O(n) 扫描，累加「资源消耗」（时间或天数），并及时终止提前返回。

#### 向上取整

875 中每小时吃 `K` 根，若堆中剩余 `p` 根，需的小时数是 `ceil(p/K)`。

建议写作 `(p + K - 1) / K`，避免浮点运算。

### 实现原理和步骤

#### 初始化左右边界

```
int left = 1, right = max(piles);
```

#### 二分循环

```java
while(left < right){
  int mid = left + (right -left) / 2;
  if (canFinish(mid)){
    right = mid;
  }else{
    left = mid + 1;
  }
}

return left;
```

#### 定义Check函数

遍历`piles`，累加`hours += (piles + K -1)`， 一旦`hours > H`，返回`false`

注意向上取整的逻辑，对于每一个堆，其需要的时间为`(piles[i] + k - 1)/k`向上取整。

```java
    private boolean canFinish(int[] piles, int H, int K) {
        long hours = 0;
        for (int p : piles) {
            // 每堆单独算：需要 (p + K - 1) / K 小时
            hours += (p + K - 1) / K;
            if (hours > H)
                return false;
        }
        return true;
    }
```



#### 返回结果

最终`left == right`， left或者right就是最终答案



### 代码实现

```java
    public int minEatingSpeed(int[] piles, int h) {
        int maxPile = 0;
        for (int p : piles) {
            maxPile = Math.max(maxPile, p);
        }
        int left = 1, right = maxPile;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canFinish(piles, h, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // 检查以速度 K 能否在 H 小时内吃完
    private boolean canFinish(int[] piles, int H, int K) {
        long hours = 0;
        for (int p : piles) {
          // 每堆单独算：需要 (p + K - 1) / K 小时
          //注意这个计算技巧，取上的技巧
            hours += (p + K - 1) / K;
            if (hours > H)
                return false;
        }
        return true;
    }
```

### 注意事项

- **边界考虑**

  - 当 `piles` 全部为 1 且 `H` 很大时，`left=1`、`right=1`，可直接返回 1。

- **向上取整**

  - 推荐 `(x + y - 1) / y`，效率高且无精度误差。

- **数据类型**

  - 累加时间/天数时，用 `long` 避免累积溢出。

- **提前退出**

  - `check` 中一旦超限，可立即返回 `false`，节省时间。

  

### 经验总结

**模板化思考**

- 「在答案空间上进行二分」是很多“求最小/最大 X 使得条件成立”的常用套路。

**多练类型题**

- 经典题：875、1011、以及“划分数组”、“分发糖果”等，都可以用此方法。

**养成善于求界的习惯**

- 先识别最小可能值和最大可能值，写出边界，能让算法更健壮。

**关注单调性**

- 只有当「随着 X 增大/减小，条件成立与否呈单调变化」时，此方法才适用。

**代码规范**

- 提前处理边界，避免 `left + right` 溢出；`mid = left + (right - left) / 2`；`hours` 或 `days` 用 `long`。

## Leetcode 2517 [Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/)

给定 $n$ 个糖果的价格数组 `price[]` 和一个需求量 $k$，要从中挑出 $k$ 个价格互异的糖果，使得“美味度”——所选糖果价格任意两两之差的最小值——达到最大。
 换句话说，就是在所有大小为 $k$ 的子集里，寻找那个使得子集内**两数最紧密间距**（`minimum gap`）最大的子集。

### 核心思想 与经典套路 - 二分答案 + 贪心检验

#### 核心思路： 找到最大的$x$: 能够选出k元素个符合$tastiness_{set} \le x$

我们考虑寻找一个最大的$x$,  在这个$x$限制下，我们依然能够找到k个糖果的子集set，使得$tastiness_{set} \le x$

换句话说，对于任意一个比$x$还大的$x'$， 我们都找不到这样的k个糖果了。

现在，这算是一个**最大化最小值**的问题。

#### 二分答案 ：最大化最小值

**最大化最小值**问题的常用思路： 对最小差值$x$做**二分猜测**，再验证**是否能够选出间隔$ >= x$的  K个数**

####贪心检测 - 是否能够选择出K个糖果？

也就是说我们需要在最小间隔$x$的条件下，尝试在数组中找出`k`元素。

##### 对数组进行从小到大的排序

为了能够快速的找出结果，我们只需要对数组进行排序。

##### 使用贪心算法：每次寻找下一个与当前元素间距大于$x$的元素

将`price`排序后，从最小开始，依次挑选上一个与下一个的**价格差 $\ge x$的元素**，一直到选够`k`个元素

1. 首先我们将`arr[0]`加入选择列表（设置为`last`）
2. 然后我们在已排序的数组中查找下一个与`last`间距大于$x$的元素
3. 找到以后，加入选择列表，将它设置为`last`
4. 按照上面的算法，如果找到了`k`个元素，则返回`true`
5. 如果没有找到`k`个元素，则返回`false`。

###  难点分析和应对

#### 如何确定答案区间？

- 最小的差值为0
- 最大的差值应该是`max(price) - min(price)`

#### 如何防止二分查找陷入死循环

#####什么情况下二分查找 + 下中位数会导致死循环？

###### 下中位数的特性： 区间只有两个元素时第一个会选为中点

下中位数的计算方法是：$left + (right - left) \div 2$

在一个只剩两个元素的区间 `[L, R]` (其中 `R = L + 1`) 上计算时，`mid` 的值会等于 `left`。

- **例如：** `left = 5`, `right = 6`
- `mid = 5 + (6 - 5) // 2 = 5 + 1 // 2 = 5 + 0 = 5`
- **结论：`mid == left`**

###### 如果使用`while(left < right)`模式：left = mid

```python
# 可能会导致死循环的模板
while left < right:
    mid = left + (right - left) // 2  # 1. 使用了下中位数

    if (condition(nums[mid])):
        left = mid                  # 2. 包含了 left = mid 的更新
    else:
        right = mid - 1
```

###### 死循环是怎样触发的？

让我们把 `left = 5`, `right = 6` 带入这个模板。

- **循环开始：** `left = 5`, `right = 6`。 `left < right` (5 < 6) 成立，进入循环。
- **计算 `mid`：** `mid = 5 + (6 - 5) // 2 = 5`。
- **检查条件：** 假设 `condition(nums[mid])` (即 `condition(nums[5])`) 为 `true`，程序进入 `if` 分支。
- **更新 `left`：** `left = mid`，所以 `left` 被赋值为 `5`。
- **循环结束：** 此时，`left` 仍然是 `5`，`right` 仍然是 `6`。
- **下一轮循环：** `left = 5`, `right = 6`。`left < right` 仍然成立，循环继续。
- `mid` 再次被计算为 `5`。
- `condition(nums[5])` 仍然为 `true`。
- `left` 再次被赋值为 `5`。

**问题出现了：** 搜索区间 `[left, right]` 停留在了 `[5, 6]`，再也无法缩小，导致了无限循环。

#####死循环问题的解决方法：

###### 什么是上中位数？

上中位数的计算公式是：$mid = left + (right - left + 1) / 2$。

公式推导一下就是:$mid = (left + right + 1) \div 2$

**如果数组中只有两个元素，那么上中位数所指向的就是第二个元素**。

###### 解决方法一： 上中位数

如果你的逻辑**必须**包含 `left = mid`，那么你应该使用 **上中位数 (Upper Median)**。

- **上中位数计算：** `mid = left + (right - left + 1) / 2` (或者 `(left + right + 1) / 2`)

上述修正过的套路模板就是：

```python
# 修正后的模板
while left < right:
    # 1. 使用上中位数
    mid = left + (right - left + 1) // 2 
    
    if (condition(nums[mid])):
        left = mid                  
    else:
        right = mid - 1
```

**为什么这能行？** 我们再次用 `left = 5`, `right = 6` 来测试：

- **计算 `mid`：** `mid = 5 + (6 - 5 + 1) // 2 = 5 + 2 // 2 = 6`。
- **Case 1：** `condition(nums[6])` 为 `true`。
  - `left = mid` (即 `left = 6`)。
  - 搜索区间变为 `[6, 6]`。下一轮循环 `left < right` (6 < 6) 为 `false`，循环退出。
- **Case 2：** `condition(nums[6])` 为 `false`。
  - `right = mid - 1` (即 `right = 5`)。
  - 搜索区间变为 `[5, 5]`。下一轮循环 `left < right` (5 < 5) 为 `false`，循环退出。

在所有情况下，区间都成功缩小了。

###### 方法二：不要使用left=mid这种操作，使用right = mid

如果你**坚持**要使用下中位数 (`mid = left + (right - left) // 2`)，那么你**必须**避免 `left = mid` 的更新方式。

你应该使用 `right = mid` 这种更新逻辑。

```python
# 使用下中位数的安全模板
while left < right:
    mid = left + (right - left) // 2  # 1. 使用下中位数
    if (condition(nums[mid])):
        right = mid                 # 2. 边界更新 right = mid
    else:
        left = mid + 1
```

**为什么这能行？** 我们再次用 `left = 5`, `right = 6` 来测试：

- **计算 `mid`：** `mid = 5`。
- **Case 1：** `condition(nums[5])` 为 `true`。
  - `right = mid` (即 `right = 5`)。
  - 搜索区间变为 `[5, 5]`。下一轮 `left < right` (5 < 5) 为 `false`，循环退出。
- **Case 2：** `condition(nums[5])` 为 `false`。
  - `left = mid + 1` (即 `left = 6`)。
  - 搜索区间变为 `[6, 6]`。下一轮 `left < right` (6 < 6) 为 `false`，循环退出。

##### 对于上中位数和下中位数的总结

| 场景           | 寻找左边界时（最小符合条件的值）          | 寻找右边界时（最大符合条件的值）      |
| -------------- | ----------------------------------------- | ------------------------------------- |
| 中位数类型     | 下中位数$mid = left + (right - left) / 2$ | 上中位数:$mid = (right + left +1)/2$  |
| 左指针右移逻辑 | 左指针右移到`mid+1`: `left = mid + 1`     | 左指针右移到`mid`:`left = mid`        |
| 右指针左移逻辑 | 有指针左移到`mid`:`right = mid`           | 右指针左移到`mid-1`:`right = mid - 1` |



#### 检验函数的复杂度

- 排序耗 $O(n\log n)$，每次贪心检验 $O(n)$。区间长度为 $C=\max-\min$，二分耗 $O(\log C)$，总 $O(n\log n + n\log C)$，可接受。

### 基本原理和详细步骤

#### 对数组进行排序

`Arrays.sort(price)`

#### 初始化二分区间

```java
int left = 0;
int right = price[n-1] - price[0]
```

#### 编写检验函数

```java
    //贪心算法，是否能从prices[] 找出k个元素，使得它们两两之间的差值大于tastiness
    //排序过之后，我们按照顺序选择元素，只要选择相邻间距大于tastiness就可以了
    //看看我们在最小间距大于等于tastiness的情况下，是否能够找出k个元素
    //我们从第一个元素开始找，看看在最小间距限制下，是否能够找到k个
    private boolean check(int[] price, int k, int tastiness){
        int count = 1;
        int n = price.length;
        int last = price[0];

        for(int i = 1; i < n; i++){
            //如果price[i]和上一个被选中的差小于tastiness
            //则选中price[i]
           if(price[i] - last >= tastiness){
            count++;
            last = price[i];
            //如果找齐了k个元素，返回true
            if(count == k) return true;
           }
        }
        //如果最终没有找齐k个元素，返回false
        return false;
    }
```

#### 二分查找最大可行K

```java
    public int maximumTastiness(int[] price, int k) {
        //最小的tastiness是啥？
        int left = 0;
        int n = price.length;
        Arrays.sort(price);

        int right = price[n-1] - price[0];

        int ans = Integer.MIN_VALUE;

        while(left <= right){
            int mid  = left + (right - left) / 2;
            //找到一个合格值，尝试继续找更大的
            if(check(price,k,mid)){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return ans;
    }
```

### 实现代码

```java
//price[i]表示第i个糖果的价格
//给定一个正整数k
//商店销售k中不同的糖果
//tastiness[basket] = min(abs(diff(price[i] - price[i])))
//求糖果蓝的最大tastiness

//一个篮子中有k中糖果
//一共有n种糖果
//是否能够取出k种糖果，使得tastiness <= x

class Solution {
    public int maximumTastiness(int[] price, int k) {
        //最小的tastiness是啥？
        int left = 0;
        int n = price.length;
        Arrays.sort(price);

        int right = price[n-1] - price[0];

        int ans = Integer.MIN_VALUE;

        while(left <= right){
            int mid  = left + (right - left) / 2;
            //找到一个合格值，尝试继续找更大的
            if(check(price,k,mid)){
                ans = mid;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return ans;
    }
    //贪心算法，是否能从prices[] 找出k个元素，使得它们两两之间的差值大于tastiness
    //排序过之后，我们按照顺序选择元素，只要选择相邻间距大于tastiness就可以了
    //看看我们在最小间距大于等于tastiness的情况下，是否能够找出k个元素
    //我们从第一个元素开始找，看看在最小间距限制下，是否能够找到k个
    private boolean check(int[] price, int k, int tastiness){
        int count = 1;
        int n = price.length;
        int last = price[0];

        for(int i = 1; i < n; i++){
            //如果price[i]和上一个被选中的差小于tastiness
            //则选中price[i]
           if(price[i] - last >= tastiness){
            count++;
            last = price[i];
            //如果找齐了k个元素，返回true
            if(count == k) return true;
           }
        }
        //如果最终没有找齐k个元素，返回false
        return false;
    }
}
```

### 注意事项

- **细节：** 记得使用“上中位数”避免无限循环；

- **边界：** 当所有价格相同，`right` 为 0，二分可直接返回 0；

- **整数溢出：** 计算 `mid` 用无符号右移或 `(left + right + 1) / 2`，均可避免 `(left+right)` 溢出；

- **排序开销：** 对 $n$ 达到 $10^5$ 级别仍能在时间内完成。

### 经验总结

- “二分答案+贪心检验”是处理“最大化最小化”、“最小化最大化”一类问题的**黄金套路**。
- 通过合并“排序 + 线性扫描”保证每次检验 $O(n)$，在大多数题目中足够高效。
- 确定答案区间与检验可行性是核心：答案区间要**闭合**且**准确**，检验函数要**单调可分**（可行／不可行清晰分界）。
- 面对「选取若干元素使相邻差值满足某条件」的问题，都可尝试此套路，快速搭建框架。



# 分割型二分

## 场景与目标 - 将数组分为最大值最小的m段

- 将数组分成m段，使每段的最大值最小

## 问题分析 - 求最大的最小值

猜一个最大段和 `mid`，验证能否在 ≤ m 段内完成分割。

## 核心思想 - 二分答案

本质上分割型二分也属于**二分答案**题型的一种。

问题可以转化为，**寻找一个最小的$x$ , 使得数组可以分为划分为$m$个段，每个段的最大值不超过$x$。**

这属于一个求**最大最小值**问题。

现在我们是不是可以总结一下求最大最小值和最小最大值的套路了？

### 求最大最小值的方法

#### 场景： 物品分组

"最大化...的最小值"。

这类问题通常要求您在某个空间内放置物品或进行分组，使得**所有物品（或组）之间的“某个指标”的最小值**是所有可能方案中**最大的**。

#### 目标： 所有分组的某个指标最小值的最大值

这类问题通常要求您在某个空间内放置物品或进行分组，使得**所有物品（或组）之间的“某个指标”的最小值**是所有可能方案中**最大的**。

**经典例子：**

- **LeetCode 1552. 两球之间的磁力 (Aggressive Cows)：** 在 `n` 个位置上放 `m` 个球。您需要找到一种放置方案，使得**任意两个球之间距离的最小值** 达到**最大**。
- **LeetCode 2517. 礼盒的最大甜蜜度：** 从 `n` 种糖果中选 `k` 种放入礼盒，最大化礼盒中**任意两种糖果价格之差的最小值**。
- **LeetCode 2861. 最大合金数：** (这道题稍有变形) 你有 `k` 台机器，每台机器制造一个合金需要不同材料。你有 `budget` 预算。求**最多**能制造多少个合金（最大化“最小值”为1的合金数量）。

#### 核心思路

#####**确定答案范围 `[min_ans, max_ans]`：**

- `min_ans`：可能的最小答案（例如，在 LeetCode 1552 中，最小距离至少是 1）。
- `max_ans`：可能的最大答案（例如，在 LeetCode 1552 中，最大距离至多是 `max(positions) - min(positions)`）。

#####**二分搜索：** 在 `[min_ans, max_ans]` 范围内二分，取 `mid` 作为一个**“候选答案”**。

#####**设计 `check(mid)` 函数：**

- `check(mid)` 的含义是：“我们是否**有可能**（例如：放置球）使得“最小值”**至少为** `mid`？”

#####**单调性 (Monotonicity)：**

- 如果一个值 `mid`（例如：最小距离为 50）是可行的（`check(50) == true`），那么任何**小于** 50 的值（如 49, 40）也**一定**是可行的（因为要求更低了）。
- 如果 `mid` 不可行（`check(50) == false`），那么任何**大于** 50 的值也**一定**不可行（要求更高了）。
- 这形成了一个 `[True, True, ..., True, False, False, ..., False]` 的答案空间。

#####**目标：**True区间的右边界

 我们的目标是找到这个 `True` 区间的**右边界**（最后一个 `True`），这就是“最大的最小值”。

#### 实现原理

```python
# 最大最小值 (寻找右边界) 的模板
def solve_max_min(positions, m):
    # 0. 必须先排序才能方便地计算距离
    positions.sort()
    
    # 1. 确定答案范围
    left = 1 # 最小可能距离
    right = positions[-1] - positions[0] # 最大可能距离
    
    ans = 0 # 存储满足条件的最大答案

    while left <= right:
        # 2. 取下中位数作为“候选答案”
        # (如果用 left < right 模板，这里要用上中位数 + left = mid 来避免死循环)
        mid = left + (right - left) // 2 
        
        # 3. 检查 mid 是否可行
        if check(mid, positions, m):
            # mid 可行 (可以放下 m 个球，最小距离 >= mid)
            # 它是一个潜在的答案。
            # 但我们想找“最大”的，所以我们往右边（更大的值）继续尝试
            ans = mid
            left = mid + 1
        else:
            # mid 不可行，说明 mid 太大了 (放不下 m 个球)
            # 必须减小 mid，所以向右搜索
            right = mid - 1
            
    return ans

# check(x) 函数：是否可以放置 m 个球，使得最小距离 >= x
def check(x, positions, m):
    # 同样使用贪心法
    count = 1 # 已经放了 1 个球 (在第一个位置)
    last_position = positions[0]
    
    for i in range(1, len(positions)):
        if positions[i] - last_position >= x:
            # 找到了一个新位置，可以放球
            count += 1
            last_position = positions[i]
    
    # 最终能放下的球的数量是否达到 m
    return count >= m
```



### 求最小最大值的方法

#### 场景 - 将一个集合划分为若干组

"最小化...的最大值"。

这类问题通常要求您**将一个集合（如数组）分成若干组**。

#### 目标 - 求让所有分组某个指标的最大值的最小值

这相当于让我们找到一个最大值的阈值$x$。

如果指标的最大值小于这个阈值$x$，则无法将集合划分为$k$ 组， 那么这个阈值就是我们要求的最小值。

如果指标的最大值大于这个阈值，可以划分为$k$组。

**经典例子：**

- **LeetCode 410. 分割数组的最大值：** 将一个数组 `nums` 分割成 `m` 个连续子数组。您需要找到一种分割方案，使得这 `m` 个子数组各自的和的**最大值** 达到**最小**。
- **LeetCode 875. 爱吃香蕉的珂珂：** 珂珂要在 `h` 小时内吃完 `n` 堆香蕉。她每小时吃 `k` 根。找到能吃完的**最小**速度 `k`。（这等价于最小化“每小时吃的香蕉数”这个“最大值”）
- **LeetCode 1011. 在 D 天内送达包裹的能力：** 船必须在 `D` 天内运送所有包裹。找到所需的**最小**运载能力，使得船能完成任务。（这也是最小化“每天运送的最大重量”）

#### 核心思路

##### 确定答案范围

- `min_ans`：可能的最小答案（例如，在 LeetCode 410 中，最小运力至少是数组中最大的那个元素）。
  - `max_ans`：可能的最大答案（例如，在 LeetCode 410 中，最大运力至多是整个数组的总和）。

##### 二分搜索

 在 `[min_ans, max_ans]` 范围内进行二分，取 `mid` 作为一个**“候选答案”**。

##### 设计`check(mid)`函数: 检查在阈值$x$限制下是否可以划分？

这是最关键的一步。您需要设计一个函数来**验证**这个 `mid` 值是否可行。

`check(mid)` 的含义是：“我们是否**有可能**（例如：分割数组、设置速度）使得最终的‘最大值’**不超过** `mid`？”

##### 单调性

- 这个 `check(mid)` 函数必须具有单调性。
- 如果一个值 `mid`（例如：最大和为 50）是可行的（`check(50) == true`），那么任何**大于** 50 的值（如 51, 60）也**一定**是可行的（因为限制更宽松了）。
- 如果 `mid` 不可行（`check(50) == false`），那么任何**小于** 50 的值也**一定**不可行。
- 这形成了一个 `[False, False, ..., False, True, True, ..., True]` 的答案空间。

与二分答案一样，只是`check(x)`实现为**贪心累加切段**。

#### 实现原理

```python
# 最小最大值 (寻找左边界) 的模板
def solve_min_max(nums, m):
    # 1. 确定答案范围
    left = min_possible_answer  # e.g., max(nums)
    right = max_possible_answer # e.g., sum(nums)

    # 存储满足条件的最小答案
    ans = right # 初始可以设为最大值

    while left <= right:
        # 2. 取下中位数作为“候选答案”
        mid = left + (right - left) // 2 
        
        # 3. 检查 mid 是否可行
        if check(mid, nums, m):
            # mid 可行，它是一个潜在的答案。
            # 但我们想找“最小”的，所以我们往左边（更小的值）继续尝试
            ans = mid
            right = mid - 1
        else:
            # mid 不可行，说明 mid 太小了
            # 必须增大 mid，所以向右搜索
            left = mid + 1
            
    return ans # 或者在 LeetCode 410 这类问题中，返回 left 也可以

# check(x) 函数：是否可以分割数组，使得最大子数组和 <= x
def check(x, nums, m):
    # 通常使用贪心法来实现 check
    count = 1  # 需要的子数组数量
		# 在x的限制下计算count
    # ....
    # 返回限制count 是否小于等于m
    return count <= m
```



## 实现原理和步骤

1. `left = max(nums), right = sum(nums)`
2. 当 `left < right`：
   1. `mid=(left+right)/2`
   2. 用贪心：从左到右累加，若当前段和 > mid，则切新段；统计段数 cnt
   3. 若 `cnt <= m` → `right=mid`，否则 `left=mid+1`
3. 返回 `left`

## 代码套路模板

```java
int splitArray(int[] nums, int m) {
    int left = 0, right = 0;
    for (int x : nums) {
        left = Math.max(left, x);
        right += x;
    }
    while (left < right) {
        int mid = (left + right) / 2;
        int cnt = 1, sum = 0;
        for (int x : nums) {
            if (sum + x > mid) { sum = x; cnt++; }
            else sum += x;
        }
        if (cnt <= m) right = mid;
        else left = mid + 1;
    }
    return left;
}

```

## 注意事项

- 边界初始 `left` 要取最大元素值，`right` 取总和

- `cnt` 统计段数超过 m 即失败

## 经验总结

本质仍是“答案二分”，多用于分割、分配类题。

## Leetcode 410  Split Array Largest Sum

给定一个非负整数数组 `nums` 和一个正整数 `m`，需要将数组划分成 **m** 段（子数组），使得所有子数组和中的最大值最小，返回这个最小的最大子数组和。

### 本质分析

####在**多段划分**下，寻找**最大子段和**的**最小可能值**

如果允许划分成任意多段，

- 显然**可以每个元素单独成段**，最大子段和就是**数组最大值**（左边界）；

- 如果**只划分成一段**，则最大子段和是**整个数组之和**（右边界）。
- 随着划分段数增加，最终结果在** `[max(nums), sum(nums)]` **区间内**单调递减**。

#### 转化为决策问题

**给定一个阈值T，能否划分成<=m段，使得每段和都<=T?**

- 如果可以，说明答案不大于T
- 如果不可以，说明答案大于T

由此可以在区间上对`T`做二分。

### 难点分析与应对方法

#### 找到左右边界

- 最小值不能低于数组最大值
- 最大值不能高于数组总和

#### 验证函数的正确性

- 必须保证在累加过程中只要当前段和到`mid`就立即分段，不可回退
- 小心处理恰好等于`mid`的情况，可视为当前段封顶，下一元素重新起一段

#### 避免死循环

二分时使用`while(left < high)`,更新要能缩小区间

```java
if(need <= m) right = mid;
else left = mid + 1;
```

### 实现原理和步骤

#### 初始化左右边界

- `left = max(nums)`
- `right = sum(nums)`

#### 二分搜索

```java
while (left < right){
  int mid = left + (right - left) / 2;
  if (canSplit(nums,m,mid)){
    right = mid;
  }else{
    left = mid + 1;
  }
}
return left;
```

#### 贪心验证函数

- 每次遍历`nums`, 维护currentSum 与 count = 1;
- 每次`currentSum + sum > limit`时：
  - 段数 +1；
  - 重置`currentSum = num`

#### 返回结果

最终`left`就是最小可行的最大子段和

### 实现代码

```java
 public int splitArray(int[] nums, int k) {
        //计算左右边界
        //left = max(nums)
        int left = 0;
        // right = sum(nums)
        int right = 0;
        for (int num : nums){
            left = Math.max(left, num);
            right += num;
        }

        //二分
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canSplit(nums, k, mid)){
                right = mid;
            }else{
                left = mid + 1;
            }
        }

        // 返回结果
        return left;
        
    }
    //计算能否分段
    private boolean canSplit(int[] nums, int k, int limit){
        int count = 1;
        int currentSum = 0;
        for (int num : nums){
            if (currentSum + num > limit){
                currentSum = num;
                count++;
            }else{
                currentSum += num;
            }
            if (count > k){
                return false;
            }
        }
        return true;
    }
```



# 二维矩阵查找

## 全局一维映射

### 场景和目标

将按行优先排序的矩阵视作一维数组，在全局查找 target。

### 问题分析

索引`[i,j]` 可以映射为一维数组的下标`k = i * n + j`, 在虚拟一维数组上进行二分查找

### 核心思想

直接将`mid`映射回`[i,j]`，比较`matrix[i][j]`

### 代码套路模板

```java
public boolean searchMatrix(int[][] mat, int target){
  int m = mat.length;
  int n = mat[0].length;
  int left = 0;
  int right = m*n - 1;
  //查找数值时条件为 <= 查找最值时为 <
  while (left <= right){
    int mid = left + (right - left) / 2;
    //注意反向映射的逻辑
    int i = mid / n;
    int j = mid % m;
    if (mat[i][j] == target ) return true;
    if (mat[i][j] < target){
      left = mid + 1;
    }else{
      right = mid - 1;
    }
  }
  
  return false;
}
```

## 分行再二分

### 场景与目标

每行和每一列都是单调递增，先定位行，再在改行做二分

### 问题分析

- 对`[0...m-1]`行的第`0`列做二分
- 确定可能所在行，然后在改行做二分

### 核心思想 - 两层二分

先按照行判断，再按照列判断

### 实现原理和详细步骤

#### 索索所在行

##### 确定左右边界

`left = 0, right = m -1`

##### 二分确定row

- `midRow = (left + right)/2`
- 如果`mat[midRow][0] > target`: `right= midRow -1`
- 如果`mat[midRow][n-1] < target`:`left = midRow + 1`
- 否则在`midRow`这一行查找

##### 返回结果

在查到的行上执行标准binary Search

### 代码套路模板

```java
boolean searchMatrix2(int[][] mat, int target) {
    int m = mat.length, n = mat[0].length;
    int top = 0, bottom = m - 1;
    while (top <= bottom) {
        int midRow = (top + bottom) / 2;
        if (mat[midRow][0] > target) bottom = midRow - 1;
        else if (mat[midRow][n-1] < target) top = midRow + 1;
        else {
            int left = 0, right = n - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (mat[midRow][mid] == target) return true;
                else if (mat[midRow][mid] < target) left = mid + 1;
                else right = mid - 1;
            }
            return false;
        }
    }
    return false;
}
```

### Leetcode 240：查询二维矩阵中是否包含某个元素

#### 问题要点

给定一个 $m \times n $ 的二维整数矩阵 `matrix`。这个矩阵具有以下特性：

1. **行排序**：每一行中的整数从左到右按升序排列。
2. **列排序**：每一列中的整数从上到下按升序排列。

**任务**：编写一个高效的算法，在该矩阵中搜索一个给定的目标值 `target`。如果 `target` 存在于矩阵中，返回 `true`；否则，返回 `false`。

**关键约束**：这个矩阵**不**保证“下一行的第一个元素”一定大于“上一行的最后一个元素”（这是 LeetCode 74 的特性，不是 240 的）。

```
示例：
输入：
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
], target = 5
输出：true

```

#### 本质分析 - 行内元素递增+列内元素递增 $\neq$ 行之间递增 或者 列之间递增

问题的本质是在一个“部分有序”的二维结构中进行高效查找。

需要注意的是，每一行从左到右递增排序，每一列从上到下增 序排序, 并不意味着第二行的元素会比所有的第一行的元素大。

利用上述二维映射成一维数组再做二分搜索的方式是不可行的。

##### 方法一：**暴力做法**：遍历所有元素 - $O(m\times n)$

遍历所有元素，时间复杂度 $O(m × n)$，最坏情况 $10^8$ 级别，不能接受。

##### 方法二：**按行二分查找**$O(M\times logN)$

对每行做二分，时间复杂度 $O(m log n)$，可应对中等规模，但当 m、n 都很大时仍稍逊。

##### 方法三：寻找分界点 - $O(m + n)$

在矩阵中选择一个“分界点”（例如右上角或左下角）

根据比较结果快速排除一整行或一整列，时间复杂度 O(m + n)。

#### 规律观察 - 从右上角或者左下角开始

要实现 $O(m + n)$，我们必须在每一步操作中都能“排除”一行或一列，而不是像二分查找那样只排除一半的元素。

##### 左上角  `matrix[0][0]`:

这是矩阵中最小的元素。

- 如果 `target < matrix[0][0]`，则 `target` 肯定不在矩阵中。

- 如果 `target > matrix[0][0]`，我们无法做出明确的决策。

​	因为`target` 可能在它的右边，也可能在它的下边。

**结论**：左上角不是一个好的起点。

##### **右下角 `matrix[m-1][n-1]`**：

这是矩阵中最大的元素。

- 如果 `target > matrix[m-1][n-1]`，则 `target` 肯定不在矩阵中。

- 如果 `target < matrix[m-1][n-1]`，我们也无法做出明确的决策。

  `target` 可能在它的左边，也可能在它的上边。

**结论**：右下角也不是一个好的起点。

#####**右上角 `matrix[0][n-1]`**（设为 $x$）：

这个元素是它所在行的**最大值**，也是它所在列的**最小值**。

这是一个非常关键的“鞍点”(Saddle Point)。

######**情况一：`target == x`**

- 找到了，返回 `true`。

######**情况二：`target < x`**：排除所在列（col--）

`target` 比 `x` 小的情况下，根据我们题目给出的条件：

> 行内递增，列内递增

因此`matrix[0][n-1]`是`matrix[0][...]`的最大值，是`matrix[...][n-1]`的最小值。

也就是说`target` 不可能在 `x` 所在的**列**中，因为 `x` 已经是这一列的最小值了，这一列的其他元素都 `> x`。

因此，我们可以**安全地排除掉最后一列**。

搜索范围向左移动一格（`col--`）。

###### **情况三：`target > x`**： 排除所在行(row++)

我们上面已经分析过：`matrix[0][n-1]`是`matrix[0][...]`的最大值，是`matrix[...][n-1]`的最小值。

因为`target` 比 `x` 大。

因此`target` 不可能在 `x` 所在的**行**中，因为 `x` 已经是这一行的最大值了，这一行的其他元素都 `< x`。

因此，我们可以**安全地排除掉第一行**。

搜索范围向下移动一格（`row++`）。

###### **左下角 `matrix[m-1][0]`**（设为 $y$）：

这个元素是它所在行的**最小值**，也是它所在列的**最大值**。

换句话说，这个元素是第0行的最小值

也是第$m-1$列的最大值。

这同样是一个关键的“鞍点”。

**情况一：`target == y`** - 找到了

表示已经找到，当前元素就是需要找的元素。

**情况二：`target < y`**  - 移动到上一行

我们已经知道 $y$是$row$行的最小值。

因此如果$target < y$， 则说明在$row$ 行肯定找不到`target`， 因为$row$行所有的元素肯定都比$target$大。

目标值更小，`y` 已经是该列最大值，所以 `target` 必在 `y` 上方。

因此我们排除最后一行，`row--`

**情况三：`target > y`** - 移动到下一列

我们已经知道$y$是0列的**最大值**。

如果$target > y$， 则说明第0列中找不到target，只能去后面的列里面找。

目标值更大，`y` 已经是该行最小值，所以 `target` 必在 `y` 右侧。

排除第一列，`col++`

**结论**：从右上角或左下角开始，每一步都可以明确地排除一行或一列，从而缩小搜索空间。



#### 核心思想和套路 - 从右上角或者左下角开始

**核心思想**：选择右上角（或左下角）作为起点，利用该点“行最大、列最小”（或“行最小、列最大”）的特性，在 $O(1)$ 的时间内将 `target` 与当前元素比较，从而 $O(1)$ 地排除掉一行或一列。



**从右上角开始**

- 设初始位置 `(row, col) = (0, n-1)`。
- 若 `matrix[row][col] > target`，则当前列所有元素都 ≥ `matrix[row][col]`，可将 `col--`（往左移一列）。
- 若 `matrix[row][col] < target`，则当前行所有元素都 ≤ `matrix[row][col]`，可将 `row++`（往下一行）。
- 若相等则返回 `true`。
- 直到越界仍未找到，返回 `false`。

**也可从左下角对称进行**：若大于目标则 `row--`；若小于目标则 `col++`。

####难点分析与应对方法

| 难点                      | 应对方法                                                     |
| ------------------------- | ------------------------------------------------------------ |
| 边界条件（空矩阵、空行）  | 先做参数校验：`matrix == null` or `matrix.length == 0` or `matrix[0].length == 0` |
| 指针越界                  | 循环条件写为 `row < m && col >= 0`                           |
| 了解“排除”逻辑的正确性    | 结合有序性质，画示意图：每次向左或向下，排除整列/整行        |
| 数据类型溢出（若用 long） | 本题范围内用 `int` 即可，注意不要写错比较符                  |



#### 实现原理和步骤

1. **输入校验**：判断矩阵或行列数是否为 0。

2. **初始化**：`int row = 0, col = n - 1;`

3. 循环查找

   ```java
   while (row < m && col >= 0) {
       int cur = matrix[row][col];
       if (cur == target) return true;
       else if (cur > target) col--;
       else row++;
   }
   ```

4. **退出返回**：循环结束后仍未找回，返回 `false`。

#### 实现代码

```java
   public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length  == 0 || matrix[0].length ==0) return false;
        int m = matrix.length;
        int n = matrix[0].length;
        int row = 0;
        int col = n -1;
        while (row < m && col >=0) {
            if (matrix[row][col] == target) return true;
            if (matrix[row][col] > target){
                col--;
            }else{
                row++;
            }
        }
        return false;
    }
```



#### 注意事项

**参数合法性**：空矩阵、空行、`null` 检查必须写齐；

**循环条件**：`row < m && col >= 0` 保证指针不越界；

**数据类型**：若题目值域超出 `int`，需考虑 `long` 或 `BigInteger`；

**异常处理**：生产环境中可酌情抛出非法参数异常。

#### 经验总结

**双指针排除法**：这是矩阵“查找”类题目最常见套路，核心在于利用「有序性」一次排除整行或整列。

**模式识别**：遇到「行、列同时有序」的场景，优先考虑从角落切入；

**复杂度权衡**：在可接受范围内，$O(m + n)$ 优于 $O(m log n)$；

**多思路对比**：在学习阶段，可同时实现二分查找、分治法等，深化对算法优势和适用场景的理解；

**边界思考**：画图标注排除区域，更直观地验证“排除”过程的正确性。

# 搜索两个有序数组的Kth元素

**输入：** 两个已排序的数组 `nums1` (长度 $m$) 和 `nums2` (长度 $n$)，一个正整数 $k$。

**输出：** 两个数组合并后的第 $k$ 个最小元素。

**核心约束：** 时间复杂度必须优于 $O(m+n)$。目标是 $O(\log(\min(m, n)))$ 或 $O(\log(m+n))$。

**解法要求：** 使用“二分搜索”思想。

###问题的本质： 寻找一个分割

想象一下，我们把 `nums1` 分成“左半部分”和“右半部分”，把 `nums2` 也分成“左半部分”和“右半部分”。

如果我们能找到一种分割方式，使得：

1. **数量满足：** `nums1` 的左半部分 + `nums2` 的左半部分，总共有 $k$ 个元素。
2. **顺序满足：** `nums1` 左半部分的最大值 $\le$ `nums2` 右半部分的最小值。
3. **顺序满足：** `nums2` 左半部分的最大值 $\le$ `nums1` 右半部分的最小值。

如果这个“分割”找到了，那么这 $k$ 个元素（两个左半部分）就是合并后数组的**前 $k$ 个元素**。

我们要找的第 $k$ 个元素，自然就是这两个左半部分中的**最大值**。

### 规律观察

#### 问题转化：在$[max[0,k-n]...min(m,k)]$中搜索一个$i$

- 假设我们在 `nums1` 中选取前 $i$ 个元素作为“左半部分”（$i$ 可以从 $0$ 到 $m$）。

- 为了满足“总共有 $k$ 个元素”的条件，我们**必须**在 `nums2` 中选取前 $j$ 个元素作为“左半部分”，其中 $j = k - i$。

- 我们重新推导一下$i$的具体的范围：

  - 首先

    - 因为$i$不能够超过$m$, 因此$i \le m$，

    - 又因为$i \le k$, 

      所以综上所述， $i \le min(k, m)$

  - 其次， 

    - $j = k - i$ 不能超过$n$ ， 即$k-i \le n \implies i \ge k - n$

    - 又因为 $i \ge 0$ 

      所以综上所述， $ i \ge max(0, k-n)$

  因此综合，$i$的取值范围是$[max(0,k-n), min(m,k)$

- 现在，问题转化成了：**在 $[\max(0, k-n), \min(m, k)]$ 范围内，搜索一个 $i$，使其满足“顺序条件”。**

  

#####这个“顺序条件”是什么？

我们整理一下这里的顺序条件：

- $max(nums1_{left}) \le min(nums2_{right})$

  并且

- $max(nums2_{left} \le min(nums1_{right}))$

上述公式中的每一个值的计算：

- `nums1` 左半部分最大值：`L1 = (i == 0) ? -INF : nums1[i-1]`
- `nums1` 右半部分最小值：`R1 = (i == m) ? +INF : nums1[i]`
- `nums2` 左半部分最大值：`L2 = (j == 0) ? -INF : nums2[j-1]`
- `nums2` 右半部分最小值：`R2 = (j == n) ? +INF : nums2[j]`

“顺序条件”就是：`L1 <= R2` 并且 `L2 <= R1`。

### 模式套路匹配 - 二分答案

**在答案（或索引）上进行二分搜索 (Binary Search on Answer/Index)：**

- 我们不知道 $i$ 是多少，但我们知道 $i$ 的有效范围 `[low, high]`。
- 我们可以“猜测”一个 $i$（取 `mid`），然后检查它是否满足条件。
- 如果 $i$ 不满足，我们可以根据“不满足”的原因，**安全地**排除掉一半的搜索空间（是 $i$ 太大了还是太小了？）。
- 这就是在 `i` 的索引（或分割点）上进行二分搜索的经典模式。



### 核心思想和套路 - 对较短的数组 `nums1` 的分割点 $i$ 进行二分搜索。

**核心思想：** 对较短的数组 `nums1` 的分割点 $i$ 进行二分搜索。

为了保证复杂度是 $O(\log(\min(m, n)))$，我们总是**对较短的那个数组进行二分搜索**。如果 `nums1` 较长，就交换 `nums1` 和 `nums2`。

#### 确定答案的范围

确定二分搜索的 $i$ 的范围 `[low, high]`。

- $i$ 是 `nums1` 左半部分的**元素个数**。
- `low = max(0, k-n)`
- `high = min(m, k)`

#### 二分搜索的过程：while (low <= high)

取 `i = (low + high) / 2`

计算 `j = k - i`

#####**获取四个关键值**：两个数组的左侧最大值和右侧最小值

注意（处理 $i=0, i=m, j=0, j=n$ 的边界）：

- **nums1左侧最大值：**`leftMax1 = (i == 0) ? -INF : nums1[i-1]`
- **nums1右侧最小值：**`rightMin1 = (i == m) ? +INF : nums1[i]`
- **nums2左侧最大值**：` leftMax2 = (j == 0) ? -INF : nums2[j-1]`
- **nums2右侧最小值：**`R2 = (j == n) ? +INF : nums2[j]`

##### 检查当前答案是否符合条件

######情况1：$leftMax(nums1)> rightMin(nums2)$- $i$ 太靠右了

- `nums1` 左侧的最大值 > `nums2` 右侧的最小值。
- 这意味着 `nums1` 的分割点 $i$ **太靠右了**（$i$ 太大），导致 $L1$ 太大。
- 我们需要将 $i$ 往左移。
- **动作：右指针左移到$i-1$:`high = i - 1`**

###### 情况2: $leftMax(nums2) > rightMin(nums1)$ - $i$ 太靠左了

- `nums2` 左侧的最大值 > `nums1` 右侧的最小值。

- 这意味着 $j$ 太大了（$L2$ 太大），$j=k-i$ 太大 $\implies$ $i$ **太靠左了**（也就是说$i$ 太小了）。

- 我们需要将 $i$ 往右移。

- **动作：`low = i + 1`**

###### 情况三: $leftMax(nums1) \le rightMin(nums2)$  && $ leftMax(nums2) \le rightMin(nums1)$

**找到了！** 这就是我们想要的完美分割。

第 $k$ 个元素就是左半部分（总共 $k$ 个元素）中的最大值。

**动作：`return max(L1, L2)`**



#### 代码套路模板

```Java
// 确保 nums1 是较短的数组
public double findKth(int[] nums1, int[] nums2, int k) {
    int m = nums1.length;
    int n = nums2.length;
    
    // 保证 m <= n
    if (m > n) {
        // 交换数组，递归调用
        // 注意：k 不变，因为我们只是交换了引用
        return findKth(nums2, nums1, k); 
    }
    
    // 在 nums1 上进行二分搜索
    // i 的范围是 [low, high]
    // i: nums1 左侧分区的元素个数
    // j: nums2 左侧分区的元素个数
    // i + j = k
    
    // low: i 至少要取多少个？
    // j = k - i. j 不能超过 n => k - i <= n => i >= k - n
    // 同时 i 不能小于 0
    int low = Math.max(0, k - n);
    
    // high: i 最多能取多少个？
    // i 不能超过 m
    // j = k - i. j 不能小于 0 => k - i >= 0 => i <= k
    int high = Math.min(m, k);
    
    while (low <= high) {
        int i = (low + high) / 2;
        int j = k - i;
        
        // 获取 L1, R1, L2, R2 (边界处理)
        double L1 = (i == 0) ? Double.NEGATIVE_INFINITY : nums1[i - 1];
        double R1 = (i == m) ? Double.POSITIVE_INFINITY : nums1[i];
        double L2 = (j == 0) ? Double.NEGATIVE_INFINITY : nums2[j - 1];
        double R2 = (j == n) ? Double.POSITIVE_INFINITY : nums2[j];
        
        if (L1 > R2) {
            // i 太大，L1 太大
            high = i - 1;
        } else if (L2 > R1) {
            // i 太小，导致 j 太大，L2 太大
            low = i + 1;
        } else {
            // 完美分割: L1 <= R2 && L2 <= R1
            // 第 k 个元素就是左侧k个元素中的最大值
            return Math.max(L1, L2);
        }
    }
    
    return -1; // 理论上不会到达这里
}
```

#### 注意事项和经验总结

1. **k 是第 k 个（1-based），索引是（0-based）：** 这是最容易出错的地方。在上面的解法中，$i$ 和 $j$ 代表的是“元素个数”，所以 `nums1` 左侧 $i$ 个元素的最后一个是 `nums1[i-1]`。
2. **边界处理（$i=0, i=m, j=0, j=n$）：** 这是本算法的**绝对核心和难点**。使用 `-/+ Infinity` (负无穷/正无穷) 是处理这个问题的最优雅方式。
   - `i=0`：`L1 = -INF` ( `nums1` 左侧为空)
   - `i=m`：`R1 = +INF` ( `numss1` 右侧为空)
3. **交换数组：** 一定要记得对**较短**的数组进行二分搜索，才能保证 $O(\log(\min(m, n)))$ 的时间复杂度。
4. **$i$ 的搜索范围：** `[max(0, k-n), min(m, k)]` 这个范围的推导至关重要，它保证了 $i$ 和 $j$ ($j=k-i$) 两者**同时**在各自的合法范围内 (`[0, m]` 和 `[0, n]`)。
5. **理解“淘汰”方向：**
   - `L1 > R2` 意味着 $i$ 太大，`high = i - 1`。
   - `L2 > R1` 意味着 $i$ 太小，`low = i + 1`。
   - 这个逻辑必须清晰，否则二分会写反。
6. **中位数 vs 第k小：** 这个算法是通用的“第k小”算法。在解决 LeetCode 4 中位数问题时，你需要调用这个函数 1 次或 2 次。
   - `total = m + n`
   - `if (total % 2 == 1)`:
     - `return findKth(nums1, nums2, total / 2 + 1)`
   - `else`:
     - `k1 = total / 2`
     - `k2 = total / 2 + 1`
     - `val1 = findKth(nums1, nums2, k1)`
     - `val2 = findKth(nums1, nums2, k2)`
     - `return (val1 + val2) / 2.0`

这个基于“二分分割点”的解法非常巧妙，是处理 Top K / 中位数问题的强大工具。

### Leetcode 4 : 求两个有序数组合并以后的中位数

#### 中位数怎么计算？

##### 如果数组的长度为奇数:$r = nums[len\div 2+1]$

如果数组的长度是奇数，我们只需要找到最中见的数字即可，即第$len/2 + 1$个数字，返回它的值就行了。

##### 如果数组的长度为偶数: $r = \frac {(nums[len/2]+nums[len/2 + 1])} 2$

我们需要分别求出来第$len/2$个数和第$len/2+1$个数。

然后求这两个数的平均值：

$r = \frac {(nums[len/2]+nums[len/2 + 1])} 2$ 

```Java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;

        int totalLen = m + n;
        if(totalLen % 2 == 1){
            //如果是偶数
            //寻找第totalLen / 2 + 1个元素
            return findKth(nums1, nums2, totalLen/2 + 1);
        }else{
            //如果是偶数
            //寻找第totalLen/2 和第totalLen/2 + 1个元素
            //然后取平均
            int k1 = totalLen/2;
            int k2 = totalLen/2 + 1;
            int k1thVal = findKth(nums1, nums2, k1);
            int k2thVal = findKth(nums1, nums2, k2);
            return (k1thVal + k2thVal) / 2.0;
        }
    }

    private int findKth(int[] nums1, int[] nums2, int k){
        int m = nums1.length;
        int n = nums2.length;
        //i的范围应该是
        //i <= m; i <= k
        int right = Math.min(m, k);

        int left = Math.max(k-n, 0);

        while(left <= right){
            int mid = left + (right - left) / 2;
						
            //如果mid == 0, leftMax1 取Integer.MIN_VALUE
            int leftMax1 = mid == 0 ? Integer.MIN_VALUE : nums1[mid - 1];
          	//如果mid == m, leftMax取Integer.MAX_VALUE
            int rightMin1 = mid == m ? Integer.MAX_VALUE :nums1[mid];

            int mid2 = k - mid;
            int leftMax2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];
            int rightMin2 = mid2 == n ? Integer.MAX_VALUE : nums2[mid2];

            if(leftMax1 > rightMin2){
                right = mid - 1;
            }else if(leftMax2 > rightMin1){
                left = mid + 1;
            }else{
                return Math.max(leftMax1, leftMax2);
            }
        }

        return -1;
    }
}
```



# 范围查询求最值 - 最值前缀数组的应用

### 最值前缀是什么？

前缀最大值的核心思想是 **“预处理”** 和 **“空间换时间”**。

它通过一次遍历，将“求解数组任意前缀的最大值”这个操作的**时间复杂度从 O(N) 降为 O(1)**。

具体来说，**我们创建一个辅助数组（或在原数组上修改），该数组在索引 `i` 处存储的不再是原始值 `A[i]`，而是原始数组从开头到 `i` 这个位置的所有元素中的最大值，即 `max(A[0], A[1], ..., A[i])`。**

这个思想的关键在于其**状态转移**的简洁性：

> **位置 `i` 的前缀最大值，只依赖于 `位置 i-1 的前缀最大值` 和 `位置 i 的原始值`。**

$prefixMax[i]=max(prefixMax[i−1],array[i])$

这使得我们可以在一次线性扫描中完成整个预处理。

### 最值前缀的应用场景 - **反复查询**某个数组**从头开始到某个位置为止**的最值

典型的场景包括：

1. **范围查询与数据预处理（如此题 LeetCode 2070）**
   - 问题：对于多个查询 `q`，找出满足某个条件（如 `price <= q`）的元素集合中的最大美丽值。
   - 应用：将物品按条件（价格）排序后，其美丽值的前缀最大值数组就直接对应了“价格上限为 `p` 时能获得的最大美丽值”。后续查询可通过二分搜索快速定位。
2. **股票买卖问题**
   - 问题：给定一个数组代表每日股价，只允许买卖一次，求最大利润。（例如 LeetCode 121. Best Time to Buy and Sell Stock）
   - 应用：在从左到右遍历股价数组时，我们可以实时维护一个**前缀最小值 (Prefix Minimum)**，代表“到今天为止的最低股价”。那么在第 `i` 天，可能的最大利润就是 `prices[i] - min_price_so_far`。我们只需要遍历一次，不断更新最大利润即可。
3. **双向扫描问题（前后缀结合）**
   - 问题：需要知道每个位置**左边的最值**和**右边的最值**。 (例如 LeetCode 42. Trapping Rain Water)
   - 应用：计算每个位置能接多少雨水，取决于它左边的最高墙（前缀最大值）和右边的最高墙（**后缀最大值**）。我们可以通过一次从左到右的遍历计算出前缀最大值数组，再通过一次从右到左的遍历计算出后缀最大值数组，最后再遍历一次计算结果。
4. **数据流或在线问题**
   - 问题：数据一个一个地输入，在任何时候都需要快速知道到目前为止所有数据的最值。
   - 应用：每当新数据流入时，只需将其与之前记录的前缀最大值比较一次，即可在 O(1) 时间内更新当前的最大值。

### 最值前缀的实现原理

实现过程非常直观，分为三步：

1. **创建存储空间**：创建一个与原数组 `A` 等大的新数组 `prefixMax`。（或者，如果允许修改原数组，可以直接在 `A` 上操作以节省空间）。
2. **初始化（处理边界）**：`prefixMax` 的第一个元素就是原数组的第一个元素。`prefixMax[0] = A[0]`。
3. **迭代计算**：从第二个元素开始（`i = 1`），遍历整个数组，并应用状态转移方程：`prefixMax[i] = Math.max(prefixMax[i-1], A[i])`。

完成这三步后，`prefixMax` 数组就构建好了，可以用于后续的 O(1) 查询。

### 代码套路模板

```java
/**
 * 计算一个数组的前缀最大值
 * @param nums 原始输入数组
 * @return 一个新的数组，其中 newArr[i] = max(nums[0]...nums[i])
 */
public int[] getPrefixMax(int[] nums) {
    if (nums == null || nums.length == 0) {
        return new int[0];
    }

    int n = nums.length;
    int[] prefixMax = new int[n];

    // 1. 初始化边界条件
    prefixMax[0] = nums[0];

    // 2. 迭代计算
    for (int i = 1; i < n; i++) {
        prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);
    }

    return prefixMax;
}
```



## Leetcode 2070: 每一个查询的最大美丽值

### 问题要点

**输入:**

1. 一个二维整数数组 `items`，其中 `items[i] = [price_i, beauty_i]`，表示第 `i` 个物品的价格和美丽值。
2. 一个整数数组 `queries`，其中 `queries[j]` 表示一个查询的价格上限。

**输出:**

- 一个数组 `answer`，其长度与 `queries` 相同。
- `answer[j]` 是对第 `j` 个查询 `queries[j]` 的回答：在所有价格**小于或等于** `queries[j]` 的物品中，能够找到的**最大美丽值**。
- 如果不存在价格小于或等于 `queries[j]` 的物品，则该查询的答案为 `0`。

**核心限制:** `items` 和 `queries` 的长度都可以达到$ 10^5$，这意味着一个暴力解法（对每个查询都遍历所有物品）的时间复杂度将是 $O(N\times{Q})$，即 $10^5\times{10^5}=10^{10}$，这一定会超时。

因此，必须寻找更高效的算法。

### 问题的本质和分析

#### 问题的本质 - 范围查询求最值

这个问题的本质是**范围查询求最值**。

对于每一个查询 $q$，我们都在一个动态的范围（价格 $p \le q$）内寻找美丽值的最大值。

#### 一个发现： 查询和物品之间存在的单调性

问题的关键在于，查询和物品之间存在一种**单调性**。

当我们增加一个查询的价格上限时，符合条件的物品集合只会增大，不会减小。

例如，如果一个物品的价格是 10，它对于价格上限为 15 的查询是符合条件的，那么对于价格上限为 20 的查询也一定符合条件。

#### 如何利用单调性优化解决方法？

这种单调性是优化的突破口。

我们可以利用它来避免重复计算。

如果我们已经知道了价格上限为 $p$ 时的最大美丽值 $max_p$。

那么对于任何大于 $p$ 的新价格上限 $p'$，我们只需要在 $maxp_p$ 的基础上，考虑那些价格在 $(p, p']$ 区间内的物品即可。



### 背景知识

#### 排序

对物品或查询进行排序是预处理的关键步骤。特别是基于比较的排序算法，其时间复杂度通常为 $O(NlogN)$。

#### 二分搜索

**二分搜索 (Binary Search):** 在一个有序数组中快速查找某个元素或其边界。时间复杂度为 $O(logN)$。

这是在预处理后的数据上进行高效查询的核心工具。

#### 前缀最大值 - prefix maximum

**前缀最大值 (Prefix Maximum):** 这是一个常见的动态规划或预处理思想。

对于一个序列 `A`，我们可以创建一个新的序列 $P$，其中 $P[i] = max(A[0], A[1], ..., A[i])$。

这使得我们可以在 $O(1)$ 的时间内查询任意前缀 $A[0...i]$ 的最大值。

对于给定的查询条件$q$，我们需要使用**二分搜索**，找到$p \le q$的最大的价格$p$即可。

本题将排序、前缀最大值和二分搜索巧妙地结合在了一起。

### 模式匹配

这个问题可以匹配到以下常见的算法模式：

#### **预处理 + 查询 (Preprocessing + Queries):** 

当一系列查询需要在同一份静态数据上执行时，通常可以通过一次性的预处理来构建一个优化的数据结构，从而让每次查询都变得非常快。

#### **排序 + 二分搜索:** 

这是一个非常经典的组合。当查询涉及到在某个值域范围内寻找答案时，如果数据可以被排序，那么二分搜索通常是最高效的查询方式。

#### **离线查询 (Offline Queries) + 双指针:**

 如果我们可以不按原始顺序回答查询，我们可以将查询也进行排序，然后使用双指针法同时遍历物品和查询，这通常能将复杂度从 $O(QlogN)$ 优化到 $O(NlogN+QlogQ)$（排序的开销）或 $O((N+Q)log(N+Q))$。

对于本题，**"排序 + 预处理前缀最大值 + 二分搜索"** 是最直观和强大的模式。

###核心思想和套路

#### 预处理items数组

##### 按照价格从低到高进行排序

将 `items` 数组按照物品价格 `price` 从低到高进行排序。如果价格相同，美丽值的顺序不影响结果。

##### 计算前缀最大美丽值

排序后，我们遍历 `items` 数组。

对于第 `i` 个物品 `items[i]`，我们将其美丽值 `items[i][1]` 更新为**到目前为止（包括 `items[i]`）所有物品中的最大美丽值**。

- 令 `max_beauty = 0`。

- 遍历 `items`，`max_beauty = max(max_beauty, items[i][1])`，然后 `items[i][1] = max_beauty`。

**处理之后的效果:** `items` 数组的价格是递增的，并且其美丽值也是**非递减**的。

`items[i][1]` 存储的是所有价格小于等于 `items[i][0]` 的物品中的最大美丽值。

#### 处理Queries数组

对于每一个查询 `q`，我们现在需要在一个价格有序、美丽值非递减的 `items` 数组中寻找答案。

**目标:** 找到价格小于等于 `q` 的所有物品，并返回它们中（被预处理过的）最大美丽值。由于美丽值已经是非递减的，这等价于找到价格小于等于 `q` 的**最右边（价格最高）**的那个物品，并取其美丽值。

**方法：二分搜索。** 在 `items` 数组的价格上执行二分搜索，查找满足 `price <= q` 的最大索引。

**结果:**

- 如果找到了这样的物品（即二分搜索找到了一个合法的索引 `idx`），那么答案就是 `items[idx][1]`。
- 如果没有找到（例如所有物品的价格都大于 `q`），则说明没有符合条件的物品，答案为 `0`。

###实现代码

```java
class Solution {
    //items[i] = [price_i,beauty_i]
    //queries[j] = limited_price_j
    //找出价格小于limited_price_j的最大的美丽值
    //考虑怎么排序？按照价格+美丽值排序？先按照价格？
    class Item {
        int price;
        int beauty;
        int maxBeauty;
        public Item(int price, int beauty){
            this.price = price;
            this.beauty = beauty;
            this.maxBeauty = 0;
        }
    }
    public int[] maximumBeauty(int[][] items, int[] queries) {
        List<Item> itemList = new ArrayList<>();
        for(int[] item: items){
            itemList.add(new Item(item[0], item[1]));
        }
        itemList.sort((a,b) -> a.price - b.price);
        //生成前缀最大值
        int maxBeauty = 0;
        for(int i = 0; i < itemList.size(); i++){
            Item item = itemList.get(i);
            maxBeauty = Math.max(maxBeauty, item.beauty);
            item.maxBeauty = maxBeauty;
        }

        //寻找右边界
        int[] ans = new int[queries.length];
        for(int i = 0; i < queries.length; i++){
            int q = queries[i];
            ans[i] = binarySearch(itemList, q);
        }
        return ans;

    }

    private int binarySearch(List<Item> itemList, int target){
        int left = 0;
        int right = itemList.size() - 1;
        int ans = 0;
        while (left <= right) { //使用 <=时，需要辅助变量
            int mid = left + (right - left) / 2;
            //说明结果可能在右边，左指针向右移动，并保留当前最大beauty值
            Item midItem = itemList.get(mid);
            if(midItem.price <= target){
                ans = midItem.maxBeauty;
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return ans;
    }
}
```



### 注意事项

- **数据范围与整数溢出:** 题目中价格和美丽值的范围是 109，在 Java 中使用 `int` 类型是安全的。
- **排序的稳定性:** 当价格相同时，物品的相对顺序不重要，所以不需要稳定的排序。`Comparator.comparingInt` 已经足够。
- **二分搜索的边界:** 实现二分搜索时要特别小心边界条件。我们的目标是找到“小于等于”的上界（最后一个满足条件的位置），所以当 `items[mid][0] <= targetPrice` 时，我们记录该索引并继续向右搜索（`left = mid + 1`）。
- **空 `items` 数组:** 如果 `items` 为空，代码需要能正确处理。在我们的实现中，`items.length` 为 `0`，循环和二分搜索都不会执行，最终会正确返回全为 `0` 的 `answer` 数组。
- **查询的价格小于所有物品价格:** 如果一个查询价格比所有物品的最低价还低，二分搜索会返回 `-1`，此时我们正确地将答案设为 `0`。

### 经验总结

**核心套路:** **排序 + X**。这里的 "X" 可以是：

- **二分搜索:** 当查询具有单调性时。
- **双指针:** 当查询本身也可以被排序时（离线处理）。
- **树状数组/线段树:** 当数据需要动态更新时（本题数据是静态的，所以用不到）。
- **哈希表/字典树:** 当需要快速键值查找时。

本题的解法将“前缀最大值”这个简单的动态规划思想与“排序+二分搜索”的经典模式相结合，形成了一个高效且优雅的解决方案。
