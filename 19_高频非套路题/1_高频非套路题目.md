# Leetcode 41 : 数组中第一个缺失的正数

##问题要点

###问题场景和目标

给定一个无序整数数组 `nums`，要求在 **O(n)** 时间、**O(1)** 额外空间（不计输入数组本身）内，找出数组中缺失的最小正整数。

- **输入特点**：元素可能为负数、零、超出范围的正数，也可能有重复。
- **输出要求**：**最小的、严格大于 0 的整数**，且该整数不在数组中出现。

### 限制和要求

- **时间复杂度 (Time Complexity):** O(n)，其中 n 是数组的长度。
- **空间复杂度 (Space Complexity):** O(1)，即只能使用常数级别的额外空间。

数学本质上，这是在 `[1, 2, …, n]` 范围内寻找第一个“空桶”（一个没有被占用的正整数）。
**数组长度为 `n`:**

- **如果所有 `1…n` 都出现了，那么答案必定是 `n+1`**；

- 否则，答案是第一个未出现的。

## 问题的本质和分析

### 问题的本质 - 不考虑限制的话使用HashMap就行了

这道题的本质是在一个包含负数、零和正数的无序集合中，高效地找到序列 `1, 2, 3, ...` 中第一个缺失的成员。

如果我们不考虑空间复杂度的限制，问题会简单很多。我们可以：

- **使用哈希集合 (HashSet):** 将所有正数存入一个哈希集合。然后从 1 开始遍历，检查哪个数字最先不在集合中。这需要 O(n) 的时间和 O(n) 的空间。
- **排序 (Sorting):** 对数组进行排序。然后遍历排序后的数组，找到第一个不连续的正整数。这需要 O(n log n) 的时间和 O(1) 或 O(n) 的空间（取决于排序算法的实现）。

然而，题目严格的 O(1) 空间限制意味着我们不能使用这些辅助数据结构，必须在**原地 (in-place)** 修改输入数组来达到目的。

### 问题的分析 - 缺失的数字应该在`[1...n+1]`

关键的洞察在于：**对于一个长度为 `n` 的数组，它能包含的第一个缺失的正数，其答案范围必然在 `[1, n+1]` 之内。**

**为什么？** 我们可以分情况讨论：

#### 数组包含了从1到n中的所有数字：缺失的数字就是`n+1`

- **最坏情况：** 数组 `nums` 正好包含了从 `1` 到 `n` 的所有整数，即 `[1, 2, ..., n]`。此时，第一个缺失的正数就是 `n + 1`。

#### 数组中有从1到n之外的数字：缺失的数字在`[1...n]`中

- **其他情况：** 如果数组中包含了负数、0、或者大于 `n` 的正数，或者有重复的正数，那么必然在 `[1, n]` 这个区间内至少有一个数字缺失了。

这个洞察极其重要，因为它将我们的搜索范围从无限的正整数集缩小到了 `[1, n]`。这启发我们可以利用数组本身的索引来存储信息。

## 模式匹配 - 循环排序

这道题的解法与一种被称为 **循环排序 (Cyclic Sort)** 的模式高度相关。

### 循环排序适用于的场景？

**循环排序模式**适用于解决以下类型的问题：

- 给你一个长度为 `n` 的数组。
- 数组中的数字几乎都落在 `[1, n]` 或 `[0, n-1]` 的范围内。
- 任务是找到数组中缺失或重复的数字。

### 循环排序的原理 - 将每个元素放归位

####什么是元素归位？

其核心思想是：**将每个数字 `x` 放置到它“应该”在的位置**。

例如，如果数字范围是 `[1, n]`，那么数字 `1` 应该在索引 `0` 的位置，数字 `2` 在索引 `1` 的位置。

以此类推，**数字 `x` 应该在索引 `x-1` 的位置**。



#### 元素归位的方法

##### 检查`nums[i]`是否在其位置上： $nums[i] == i+1$

如果我们发现一个元素`nums[i] = x`， **其中 $x \neq  i + 1$**.

那么说明元素$x$不在其位置上，因为元素$x$的位置应该是$x-1$。

##### 交换过程：`while(nums[i] != i+1)`

我们发现$nums[i] \neq i+1$之后，假设`nums[i]`的值是$x$。

那么我们将`nums[i]`和`nums[i-1]`交换。

然后我们继续检查`nums[i]`的值是否是$i+1$。

如果不是的话，我们继续上面的交换过程，直到`nums[i]`满足下面三个条件之一：

- 位置正确
- 值是非整数
- 值 $\gt n$ 



通过一次**遍历和交换**，我们可以将数组整理成一个近乎有序的状态，从而轻松找到缺失的元素。

LeetCode 41 正是这种模式的完美应用。我们的目标是将数字 `i+1` 放到 `nums[i]` 的位置上。

## 核心思想和关键套路： 原地哈希 + 两轮扫描

结合问题分析和模式匹配，最优解法的核心思想可以概括为：**利用数组的索引作为哈希表，将数字归位**。

### 第一次遍历：检查并且并归位

第一次遍历数组，目的是将每个正数 `nums[i]` 放到它正确的位置 `nums[nums[i] - 1]` 上。

#### 归位操作

在遍历过程中，对于当前数字 `nums[i] = x`：

- 首先判断 `x` 是否是一个有效的、需要被归位的正数。

  它必须满足 `1 <= x <= n`。

  对于负数、0 和大于 `n` 的数，我们直接忽略，因为它们不可能成为答案（答案在 `[1, n+1]` 范围内）。

- 如果 `x` 是有效正数，我们检查 `x` 是否已经在正确的位置上，即 `nums[x - 1] == x`。

  如果已经在，说明这个位置已经处理好了，继续下一个。

- 如果 `x` 不在正确的位置上，我们就将 `nums[i]` 与 `nums[x - 1]` 进行交换。

  这样，数字 `x` 就被放到了 `nums[x-1]` 这个属于它的“坑”里。

#### 处理交换之后的元素

交换后，原来 `nums[i]` 的位置上有了一个新的数字，这个新数字可能也需要归位。

因此，我们需要一个 `while` 循环来持续这个过程，直到 `nums[i]` 的位置上的数字满足了**无需处理**的条件（非正数、大于n、或已在正确位置）。

### 第二次遍历：查找不符合规律的元素

 当第一次遍历和归位操作完成后，理想情况下，数组 `nums` 中 `nums[i]` 的值应该等于 `i + 1`。

我们进行第二次遍历，从头开始检查。

第一个 `nums[i] != i + 1` 的位置，就意味着 `i + 1` 这个数字缺失了。我们返回 `i + 1`。

### 处理特殊情况 - 所有元素位置都在正确的位置上

如果第二次遍历结束后，发现所有 `nums[i]` 都等于 `i + 1`，这说明 `[1, n]` 都存在，那么缺失的第一个正数就是 `n + 1`。

## 实现原理和步骤

1. 读取数组长度`n = nums.length`

2. 第一轮**双指针 + 交换**

   ```java
   for (int i = 0; i< n; i++){
     while(nums[i]>=1 && nums[i] <=n
          && nums[i-1] != nums[i]){
       swap(nums,i,nums[i] - 1)
     }
   }
   ```

3. 第二轮**线性扫描**

```java
for (int i = 0; i < n; i++){
 if (nums[i] != i+1){
   return i+1;
 }
}

return n+1;
```



4. 辅助函数`swap`:交换数组中两个下标的值

## 实现代码

```java
public class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 步骤 1 & 2 & 3: 将每个数字放到正确的位置 (Cyclic Sort)
        // 目标：让 nums[i] = i + 1
        for (int i = 0; i < n; i++) {
            // 当 nums[i] 是一个在 [1, n] 范围内的正数，
            // 并且它没有在正确的位置上时，进行交换。
            // 正确的位置应该是 nums[i] - 1。
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 例如 nums[i] = 3, n=4, 应该放到索引 2 的位置
                // 如果 nums[2] 不等于 3, 就交换 nums[i] 和 nums[2]
                swap(nums, i, nums[i] - 1);
            }
        }

        // 步骤 4 & 5: 查找第一个位置和值不匹配的元素
        // 经过上面的循环，如果 1, 2, ..., k 都存在，那么 nums[0]..nums[k-1]
        // 应该分别是 1, 2, ..., k
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                // 找到了第一个不匹配的，i+1 就是缺失的最小正数
                return i + 1;
            }
        }

        // 步骤 6: 如果 [1, n] 都存在，那么缺失的就是 n + 1
        return n + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 注意事项

- **避免无限交换**：`while` 条件中要加 `nums[nums[i]-1] != nums[i]`，否则遇到相同值会死循环。
- **边界判断**：一定要先判断 `nums[i]` 是否在 `[1, n]`，否则 `nums[i]-1` 可能越界。
- **空间限制**：只能使用常数级额外空间，不要用 `HashSet`、排序或额外数组。
- **原地修改**：若题目后续还有使用原数组的需求，请记得拷贝或恢复。

## 经验总结

**原地哈希套路**：利用数组下标「映射」值域 `[1,n]`，可快速定位、去重、缺失检测。

**双重扫描**：先重排，再扫描，是常用的线性时间算法模式。

**莫忘边界与重复**：负数、零、超界和重复，是众多线性原地算法的「坑」，必须严密判断。

**扩展思路**：也可用“标记符号法”（把出现过的 `k` 对应下标变为负数），同样能在 O(1) 空间内实现

# 