## 图的分类

| 类型                  | 子类            | 说明                          |
| --------------------- | --------------- | ----------------------------- |
| **有向图**            | ——              | 边有方向 `(u → v)`            |
| **无向图**            | ——              | 边无方向 `(u ↔ v)`            |
| **带权图**            | 有向/无向都可以 | 每条边有权值                  |
| **无权图**            | ——              | 常用于 BFS 最短路径           |
| **稀疏图 / 稠密图**   | ——              | 边远少于点的平方 / 接近完全图 |
| **连通图 / 非连通图** | ——              | 所有点都能互达 / 不能互达     |
| **DAG（有向无环图）** | ——              | 用于拓扑排序、任务依赖建模    |
| **树 / 森林**         | ——              | 无环连通图（树） / 多棵树     |

## 图的表示

### 邻接表

```java
List<List<Integer>> graph = new ArrayList<>();
for (int i=0;i<n;i++){
  //对于每一个节点，都添加一个list，保存与其相邻的节点
	graph.add(new ArrayList<>());
}
// 边是使用数组表示 int[i][j] 
// i表示edge的index, 
// j=int[2], 表示起点和终点
for (int[] edge: edges){
	int u = edge[0], v=edge[1];
	graph.get(u).add(v);
	// graph.get(v).add(u);//如果是无向图的话，两个数组都要添加

}
```

### 邻接矩阵

> 邻接矩阵适合稠密图

```java
//邻接矩阵是一个二维数组graph[u][v]
// graph[u][v]=1表示存在一条从u到v的边
int[][] graph = new int[][];

for (int[] edge: edges){
  int u=edge[0],v=edge[1];
  graph[u][v]=1;
  // graph[v][u]=1 //如果是无向图
}
```

### 边列表（适合并查集、Kruskal）

```java
List<int[]> edges = new ArrayList<>();
edges.add(new int{u,v,weight});
```

## 常见算法策略

| 算法 / 技术           | 典型场景                       | Java 模板说明                 |
| --------------------- | ------------------------------ | ----------------------------- |
| **BFS（广度优先）**   | 无权图最短路径、岛屿扩展问题   | `Queue + visited Set`         |
| **DFS（深度优先）**   | 遍历图、连通块、图染色、检测环 | `递归 DFS + visited`          |
| **Union-Find 并查集** | 判断连通性、合并集合、检测环   | `parent[] + find + union`     |
| **Dijkstra**          | 加权图中最短路径               | `PriorityQueue + dist[]`      |
| **Bellman-Ford**      | 有负权边的最短路径（较少用）   | `O(VE)`，代码略长             |
| **拓扑排序**          | DAG 拓扑结构判断或任务调度问题 | `Queue + 入度数组 indegree[]` |
| **Kruskal**           | 最小生成树                     | `边排序 + Union-Find`         |
| **Prim**              | 最小生成树（稠密图更优）       | `PriorityQueue + visited`     |

### 相关算法在面试题中的占比排名

在大厂/互联网公司（如 Google、Amazon、Meta、字节、阿里、腾讯）中，图论题目的出题频率大概占**中高级算法题目的 15% 左右**，其中：

**最常考的图算法** 排名一般是：

1. **BFS/DFS**（包括拓扑排序）
2. **Union-Find（并查集）**
3. **Dijkstra（最短路径）**
4. **Kruskal / Prim（最小生成树）**
5. **A\* / Bellman-Ford（罕见）**