#单原最短路径问题 - Bellman-Ford算法

##算法解决了什么问题？ - 计算从一个指定的起点到图中所有其他定点的最短路径

Bellman-Ford 算法用于解决**单源最短路径（Single-Source Shortest Path, SSSP）**问题。

即，计算从一个指定的源点 `s` 到图中所有其他顶点的最短路径。

##和 Dijstra算法的比较

###可以处理带有负权的边

这是Bellman-Ford和Dijstra最显著的区别。

Dijkstra 的贪心策略在遇到负权边时会失效，而 Bellman-Ford 能够正确处理这种情况。

###能够检测负权环 (Negative Weight Cycles)

如果图中存在一个从源点可达的、权重之和为负的环路，那么理论上最短路径可以无限小（不停地绕圈）。

Bellman-Ford 算法能够可靠地检测出这种情况并报告。

###适用于带边数限制的最短路径问题

算法的迭代性质使其天然适用于解决“最多经过 K 条边的最短路径”这类问题，正如我们在 LeetCode 787 中看到的那样。

当你的图存在负权边，或者你需要判断是否存在负权环时，Bellman-Ford 是首选算法。

如果确定所有边权非负，通常会选择效率更高的 Dijkstra 算法。

##核心思想 - 松弛迭代

Bellman-Ford 的核心思想是**迭代松弛 (Iterative Relaxation)**。它非常朴素和暴力，但极其有效。

对图中的所有边，进行 `V-1` 轮松**弛操作**。算法能保证找到从源点出发、最多经过 `i` 条边的最短路径。

###什么是他妈的松弛操作？

对于一条边 `(u, v)`，如果 `dist[u] + weight(u, v) < dist[v]`，就更新 `dist[v]` 为 `dist[u] + weight(u, v)`。

这好比是说：“我发现了一条经过 `u` 到达 `v` 的更短路径，所以更新一下记录。”

####迭代 (Iteration) - 对所有的边进行松弛

Bellman-Ford 不像 Dijkstra 那样“聪明”地**选择下一个要访问的节点**，而是“盲目地”对**所有边**进行松弛，并重复这个过程。

算法的巧妙之处在于，它系统性地对所有边进行 `|V| - 1` 次松弛操作（其中 `|V|` 是图中顶点的数量）。

因为在一个不包含负权环路的图中，任意两个顶点之间的最短路径最多包含 `|V| - 1` 条边。

因此，经过 `|V| - 1` 轮的全局松弛，从源点出发的任何最短路径都应该已经被找到了。

##### 为什么是`v-1`轮？

在一个包含 `V` 个顶点的图中，任意两个顶点之间的最短路径，如果不包含环，**最多只能由 `V-1` 条边组成**。

因此，进行 `V-1` 轮松弛，就足以确保**所有不含环的最短路径都被找到**。

第一轮找到所有长度为1的最短路，第二轮找到所有长度不超过2的最短路，以此类推。

## Bellman - Ford算法的要素

### 图的表示

通常使用邻接表或边列表来表示图，其中需要存储每条边的起点、终点和权重。

### 距离数组

一个大小为 `|V|` 的数组（例如 `dist`），用于存储从源点到每个顶点的当前最短路径长度的估计值。

### 前驱数组

个大小为 `|V|` 的数组（例如 `predecessor`），用于记录**最短路径中每个顶点的前一个顶点**，以便在算法结束后重构最短路径。

### 原点

**源顶点 (source vertex)**：算法的起点。

## 实现原理和详细步骤

### 初始化 距离数组和前驱数组

1. 创建一个距离数组 `dist`，并将源顶点 `s` 的距离初始化为 0 (`dist[s] = 0`)。
2. 将所有其他顶点的距离初始化为无穷大 (`dist[v] = ∞` for all `v ≠ s`)。这表示我们尚未找到任何从 `s` 到达这些顶点的路径。
3. 创建一个前驱数组 `predecessor`，并将所有顶点的前驱初始化为 `null`。

### 迭代松弛 `v-1`次

重复以下过程 `|V| - 1` 次：

- 遍历图中的每一条边 `(u, v)`，其权重为 `w`。
- 对这条边进行松弛操作：如果 `dist[u] + w < dist[v]`，则更新 `dist[v] = dist[u] + w`，并设置 `predecessor[v] = u`。

### 检测负权环路

- 在完成 `|V| - 1` 次迭代后，再对图中的所有边进行一次遍历。

- 对于任意一条边 `(u, v)`，其权重为 `w`，如果仍然满足 `dist[u] + w < dist[v]`，则说明图中存在负权环路。

- 如果检测到负权环路，算法通常会报告该情况并终止，因为此时无法给出有意义的最短路径结果。

##代码套路模板

```Java
public int[] BellmanFord(Map<Integer,List<int[]>> graph, int source){
  int n = graph.size();
  int[] dist = new int[n];
  Arrays.fill(dist,Integer.MAX_VALUE);
  dist[source] = 0;
  
  int[] predecessor = new int[n];
  Arrays.fill(predecessor,-1);
  List<int[]> edges = new ArrayList<>();
  
  //2. 松弛过程
  for(int curr=0; curr < n; curr++){
    List<int[]> neigborEdges = graph.get(curr);
    //收集所有的边
    edges.addAll(neigborEdges);
    //松弛过程
    for(int[] edge : neigborEdges){
      int next = edge[1];
      int weight = edge[2];
      if(dist[curr] + weight < dist[next]){
        dist[next] = dist[curr] + weight;
        predecessor[next] = current;
      }
    }
    
    //3. 检查是否有负权环路
    for(int[] edge : edges){
      int from = edge[0];
      int to = edge[1];
      int weight = edge[2];
      if(dist[from] + weight < dist[to]){
        System.out.println("[ERROR] Graph contains a negative-weight cycle.")
        return null;
      }
    }
    
  }
}
```

## 注意事项和经验总结

### 没有负边的情况下Dijstra是更好的选择

Bellman-Ford 算法的时间复杂度为 O(∣V∣⋅∣E∣)，其中 ∣V∣ 是顶点数，∣E∣ 是边数。这使得它在稠密图上的效率低于 Dijkstra 算法（使用优先队列的实现为 O(∣E∣+∣V∣log∣V∣)）。因此，如果图中没有负权边，Dijkstra 算法是更好的选择。

### 负权环路

务必进行第三步的负权环路检测。如果省略这一步，在存在负权环路的图上，算法可能会给出错误的最短路径结果。

### 适用性

Bellman-Ford 算法的核心优势在于其处理负权边的通用性。当图中可能存在负权边时，它是计算单源最短路径的标准算法之一。

### 分布式实现

该算法的思想易于在分布式系统中实现。每个节点只需要维护其到源点的距离，并与邻居节点交换信息即可。

## Leetcode 787: **在最多 K 次中转（即最多 K+1 条边）内**的单源最短路径

### 问题要点

#### 问题描述

给定 `n` 个城市，航班数组 `flights[i] = [from, to, price]`，起点城市 `src`，终点城市 `dst`，和中转次数上限 `k`，返回从 `src` 到 `dst` 的**最小花费**，要求中转次数 ≤ `k`（即最多经过 `k+1` 个城市），找不到则返回 -1。

####关键约束

- 图是**有向图**，并且带**权重**
- 中转次数 <= `k`，等价于**路径长度小于<`k+1` 条边**
- 你不能无限制的探索所有路径
- 每个节点可能需要多次探索（**不同转机次数**）， 才能找到最优解

### 问题本质和分析 - 带限制条件的最短路径问题

这是一个典型的**图论**问题。具体来说，是在一个带权有向图中，寻找从单个源点 (`src`) 到单个终点 (`dst`) 的路径。

它不是一个简单的最短路径问题，而是一个**带限制条件的最短路径问题 (Constrained Shortest Path Problem)**。这个限制条件就是路径的长度（边的数量）不能超过 `k+1`。

#### 为什么标准Dijstra算法不再适用？

Dijkstra 是一种贪心算法，它每次都选择当前看来路径权重最小的节点进行扩展。

一旦一个节点被访问并**确定了其最短距离**，Dijkstra 就**不会再次访问它**。

但在本题中，**一条当前看来票价较高的路径，可能因为其中转次数少，而为后续到达终点提供了可能性**。

而一条票价低的路径，可能因为中转次数过多，在到达终点前就超过了 `k` 次中转的限制。

因此，Dijkstra 的贪心策略在这里会失效。



总的来说，**Dijkstra 算法是解决普通单源最短路径问题的贪心算法，而 LeetCode 787 是一个带有附加限制（中转次数）的最短路径问题，这个限制使得标准 Dijkstra 算法不再适用。**

#####核心矛盾： 贪心选择 VS 附加约束

Dijkstra 算法的基石是一个贪心假设：**如果我当前找到了一条到达节点 `A` 的最短路径，那么这条路径一定是全局最短的**。

因此，当 Dijkstra 将节点 `A` 从优先队列中取出并标记为已访问后，它就永远**不会再回头更新到 `A` 的路径**。

然而，LeetCode 787 中的 `K` 站中转限制彻底打破了这个假设。

##### 举个例子来说明 : S -> D最多中转一次的最低成本

假设我们要从城市 `S` 到城市 `D`，最多允许中转 1 次 (`k=1`)。

- **路径 1:** `S -> A -> D`
  - `S -> A` 票价 100，`A -> D` 票价 100。
  - 总票价：200，中转 1 次。
- **路径 2:** `S -> D`
  - `S -> D` 票价 300。
  - 总票价：300，中转 0 次。

Dijkstra 的执行过程：

###### 找到S->A和S->D的距离

- Dijkstra 从 `S` 出发，首先会探索到 `A` (成本 100) 和 `D` (成本 300)。

- 优先队列会弹出成本最低的 `(100, A)`。

######找到 A->D的距离

- 从 `A` 出发，它会找到 `A -> D`，总成本为 `100 + 100 = 200`。

  此时，算法更新到 `D` 的成本为 200。

###### 确定S->D的最短距离

- 接下来，优先队列会弹出 `(200, D)`。

  根据 Dijkstra 的规则，节点 `D` 的最短路径已经被找到（成本 200），`D` 被标记为“已访问”。

###### 问题来了：如果K为0呢？（不允许中转）

- **问题来了**：这条成本为 200 的路径 `S -> A -> D` 包含 2 条边（1 次中转）。
  - 如果题目要求 `k=0`（不允许中转），这条路径是无效的！
  - 而那条成本为 300 的直飞路径 `S -> D` 才是正确答案。
  - 标准 Dijkstra 算法由于其贪心性质，无法处理这种“步数”限制。

#### 为什么Bellman-Ford更适合这个问题？

Bellman-Ford 算法的核心思想是**通过迭代来逐步逼近最短路径**。它的每一轮迭代都有着非常明确的物理意义：

- **第 1 轮迭代**：找到从源点出发，**最多经过 1 条边**能到达的所有节点的最短路径。
- **第 2 轮迭代**：利用第 1 轮的结果，找到从源点出发，**最多经过 2 条边**能到达的所有节点的最短路径。
- ...
- **第 `i` 轮迭代**：利用第 `i-1` 轮的结果，找到从源点出发，**最多经过 `i` 条边**能到达的所有节点的最短路径。

现在我们看看题目的要求：**最多K次中转**，这等价于路径的边数**最多为`K+1`**

看到了吗？这个限制和 Bellman-Ford 算法的迭代过程**完美地对应**上了！

- 我们只需要执行 `k+1` 轮 Bellman-Ford 的松弛操作。
- 在第 `k+1` 轮迭代结束后，`dist[dst]` 数组中存储的值，就是从源点 `src` 出发，路径边数不超过 `k+1` 到达终点 `dst` 的最短路径长度。

这种解法不仅正确，而且在逻辑上极其清晰：**用算法的迭代次数，直接模拟和限制了题目中的中转次数（路径边数）**。

代码实现上，就是把 Bellman-Ford 的外层循环从 `V-1` 次改为 `k+1` 次。

**从理解角度看，这种方法几乎就是对问题描述的直接翻译。**

### 套路模式匹配

Bellman-Ford 算法通过 `V-1` 轮迭代来求解最短路径，其每一轮迭代都有明确的含义：**第 `i` 轮迭代可以找到从源点出发、最多经过 `i` 条边的最短路径**。

| Bellman-Ford 标准算法                                  | LeetCode 787 问题                        | 匹配关系   |
| ------------------------------------------------------ | ---------------------------------------- | ---------- |
| 第 1 轮迭代：找到最多经过 **1** 条边的最短路径         | 直飞（0 中转）：路径包含 **1** 条边      | ✅ 完美匹配 |
| 第 2 轮迭代：找到最多经过 **2** 条边的最短路径         | 最多 1 次中转：路径包含 **2** 条边       | ✅ 完美匹配 |
| ...                                                    | ...                                      | ...        |
| 第 `k+1` 轮迭代：找到最多经过 **`k+1`** 条边的最短路径 | 最多 `k` 次中转：路径包含 **`k+1`** 条边 | ✅ 完美匹配 |

### 核心思想和套路 - 动态规划

#### 动态规划的模型匹配 - `dp[i][j]`:从起点 `src` 出发，**恰好乘坐 `i` 趟航班**，到达城市 `j` 的最低票价

这个问题的核心思想可以看作是**动态规划 (Dynamic Programming)**，而 Bellman-Ford 本身就蕴含了 DP 的思想。

`dp[i][j]` 表示：从起点 `src` 出发，**恰好乘坐 `i` 趟航班**，到达城市 `j` 的最低票价。

在**Bellman-Ford**算法中，这个数组的含义是：**在执行完第 `i` 轮松弛操作后，从起点 `src` 到达城市 `j` 的最短路径长度（最低票价）。**

`i`：代表 Bellman-Ford 算法的**迭代轮次**，同时也等价于路径所包含的**最多边数**。范围是 `[0, k+1]`。

`j`：代表目标城市（节点）。范围是 `[0, n-1]`。

##### 状态数组的维度

- 第一维 `i`（航班数）：航班数可以从 0 (原地不动) 到 `k+1` (最多 `k` 次中转)，所以大小需要是 `k+2`。

- 第二维 `j`（城市编号）：从 `0` 到 `n-1`，所以大小需要是 `n`。

- 因此，我们创建一个 `dp[k+2][n]` 的二维数组。

#### 动态规划的状态转移 - Bellman-Ford松弛过程

##### Bellman-Ford的松弛过程

Bellman-Ford 的核心是松弛操作：`dist[v] = min(dist[v], dist[u] + weight)`。

在我们的二维数组中，当我们进行第 `i` 轮迭代时，我们是**利用第 `i-1` 轮的结果**来计算第 `i` 轮的新距离。

因此，松弛操作就具体化为状态转移方程： `dist[i][v] = min(dist[i][v], dist[i-1][u] + price)`

这个方程的含义是：在第 `i` 轮迭代中，要更新到达 `v` 的距离，我们考察所有能飞到 `v` 的航班 `(u, v)`，并使用 `u` 在**上一轮（第 `i-1` 轮）** 的计算结果 `dist[i-1][u]` 加上当前航班的票价，来尝试更新 `v` 在**当前轮（第 `i` 轮）** 的距离 `dist[i][v]`。

这完美地体现了 Bellman-Ford 算法逐轮逼近最短路的核心思想。

#####转化为本问题的状态转移过程

要计算 `dp[i][j]` (乘坐 `i` 趟航班到达城市 `j` 的票价)，我们需要考虑所有能够飞到 `j` 的航班。

假设有一条航班 `[from, to, price]`，其中 `to` 就是 `j`。

 那么，我们可以先通过 `i-1` 趟航班到达 `from`，然后乘坐这趟航班到达 `j`。 

其状态转移方程为： `dp[i][j] = min(dp[i][j], dp[i-1][from] + price)`

我们一层一层地计算，直到计算完第 `k+1` 层。最终的答案并不是 `dp[k+1][dst]`，因为题目要求是**最多** `k` 次中转，所以我们需要在 `dp[1][dst]`, `dp[2][dst]`, ..., `dp[k+1][dst]` 中取一个最小值。





### 实现原理和步骤

#### 初始化DP数组

- 创建一个 `dp[k+2][n]` 的二维数组。
- 用一个非常大的值（代表无穷大 `INF`）填充整个数组，表示初始时所有城市都不可达。
- 设置**基础状态**: `dp[0][src] = 0`。这表示在不乘坐任何航班的情况下，我们已经在起点 `src`，花费为 0。

#### 迭代松弛操作

- 外层循环 `i` 从 `1` 到 `k+1`，代表当前乘坐的航班数量。
- 内层循环遍历每一条航线 `flight = [from, to, price]`。
- 应用状态转移方程：
  - 如果 `dp[i-1][from]` 不是无穷大（意味着城市 `from` 在 `i-1` 步时是可达的），我们就尝试更新 `dp[i][to]`：
  - `dp[i][to] = min(dp[i][to], dp[i-1][from] + price)`

#### 寻找最终结果

- 循环结束后，`dp` 数组已经填充完毕。`dp[i][dst]` 存储了恰好乘坐 `i` 趟航班到达 `dst` 的最低票价。

- 我们需要的结果是**最多** `k+1` 趟航班的最低票价。因此，我们需要遍历 `i` 从 `1` 到 `k+1`，找出 `dp[i][dst]` 中的最小值。

- 初始化一个结果变量 `ans` 为无穷大，然后 `ans = min(ans, dp[i][dst])` for `i` in `[1, k+1]`。

#### 返回结果

- 如果最终 `ans` 仍然是无穷大，说明在限制内无法到达，返回 `-1`。
- 否则，返回 `ans`。

### 实现代码

```Java
import java.util.Arrays;

class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        // 使用一个足够大的值表示无穷大，防止加法溢出
        int INF = Integer.MAX_VALUE / 2;

        // dp[i][j]: 从 src 出发，【恰好】乘坐 i 趟航班，到达城市 j 的最低票价
        // i: 航班数, 范围 [0, k+1]
        // j: 目标城市, 范围 [0, n-1]
        int[][] dp = new int[k + 2][n];

        // 步骤 1: 初始化
        for (int i = 0; i <= k + 1; i++) {
            Arrays.fill(dp[i], INF);
        }
        // 基础状态: 乘坐 0 趟航班，在 src 的花费为 0
        dp[0][src] = 0;

        // 步骤 2: 迭代计算
        // i 代表当前计算的是乘坐【恰好 i 趟】航班的情况
        for (int i = 1; i <= k + 1; i++) {
            for (int[] flight : flights) {
                int u = flight[0];
                int v = flight[1];
                int price = flight[2];

                // 状态转移：必须从一个【恰好 i-1 趟】航班可达的前置节点 u 出发
                if (dp[i - 1][u] != INF) {
                    dp[i][v] = Math.min(dp[i][v], dp[i - 1][u] + price);
                }
            }
        }

        // 步骤 3: 寻找最终结果
        // 答案是所有【不超过 k+1 趟】航班方案中的最优解
        int minCost = INF;
        for (int i = 1; i <= k + 1; i++) {
            minCost = Math.min(minCost, dp[i][dst]);
        }

        // 步骤 4: 返回
        return minCost == INF ? -1 : minCost;
    }
}
```





