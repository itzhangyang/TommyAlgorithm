#并查集模板

##理解并查集究竟是什么东西

###数据的存放

有一堆元素，属于**不同的集合**，**每一个集合有一个老大，**或者是代表

`parent[i]` 表示元素i的老大

一般来说**初始状态之下每个元素就是自己的老大**，用一个数组来表示就是：

```
 for (int i=0; i<n;i++) parent[i]=i;
```

###Find(x):找出元素x的老大

比如想知道4属于哪一个集合，就是找4的老大，那么寻找的过程就是

- 先看看4是不是自己的老大：parent[4]==4;
- 如果4不是自己大老大：
  - 找到4的老大
  - 如果4的老大还有老大， 则继续寻找
  - 一直找到那个老大是自己的老大，返回这个终极大Boss

###Union(x,y) 合并 x和y所在的两个集合

- 首先，找出x和y各自的老大`find(x)`和`find(y)`
- **如果两个老大不一样**，则**把其中一个老大挂到另外一个老大下面**
- **如果两个老大相同：说明他们本来就在一个集合，不用动**

##并查集代码实现模板

```java
class UnionFind {
  int[] parent;
  //联通分量数量
  int count;
  UnionFind(int n){
    parent = new int[n];
    count = n;
    for (int i=0; i<n;i++) parent[i]=i;
  }
  
  int find(int x){
    if (x!=parent[x]) parent[x]=find[parent[x]];
    return parent[x];
  }
  
  boolean union(int x, int y){
    int rootX = find(x);
    int rootY=find(y);
    if(rootX == rootY){
      return false;
    }
    parent[rootX]=rootY;
    count--;
    return true;
  }
}
```

##并查集的应用场景

| 场景                 | 问题                                   | 应用                                                       | 示例                                              |
| -------------------- | -------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------- |
| 连接问题             | 判断两个节点是否属于同一个`连通块`     | 动态连通性问题、计算连通分量个数                           | Leetcode 547. 省份数量（等价于图中连通块数量）    |
| **判断图中是否有环** | **判断图中是否有环**                   | 对图的边进行遍历，如果两个端点已经在同一集合，则形成了环。 | 最小生成树 Kruskal 算法。                         |
| 动态朋友关系问题     | 朋友圈查询                             | 一系列「连接 a 和 b」的操作，判断两人是否在同一个朋友圈。  | 朋友圈查询（如 Leetcode 1319、Leetcode 399 等）。 |
| 图中岛屿数量         | 图中岛屿数量                           | 将二维网格视为图，对 1 相邻的格子进行合并。                |                                                   |
| **冗余连接**         | 给定一组边，找出多余的一条，构成了环。 |                                                            | Leetcode 684、685                                 |

##Leetcode 547:并查集的直观理解-省份数量（等价于图中连通块数量）

### 问题要点

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

###问题的本质

本题的目的是将所有相互连通的节点分类，相互连通的节点分为一个集合，然后返回集合的数量即可。

###核心思想-通过并查集合并所有相互连通的节点到一个集合当中。

通过使用并查集的`union(x,y)`方法，将矩阵中有连接的节点加入到相同的集合。

然后通过并查集的`find(x)`方法查询每一个节点的老大，返回老大的数量即可。

###实现代码

```java
    public class UnionFind {
        int[] parent;
        int count;//联通分量的数量

        UnionFind(int n){
            parent = new int[n];
            count = n;
            for(int i=0;i<n;i++){
                parent[i]=i;
            }
        }

        int find(int x){
            if (x!=parent[x]) parent[x] = find(parent[x]);
            return parent[x];
        }

        boolean union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);
            if (rootX != rootY){
                parent[rootX] = rootY;
                count--；//合并成功，联通分量-1
            }
            return true;
        }    
    }
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        UnionFind uf = new UnionFind(n);
        for (int i=0; i< n ; i++){
            for (int j=0;j<n;j++){
                if (isConnected[i][j]==1){
                    uf.union(i, j);
                }
            }
        }

        Set<Integer> parentSet = new HashSet<>();
        for (int m=0; m<n;m++){
            parentSet.add(uf.find(m));
        }
        return parentSet.size();
    }
```

##Leetcode 1319: 连通网络的操作次数

有 `n` 台电脑，用 `connections[i] = [a, b]` 表示电脑 a 和 b 之间有一根网线连接。

你需要在任意两台电脑之间连接线缆，问**最少需要几次操作才能使整个网络连通**？

如果无法做到，返回 -1。

##### 问题本质：无向图的最小生成树需要有至少n-1条边

> **一个无向图中，至少需要将所有节点连成一棵树（一个连通图），最少需要 n - 1 条边**。

##### 核心思想：并查集

1. 必须条件，如果边的数量少于n-1,那么一定是无法连通的，直接返回`-1`
2. 采用**并查集**用于判断图中**连通分量**的个数
3. 假设有`c`个连通分量，则至少需要`c-1`条边来连成一个图
4. 本题的关键是：
   - 统计**连通分量**的个数
   - 判断是否有足够的**多余边**（`c-1`）来连接他们

##### 实现原理

###### 使用并查集计算连通分量的个数和冗余边的个数

如果`a`和`b`之间存在一条边，则使用`union`函数来合并它们

- 如果合并之前发现`root[a] == root[b]`，则说明 **`a`和`b`已经在同一个连通分量当中，这条边属于`冗余边`**
- 如果合并之前发现`root[a] != root[b]`，说明`a`和`b`不在同一个连通分量当中，合并即可

###### 利用并查集的find()函数统计连通分量的数量

可以通过定义一个连通分量个数`count`：

- 初始值为节点的数量。
- 每次合并成功两个节点以后，连通分量`count -= 1`

###### 计算冗余的边是否足以连接所有的连通分量

- 假设有`c`个连通分量，则需要`c-1`条冗余边来连接所有的连通分量

##### 代码实现

```java
    class UnionFind{
        int parent[];
        int count;
        int extraEdges;

        public UnionFind(int n){
            parent = new int[n];
            count = n;
            extraEdges=0;
            for (int i=0;i<n;i++) parent[i]=i;
        }

        public int find(int x){
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        public boolean union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY){
                extraEdges++;
                return false;
            }

            parent[rootX] = rootY;
            count--;
            return true;
        }
    }
    //并查集方式 查询到
    public int makeConnected(int n, int[][] connections) {
        // check whether the edges < n-1;
        if (connections.length < n-1){
            return -1;
        }
        UnionFind uf = new UnionFind(n);

        for (int[] conn : connections){
            uf.union(conn[0], conn[1]);
        }

        if (uf.extraEdges < uf.count-1){
            return -1;
        }

        return uf.count-1;
    }
```

##### 注意事项

| 事项           | 说明                                         |
| -------------- | -------------------------------------------- |
| ❗ 最少边数限制 | 连通 `n` 个点至少需要 `n - 1` 条边           |
| ❗ 并查集初始化 | `parent[i] = i`，不是 `0`                    |
| ❗ 统计连通分量 | 每次成功 union 时 `count--`                  |
| ❗ 多余边计算   | union 失败的就是多余边，可用于连接孤立的子图 |
| ❗ 返回结果     | 连通分量数量 - 1 即为所需操作次数            |

##Leetcode 684: 冗余连接（检测图中的环）

> 树可以看成是一个连通且 **无环** 的 **无向** 图。
>
> 给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。
>
> 添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。
>
> 图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。
>
> 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。
>
> 如果有多个答案，则返回数组 `edges` 中最后出现的那个。

需要记住一点，树额外加入一个边之后，就形成了一个`带环的图` , 所以题目就变成了`寻找图中的环`。

注意可能会存在`多条`冗余的边，题目要求返回`最后出现`的`冗余边`。

##### 核心思想

这是一个`图`中找环的问题，可以通过`并查集`方式来判断一条边是否沟通环。

从无到有的构建图，`每次加入一条边时，判断是否构成环`.

- 每条边连接两个点，我们需要模拟构建图的过程
- 每连接一条边，我们就检查边的`两个点是否已经在图中连通了`
  - 如果没有连通：这条边不会构成环，可以添加
  - 如果已经连通：这条边会形成环，我们已经找到了答案

###### 并查集中的元素是什么？

图中所有的节点

###### 并查集的中的集合是什么？老大是谁？

一个集合意味着一组可以相互连通的节点

###### 并查集中的查找是什么意思？

用来查找两个节点是否有共同的老大（是否同属一个集合）

###### 并查集中的合并操作是什么？

添加边的时候，如果两个节点不在同一个集合，将两个节点所属于的集合合并。

**如果两个节点已经在同一个集合，说遍这条边属于冗余的**



##### 算法原理

1. 初始化每个节点各自为一个集合。
2. 遍历每一条边 `[u, v]`：
   - 如果 `u` 和 `v` 已连通（属于同一集合）：**说明这条边构成环，返回它。**
   - 否则，把它们“连接”起来（合并集合）。
3. 遍历完成后返回构成环的那条边。

##### 代码实现

###### 并查集的定义

```java
public class UnionFind{
	int[] parent;
	
	public UnionFind(int n){
    for (int i=1;i<=n;i++){
      parent[i]=i;
    }
	}
  
  public find(int x){
    if (parent[x]!=x){
      parent[x] = find[parent[x]];
    }
    return parent[x];
  }
  
  public union(int x, int y){
    int parentX = find(x);
    int parentY = find(y);
    if (parentX != parentY){
      parent[parentX] = parentY;//注意是将x的parent的parent修改为Y的parent
    }
  }
}
```



###### 在图的构建过程发现环

```java
public int[] findRedundantConnection(int[][] edges){
  UnionFind uf = new UnionFind(n);
  int[] lastRedundantCollection = new int[2];
  for (int[] edge: edges){
  	int node1 = edge[0];
  	int node2 = edge[1];
  	int parent1 = find(node1);
  	int parent2 = find(node2);
  	if (parent1 == parent2){
  		lastRedundantCollection = edge;
  	}else{
  		uf.union(node1, node2);
  	}
  	return lastRedundantCollection;
  }
}
```

# 