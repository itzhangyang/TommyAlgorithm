#Kruskal 算法：最小生成树算法

##Kruskal 解决了什么问题？-无向连通加权图最小生成树

在一个 **无向连通图** 中，选出一些边构成一个**生成树**，使得：

- 覆盖所有的顶点；
- 总边权最小；
- 没有环。

**如果一个图有n个节点，那它的最小生成树有`n-1`** 条边。

##Kruskal  用于哪些场景？

- 网络布线最小成本

- 公路/电缆/管道铺设最小代价

- 聚类分析

##Kruskal  的产出 - 一个由边构成的列表

##### 这些边囊括了所有的节点。

##### 边的数量是n-1

##### 边的权重总和最小

##### 没有环的存在

##核心思想：贪心

> 每次选择`当前权重最小`，`不会形成环`的一条边加入生成树，直到构成一颗生成树为止

这是一种贪心策略，关键在于避免环的生成

##算法原理：并查集+排序

###将所有边按照权重从大到小排序

注意和拓扑排序的区别：

- **`拓扑排序`是先计算每个节点的入度，然后使用队列逐渐减少每个节点的入度**
- **`最小生成树`算法是将每个`边的权重`按照`从小到大`的顺序排序**

###从最小边开始，判断当前边连接的两个点是否属于不同集合（不连通）

- **若不属于同一个集合，将它们加入生成树**
- **若不是，说明加入这条边会生成环，则跳过**

##### 重复上述步骤2，直到选择n-1条边（n是节点树）

##Kruskal算法的关键要素

###边列表: `List<Edge>` - 按照权重排序

存储所有的边，并且按照权重排序

###并查集

判断两个节点是否属于同一个集合（是否连通）

###生成树集合

收集最终选中的边（也可以直接统计总权重）

### 记录已经选择的节点的数量

在实现过程中，在选中某条边以后，需要同时根据变的端点记录**已经选择的节点的数量**

如果已经选择的节点数量为`n`，则结束循环过程。

### 记录最小权重和

在实现过程中，选中某条边以后，需要同时记录已经选中的边的总权重。

如果已经选择了n个节点，在记录的总权重就是**最小生成树的总权重**。



##代码实现 - 基于并查集

###并查集的定义和实现

```java
class UnionFind{
    int[] parent;
    int count;
    int selectedEdges;
    int selectedWeight;
    public UnionFind(int n){
        this.count = 0;
        this.parent = new int[n];
        for(int i = 0; i < n; i++){
            parent[i] = i;
        }
        this.selectedWeight = 0;
        this.selectedEdges = 0;
    }

    public int find(int x){
        if(parent[x] != x){
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public boolean union(int x, int y, int weight){
        int rootX = find(x);
        int rootY = find(y);

        if(rootX == rootY){
            return false;
        }
        parent[rootX] = rootY;
        selectedEdges++;
        selectedWeight += weight;
        return true;
    }
}
```

###边列表排序

```
Arrays.sort(edges->edge.weigt);
```

###初始化并查集

```
UnionFind uf = new UnionFind(n);
```

###贪心算法处理过程

```java
int n = points.length;
List<Edge> edges = getEdges(points);
UnionFind uf = new UnionFind(n);
for(Edge edge : edges){
  uf.union(edge.idx1, edge.idx2, edge.getDist());
  if(uf.selectedEdges == n-1){
  break;
  }
}
```

###返回最小生成树总权重

```java
return uf.selectedWeight;
```

##总结

| 项目           | Kruskal 算法说明                     |
| -------------- | ------------------------------------ |
| 适用图类型     | 无向图，边稀疏图效果更好             |
| 算法思想       | 贪心，按权重从小到大选边             |
| 是否需要连通图 | 是（才能得到一棵生成树）             |
| 是否需要防环   | 是，使用并查集避免环                 |
| 时间复杂度     | `O(ElogE)`，E为边数（排序 + 并查集） |

注意： **Kruskal**算法仅仅适用于**无向图**。

##Leetcode 1584: 连接所有点的最小费用

给你一个`points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。

连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。

###核心思想-最小生成树的特征

生成一个`最小生成树`，`最小生成树`具有的特征：

- 覆盖所有的节点
- 边的总权重最小
- 没有环

如果一个图中有n个节点，那么它的最小生成树具有`n-1`个边。

###关键数据结构

####节点列表`List<Node>`

####边列表`List<Edge>`

####并查集`UnionFind`

###算法原理

- 将二维数组转变成一组节点`List<Node>`，注意二维数组的定义是`points[i]={xi,yi}`

  ```java
  class Node {
    int id;// 节点在二维数组中的index
    int x;//节点的x坐标
    int y;//节点的y坐标
    
    public (int id, int x,int y){
      this.x=x;
      this.y=y;
      this.id = id
    }
  }
  
  public List<Node> getNodes(int[][] points){
    List<Node> nodes = new ArrayList<>();
    int n = points.length;
    for (int i=0;i<n;i++){
      int[] point = points[i];
      nodes.add(new Node(i,point[0],point[1]));
    }
    return nodes;
  }
  ```

- 将图视为一个`强连通图`，从节点中生成所有的`边`,并且按照距离的`从小到大`排序

  ```java
  class Edge{
    int id1;
    int x1;
    int y1;
    int id2;
    int x2;
    int y2;
    public Edge(int id1,int x1,int y1,int id2,int x2,int y2){
      this.id1 =id1;
      this.x1=x1;
      this.y1=y1;
      this.id2 = id2;
      this.x2=x2;
      this.y2=y2;
    }
    
    public int distance(){
      return Math.abs(x1-x2)+Math.abs(y1-y2);
    }
  }
  
  public List<Edge> getEdges(List<Node> nodes){
    List<Edge> edges = new ArrayList<>();
    for (Node node1: nodes){
      for (Node node2:nodes){
        if (node1 !=node2){
          edges.add(new Edge(node1.id,node1.x, node1.y, node2.id,node2.x,node2.y));
        }
      }
    }
    //按照距离进行排序
    edges.sort(Comparaor.comparingInt(edge->edge.getDistance()))；
    return edges;
  }
  ```

- 定义并查集

  ```java
  class UnionFind{
    int[] parent;//每一个节点的老大
    
    //n是节点的数量
    public UnionFind(List<Node> nodes){
      int n = nodes.sizes();
      for (int i=0;i<n;i++){
        parent[i]=i;
      }
    }
    
    public find(int x){
      if (parent[x]!=x){
        parent[x]=find(parent[x]);
      }
      return parent[x];
    }
    
    public union(int x, int y){
      int parentX = find(x);
      int parentY = find(y);
      if (parentX != parentY){
        parent[parentX]=parentY;
      }
    }
  }
  
  public UnionFind getUnionFind(List<Node> nodes){
    return new UnionFind(nodes);
  }
  ```

  

- [最小生成树算法] 初始化关键数据结构

  ```java
  List<Node> nodes = getNodes(points);
  List<Edge> edges = getEdges(nodes);
  UnionFind uf = getUnionFind(nodes);
  //加入最小生成树的边，一棵最小生成树需要正好n-1个边
  int usedEdges =0;
  //最小生成树的权重总和
  int minTotalDistance=0;
  ```

- [最小生成树] 遍历已经排序的edges:

  - 检查每一条边的两个端点是否连通(有同一个老大)
    - 如果已经连通，跳过
    - 如果没有连通：
      - 在并查集中合并两个端点；
      - 增加边的数量 `usedEdges +=1`
      - 增加总权重 `minTotalDistance += edge.getDistance()`
  - 检查最小生成树中的边的数量是否已经达到n-1
    - 如果已经达到，则终止遍历
    - 如果没有达到则继续遍历

```java
for (Edge edge:edges){
	int node1 = edge.id1;
  int node2 = edge.id2;
  int parent1=uf.find(node1);
  int parent2 = uf.find(node2);
  if (parent1!=parent2){
    uf.union(node1,node2);
    usedEdges +=1;
    minTotalDistance += edge.getDistance();
    if (usedEdges == n-1){
      break;
    }
  }
}
```

- 判断是否可以生成最小生成树（`UdedEdges==n-1`）
  - 如果是，则返回totalMinDistance;
  - 如果不是，则返回`-1`;