# 最短路径： 从某点到其他点的最短距离

##场景描述

如地图中最短通勤路线、服务器之间最短传输距离、从当前页面跳转到目标页面的最短点击路径等。

##通用应对策略

###无权图的最短路径问题-BFS

####核心算法思想

在图中维护`dist`表，通过更新最小距离扩展搜索边界。

#### 实现套路

##### 使用 BFS求无权图的最短路径

```java
public int shortedPath(Map<Integer, List<Integer>> graph,int start, int target){
  Queue<Integer> queue = new LinkedList<>();
  queue.offer(start);
  
  Set<Integer> visited = new HashSet<>();
  visited.add(start);
  
  int steps = 1;
  
  while(!queue.isEmpty()){
    int size = queue.size();
    for (int i=0; i<size;i++){
      Integer current = queue.poll();
      if (current == target){
        return steps;
      }
      
      List<Integer> nexts = graph.getOrDefault(current,new ArrayList<>());
      
      for (Integer next : nexts){
        if (!visisted.contains(next)){
          queue.offer(next);
          visited.add(next);
        }
      }
    }
  }
  
  return -1;//达不到的情况下按照要求返回特定数字
}
```

###加权图的最短路径问题:Dijkstra

**Dijkstra算法求的是某个节点到其他所有节点的最短距离，而不是某个特定目标节点的最短距离**

####初始化Dijkstra的核心数据结构：小顶堆

####求所有的边和权重

一般加权图的表示方法可能会是`Map<node, <next,weight>>`，这个时候一般需要从其中解析所有的**边权重**。

```java
class Edge{
  int start;
  int end;
  int weight;
}
```

####排序： 将所有的边按照权重从从小到大排列

```java
Arrays.sort(edges, (a,b) -> a.weight-b.weight);
```

####初始化最短距离-`dist[node in nodes] = max`

初始化最小距离数组:

- **`dist[i]`表示起点到目标节点`i`的最短距离**
- `dist[start]`初始值为0，每个节点到自己的距离都是`0`
- `dist[i != start]`初始值都设置为`Integer.MAX_VALUE`，求最小值的时候，初始值一般都设置为`max`

####初始化小顶堆和存储结构-存储start到每一个节点的距离

Question： **小顶堆和dist[]中的元素的区别是啥？**

- `dist[]`会存放最终结果
- 小顶堆是一个辅助结构，确保可以**按照距离start节点的距离从小到大的遍历节点**

#####**小顶堆元素结构定义：**

```java
class Distance {
  int node;
  int distance;
}
```

#####**初始化小顶堆并且将start元素入队**

```Java
PriorityQueue<Distance> pq = new PriorityQueue<>((a,b)->a.distance - between.distance);
pq.offer (new Distance(start,0));
```

####利用队列遍历和更新每个节点的最小距离 - 类似于BFS过程

**这个过程和BFS有点类似**，但是**最小堆中可能会存在多个相同的节点**

##### 1. 从**小顶堆中** 取出当前距离start最近的**未处理节点**（`u`）。

需要指出的是，**最小堆中可能会存在多个相同的节点u，但是它们到起点的距离不同**。

因此最小堆中最先出堆的u节点以及对应的最短距离就是最优解，后序再次遇到节点u应当剪枝忽略。

- 如果堆顶的节点之前没有处理过，则说明它是最优值，继续处理其邻接节点的值。
- 节点`u`的邻接点距离还没有确认

##### 2. 如果`start`到`u`的距离`distance` 大于 `dist[u]`，则剪枝`continue`-继续取小顶堆中的下一个元素

这是因为：

- `dist[u]` 是我们目前已经找到的 **start 到 u 的最短路径值**。
- `distance` 是某个路径下从 `start` 到 `u` 的距离，但它**不一定是最短的**，可能是之前其他路径推导出来的、**但后来被更短路径更新过**。
- **Dijkstra 的最短路径具有“单源最短性”——一旦找到最短路径，就不会被更短路径更新。**

因此：

- 如果 `distance > dist[u]`，就说明这个节点已经被更短的路径更新过了。
- 此时这个 `(distance, u)` 是 **过期的旧路径**，已经不是最优的了，没必要继续处理它。
- 所以我们 `continue` 掉它，直接跳过，去堆中取下一个可能更有效的节点。

##### 3. 获取节点`u`的所有**邻接节点**，更新**start到这些邻接节点的最短距离**

对于每一个邻接节点`v`, 如果`dist[v] > dist[u]+weight[u,v]`,则

- 更新`dist[v]=dist[u]+weight[u,v]`

- 将节点`v` 加入**小顶堆**

  ```java
  pq.add(new Distance(v,dist[v]));
  ```

1. 重复上面的过程，直到**小顶堆为空为止**

#### 一但确定不再访问的原则

在很多高效的 Dijkstra 实现中，确实没有一个明确的 `boolean[] visited` 数组。

它通过`dist`数组和一个关键的**剪枝**，隐式的实现了**确定最小值之后不再进行访问**的逻辑。

##### Dijstra的核心保证 - 一个节点的第一个从堆中取出的记录所记录的就是最近距离

为什么呢？

优先队列保证了我们每次取出的都是当前所有“待处理”路径中总成本最低的那一个。

因为图中没有负权重边，所以任何一条更长的路径（经过更多节点）再回到 `u`，其总成本必然会比当前这个已取出的最短路径要大。

因此，一旦节点 `u` 以成本 `c` 被取出，就意味着 `dist[u]` 被永久地确定为了 `c`，这个值不会再有更小的可能了。

##### 堆中的过时状态怎么半？- 过时就剪枝丢弃

处理方法就是在**从优先队列取出元素后，立刻进行一次检查**。

```Java
while (!pq.isEmpty()) {
    int[] curr = pq.poll();
    int price = curr[0];
    int city = curr[1];

    // 这就是隐式的 visited 检查！
    // 如果当前取出的路径成本比已记录的到这个城市的最短路成本还大，
    // 说明它是一个“过时”的状态，直接跳过。
    if (price > dist[city]) {
        continue;
    }
    
    // ... 后续的邻居节点遍历和更新 ...
}
```



####Dijkstra的代码实现套路

```java
class Distance{
  int node;
  int distance;
  public Distance(int node, int distance){
    this.node = node;
    this.distance = distance;
  }
}
public int[] dijkstra(List<int[]> graph, int start){
  int n = graph.size();
  int[] dist = new int[n];
  
  Arrays.fill(dist,Integer.MAX_VALUE);
  dist[0] = 0;
  
  PriorityQueue<Distance> pq = new PriorityQueue<>((a,b)->a.distance - b.distance);
  pq.offer(start);
  
  while (!pq.isEmpty()){
    Distance current = pq.poll();
    //注意最小堆中可能会存在多个相同的节点u，只是距离start最小的节点u在堆顶
    //所以如果说有一个更优的节点u距离被处理过以后，堆里面的后序节点u应当被直接忽略点
    //通过这种方式可以将后序的非最优的节点u排除掉
    if (current.distance > dist[current.node]) continue;
    //取出节点u的所有邻接点和边
    //如果路径[start...u-v]的成本比[start...v]的cost更低，
    //bfs过程中，是遍历所有邻接点，并且将所有邻接点再次入队，这里只是将符合条件的邻接点入队，因此是类似bfs的过程
    //之所以选择
    List<int[]> edges = graph.getOrDefault(current.node,new ArrayList<>());
    for (int[] edge : edges){
      int neighbor = edge[0];
      int weight = edge[1];
      if (dist[neighbor] > dist[current]+weight){
        dist[neighbor] = dist[current]+weight;
        pq.offer(new Distance(neighbor,dist[neighbor]))
      }
    }
  }
  
  return dist;
}
```

##Leetcode 787: K站中转内最便宜的航班

### 问题要点

#### 问题描述

给定 `n` 个城市，航班数组 `flights[i] = [from, to, price]`，起点城市 `src`，终点城市 `dst`，和中转次数上限 `k`，返回从 `src` 到 `dst` 的**最小花费**，要求中转次数 ≤ `k`（即最多经过 `k+1` 个城市），找不到则返回 -1。

####关键约束

- 图是**有向图**，并且带**权重**
- 中转次数 <= `k`，等价于**路径长度小于<`k+1` 条边**
- 你不能无限制的探索所有路径
- 每个节点可能需要多次探索（**不同转机次数**）， 才能找到最优解

### 问题本质和分析 - 带限制条件的最短路径问题

这是一个典型的**图论**问题。具体来说，是在一个带权有向图中，寻找从单个源点 (`src`) 到单个终点 (`dst`) 的路径。

它不是一个简单的最短路径问题，而是一个**带限制条件的最短路径问题 (Constrained Shortest Path Problem)**。这个限制条件就是路径的长度（边的数量）不能超过 `k+1`。

#### 为什么标准Dijstra算法不再适用？

Dijkstra 是一种贪心算法，它每次都选择当前看来路径权重最小的节点进行扩展。

一旦一个节点被访问并**确定了其最短距离**，Dijkstra 就**不会再次访问它**。

但在本题中，**一条当前看来票价较高的路径，可能因为其中转次数少，而为后续到达终点提供了可能性**。

而一条票价低的路径，可能因为中转次数过多，在到达终点前就超过了 `k` 次中转的限制。

因此，Dijkstra 的贪心策略在这里会失效。



总的来说，**Dijkstra 算法是解决普通单源最短路径问题的贪心算法，而 LeetCode 787 是一个带有附加限制（中转次数）的最短路径问题，这个限制使得标准 Dijkstra 算法不再适用。**

#####核心矛盾： 贪心选择 VS 附加约束

Dijkstra 算法的基石是一个贪心假设：**如果我当前找到了一条到达节点 `A` 的最短路径，那么这条路径一定是全局最短的**。

因此，当 Dijkstra 将节点 `A` 从优先队列中取出并标记为已访问后，它就永远**不会再回头更新到 `A` 的路径**。

然而，LeetCode 787 中的 `K` 站中转限制彻底打破了这个假设。

##### 举个例子来说明 : S -> D最多中转一次的最低成本

假设我们要从城市 `S` 到城市 `D`，最多允许中转 1 次 (`k=1`)。

- **路径 1:** `S -> A -> D`
  - `S -> A` 票价 100，`A -> D` 票价 100。
  - 总票价：200，中转 1 次。
- **路径 2:** `S -> D`
  - `S -> D` 票价 300。
  - 总票价：300，中转 0 次。

Dijkstra 的执行过程：

###### 找到S->A和S->D的距离

- Dijkstra 从 `S` 出发，首先会探索到 `A` (成本 100) 和 `D` (成本 300)。

- 优先队列会弹出成本最低的 `(100, A)`。

######找到 A->D的距离

- 从 `A` 出发，它会找到 `A -> D`，总成本为 `100 + 100 = 200`。

  此时，算法更新到 `D` 的成本为 200。

###### 确定S->D的最短距离

- 接下来，优先队列会弹出 `(200, D)`。

  根据 Dijkstra 的规则，节点 `D` 的最短路径已经被找到（成本 200），`D` 被标记为“已访问”。

###### 问题来了：如果K为0呢？（不允许中转）

- **问题来了**：这条成本为 200 的路径 `S -> A -> D` 包含 2 条边（1 次中转）。
  - 如果题目要求 `k=0`（不允许中转），这条路径是无效的！
  - 而那条成本为 300 的直飞路径 `S -> D` 才是正确答案。
  - 标准 Dijkstra 算法由于其贪心性质，无法处理这种“步数”限制。

### 模式套路匹配

#### 动态规划 - Bellman - Ford算法

特别是 **Bellman-Ford 算法** 的思想。

Bellman-Ford 算法本身就是一种通过迭代求解最短路径的动态规划方法，它的迭代次数与路径中的边数直接相关。

#### 图的广度优先搜索

我们可以把中转次数 `k` 看作 BFS 的“层数”。

每进行一层 BFS，就相当于多乘坐了一次航班。

#### Dijstra算法的变种

我们可以修改 Dijkstra 算法的状态定义，将中转次数也加入到状态中，从而使其能够处理这个额外的约束。



###核心思想和套路 - 基于修改版的 Dijkstra (BFS + 优先队列)

这是一个**带限制的加权最短路径**，而**不是普通的Dijkstra问题**

| 项       | 说明                                                  |
| -------- | ----------------------------------------------------- |
| 图结构   | 加权有向图                                            |
| 要求     | 从 `src` 到 `dst` 的**最小总代价路径**                |
| 限制     | **最多中转 `k` 次（路径长度 ≤ k+1）**                 |
| 特性     | 路径的长度和总代价都需要考虑                          |
| 可用算法 | **BFS + 优先队列（带状态）** 或 **Bellman-Ford 变体** |

本题最经典、最核心的两种解法是 **动态规划 (Bellman-Ford)** 和 **修改版的 Dijkstra**。

####**核心思想**: 

Dijkstra 贪心地选择“总票价”最低的路径。

我们修改它，让它不仅考虑票价，还要考虑中转次数。

我们仍然使用优先队列，但队列中存储的不再仅仅是 `(票价, 城市)`，而是 `(票价, 城市, 已用航班数)`。

#### 三元组的定义

- 优先队列中存储一个数组或对象，包含三个信息：`[totalPrice, city, stops]`。

- 优先队列根据 `totalPrice` 进行升序排序。

#### 剪枝优化

当我们从队列中取出一个状态 `(price, city, stops)` 时，如果 `stops > k+1`，则这条路径已经不合法，直接跳过。

//为什么是K+1?

为了防止在图中兜圈子，我们可以记录到达每个城市所需的最少航班数。

如果找到一条新路径到达某个城市，但其航班数比之前记录的还要多（或相等但票价更高），则可以剪枝。

### 实现原理和步骤

1. 构建邻接表来表示图，`adj[u]` 存储所有从 `u` 出发的 `[v, price]` 对。

2. 创建一个优先队列 `pq`，用于存储 `int[]{totalPrice, city, stops}`。

3. 创建一个二维数组 `minCosts[stops][city]` 或者一个 `minStops[city]` 数组来记录和剪枝。

   这里用 `minStops` 更简单，`minStops[i]` 记录到达城市 `i` 的最少航班数。

4. 将起点加入队列：`pq.offer(new int[]{0, src, 0})`。`minStops` 数组所有值初始化为无穷大。

5. 当队列不为空时，循环： 

   a. 弹出队列中票价最低的元素 `curr = {price, city, stops}`。

    b. **检查中转次数**：如果 `stops > k + 1`，则跳过。

    c. **剪枝**：如果 `stops` 大于或等于 `minStops[city]`，说明之前已经有一条更优（或一样好）的路径到达该城市，跳过。

    d. 更新 `minStops[city] = stops`。 

     e. **检查终点**：如果 `city == dst`，直接返回 `price`，因为优先队列的特性，第一个到达终点的路径一定是票价最低的。

    f. 遍历 `city` 的所有邻居 `neighbor`： 

   - i.  计算新票价 `newPrice = price + neighbor.price`。 
   - ii. 将 `{newPrice, neighbor.city, stops + 1}` 加入优先队列。

如果队列为空还没找到终点，说明无法到达，返回 `-1`。

###**代码实现**

```java
  import java.util.*;

class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        // 构建邻接表
        List<int[]>[] adj = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int[] flight : flights) {
            adj[flight[0]].add(new int[]{flight[1], flight[2]});
        }

        // 优先队列: [总费用, 当前城市, 已用航班数]
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, src, 0});

        // 记录到达每个城市的最少航班数，用于剪枝
        int[] minStops = new int[n];
        Arrays.fill(minStops, Integer.MAX_VALUE);

        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int price = curr[0];
            int city = curr[1];
            int stops = curr[2];

            // 如果当前路径的航班数已经超过 k+1，或者
            // 已经有另一条更少航班的路径到达当前城市，则剪枝
            if (stops > k + 1 || stops >= minStops[city]) {
                continue;
            }
            
            // 记录到达当前城市所需的最少航班数
            minStops[city] = stops;

            if (city == dst) {
                return price;
            }

            for (int[] neighbor : adj[city]) {
                int nextCity = neighbor[0];
                int nextPrice = neighbor[1];
                pq.offer(new int[]{price + nextPrice, nextCity, stops + 1});
            }
        }

        return -1;
    }
}
```

###注意事项

####不能使用传统的Dijkstra剪枝

因为Dijkstra默认**一旦访问过某个节点就不再访问**，不适合本题，因为路径中中转次数也影响结果

###### 不要只记录每个城市的最短路径

同一个城市要允许被访问多次，只要中转次数不同，或者花费更低

###### 不要使用`TransferMap`做剪枝

这个是全局剪枝，可能会错误忽略更多路径

##### 每次都选择nexts中代价最小的那个城市，这样是否能够保证最终的结果就是最小的呢？

**“每次都从 nexts 中选择代价最小的城市扩展”** —— 这听起来像 Dijkstra 的逻辑。

###### 每次都选择最便宜的路线并不能保证最终路线是最便宜的！

本题中有一个限制条件：

> **最多只能中转 `k` 次（也就是路径长度最多是 `k+1`）**

这个限制破坏了 Dijkstra 算法中最核心的假设：

> 一旦某个城市被以最小代价访问，就不用再访问它了（即最优子结构 + 单调性）。

###### 一个典型的例子

```
flights = [
  [0, 1, 100],
  [1, 2, 100],
  [0, 2, 500]
]
src = 0, dst = 2, k = 1

```

两条路径：

- `0-2`，直接走，代价500，0次中转
- `0-1-2`，代价200，1次中转

如果我们在扩展`0-2`时发现它最便宜，就立刻会返回答案`500`，就会错过更优的路径`0-1-2`。

因此：即使某路径目前代价最小，也不能“贪心地认为它一定是最优”，因为还有可能在中转次数限制内出现“代价更小”的路径。

##### 经验总结

| 问题模式                      | 对应算法                 |
| ----------------------------- | ------------------------ |
| 加权图 + 不限制路径长度       | Dijkstra                 |
| 加权图 + 限制边数（路径长度） | BFS + 状态               |
| 无权图 + 限制步数             | 普通 BFS                 |
| 全图路径更新 + 最多 K 次更新  | Bellman-Ford（K 轮松弛） |

##### 考察点

本题是一个 **路径长度受限的加权最短路径问题**，最推荐的解法是 **BFS + PriorityQueue + 状态三元组**，要避免传统 Dijkstra 的“访问即最优”剪枝误用。

你能不能识别“最短路径” + “路径长度限制”的综合问题；

能否设计状态 `(city, cost, stops)`；

能否正确控制剪枝条件。

##Leetcode 1514 概率最大的路径-Dijkstra变种

给你一个由 `n` 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 `edges[i] = [a, b]` 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 `succProb[i]` 。

指定两个节点分别作为起点 `start` 和终点 `end` ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 `start` 到 `end` 的路径，请 **返回 0** 。只要答案与标准答案的误差不超过 **1e-5** ，就会被视作正确答案。

输入：

- `n`：节点个数
- `edges[i] = [a, b]`：无向边
- `succProb[i]`：与 `edges[i]` 对应的成功概率（范围是 0 到 1）
- `start`：起始点
- `end`：目标点

输出：

- 最大的成功概率

###问题本质- **图上的最短路径问题的变种**

这其实是一个 **图上的最短路径问题的变种**。

- 原始的最短路径算法如 Dijkstra 是以“加法”为权值（最小化总和）。
- 本题要最大化概率 —— 路径的概率是沿路所有边的乘积，**目标是最大化乘积**。

**转化思想：**

- 最大化乘积的问题，本质上是一个 “**最大乘积路径**” 问题。
- 因为乘法的性质（乘积大于0且 ≤1），我们不能直接用加法形式的 Dijkstra，但可以做如下变通。

###核心思想-Dijkstra中将最小堆替换为最大堆

使用 **最大堆版的 Dijkstra 算法**（因为我们追求的是最大概率）。

每个节点记录从 `start` 到达该节点的最大概率。

使用 **优先队列（大根堆）** 处理当前概率最大的节点。

###实现原理

1. 使用邻接表构建图。
2. 初始化一个概率数组 `prob[]`，`prob[i]` 表示从 `start` 到 `i` 的最大概率。
3. 使用大根堆 `priority_queue`，按概率从大到小进行遍历。
4. 每次取出当前概率最大的节点，如果是终点则直接返回。
5. 否则遍历邻居节点，更新其最大概率（如果更大）。

###实现代码

```java
class Solution {
    class Prob{
        int node;
        double prob;

        public Prob(int node, double prob){
            this.node = node;
            this.prob = prob;
        }
    }
    // Dijstra解法，改成大顶堆
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        Map<Integer,Map<Integer,Double>> graph = getGraph(n, edges, succProb);
        
        double[] dist = new double[n];
        dist[start_node]=1.0d;

        PriorityQueue<Prob> pq = new PriorityQueue<>((a, b) -> Double.compare(b.prob, a.prob));

        pq.offer(new Prob(start_node,1.0d));

        while (!pq.isEmpty()) {
            Prob current = pq.poll();

            if (current.prob < dist[current.node]) continue;

            Map<Integer, Double> nexts = graph.getOrDefault(current.node, new HashMap<>());
            for (Map.Entry<Integer, Double> entry : nexts.entrySet()){
                int nextNode = entry.getKey();
                double nextProb = entry.getValue();

                if (dist[nextNode] < dist[current.node]*nextProb){
                    dist[nextNode] = dist[current.node]*nextProb;
                    pq.offer(new Prob(nextNode, dist[current.node]*nextProb));
                }
            }
        }

        return dist[end_node];
        

        
    }

    private Map<Integer,Map<Integer,Double>> getGraph(int n, int[][] edges, double[] succProb){
        Map<Integer, Map<Integer,Double>> map = new HashMap<>();
        for (int i=0; i< edges.length;i++){
            int[] edge = edges[i];
            int from = edge[0];
            int to = edge[1];
            double prob = succProb[i];

            map.computeIfAbsent(from, x->new HashMap<>()).put(to, prob);
            map.computeIfAbsent(to, x -> new HashMap<>()).put(from, prob);
        }

        return map;
    }
}
```

##Leetcode 1631: [最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

你准备参加一场远足活动。给你一个二维 `rows x columns` 的地图 `heights` ，其中 `heights[row][col]` 表示格子 `(row, col)` 的高度。一开始你在最左上角的格子 `(0, 0)` ，且你希望去最右下角的格子 `(rows-1, columns-1)` （注意下标从 **0** 开始编号）。你每次可以往 **上**，**下**，**左**，**右** 四个方向之一移动，你想要找到耗费 **体力** 最小的一条路径。

一条路径耗费的 **体力值** 是路径上相邻格子之间 **高度差绝对值** 的 **最大值** 决定的。

请你返回从左上角走到右下角的最小 **体力消耗值** 。

##### 注意题目中的描述：相邻格子之间高度差绝对值的最大值决定的

> **从起点 (0,0) 到位置 (i,j) 的所有路径中，路径上的高度差最大值的最小值（即最小 effort）。**

换句话说：

- 它不是从 (0,0) 到 (i,j) 的「最短路径长度」；
- 而是从 (0,0) 到 (i,j) 的「路径上每一格高度差的最大值」，这些路径中我们选择「那个最大值最小的」。

这就意味着你需要通过如下方式计算effort:

```
int effort = Math.max(dist[i][j], Math.abs(heights[ni][nj] - heights[i][j]));
```

所以假设 `diff[i] = height[i]-height[i-1]`，我们需要求的是diff中的最大值



##### 核心思想：Dijkstra求加权图的最小路径

##### 实现代码

```java
  class Cost{
        int i;
        int j;
        int cost;

        public Cost(int i, int j, int cost){
            this.i = i;
            this.j = j;
            this.cost = cost;
        }
    }

    int[][] directions = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};

    public int minimumEffortPath(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;

        int[][] dist = new int[rows][cols];

       for (int i = 0; i< rows; i++){
        for (int j=0; j < cols; j++){
            dist[i][j] = Integer.MAX_VALUE;
        }
       }

        dist[0][0] = 0;

        PriorityQueue<Cost> pq = new PriorityQueue<>((a,b)-> a.cost - b.cost);
        pq.offer(new Cost(0,0,0));

        while(!pq.isEmpty()){
            Cost current = pq.poll();
            for (int[] dir : directions){
                int ni = current.i+dir[0];
                int nj = current.j+dir[1];
                int i = current.i;
                int j = current.j;
                if (ni >= 0 && ni < rows && nj >=0 && nj <cols){
                    int effort = Math.max( dist[i][j], Math.abs(heights[ni][nj]-heights[i][j]));
                    if (effort < dist[ni][nj]){
                    dist[ni][nj] = effort;
                    pq.offer(new Cost(ni, nj, dist[ni][nj]));
                    }
                    
                }
            }
        }
        return dist[rows-1][cols-1];

    }
```

##Leetcode : 1928-规定时间内到达终点的最小花费

一个国家有 `n` 个城市，城市编号为 `0` 到 `n - 1` ，题目保证 **所有城市** 都由**双向道路** **连接在一起** 。

道路由二维整数数组 `edges` 表示，其中 `edges[i] = [xi, yi, timei]` 表示城市 `xi` 和 `yi` 之间有一条双向道路，耗费时间为 `timei` 分钟。

两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。

每次经过一个城市时，你需要付通行费。

通行费用一个长度为 `n` 且下标从 **0** 开始的整数数组 `passingFees` 表示，其中 `passingFees[j]` 是你经过城市 `j` 需要支付的费用。

一开始，你在城市 `0` ，你想要在 `maxTime` **分钟以内** （包含 `maxTime` 分钟）到达城市 `n - 1` 。

旅行的 **费用** 为你经过的所有城市 **通行费之和** （**包括** 起点和终点城市的通行费）。

给你 `maxTime`，`edges` 和 `passingFees` ，请你返回完成旅行的 **最小费用** ，如果无法在 `maxTime` 分钟以内完成旅行，请你返回 `-1` 。

###问题本质-**带双重约束的最短路径变种问题**

- 给定一个图，每条边有
  - `cost`:通过这条边的金钱花费
  - `time`:通过这条件的时间消耗
- 要求：从`0`出发，到达`n-1`,总时间不超过`maxTime`
- 目标： 在满足时间限制的条件下，花最少的时间到达终点（n-1）；

这本质上是一个**带双重约束的最短路径变种问题**，区别于Dijkstra传统的**单一权重**最短路径

###核心思想-优先队列+动态规划+Dijkstra的变种

我们可以使用优先队列+动态规划/Dijkstra变种来解决：

- 每个状态（`当前节点+当前时间+当前花费`），但是我们**用优先队列对花费进行排序**
- 对每个点记录在某个时间下的最小花费:`minCost[node][time]`
- 每次从队列中取出**当前最小花费**的状态进行扩展，如果能在**时间范围内**走通就行

###实现原理

####图的建模

用`邻接表`记录每个点连接的边（终点，时间，花费）

####BFS优先队列状态定义

优先队列的状态定义为(`cost,currentNode,timeSpent`)

####剪枝优化

- 如果到某个点在某个时间下已经有更优解，就不再继续处理这个状态
- 通过`minTime[node]`或者`dp[node][time]`剪枝

###实现代码

####定义状态

```java
class Tuple{
    int node;
    int cost;
    int time;
    public Tuple(int node, int cost, int time){
        this.node = node;
        this.cost = cost;
        this.time = time;
    }
}
```

#### 定义边

```Java
class Edge{
    int node1;
    int node2;
    int cost;
    int time;
    public Edge(int node1, int node2, int cost, int time){
        this.node1 = node1;
        this.node2 = node2;
        this.cost = cost;
        this.time = time;
    }
}
```



####构建图的邻接表

```java
    private Map<Integer, List<Edge>> getGraph(int n, int[][] edges,int[] passingFees){
        Map<Integer, List<Edge>> graph = new HashMap<>();
        for(int i = 0; i < n; i++){
            graph.putIfAbsent(i, new ArrayList<>());
        }

        for(int i = 0; i < edges.length; i++){
            int node1 = edges[i][0];
            int node2 = edges[i][1];
            int time = edges[i][2];
            int cost1 = passingFees[node1];
            int cost2 = passingFees[node2];

            Edge edge1 = new Edge(node1, node2, cost2, time);
            graph.get(node1).add(edge1);
            Edge edge2 = new Edge(node2, node1, cost1, time);
            graph.get(node2).add(edge2);
        }

        return graph;
    }
```

####初始化动态规划数组`dp[node][time]`-某个节点在某个时间下的最小花费

```java
        int n = passingFees.length;
        //minCost[i][j] 表示在j时间内通过城市i的最小费用
        int[][] minCost = new int[n][maxTime+1];

        for(int[] sub : minCost){
            Arrays.fill(sub, Integer.MAX_VALUE);
        }
        //这里比较重要
        minCost[0][0] = passingFees[0];
```

####初始化优先队列`PriorityQueue<State>`

```java
        PriorityQueue<Tuple> minHeap = new PriorityQueue<>((a,b) -> a.cost - b.cost);
        minHeap.offer(new Tuple(0,passingFees[0],0));
```

####遍历和更新优先队列和DP数组

```java
        while(!minHeap.isEmpty()){
            Tuple curr = minHeap.poll();
            // if(curr.time > maxTime) continue;
            if(curr.node == n-1){
                return curr.cost;
            }

            List<Edge> edgeList = graph.get(curr.node);

            for(Edge edge : edgeList){
                int time = curr.time + edge.time;
                int next = edge.node2;
                if(time <= maxTime){
                    int cost = curr.cost + edge.cost;
                    if(minCost[next][time] > cost){
                        minCost[next][time] = cost;
                        minHeap.offer(new Tuple(next, cost, time));
                    }
                }
            }
        }
```

##### 注意事项

######为什么无法用传统的Dijkstra方法？

- 因为这里的路径代价是双重约束：
  - 最小化是`cost`->Dijkstra方法
  - `time`限制 ->动态规划//Todo: 复习动态规划在什么场景下适用？

###### 为什么优先队列按照cost排序？

- 我们的目标是最小的cost，所以先扩展cost最小的状态
- 如果终点第一次被弹出满足时间条件，肯定是最优

###### 为什么需要`dp[v][time]`数组

- 避免对同一个点，同一个时间重复访问，进行状态压缩与剪枝

###### 时间复杂度控制

`O(N * maxTime * log(N * maxTime))`，N 为节点数，maxTime 为上限时间（最大为 1000）。

##### 经验总结

| 项目     | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| 问题分类 | 图论 + 最短路径变种 + 动态规划                               |
| 本质     | Dijkstra 多维状态 + 时间限制约束                             |
| 适合场景 | 多维约束路径问题（如成本+时间、风险+收益）                   |
| 易错点   | 1. 没加时间维度剪枝；2. 不优先以 cost 排序；3. 没记录 visited 状态 |
| 模板价值 | Dijkstra 多维状态拓展通用模板，可以推广到风险控制、旅行规划等问题 |

##Leetcode 778 : 水位上升中的游泳池

###问题要点

**输入**: 一个 `N x N` 的整数矩阵 `grid`，其中 `grid[i][j]` 表示该位置的高度。

**过程**:

- 时间 `t` 时，水面高度为 `t`。
- 你可以从一个方格游到其相邻（上、下、左、右）的另一个方格，当且仅当这两个方格的高度都**小于等于**当前的水位 `t`。

**目标**: 从左上角 `(0, 0)` 出发，到达右下角 `(N-1, N-1)`。

**求解**: 找到能够成功到达终点的**最小**初始时间 `t`。

###本题本质和分析

这个问题的核心是寻找一条从起点到终点的路径，并使这条路径上所有方格的**最大高度值**最小化。

为什么是这样？ 假设你选择了一条路径 `P`。

为了能顺利通过这条路径上的所有方格，水面高度 `t` 必须至少等于路径 `P` 上**高度最高的那个方格的高度**。

设这个最大高度为 `H_max(P)`。

那么，要通过这条路径，所需的最少时间就是 `t=H_max(P)`。



我们的目标是找到一个**最小的** `t`。

这意味着，我们需要在所有可能的从 `(0, 0)` 到 `(N-1, N-1)` 的路径中，找到一条路径 `P*`，使得它的 $H\_{max}(P^*)$ 是所有路径中最小的。

这个最小化的最大高度值，就是我们要求的答案。



这个问题属于典型的**最小化最大值（Minimax）**路径问题，也叫**瓶颈路（Bottleneck Path）**问题。



此外，该问题具有一个非常重要的性质：**单调性（Monotonicity）**。

- 如果时间 `t` 可以让你从起点到达终点，那么任何大于 `t` 的时间 `t'` 也一定可以让你到达终点。
- 因为在时间 `t` 能通过的路径，所有格子的高度都 $\le{t}$，自然也 $\le{t′}$，所以这条路径在时间 `t'` 时同样有效。

这个单调性是解决这类问题的关键突破口。

###模式匹配

####二分查找 + 图的连通性检查

##### 二分答案的核心思想

二分答案属于二分查找系列其中的套路之一。

其核心思想是：**将“求解最优值”的问题，转化为“判定一个值是否可行”的问题。**

本质上就是每次找到一个中间值，看看中间值**是否可行**。

如果可行，将中间值记录下来，尝试在`[left...mid-1]`中寻找更小的值。

如果不可行，则尝试在`[mid+1,right]`中继续按照上述逻辑寻找答案。

##### 这个问题套到二分答案模型上

现在我们就需要寻找一个最小的最大高度`t`，使得在t的条件下，可以通过BFS或者DFS到达终点。

```Java
    private boolean bfs(int[][] grid,int t){
        if(grid[0][0] > t) return false;//这一句很重要
        
        int rows = grid.length;
        int cols = grid[0].length;
        boolean[][] visited = new boolean[rows][cols];

        Queue<Cell> queue = new LinkedList<>();
        queue.offer(new Cell(0,0,grid[0][0]));

        while(!queue.isEmpty()){
            Cell curr = queue.poll();
            if(curr.row == rows-1 && curr.col == cols -1){
                return true;
            }
            int row = curr.row;
            int col = curr.col;

            for(int[] dir : dirs){
                int nextRow = row + dir[0];
                int nextCol = col + dir[1];
                if(nextRow >= 0 && nextRow < rows && nextCol >= 0 && nextCol < cols){
                    if(visited[nextRow][nextCol]){
                        continue;
                    }
                    if(grid[nextRow][nextCol] <= t){
                        visited[nextRow][nextCol] = true;
                        queue.offer(new Cell(nextRow, nextCol, grid[nextRow][nextCol]));
                    }
                }
            }
        }
        return false;
    }
```



##### 二分寻找最小的符合条件的最大值

###### 左指针

###### 右指针

###### Mid指针

###### Check条件函数

```Java
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        int left = grid[0][0];
        int right = n * n - 1;
        int ans = 0;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(bfs(grid,mid)){
                ans = mid;
                right = mid - 1;
            }else{
                left = mid+1;
            }
        }
        return ans;
    }
```



我们的问题是寻找一条**路径**， 使得路径中的**最大节点**的值**最小**。

换一个思路，求具有**最小的最大值**的从起点到终点的路径`p`。 

**这里所说的单调性，是指如果某个路径（$t = T$）符合条件, 那么对于任意$T' \ge T$ ，路径($ t = T'$) 也是符合条件的**。

那么我们的问题就变成类似**利用二分查找查找左边界**的算法了。

- **模式**: 当问题是求解 "最小的 X 使得条件 C(X) 成立"，并且条件 C(X) 具有**单调性**时，就可以使用**二分查找**。

- **匹配**: 我们要求 "最小的时间 `t` 使得 `(0,0)` 和 `(N-1,N-1)` 连通"。

  这里的 `t` 就是 `X`，连通性就是条件 `C(X)`。

  我们已经分析出其具备单调性。

##### 复习： 使用二分查找查找左边界

寻找大于某个值的最小值？

```Java
private int find(int[] arr, int target){
  int left = 0;
  int right = arr.length - 1;
  int ans;
  while(left < right){
    int mid = left + (right - left) / 2;
    if(arr[mid] > target){
      ans = 
    }
  }
}
```



####Dijstra最短路径的变种

Dijstra算法用于求**加权图**中**指定起点**到**所有其他点**的**最短路径**。

**模式**: 在一个加权图中寻找从起点到终点的路径，使得路径成本最小。

**匹配**: 标准的 Dijkstra 是求路径权重之和的最小值。

但我们可以**重新定义路径成本**。

**在这里，路径的成本不是“和”，而是路径上遇到的“最大值”**。

只要相应地修改 Dijkstra 算法中状态的定义和更新逻辑，就可以求解。



####并查集 - 在点中不断加边

**模式**： 解决图的连通性问题。

例如，在一堆点中不断加边，然后查询任意两点是否连通。

**匹配**

我们可以把水位上升的过程看作是不断**激活**格子的过程。

水位从0开始上升，每当水位达到一个格子的高度时，这个格子就变得可以通行（被**激活**）。

我们将所有格子按照高度从小到大排序，依次**激活**它们，并且将其与周围**已经激活**的邻居**合并**。

当我们发现起点和终点被合并到同一个集合时，此刻的水位（即刚刚被激活的格子的高度）就是答案。

###核心思想和套路

####套路一： 二分查找 + BFS/DFS

这个思路相对来说属于最直观的思路。

别忘了使用二分查找搜索边界值的几个重要套路。

#####**定义二分查找的范围**: 

答案 `t` 的下界是 `grid[0][0]`（至少要能出发），上界是 `N*N - 1`（题目给定的高度范围）。

一个安全的范围是 `[0, N*N - 1]`。



**定义二分查找的条件函数 - check函数**

说白了，就是检查当前时间`t`是否能够完成从起点到终点的遍历。

这本质上是一个**图的连通性**问题。

我们可以把**所有高度 $\le{t}$的格子**看作图中的节点，如果两个这样的节点相邻，则它们之间有边。

`check(t)` 的实现非常简单：从 `(0,0)` 开始进行一次**广度优先搜索（BFS）或深度优先搜索（DFS）**，但只允许访问**高度 $\le{t}$**的格子。

如果在搜索过程中能够达到`(N-1,N-1)`，则返回`true`，否则返回`false`。



**二分查找的遍历和逻辑**

设查找范围为 `[low, high]`。

取中间值 `mid = low + (high - low) / 2`。

如果 `check(mid)` 为 `true`，说明 `mid` 这个时间是可行的，但可能**还有更小的时间也可以，所以我们尝试更小的范围**。

记录 `mid` 为一个潜在的答案，并令 `high = mid - 1`。

如果 `check(mid)` 为 `false`，说明 `mid` 这个时间太小了，必须提高水位，所以令 `low = mid + 1`。

循环结束时，记录下的最后一个可行答案就是最小值。

####套路二： Dijstra算法

#####**先复习Dijstra算法的核心思想**

- 定义从起点到每一个节点的距离`dist[]`， 初始值：

  - `dist[start] = 0`
  - `dist[other] = Integer.MAX_VALUE `

- 定义任意节点与起点的**当前距离**

  ```Java
  class Pair{
    int node;
    int distance;
  }
  ```

- 定义**最小堆**， 按照**当前距离**排序， 并且将起点加入最小堆：

  ```java
  PriorityQueue<Pair> minHeap = new PriorityQueue<>((a,b) - > a.distance - between.distance);
  minHeap.off(new Pair(start,0));
  ```

- 遍历和更新**最小堆**：

  ```java
  while(!minHeap.isEmpty()){
    Pair curr = minHeap.poll();
    //不再重新计算
    if(curr.distance > dist[curr.node]) continue;
    
    List<int[]> edges = graph.get(pair.node);
    for(int[] edge : edges){
     int neighbor = edge[0];
      int weight = edge[1];
      if(dist[neigbor] > dist[curr.node] +  weight){
        dist[neigbor] = dist[curr.node] +  weight;
        minHeap.off(new Pair(neighbor,dist[neighbor]));
      }
    }
  }
  ```

#####**Dijistra的修改和处理**

1. **重新定义“距离”**: 在这个问题中，“距离”或“成本”不是路径长度的和，而是到达某个点 `(r, c)` 的路径上所必须经过的**最大高度**。我们用 `dist[r][c]` 存储这个值。
2. **优先队列（Priority Queue）**: Dijkstra 算法的核心是优先队列。队列中存储的元素不再是 `(节点, 到起点的距离和)`，而是 `(行, 列, 到达该点的路径所需最小的最大高度)`，即 `(r, c, max_height)`。
3. **优先级**: 优先队列应该是一个**小顶堆**，按照 `max_height` 排序。我们总是优先处理那些“瓶颈”更低的路径。
4. **算法流程**:
   - 初始化一个 `dist` 数组，所有值设为无穷大，表示尚未找到路径。
   - 将起点 `(0, 0)` 加入优先队列，其状态为 `(0, 0, grid[0][0])`。同时 `dist[0][0] = grid[0][0]`。
   - 当队列不为空时，取出堆顶元素 `(r, c, height)`。这个 `height` 就是从 `(0,0)` 到 `(r,c)` 的一条最优路径的瓶颈值。
   - 如果 `(r, c)` 是终点，那么 `height` 就是全局的答案，直接返回。
   - 遍历 `(r, c)` 的四个邻居 `(nr, nc)`：
     - 计算从起点经由 `(r, c)` 到达 `(nr, nc)` 的新路径瓶颈：`new_height = max(height, grid[nr][nc])`。
     - 如果 `new_height` 小于之前记录的到达 `(nr, nc)` 的最小瓶颈 `dist[nr][nc]`，说明我们找到了一条更好的路径。
     - 更新 `dist[nr][nc] = new_height`，并将新状态 `(nr, nc, new_height)` 加入优先队列。

####基于并查集套路

#####**核心思想**: 模拟事件发生的过程。

水位从低到高上涨，可以看作是图中的节点（格子）按照其高度被逐一**激活**。

每激活一个节点，就尝试将它与周围已经激活的邻居**连通**。

我们要求的，正是起点和终点首次被连通时的那个**激活**时刻。

- 将问题中的所有基本单元（本题是 `N*N` 个格子）初始化为**并查集中的孤立集合**
- 确定事件发生的顺序。在本题中，事件是“格子被激活”，顺序**由格子的高度**决定。因此，需要将所有格子**按高度排序**。
- 按顺序处理事件。遍历排序后的格子，每处理一个，就执行 `union` 操作，将其与周围满足条件的邻居合并。
- 在每次 `union` 操作后，**检查关心的那两个节点（起点和终点）是否已经连通**（即 `find(start) == find(end)`）。
- 第一次满足连通条件时的事件触发值（本题是格子的高度），即为所求的答案。

###实现原理

####基于二分查找思路

**主函数 `swimInWater`**: 

- a.  获取矩阵维度 `N`。 

- b.  确定二分查找的范围，`low = grid[0][0]`, `high = N * N - 1`。`ans` 初始化为 `high`。 

- c.  进入 `while (low <= high)` 循环：

  -  i.  计算 `mid = low + (high - low) / 2`。

  -  ii. 调用 `canReach(mid, grid)` 辅助函数。

  -  iii. 如果返回 `true`，说明 `mid` 时间可行，**尝试更小的时间：**`ans = mid`，`high = mid - 1`。

  -  iv. 如果返回 `false`，说明 `mid` 时间太小，必须增加。`low = mid + 1`。 

- d.  循环结束后，`ans` 即为最小可行时间，返回 `ans`。

**辅助函数 `canReach(t, grid)`**: 

- a.  如果 `grid[0][0] > t`，起点都无法进入，直接返回 `false`。 

- b.  初始化一个 BFS 队列 `Queue<int[]>` 和一个 `boolean[N][N] visited` 数组。

- c.  将 `(0, 0)` 加入队列，并标记 `visited[0][0] = true`。 

- d.  进入 `while` 循环，当队列不为空时：

  -  i.  取出队首格子 `(r, c)`。

  -  ii. 如果 `(r, c)` 是终点 `(N-1, N-1)`，返回 `true`。

  -  iii. 遍历其四个方向的邻居 `(nr, nc)`。

  -  iv. 检查邻居是否满足条件：`在界内`、`未访问过`、`grid[nr][nc] <= t`。

  -  v.  如果满足，将邻居加入队列并标记为已访问。

- e.  如果队列为空后仍未到达终点，说明在时间 `t` 下无法连通，返回 `false`。

####基于Dijstra算法

1. 获取矩阵维度 `N`。处理 `N=1` 的边界情况。
2. 创建一个 `dist[N][N]` 数组，用于记录到达每个点的**最小瓶颈高度**，全部初始化为 `Integer.MAX_VALUE`。
3. 创建一个优先队列 `PriorityQueue<int[]>`，存储 `[row, col, height]`。**自定义比较器，使其按 `height` 升序排列**。
4. 将起点信息加入队列：`pq.offer(new int[]{0, 0, grid[0][0]})`。同时设置 `dist[0][0] = grid[0][0]`。
5. 定义方向数组 `dirs` 用于遍历四个邻居。
6. 进入主循环 `while (!pq.isEmpty())`： 
   - a.  `poll()` 出队头元素 `curr`。 
   - b.  从中解析出 `r, c, h`。 
   - c.  **剪枝**: 如果 `h > dist[r][c]`，**说明这是一个过时的、较差的路径信息**，直接 `continue`。
   - d.  **判断终点**: 如果 `r == N-1 && c == N-1`，则 `h` 就是最终答案，返回 `h`。
   - e.  遍历四个方向：
     -  i.   计算邻居坐标 `nr, nc`。
     -  ii.  检查坐标是否越界。
     -  iii. 计算到邻居的新瓶颈 `new_h = Math.max(h, grid[nr][nc])`。
     -  iv.  如果 `new_h < dist[nr][nc]`，说明找到了更优路径：
        - 更新 `dist[nr][nc] = new_h`。 
        - 将 `[nr, nc, new_h]` 加入优先队列。
7. 如果循环结束仍未返回，说明有错误（但在本题中不会发生）。

###### 基于并查集的实现

**并查集工具类 `UnionFind`**: 

- a.  成员变量：`int[] parent` 数组，`int count` (或 `sz` 数组用于按大小合并)。 
- b.  构造函数：初始化 `parent` 数组，使每个元素的父节点是它自己。
- c.  `find(i)` 方法：查找元素 `i` 的根节点，包含**路径压缩**优化。 
- d.  `union(i, j)` 方法：合并 `i` 和 `j` 所在的集合，可以包含**按秩/大小合并**的优化。
- e.  `isConnected(i, j)` 方法：通过 `find(i) == find(j)` 判断是否连通。



**主函数 `swimInWater`**: 

- a.  获取矩阵维度 `N`。 
- b.  创建一个 `List<int[]>`，存储所有格子的信息 `[height, row, col]`。
- c.  遍历 `grid`，将 `N*N` 个格子的信息填充到 List 中。 
- d.  对 List 根据 `height` 进行**升序排序**。 
- e.  实例化一个 `UnionFind` 对象，大小为 `N*N`。
- f.  遍历排序后的 List：
  -  i.  获取当前处理的格子 `(h, r, c)`。
  -  ii. 将其二维坐标转为一维索引 `idx = r * N + c`。
  -  iii. 遍历该格子的四个邻居 `(nr, nc)`。
  -  iv.  检查邻居 `(nr, nc)` 是否在界内。
  -  v.   **关键点**: 检查邻居的高度 `grid[nr][nc]` 是否也小于等于当前的高度 `h`。因为只有当邻居的高度也被“淹没”时，它们才能连通。 
  -  vi.  如果满足条件，就合并当前格子和邻居：`uf.union(idx, nr * N + nc)`。 
  -  vii. 每次合并后，检查起点和终点是否连通：`uf.isConnected(0, N*N - 1)`。
  -  viii. 如果连通，那么当前格子的高度 `h` 就是首次连通时的瓶颈高度，即为答案，直接返回 `h`。

##### 实现代码

###### 基于二分查找 + BFS

```Java
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        //表示最少要等grid[0][0]高度的时间
        int low = grid[0][0];
        //但是这里我不懂high为什么是n*n-1?
        //这是因为题目约束中的
        //0 <= grid[i][j] < n2
        int high = n*n - 1;
        int ans = high;
        while(low <= high){
            int mid = low + (high - low) / 2;
            //如果可以到达，表示找到了一个可能的答案，继续尝试更小的答案
            if(canReach(grid, mid)){
                ans = mid;
                high = mid -1 ;
            }else{
                low = mid + 1;
            }
        }

        return ans;

        
    }

    private boolean canReach(int[][] grid, int t){
        int n = grid.length;
        if(grid[0][0] > t){
            return false;
        }

        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};

        boolean[][] visited = new boolean[n][n];
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0,0});
        visited[0][0] = true;

        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            if(curr[0] == n-1 && curr[1] == n-1){
                return true;
            }
            for(int[] dir : dirs){
                int nr = curr[0] + dir[0];
                int nc = curr[1] + dir[1];
                if(nr < 0 || nr >= n || nc < 0 || nc >=n){
                    continue;
                }
                if(visited[nr][nc]){
                    continue;
                }
                if(grid[nr][nc] > t){
                    continue;
                }

                queue.offer(new int[]{nr,nc});
                visited[nr][nc] = true;
            }
        }

        return false;
    }
```



###### 基于Dijistra算法

```java
//给定一个nxn的grid,grid[i][j]表示点(i,j)的高度
//开始下雨了，在时间t的时候，降水量高度为t，这意味着所有高度小于等于t的cell都会被淹没或者到达
//你可以从一个格子中游泳到相邻的四个格子，如果你的起点和终点格子不高于t
//你游泳到达的时间可以忽略不计
//返回从(0,0)游泳到(n-1,n-1)所需要的最短时间
//你在某个格子的时候的水位以及周边四个格子和水位的差别，本质上就是高度差？
class Pair{
    int row;
    int col;
    int time;


    public Pair(int row, int col, int time){
        this.row = row;
        this.col = col;
        this.time = time;
    }
}

class Cell{
    int row;
    int col;
    int elevation;
    int rows;
    int cols;
    public Cell(int row, int col, int elevation,int rows, int cols){
        this.row = row;
        this.col = col;
        this.elevation = elevation;
        this.rows = rows;
        this.cols = cols;
    }

    @Override
    public boolean equals(Object o){
        if(!(o instanceof Cell)){
            return false;
        }
        Cell other = (Cell)o;
        return this.row == other.row && this.col == other.col;
    }

    @Override
    public int hashCode(){
        return this.row * cols + this.col;
    }
}
class Solution {
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        int[][] minTime = new int[n][n];
        for(int[] m : minTime){
            Arrays.fill(m, Integer.MAX_VALUE);
        }
        //一开始的等待时间是grid[0][0]
        minTime[0][0] = grid[0][0];

        Map<Cell, List<Cell>> graph = getGraph(grid);

        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a,b) -> a.time - b.time);
        minHeap.offer(new Pair(0,0,grid[0][0]));

        while(!minHeap.isEmpty()){
            Pair curr = minHeap.poll();
            if(curr.time > minTime[curr.row][curr.col]){
                continue;
            }
            if(curr.row == n-1 && curr.col == n-1){
                return curr.time;
            }

            List<Cell> nexts = graph.get(new Cell(curr.row, curr.col, grid[curr.row][curr.col], n, n));
            for(Cell next : nexts){
                int time = Math.max(curr.time, grid[next.row][next.col]);
                if(minTime[next.row][next.col] > time){
                    minTime[next.row][next.col] = time;
                    minHeap.offer(new Pair(next.row, next.col, time));
                }
            }
        }
        return -1;
       
    }

    private Map<Cell, List<Cell>> getGraph(int[][] grid){
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        Map<Cell, List<Cell>> graph = new HashMap<>();
        for(int row = 0; row < grid.length; row++){
            for(int col = 0; col < grid[0].length; col++){
                Cell cell = new Cell(row, col, grid[row][col], rows, cols);
                graph.putIfAbsent(cell, new ArrayList<>());
                for(int[] dir : dirs){
                    int nextRow = row + dir[0];
                    int nextCol = col + dir[1];
                    if(nextRow >= 0 && nextRow < rows && nextCol >= 0 && nextCol < cols){
                        Cell next = new Cell(nextRow, nextCol, grid[nextRow][nextCol], rows, cols);
                        graph.get(cell).add(next);
                    }
                }
            }
        }
        return graph;
    }
}
```

###### 基于并查集的解法

```java
    class UnionFind{
        int[] parent;
        int n;
        
        public UnionFind(int n){
            this.n = n;
            this.parent = new int[n];
            for(int i = 0; i < n; i++){
                parent[i] = i;
            }
        }

        public int find(int x){
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }
        public boolean merge(int x, int y){
            int rootX = find(x);
            int rootY = find(y);
            if(rootX == rootY){
                return false;
            }
            parent[rootX] = rootY;
            return true;
        }

        public boolean isConnected(int x, int y){
            return find(x) == find(y);
        }
    }

    class Cell{
        int row;
        int col;
        int height;
        public Cell(int row, int col, int height){
            this.row = row;
            this.col = col;
            this.height = height;
        }
    }
    public int swimInWater(int[][] grid) {
        if(grid.length == 1){
            return 0;
        }
        int n = grid.length;
        List<Cell> list = new ArrayList<>();
        for(int row = 0; row < n; row++){
            for(int col = 0; col < n; col++){
                list.add(new Cell(row, col, grid[row][col]));
            }
        }

        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};

        list.sort((a,b) -> a.height - b.height);

        UnionFind uf = new UnionFind(n*n);

        for(Cell curr : list){
            int idx = curr.row * n + curr.col;
            
            for(int[] dir : dirs){
                int nr = curr.row + dir[0];
                int nc = curr.col + dir[1];
                if (nr < 0 || nr >= n || nc < 0 || nc >= n){
                    continue;
                }
                if(grid[nr][nc] > curr.height){
                    continue;
                }

                int nextIdx = nr * n + nc;
                uf.merge(idx, nextIdx);
                if(uf.isConnected(0, n*n-1)){
                    return curr.height;
                }
            }
        }
        return -1;
    }
```

###注意事项

###### 基于二分查找的算法

- 二分范围的确定要准确。下界可以优化为 `max(grid[0][0], grid[n-1][n-1])`，但用 `0` 或 `grid[0][0]` 也足够安全。

- `check` 函数的逻辑必须正确且高效。对于本题，BFS/DFS 是检查连通性的标准方法。

- 二分循环的更新逻辑 (`low=mid+1` vs `high=mid-1`) 很容易写反，需要清晰地理解 `check` 函数结果的含义。

###### 基于Dijstra算法的方案

**Dijkstra 与 BFS 的区别**: 如果不使用优先队列，而是用普通队列，算法就退化成了 BFS。BFS 找到的是边数最少的路径，不符合本题要求。这里的优先队列确保了我们总是在当前所有可扩展的路径中，选择那条“瓶颈”最低的进行扩展。

**`visited` 数组的重要性**: 必须要有 `visited` 数组（或功能等价的 `dist` 数组剪枝）来防止重复访问和陷入死循环，这对于保证算法效率至关重要。一个格子一旦被标记为 `visited`，意味着我们已经找到了到达它的最优（瓶颈最小）路径，无需再次处理。

**坐标与索引转换**: 如果使用并查集，需要将二维坐标 `(r, c)` 映射到一维索引，通常使用 `index = r * N + c`

###### 基于并查集的算法

- 核心在于**排序**。必须将所有节点（或边，取决于问题）按其“激活成本”排序，以模拟事件的发生。

- 在 `union` 时，需要想清楚 `union` 的条件。本题中，是与**已经激活**（即高度也小于等于当前水位）的邻居进行合并。

- 二维到一维的坐标映射要准确无误。

##### 经验总结

###### 基于二分查找的算法

**适用场景**: 任何具有单调性的“求最小/最大的可行解”问题。这是一个万金油式的强大技巧。

**思维模式**: "化繁为简" 或 "猜答案"。将复杂的优化问题降维成简单的、可重复的判定问题。

**复杂度**: $O(N^2logK)$。当值域 K 非常大时，logK 可能会比 Dijkstra 的 logN 大，但通常两者性能相近。此方法代码结构清晰，分为“主循环”和“检查工具”，易于理解和调试。

###### 基于Dijstra算法的方案

**识别问题模型**: 能否将问题抽象成熟悉的图论模型是解题的第一步。本题的“最小化路径最大值”是一个非常经典的模型。

**掌握核心套路**:

- 对于具有**单调性**的“求最小/最大可行解”问题，**二分答案**是一个普适且强大的工具。它能将一个优化问题转化为若干个判定问题。
- 对于在图上求非标准“最短路”（如最小化路径最大值、最大化路径最小值等），**改造 Dijkstra** 是一个非常有效的思路。关键在于正确定义优先队列中元素的**状态**和**比较逻辑**。

**选择合适的算法**: 虽然本题有多种解法，但在面试或竞赛中，能快速识别并实现其中一种高效解法即可。Dijkstra 的变种思路直接、优雅，代码也相对紧凑，是解决此类问题的首选之一。

**举一反三**: 这个问题的思想可以应用到很多其他问题中，例如 LeetCode 1631 "Path With Minimum Effort"（最小体力消耗路径），其本质和本题几乎完全一样，只是瓶颈的定义从“最大高度”变成了“相邻格子间的最大高度差”。掌握了本题的解法，那道题也能迎刃而解。

###### 基于并查集的解决方法

连通”时，并查集是首选。它在处理这类问题时效率极高。

**思维模式**: "模拟和构造"。它模拟了问题发生的物理过程，通过一步步构建连通分量来得到答案。

**复杂度**: 排序的复杂度是 $O(N^2log(N^2))=O(N^2logN)$，并查集操作的复杂度接近 $O(N^2alpha(N^2))$，其中 alpha 是反阿克曼函数，增长极其缓慢，可视为常数。所以总复杂度由排序决定，为 $O(N^2logN)$。虽然与Dijkstra同级，但其思想是独特的。

##Leetcode 815 : 最少换乘的公交车数量

你将获得一个公交线路列表 `routes`，其中 `routes[i]` 代表第 `i` 辆公交车会无限循环行驶的公交站序列。

给定一个起始公交站 `source` 和一个目标公交站 `target`，你的任务是计算从 `source` 到 `target` 所需乘坐的最少公交车数量。如果无法到达，则返回 -1。

###**关键约束和条件：**

- 你最初不在任何公交车上。
- 只能通过乘坐公交车在不同站点之间移动。
- `source` 和 `target` 是公交站编号。
- `routes` 的长度在 1 到 500 之间。
- 每条线路的站点数在 1 到 10^5 之间。
- 所有线路的总站点数不超过 10^5。
- 站点编号、`source` 和 `target` 都在 0 到 10^6 之间。

###问题本质和分析 - BFS

这个问题的核心是**求解最小换乘次数**。

题目要求的是**最少的公交车数量**，而不是~~经过的最少站点数~~。

这暗示着，**只要在同一辆公交车上，无论经过多少站，成本都计为 1**（即乘坐了这一辆车）。

只有当从一个站下车，换乘另一辆公交车时，成本才会增加。

这种“最小步数”、“最少次数”的问题是典型的**广度优先搜索 (BFS)** 的应用场景。

BFS 能够保证在无权图中找到从起点到终点的最短路径。

####图中的节点应该是什么？

我们可以将整个交通网络抽象成一个图。但是，图的节点应该是什么？

#####**如果以“公交站”为节点**：

公交站之间的边该如何定义？如果两个站之间有任何一辆公交车通过，就连接它们吗？

这样做的问题是，我们无法区分**站内换乘**和**沿线经过**。

例如，从站 A 到 B，再到 C，如果 A、B、C 都在同一条线路上，我们只想计算一次乘车。

但如果 B 是一个换乘站，我们可能需要下车换乘，这会计为两次乘车。

简单地连接站点无法体现**换乘**这一核心成本。

#####**如果以“公交线路”为节点**：

这个思路更有前景。

如果两条公交线路有共同的站点，我们就可以认为这两条线路是**相连**的，可以在它们之间进行换乘。

这样，问题就转化为：从包含 `source` 站点的任意一条线路开始，最少需要经过几条“相连”的线路，才能到达一条包含 `target` 站点的线路。

起点： 包含`source`站点的线路

终点：包含`target`站点的线路

这完美地契合了 BFS 的模型，其中图的“层”或“深度”就对应了乘坐的公交车数量。

因此，问题的本质可以抽象为：**在一个以公交线路为节点的图中，寻找从任何包含 `source` 的线路到任何包含 `target` 的线路的最短路径长度。**

###模式匹配

当你看到以下关键词时，应能迅速联想到此题的模式：

- **最少/最短**：提示寻找最短路径。
- **次数/步骤/层级**：暗示图的遍历，且每一步的权重相同。
- **无权图**：每次换乘计为1，没有其他权重，符合无权图的定义。
- **网络/连接/换乘**：暗示了图结构中的节点和边的关系。

这些线索强烈指向 **广度优先搜索 (BFS)**。

BFS 是解决无权图最短路径问题的标准算法。

此题可以看作是 BFS 在一个需要我们自己从输入数据中**隐式构建图**的场景下的应用。

###核心思想和套路

####图的构建

我们需要一种高效的方式来查找一个站点有哪些公交线路经过。

一个绝佳的数据结构是 `HashMap<Integer, List<Integer>>`，其中：

-  `key` 是**公交站编号**；
-  `value` 是经过该站点的所有**公交线路的索引**（或编号）。

这个 `HashMap` 就是我们隐式图的邻接表。

####BFS初始化

- 创建一个队列 `Queue` 用于 BFS，存储待访问的**公交线路索引**。

- 创建一个 `visited` 集合（或布尔数组）来记录哪些**公交线路**已经被访问过，防止重复搜索和死循环。

- 将 `source` 站点的所有初始公交线路加入队列，并将它们标记为已访问。

- 初始化公交车数量（或 BFS 的层数）为 1。

####BFS遍历

- 进行逐层遍历。在每一层，处理当前队列中的所有线路。
- 对于队列中弹出的每一条线路 `bus`：
  - 遍历该线路上的所有站点 `stop`。
  - 检查 `stop` 是否是 `target`。如果是，说明我们已经乘坐当前这辆车到达了终点，直接返回当前的公交车数量。
  - 如果不是 `target`，则利用第一步构建的 `HashMap` 找到所有经过 `stop` 站点的**其他**公交线路 `nextBus`。
  - 对于每一个 `nextBus`，如果它没有被访问过，就将其加入队列，并标记为已访问。
- 当处理完一层的所有线路后，将公交车数量加 1，然后继续下一层的 BFS。

####特殊边界情况 

**处理特殊情况和边界**：

- 如果 `source` 和 `target` 相同，无需乘车，直接返回 0。
- 如果 BFS 结束后队列为空，仍未找到 `target`，说明 `source` 和 `target` 之间不连通，返回 -1。

###实现原理和步骤

####特殊情况处理

检查 `source` 是否等于 `target`。如果是，直接返回 0。

####构建站点到公交线路的映射

创建一个 `Map<Integer, List<Integer>> stopToRoutes`。

遍历输入 `routes` 数组，对于每一条线路 `i` 和该线路上的每一个站点 `stop`，将线路索引 `i` 添加到 `stopToRoutes.get(stop)` 的列表中。

```java
    Map<Integer, List<Integer>> stopToRoutes = new HashMap<>();
        for(int i = 0; i < routes.length;i++){
            for(int stop : routes[i] ){
                stopToRoutes.computeIfAbsent(stop, x -> new ArrayList<>()).add(i);
            }
        }
```

####初始化BFS

- 创建一个队列 `queue`，用于存放待处理的**站点**。

- 创建一个 `HashSet<Integer> visitedRoutes`，用于记录已经乘坐过的**公交线路索引**。

- 将 `source` 站点加入队列。

- 初始化 `busCount`（乘坐的公交车数量）为 0。

####步骤 4：执行分层 BFS

进入 `while` 循环，只要队列不为空就继续。

- 在每一轮循环开始时，将 `busCount` 加 1，代表换乘到新的一批公交车。
- 获取当前队列的大小 `size`，这代表了当前层（即乘坐 `busCount - 1` 辆车可以到达的）所有站点。
- 循环 `size` 次，处理当前层的所有站点。

####**步骤 5：处理每一层的节点**

- 从队列中弹出一个站点 `currentStop`。
- 通过 `stopToRoutes` 映射，**获取所有经过 `currentStop` 的公交线路 `routesPassingCurrentStop`**。
- 遍历这些线路：
  - 如果某条线路 `routeIndex` 已经被访问过 (`visitedRoutes.contains(routeIndex)`)，则跳过。
  - 否则，将该线路标记为已访问：`visitedRoutes.add(routeIndex)`。
  - 现在，我们“乘坐”上了这条新线路。**遍历这条线路上的所有站点 `nextStop`**。
    - 检查 `nextStop` 是否为 `target`。如果是，我们成功到达，返回当前的 `busCount`。
    - 如果不是，将 `nextStop` 加入队列，作为下一层 BFS 的起点。

```java
        while(!queue.isEmpty()){
            busCount++;
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int currStop = queue.poll();
                List<Integer> nextRoutes = stopToRoutes.get(currStop);
                for(int nextRoute : nextRoutes){
                    if(visitedRoutes.contains(nextRoute)){
                        continue;
                    }
                    
                    visitedRoutes.add(nextRoute);
                    for(int nextStop : routes[nextRoute]){
                        if (nextStop == target) {
                            return busCount;
                        }
                        queue.add(nextStop);
                    }
                }
            }
        }

        return -1;
```

##### 实现代码

```java
class Solution {
    //最少换乘的公交车数量
    
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target){
            return 0;
        }

       
        Map<Integer, List<Integer>> stopToRoutes = new HashMap<>();
        for(int i = 0; i < routes.length;i++){
            for(int stop : routes[i] ){
                stopToRoutes.computeIfAbsent(stop, x -> new ArrayList<>()).add(i);
            }
        }

        if(!stopToRoutes.containsKey(source)){
            return -1;
        }

        int busCount = 0;
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visitedRoutes = new HashSet<>();
        queue.offer(source);


        while(!queue.isEmpty()){
            busCount++;
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int currStop = queue.poll();
                List<Integer> nextRoutes = stopToRoutes.get(currStop);
                for(int nextRoute : nextRoutes){
                    if(visitedRoutes.contains(nextRoute)){
                        continue;
                    }
                    
                    visitedRoutes.add(nextRoute);
                    for(int nextStop : routes[nextRoute]){
                        if (nextStop == target) {
                            return busCount;
                        }
                        queue.add(nextStop);
                    }
                }
            }
        }

        return -1;
    }
}
```

###注意事项

####**BFS 状态定义**：

明确 BFS 队列中存储的是什么，`visited` 集合记录的又是什么。

在此解法中，**队列存的是“站点”，而 `visited` 记录的是“公交线路”**。

这是因为我们的成本是基于线路的，避免重复访问同一线路至关重要。

####**分层 BFS**：

使用 `levelSize` 来进行分层遍历是 BFS 计算最短路径长度的标准技巧。

它确保了我们在增加 `busCount` 之前，处理完所有乘坐相同数量公交车可达的站点。

####**建图的效率**：

使用 `HashMap` 进行预处理是关键。如果每次需要找换乘线路时都去遍历整个 `routes` 数组，会导致严重超时。`stopToRoutes.computeIfAbsent()` 是一个简洁高效的写法。

####**起始点和终点**：

不要忘记处理 `source == target` 的情况。

同时，也要考虑 `source` 或 `target` 可能不存在于任何线路中的情况（虽然本题约束下 `source` 和 `target` 都是有效站点，但 `source` 可能无车可乘）。

####**内存使用**：

由于站点编号可以很大（`10^6`），但站点总数有限，使用 `HashMap` 比使用巨大数组来做映射要高效得多。

###经验总结

#### 本质上还是以站点为节点

但是需要同时记录哪些路线已经乘坐过了，主要的目的是提升效率，避免重复计算和收集。

#### 其他总结

- **抽象问题是关键**：LeetCode 的中高难度题目，特别是图论题，往往不会直接给你一个图。你需要从问题描述中识别出节点、边和权重，自己构建出图模型。本题中，将“换乘”作为核心，把“线路”作为节点，是解题的突破口。
- **选择正确的数据结构**：对于稀疏图（节点很多，但边相对较少）或节点编号范围很大的情况，邻接表（通常用 `HashMap` 实现）是比邻接矩阵更优的选择。
- **熟练掌握 BFS 模板**：BFS 是算法面试中的高频考点。熟记其标准模板，包括队列、`visited` 集合、分层遍历等，可以帮助你快速解决一系列相关问题，如迷宫最短路径、二叉树层序遍历、拓扑排序等。
- **从成本单位反推图模型**：当题目要求“最小XX”时，思考这个“XX”是什么。在本题中，成本单位是“公交车数量”，这启发我们将“公交线路”作为图的核心元素，而不是“站点”。这个思考过程可以推广到其他问题。

