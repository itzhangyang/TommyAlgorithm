#二分图判定/合法分组

##场景描述

- 将人员分为两组，避免敌对关系一组
- 判断图中是否可以双色染色

##核心算法思想：相邻节点不能同色

###通用应对策略：BFS/DFS染色，判断邻居是否冲突

###BFS染色套路实现原理

####定义一个存储节点染色状态数组

- `-1` 未染色
- `0` 颜色为0
- `1` 颜色为1

初始状态均为**未染色**

```java
int[] color = new int[n];
Arrays.fill(color,-1);
```

####以每个节点作为开始，对图做n次BFS遍历

因为需要防止图并非是**连通图**的情况：本质上这个循环是每一次循环中对一个**连通块**进行染色

```java
for (int i=0; i < n; i++){
  //防止相同的连通块被重复染色
  //这种情况下i可能属于另外一个连通块，那个连通块已经被染色过了
  if(color[i] != -1) continue;
  Queue<Integer> queue = new LinkedList<>();
  queue.offer(i);
  color[i] = 0;
  
  while(!queue.isEmpty()){
    int u = queue.poll();
  }
  
  for(int v : graph.get(u)){
    //如果v没有染色，则染色为和u不同的颜色
    if (color[v]==-1){
      color[v] = 1- color[u];
      queue.offer(v);
    //如果v已经染色，并且和u的染色一样，则说明不可行，返回false;
    }else if (color[u] == color[v]){
      return false;
    }
  }
}

return true;
```

##Leetcode 785: 二分图判定

### 问题要点

存在一个 **无向图** ，图中有 `n` 个节点。

其中每个节点都有一个介于 `0` 到 `n - 1` 之间的唯一编号。

给你一个二维数组 `graph` ，其中 `graph[u]` 是一个节点数组，由节点 `u` 的邻接节点组成。

形式上，对于 `graph[u]` 中的每个 `v` ，都存在一条位于节点 `u` 和节点 `v` 之间的**无向边**。

该无向图同时具有以下属性：

- 不存在自环（`graph[u]` 不包含 `u`）。
- 不存在平行边（`graph[u]` 不包含重复值）。
- 如果 `v` 在 `graph[u]` 内，那么 `u` 也应该在 `graph[v]` 内（该图是无向图）
- 这个图可能不是连通图，也就是说两个节点 `u` 和 `v` 之间可能不存在一条连通彼此的路径。

####**二分图** 定义：

如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B` ，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 **二分图** 。

如果图是二分图，返回 `true` ；否则，返回 `false` 。

###实现代码

```java
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        int[] color = new int[n];
        Arrays.fill(color, -1);

        for (int i=0; i < n; i++){
            if (color[i] != -1) continue;
            
            color[i] = 0;
            Queue<Integer> queue = new LinkedList<>();
            queue.offer(i);
            while (!queue.isEmpty()) {
                int current = queue.poll();
                int[] neighbors = graph[current];
                for (int neighbor : neighbors){
                    if (color[neighbor] == -1){
                        color[neighbor] = 1 - color[current];
                        queue.offer(neighbor);
                    }else if (color[current] == color[neighbor]){
                        return false;
                    }
                }
            }
        }

        return true;
        
    }
```

##Leetcode 886: Possible Bipartition

给定一组 `n` 人（编号为 `1, 2, ..., n`）， 我们想把每个人分进**任意**大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。

给定整数 `n` 和数组 `dislikes` ，其中 `dislikes[i] = [ai, bi]` ，表示不允许将编号为 `ai` 和 `bi`的人归入同一组。当可以用这种方法将所有人分进两组时，返回 `true`；否则返回 `false`。

##### 实现代码

```java
    public boolean possibleBipartition(int n, int[][] dislikes) {
        int[] color = new int[n+1];
        Arrays.fill(color, -1);

        Map<Integer,List<Integer>> graph = getGraph(n, dislikes);

        for (int i = 1; i <= n ; i++){
            if (color[i] != -1) continue;

            color[i]=0;

            Queue<Integer> queue = new LinkedList<>();
            queue.offer(i);

            while (!queue.isEmpty()) {
                int current = queue.poll();
                List<Integer> neigbors = graph.get(current);
                for (int neighbor : neigbors){
                    if (color[neighbor] == -1){
                        color[neighbor] = 1 - color[current];
                        queue.offer(neighbor);
                    }else if (color[neighbor] == color[current]){
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private Map<Integer,List<Integer>> getGraph(int n, int[][] dislikes){
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int[] dislike : dislikes){
            map.computeIfAbsent(dislike[0], x->new ArrayList<>()).add(dislike[1]);
            map.computeIfAbsent(dislike[1], x->new ArrayList<>()).add(dislike[0]);
        }
        for (int i=1;i<=n;i++){
            map.putIfAbsent(i, new ArrayList<>());
        }

        return map;
    }
```

