# 汉密尔顿路径： 访问所有的节点

如果不卖关子，直接说结论：

- **欧拉路径**（经过每条**边**一次）：是**简单的**（P问题），有巧妙的“一笔画”算法（Hierholzer），时间复杂度 $O(E)$。
- **哈密顿路径**（经过每个**点**一次）：是**极难的**（NP-Complete问题），**没有**像欧拉路径那样巧妙的通用公式或线性算法。

## 核心思想： 回溯

哈密顿路径的本质是：**我们在走迷宫，但要求每个房间（节点）只能进一次，且必须走完所有房间。**

因为没有数学定理告诉我们要走哪条路，我们唯一的策略就是：

1. 站在当前节点，看着周围没去过的邻居。
2. **猜**一个邻居走过去。
3. 如果走到最后发现走不通了（没走完所有点且无路可走），说明**刚才猜错了**。
4. **撤销**刚才的那一步（回溯），回到上一个路口，换一条路走。

这与欧拉路径形成了最鲜明的对比：

- **欧拉 (Hierholzer)**：**不后悔**。走错了没事，反正那也是路的一部分，回头把它拼进去就行。
- **哈密顿 (Backtracking)**：**必须后悔**。走错了就是死路，必须退回来，把状态恢复原状，重新选。

## 套路一： 经典回溯

这是最通用的解法，适用于 $N$（节点数）较小的情况（通常 $N < 20$）。

#### 逻辑步骤

1. **状态记录**：需要一个 `visited[]` 数组，记录当前路径已经访问了哪些点。
2. **递归函数 `dfs(curr, count)`**：
   - `curr`：当前所在的节点。
   - `count`：已经访问了多少个节点。
3. **终止条件**：如果 `count == N`（总节点数），说明找到了一条哈密顿路径，返回 `True`。
4. **试错循环**：
   - 遍历 `curr` 的所有邻居 `next`。 
   - **剪枝**：如果 `next` 已经被访问过 (`visited[next] == true`)，跳过。
   - **做选择 (Mark)**：`visited[next] = true`。
   - **递归**：调用 `dfs(next, count + 1)`。
   - **判断**：如果递归返回 `True`，说明找到了，直接向上层返回 `True`。
   - **撤销选择 (Unmark/Backtrack)**：**这是最关键的一步！** `visited[next] = false`。
     - *为什么？* 因为刚才那条路虽然现在走不通，但在尝试其他路径组合时，这个 `next` 节点以后还得用。

```Java
class HamiltonianPath {
    boolean[] visited;
    int N; // 节点总数
    // graph用邻接表表示

    public boolean solve(int startNode) {
        visited[startNode] = true;
        return dfs(startNode, 1); // 从1个点开始计数
    }

    private boolean dfs(int curr, int count) {
        // 1. 成功条件：所有点都访问完了
        if (count == N) {
            return true;
        }

        // 2. 遍历邻居
        for (int next : graph.get(curr)) {
            if (!visited[next]) {
                // A. 做选择（标记）
                visited[next] = true;

                // B. 递归进入下一层
                if (dfs(next, count + 1)) {
                    return true; // 找到了就直接返回，不需要继续试了
                }

                // C. 撤销选择（回溯）- 恢复现场
                // 这与欧拉路径完全不同，欧拉路径是真删边，这里是假标记
                visited[next] = false;
            }
        }
        
        return false; // 当前节点的所有路都试过了，都不行
    }
}
```

## 套路二： 压缩状态DP

当节点数 $N$ 稍微大一点（比如 $N \le 20$），单纯的回溯可能会超时（复杂度 $O(N!)$）。这时候通常使用 **状态压缩动态规划**。

这是一个非常高频的**高级**面试套路（如 TSP 旅行商问题）。

#### 核心逻辑

- **痛点**：回溯法会重复计算很多相同的状态。比如“访问了 {A, B, C} 最后停在 C”和“访问了 {B, A, C} 最后停在 C”，对于接下来的路程来说，局面是一样的。
- **压缩**：既然 $N$ 很小，我们可以用一个整数的**二进制位**来表示集合。
  - 例如：`10110` (二进制) 表示第 1, 2, 4 号节点已被访问。
- **DP 定义**：
  - `dp[mask][i]`：布尔值（或最小代价）。
  - 含义：当前访问过的节点集合为 `mask`（二进制表示），且**最后停留在节点 `i`**，是否可行？

#### 转移方程

`dp[mask | (1 << next)][next] = True`

如果：

1. `dp[mask][curr]` 是 True（之前能走到 `curr`）。
2. `curr` 和 `next` 之间有边。
3. `next` 还没在 `mask` 里。

#### 复杂度

- 时间复杂度：$O(2^N \cdot N^2)$。虽然还是指数级，但比 $N!$ 快得多。

## 欧拉 vs 哈密顿：终极对比

| **特性**       | **欧拉路径 (Euler)**                       | **哈密顿路径 (Hamilton)**                                 |
| -------------- | ------------------------------------------ | --------------------------------------------------------- |
| **关注点**     | **边 (Edge)**                              | **点 (Vertex/Node)**                                      |
| **核心限制**   | 边只能走一次，点可以重复走                 | 点只能走一次（边自然也只能走一次）                        |
| **复杂度**     | **P问题 (简单)** $O(E)$ 线性时间           | **NP-Complete (极难)** $O(N!)$ 或 $O(2^N \cdot N^2)$      |
| **算法核心**   | **DFS 后序遍历 (Hierholzer)**              | **回溯 (Backtracking) / 状态压缩 DP**                     |
| **回溯逻辑**   | **不撤销**：走过的边永久删除，不需要恢复。 | **必须撤销**：`visited=false`，恢复现场以便尝试别的路径。 |
| **判断存在性** | **看度数**：数一下奇数度节点的个数即可。   | **无公式**：必须跑一遍算法试出来。                        |

