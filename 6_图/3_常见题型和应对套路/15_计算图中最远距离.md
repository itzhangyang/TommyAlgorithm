# Leetcode 1162:As Far from Land as Possible (离陆地最远的海水)

## 问题要点

**输入**: 一个 `N x N` 的二维网格 `grid`，其中 `1` 代表陆地，`0` 代表海水。

**目标**: 找到一个海水单元格，使得它到**最近**的陆地单元格的距离最远。

**距离定义**: 使用**曼哈顿距离** (Manhattan Distance)，即 `distance(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`。在网格中，这等价于从一个格子到另一个格子只允许上下左右移动所需的最少步数。

**输出**: 返回这个最大的距离。

**特殊情况**: 如果网格中没有陆地或没有海水，返回 `-1`。

## 问题的本质和分析

### 直观解法 - 遍历所有海水到陆地的距离

#### 思路 - 计算每一个海水cell到陆地cell的最近距离

初看题目，可能会陷入一个误区：遍历每一个海水单元格 `0`，然后对每一个海水单元格执行一次搜索（比如 BFS），找到离它最近的陆地 `1`，记录下这个距离。

最后在所有这些距离中取一个最大值。

#### 问题 - 时间复杂度太高

这种思路的时间复杂度是多少？ 

假设网格大小是 $N\times N$。最坏情况下，我们有 $O(N^2)$ 个海水单元格。

对于每一个海水单元格，我们都需要启动一次 BFS 来查找最近的陆地，每次 BFS 的时间复杂度是 $O(N^2)$。

所以总的时间复杂度将是 $O(N^4)$，这对于 LeetCode 通常 N=100 左右的限制来说，是无法接受的。

### 问题的本质是什么 - 点和一个点集之间的最小距离最大

**问题的本质**其实是寻找一个点，使其与一个**点集**（所有陆地单元格）的最小距离最大化。

#### 逆向思维 - 从陆地向海水蔓延

这种“多对一”或“多对多”的最短路问题，有一个非常巧妙的解法：**逆向思维**。

我们不是从“海水”找“陆地”，而是反过来，从所有“陆地”同时开始，向“海水”扩散。

可以想象成所有陆地单元格同时开始“涨潮”，潮水每秒向外蔓延一格。

那么，最后被潮水淹没的那个海水单元格，就是离所有陆地最远的单元格。

这个过程，就是**多源广度优先搜索 (Multi-source BFS)**。

## 背景知识

###**图论 (Graph Theory)**: 

网格问题可以很自然地抽象成一个图。每个单元格 `(i, j)` 是一个节点 (Node)，如果两个单元格相邻（上下左右），则它们之间有一条边 (Edge)。由于从 A 到 B 的成本和从 B 到 A 一样（都是 1 步），所以这是一个无向图。

###**广度优先搜索 (BFS, Breadth-First Search)**:

- 一种图的遍历算法，从一个起始节点开始，逐层地向外探索。
- 它使用一个**队列 (Queue)** 来实现。
- BFS 的一个核心特性是，在**无权图**（所有边的权重都为1）中，它能够找到从起点到所有其他节点的最短路径。在我们的问题中，每次移动一格的代价是 1，所以这是一个典型的无权图。

###**多源 BFS (Multi-source BFS)**:

- 这是标准 BFS 的一个变种。标准 BFS 只有一个源点（起始点），而多源 BFS 有多个源点。
- 实现上非常简单：在 BFS 开始之前，将**所有**的源点（在这里是所有陆地单元格 `1`）全部放入队列中。
- 之后的过程和标准 BFS 完全一样。这样，整个搜索过程就像是从所有源点同时开始，一层一层地向外扩散。

###**曼哈顿距离 (Manhattan Distance)**:

- 公式为 $d=∣x_1−x_2∣+∣y_1−y_2∣$。
- 在网格的 BFS 中，我们不需要显式地计算这个公式。因为 BFS 的**层数**天然地就代表了从源点出发的曼哈顿距离。第一层被访问到的节点距离为 1，第二层为 2，以此类推。

## 模式匹配

当你遇到以下特征的问题时，应首先考虑**多源 BFS**：

- **网格/矩阵背景**。
- 求解**最短路径**或**最小时间**。
- 存在**多个起始点**（或可以被视为多个起始点）。
- 要求找到某个点到**最近**的某个类型起始点的距离。
- 例如：
  - **LeetCode 994. Rotting Oranges (腐烂的橘子)**: 从所有腐烂的橘子（源点）开始，看需要多久才能感染所有新鲜橘子。
  - **LeetCode 542. 01 Matrix (01 矩阵)**: 找出每个元素到最近的 `0` 的距离。这可以看作是从所有 `0`（源点）开始的多源 BFS。
  - **LeetCode 286. Walls and Gates (墙与门)**: 从所有门（源点）开始，填充每个空房间到最近门的距离。

这些问题和本题的核心思想和解法套路几乎完全一样。

## 核心思想和套路

**逆向思考**: 将“求每个水域到最近陆地的最大距离” 转化为 “从所有陆地同时出发，到达最远水域的距离”。

**多源BFS**:

- **初始化**: 找到所有的陆地单元格 `1`，将它们的坐标 `(r, c)` 全部加入到队列中。这些是第 0 层的节点。
- **分层遍历**: 使用一个循环来控制 BFS 的层级。在每一层的开始，记录下当前队列的大小 `size`。然后，只处理这 `size` 个节点。这确保了我们一层一层地向外扩散。
- **距离计算**: 每处理完一层，就意味着距离增加 1。我们可以用一个 `distance` 变量来记录。
- **状态标记**: 为了防止重复访问，需要一个机制来标记已经访问过的单元格。可以直接修改原 `grid`（比如将访问过的海水 `0` 改为 `1` 或其他非 `0` 值），或者使用一个额外的 `visited` 数组。

##  实现代码

```Java
class Cell{
    int row;
    int col;
    public Cell(int row, int col){
        this.row = row;
        this.col = col;
    }
}
class Solution {
    public int maxDistance(int[][] grid) {
        int n = grid.length;
        Queue<Cell> queue = new LinkedList<>();
        int steps = -1;
        for(int row = 0; row < n; row++ ){
            for(int col = 0; col < n; col++){
                if(grid[row][col] == 1){
                    queue.offer(new Cell(row,col));
                }
            }
        }

        if(queue.isEmpty() || queue.size() == n *n){
            return -1;
        }
        
        int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Cell curr = queue.poll();
                for(int[] dir: dirs){
                    int nextRow = curr.row + dir[0];
                    int nextCol = curr.col + dir[1];

                    if(nextRow < 0 || nextRow >= n){
                        continue;
                    }
                    if(nextCol < 0 || nextCol >= n){
                        continue;
                    }

                    if(grid[nextRow][nextCol] == 1){
                        continue;
                    }

                    grid[nextRow][nextCol] = 1;
                    queue.offer(new Cell(nextRow, nextCol));
                }

            }
            steps++;
        }

        return steps;
    }
}
```

