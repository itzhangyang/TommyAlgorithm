# 连通性问题-统计连通块或者操作使其连通

##场景描述

- 判断图中有多少独立子图，或者社交网络中有多少社交孤岛
- 要连通整个网络需要至少添加多少条边

这里的“生成连通分量”，我们理解为对它们**进行识别、计数，并能够处理分量内的所有元素**（比如计算面积、染色等）。

##通用应对策略

###生成邻接图 - 无向图

```java
private Map<Integer,List<Integer>> getGraph(int n, int[][] edges){
  Map<Integer,List<Integer>> graph = new HashMap<>();
  for(int i = 0; i < n; i++){
    graph.putIfAbsent(i, new ArrayList<>());
  }
  
  for(int[] edge : edges){
    int node1 = edge[0];
    int node2 = edge[1];
    
    graph.get(node1).add(node2);
    graph.get(node2).add(node1);
  }
  return graph;
}
```

##使用DFS生成连通分量

####实现原理和步骤

DFS 的“一条路走到黑”策略在通用图上同样适用。它会沿着一个邻居节点不断深入，直到没有未访问过的邻居，然后才回溯。

1. **构建邻接表**: 从输入的 `n` 和 `edges` 构建图的邻接表表示。
2. **初始化**: 创建一个 `visited` 数组或集合，用于记录哪些顶点已被访问。
3. **主循环**: 遍历所有顶点，从 `i = 0` 到 `n-1`。
4. **发现新分量**: 如果顶点 `i` **未被访问**，说明我们找到了一个新的连通分量的起点。此时，将连通分量计数器加一。
5. **启动DFS**: 从顶点 `i` 开始，调用 `dfs` 函数。
6. **DFS函数内部**: 
   1. a. **标记访问**: 将当前顶点 `u` 标记为“已访问”。 
   2. b. **处理当前节点**: 对顶点 `u` 执行所需操作。
   3. c. **递归探索**: 查看邻接表中 `u` 的所有邻居 `v`。
   4. 如果邻居 `v` 未被访问，就对 `v` 递归调用 `dfs` 函数。
7. **完成一个分量**: 当从 `i` 开始的 `dfs` 调用完全返回后，该分量内的所有顶点都已被访问。
8. **继续主循环**: 主循环会跳过所有已访问过的顶点，继续寻找下一个新分量的起点。

####代码套路 - 计算连通分量的数量

也可以用来计算连通分量的具体内容

```java
public int countComponenets(int n , int[][] edges){
  Map<Integer,List<Integer>> graph = getGraph(n, edges);
	boolean[] visisted = new boolean[n];
  
  int count = 0;
  for (int i = 0; i < n; i++){
    if(!visited[i]){
      count++;
      dfs(graph,i,visited);
    }
  }
  
}

private void dfs(Map<Integer,List<Integer>> graph, int cur, boolean[] visisted){
  visisted[cur] = true;
  //处理节点
  
  //递归处理邻接节点
  for(int next : graph.get(cur)){
    if(!visited[next]){
      dfs(graph,next,visited);
    }
  }
}

```

##### 使用BFS生成连通分量

BFS 的“层层推进”策略在图上表现为从起点开始，访问完所有距离为1的邻居，再访问所有距离为2的邻居，以此类推。

1. **构建邻接表**: 同 DFS。
2. **初始化**: 创建 `visited` 数组或集合。
3. **主循环**: 同 DFS，遍历所有顶点 `i` 从 `0` 到 `n-1`。
4. **发现新分量**: 如果顶点 `i` 未被访问，则发现新分量，计数器加一。
5. **启动BFS**: a. 创建一个 **队列 (Queue)** 并将起点 `i` 入队。 b. 将起点 `i` 标记为“已访问”。
6. **BFS循环**: 当队列不为空时，持续循环： a. **出队**: 从队列头部取出一个顶点 `u`。 b. **处理当前节点**: 对 `u` 执行所需操作。 c. **探索邻居**: 查看邻接表中 `u` 的所有邻居 `v`。如果邻居 `v` 未被访问： i. 将 `v` 标记为“已访问”。 ii. 将 `v` **加入队列**。
7. **完成一个分量**: 队列变空时，表示该分量的所有顶点均已访问。
8. **继续主循环**: 继续寻找下一个新分量的起点。

###### 代码套路 - 计算连通分量的数量

```java
private int countComponents(int n, int[][] edges){
  Map<Integer,List<Integer>> graph = getGraph(n, edges);
  boolean[] visisted = new boolean[n];
  int count = 0;
  for(int i = 0; i < n; i++){
    if(!visited[i]){
      count++;
      bfs(graph,i,visited);
    }
  }
  return count;
}

private void bfs(Map<Integer,List<Integer>> graph, int cur, boolean[] visited[]){
  Queue<Integer> queue = new LinkedList<>();
  queue.offer(cur);
  visited[cur] = true;
  
  while(!queue.isEmpty()){
    Integer node = queue.poll();
    //process the node
    for(int next : graph.get(node)){
      if(!visited[next]){
        queue.offer(next);
        visited[next] = true;
      }
    }
  }
}
```

##使用并查集生成连通分量

###核心思想

并查集是处理这类问题的最直接、最高效的工具。它的逻辑是：**每条边都连接了两个顶点，我们将这两个顶点合并到同一个集合中**。

###### 工作流程

1. **初始化**: a. 创建一个并查集数据结构，包含 `n` 个元素。 b. 初始时，每个顶点都是一个独立的集合（`parent[i] = i`）。 c. 连通分量的数量 `count` 初始化为 `n`。
2. **构建分量 (合并)**: a. 遍历输入的 **边列表 `edges`** 中的每一条边 `(u, v)`。 b. 对每一条边，调用 `union(u, v)` 操作。 c. 在 `union` 函数内部，如果 `u` 和 `v` 原本不属于同一个集合（即它们的根不同），则将它们合并，并把连通分量总数 `count` 减一。
3. **完成**: 遍历完所有边之后，`count` 的最终值就是图中连通分量的数量。

```java
// 先定义并查集类
class UnionFind {
    private int[] parent;
    private int count; // 直接记录连通分量数量

    public UnionFind(int n) {
        parent = new int[n];
        count = n; // 初始时，每个顶点都是一个分量
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int i) {
        if (parent[i] == i) return i;
        return parent[i] = find(parent[i]);
    }

    public void union(int i, int j) {
        int rootI = find(i);
        int rootJ = find(j);
        if (rootI != rootJ) { // 如果不在同一个集合，则合并
            parent[rootI] = rootJ;
            count--; // 合并成功，分量数减一
        }
    }

    public int getCount() {
        return count;
    }
}

// 使用并查集的主逻辑
class Solution_UF {
    public int countComponents(int n, int[][] edges) {
        // 1. 初始化并查集
        UnionFind uf = new UnionFind(n);

        // 2. 遍历所有边进行合并
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }

        // 3. 返回最终分量数
        return uf.getCount();
    }
}
```

#### 实现套路

##### 并查集

#### 注意事项与陷阱

- **图不连通的时候操作次数 = 连通块数-1**
- 特别注意**孤立点**

##Leetcode 323 无向图中连通分量的数量

你有一个包含 `n` 个节点的图。给定一个整数 `n` 和一个数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示图中 `ai` 和 `bi` 之间有一条边。

返回 *图中已连接分量的数目* 。

##### 核心思想： 并查集记录连通块个数



##### 代码实现

```java
    class UnionFind{
        int[] parent;
        int count;

        public UnionFind(int n){
            parent = new int[n];
            count = n;
            for (int i=0;i<n;i++){
                parent[i]=i;
            }
        }

        public int find(int x){
            if (parent[x] != x){
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public boolean union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY){
                return false;
            }

            parent[rootX] = rootY;
            count--;
            return true;
        }
    }
    public int countComponents(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        for (int[] edge : edges){
            uf.union(edge[0], edge[1]);
        }
        return uf.count;
    }
```

##Leetcode 827  Making A Large Island (最大人工岛).

###问题描述

给定一个 N x N 的二进制网格 `grid`。`1` 代表陆地，`0` 代表水域。一个岛屿是由水平或垂直方向上相邻的 `1` (陆地) 连接而成的。岛屿的面积是岛上陆地单元格的数量。

你可以执行最多一次操作：将一个 `0` (水域) 单元格更改为 `1` (陆地)。

请返回执行此操作后，可以获得的最大岛屿面积。如果没有水域单元格（即整个网格都是陆地），则返回整个网格的面积。

###问题要点

1. 输入一个$N ✖️  N$ 的二维数组，元素为0或者1
2. 岛屿的定义： 四个方向（上下左右）相连的`1`构成一个岛屿
3. 操作： 最多可以将一个0变成1
4. 目标： 找到经过一次操作后，可能形成的最大岛屿的面积
5. 特殊情况： 如果网络中没有0，无法进行该操作，此时最大的岛屿就是整个网络，面积就是$N^2$

###问题的本质和分析 - 图的遍历问题

这个问题的本质是一个 **图论/网格遍历** 问题，结合了 **状态预计算** 和 **合并** 的思想。

####使用暴力解法

#####**暴力解法的过程**

- 遍历网格中的每一个0
- 对于每一个0，将之修改为1
- 从新生成的1开始，进行一次深度优先搜索或者广度优先搜索，来计算连接成的岛屿的面积
- 在所有可能的结果中取最大值

#####**暴力解法的复杂度** - $N^4$

- 网格大小为 $N^2$。
- 遍历所有 `0` 的位置，最多有 $N^2$ 个。
- 每尝试一个 `0`，都需要进行一次 DFS/BFS，其时间复杂度为 $O(N^2)$。
- 因此，总时间复杂度为 $O(N^4)$。对于 N=500 的情况，这是绝对无法接受的。

####优化思路 - 减少重复计算

暴力解法的低效在于 **重复计算**。当我们计算一个由 `0` 变 `1` 形成的新岛屿时，我们一遍又一遍地重新计算了它周围已经存在的岛屿的面积。

一个高效的方法是预先处理好信息。新岛屿的面积等于 `1` (我们翻转的那个 `0`) 加上它周围所有 **不同** 岛屿的面积之和。

这就引出了核心的优化思想：

##### 先收集所有的岛屿信息

**第一步 (预计算)**：先遍历一遍整个网格，找出所有的原始岛屿。为每个岛屿分配一个唯一的 ID，并计算出每个岛屿的面积，将这个 `(岛屿ID, 面积)` 的映射关系存储起来。

##### 检查每个0的周边岛屿面积之和

**第二步 (合并计算)**：再次遍历整个网格，这次只关注 `0` (水域)。对于每个 `0`，检查其上、下、左、右四个邻居。通过邻居的岛屿 ID，查出它们的面积，并将这些面积加起来（注意要去重，避免一个 `0` 的两个边连接到同一个岛屿），再加上 `1`（`0` 本身），就得到了如果在此处建岛的总面积。更新全局最大值。

###核心思想和套路 - 两遍扫描

####第一次扫描 - 收集岛屿信息

- **目的**: 收集全局信息，为第二步做准备。
- **方法**: 遍历网格，使用 DFS/BFS 对每个独立的连通分量（岛屿）进行 "染色"（标记唯一 ID），并计算其面积。将 `ID -> 面积` 存入哈希表。这个过程通常被称为 **"染色法"** 或 **"ID 标记法"**。

####第二次扫描 - 计算结果

- **目的**: 利用第一步收集到的信息来计算最终答案。
- **方法**: 遍历网格中的 `0` 元素。对于每个 `0`，查看其邻居的 ID，通过哈希表查找面积，合并计算出潜在的最大岛屿面积，并更新全局最大值

这种 **“先标记/预计算，后合并/查询”** 的套路在处理连通性、组件合并等问题时非常有效。

###难点分析和应对

####如何避免重复计算岛屿面积？

一个 `0` 可能有多个边与同一个大岛屿相邻。例如：

```
1 1 1
1 0 1
1 1 1
```

中间的 `0` 四个方向都与同一个岛屿相邻。如果直接把四个邻居的面积相加，就会严重重复计算。

**应对策略**: 使用 `HashSet`。在检查一个 `0` 的四个邻居时，将邻居的岛屿 ID 放入一个 `Set` 中。`Set` 的特性保证了每个唯一的岛屿 ID 只会被记录一次。最后，遍历 `Set` 中的所有 ID，从 `Map` 中取出面积并求和。

###实现原理和步骤

####数据结构

- `int[][] grid`: 我们将 **原地修改** 这个数组。原始的陆地 `1` 会被替换成它所属岛屿的ID（例如 `2`, `3`, `4`...）。这样 `grid` 本身就充当了“已访问”标记和“单元格到岛屿ID”的映射，一举两得。
- `Map<Integer, Integer> islandAreaMap`: 一个非常简单的哈希表，用于存储 `岛屿ID -> 岛屿面积` 的映射关系。查询效率高，且内存占用远小于你之前设计的 `Map<Cell, Island>`。

####利用BFS标记每个节点所属岛屿并计算岛屿面积

输入节点是一个值为1的起始节点。

通过**BFS染色标记**的方法：

- 将属于同一个岛屿的节点全部标记为该岛屿的编号。

- 计算岛屿中所有的节点的面积之和

  

```java
    private void bfs(int[][] grid, int row, int col, boolean[][] visited, int island) {
        int n = grid.length;
        islandAreaMap.put(island, islandAreaMap.getOrDefault(island, 0) + 1);
        visited[row][col] = true;
        grid[row][col] = island;

        
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] { row, col });

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int cr = cur[0];
            int cc = cur[1];
            for (int[] dir : dirs) {
                int nr = cr + dir[0];
                int nc = cc + dir[1];
                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    if (!visited[nr][nc] && grid[nr][nc] == 1) {
                      //累加岛屿面积
                        islandAreaMap.put(island, islandAreaMap.getOrDefault(island, 0) + 1);
                      //标记为已访问
                        visited[nr][nc] = true;
                      //染色方法，标记为所属岛屿的编号
                        grid[nr][nc] = island;
                      //加入队列
                        queue.offer(new int[]{nr,nc});
                    }
                }
            }
        }
    }
```

####计算每一个0节点的相邻岛屿面积和的最大值

```java
    private int calculateMaxArea(int[][] grid){
        int n = grid.length;
        int maxArea = 0;
        for (int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 0){
                    Set<Integer> neigborIslands = new HashSet<>();
                    for(int[] dir : dirs){
                     int ni = i + dir[0];
                     int nj = j + dir[1];
                     if(ni >= 0 && ni < n && nj >=0 && nj < n){
                        if(grid[ni][nj] > 1){
                            neigborIslands.add(grid[ni][nj]);
                        }
                     }
                    }
                    int area = 1;
                    for(int island : neigborIslands){
                        area += islandAreaMap.get(island);
                    }
                    maxArea = Math.max(area, maxArea);
                }
            }
        }
        return maxArea;
    }
```

###实现代码

```java
class Solution {
    Map<Integer, Integer> islandAreaMap = new HashMap<>();
    int[][] dirs = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };
    public int largestIsland(int[][] grid) {
        int n = grid.length;
        int island = 2;
        int zeroCount = 0;
        boolean[][] visited = new boolean[n][n];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    bfs(grid, i, j, visited, island);
                    if (islandAreaMap.getOrDefault(island, 0) == n*n){
                        return n * n;
                    }
                    island++;
                }else{
                    zeroCount++;
                }
            }
        }

        if(zeroCount == n*n) return 1;

        return calculateMaxArea(grid); 
    }

    private void bfs(int[][] grid, int row, int col, boolean[][] visited, int island) {
        int n = grid.length;
        islandAreaMap.put(island, islandAreaMap.getOrDefault(island, 0) + 1);
        visited[row][col] = true;
        grid[row][col] = island;

        
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] { row, col });

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int cr = cur[0];
            int cc = cur[1];
            for (int[] dir : dirs) {
                int nr = cr + dir[0];
                int nc = cc + dir[1];
                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    if (!visited[nr][nc] && grid[nr][nc] == 1) {
                        islandAreaMap.put(island, islandAreaMap.getOrDefault(island, 0) + 1);
                        visited[nr][nc] = true;
                        grid[nr][nc] = island;
                        queue.offer(new int[]{nr,nc});
                    }
                }
            }
        }
    }

    private int calculateMaxArea(int[][] grid){
        int n = grid.length;
        int maxArea = 0;
        for (int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 0){
                    Set<Integer> neigborIslands = new HashSet<>();
                    for(int[] dir : dirs){
                     int ni = i + dir[0];
                     int nj = j + dir[1];
                     if(ni >= 0 && ni < n && nj >=0 && nj < n){
                        if(grid[ni][nj] > 1){
                            neigborIslands.add(grid[ni][nj]);
                        }
                     }
                    }
                    int area = 1;
                    for(int island : neigborIslands){
                        area += islandAreaMap.get(island);
                    }
                    maxArea = Math.max(area, maxArea);
                }
            }
        }
        return maxArea;
    }
}
```

### 注意事项

#### 本题使用并查集比较复杂，使用染色方案是比较简单的

因为我们采用了一种比较常见的技巧，将Cell做个标记，标记其属于哪一个岛屿。

这样我们可以使用一个`HashMap`来保存每一个岛屿的面积。

同时对于每一个值为0的cell，我们也可以很快的寻找到其邻居岛屿。

#### Edge Case: 所有的Cell全部是1情况

这种情况下，第一个area的面积应该就是`n * n`， 应当直接返回该结果即可。

#### Edge Case: 所有的Cell全部都是0的情况

这个时候AreaMap应该是空的，但是考虑到翻转的那个cell，因此直接返回1即可。

