#图建模问题

##场景描述-场景规则转化中隐含图规则

输入并不是一个图，而是一些状态，比如单词、密码、DNA，**转换规则之间隐含图结构**。

目标是通过合法转换，从初始状态转化为目标状态，常见

- **字符串状态搜索**
- **密码破译**
- **最短修改路径问题**

##通用应对策略-转化为状态图

####状态识别

###### 什么是状态？-每一个可以走到的`阶段`

- 如果是棋盘，状态是棋子的位置
- 如果是字符串题，状态可能是当前字符串内容或者指针的位置
- 如果是组合题，状态可能是当前选择的组合

####识别状态之间的关系-边就是状态变化规则

从一个状态，如何转换到另外一个状态？

- 一个字符串可以加一个字符（编辑距离）
- 一个单词可以替换一个字符变成另外一个字符
- 一个数组交换两个数（求全排列）

##### 五步走：识状态，定转移，构图形，找起终，选策略

使用**状态图**进行

- **使用BFS搜索求最短路径**
- **使用DFS枚举所有合法路径**

##实现套路 

### 最关键的过程是图的构建过程

#### 什么是状态？

#### 状态转换过程是什么样子的？

#### 如何识别当前状态的邻居状态有哪些？



###BFS+状态生成

```java
Queue<String> queue = new Queue<>();
String<String> visited = new HashSet<>();
queue.offer(start);
visited.add(start);

while(!queue.isEmpty()){
  String current = queue.poll();
  for (String next : generateNext(current)){
    if (visited.add(next)) queue.offer(next);
  }
}
```

##注意事项

- 字符串/数组状态应该作为Key
- **双向BFS**可以降低复杂度

##Leetcode 127: 单词接龙


字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
- 对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。
- `sk == endWord`

给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。

#### 问题的本质

##### 当涉及到转化的时候就需要考虑用图来解决

**状态**：每个单词是一个节点。

**状态转移**：两个单词之间能通过**变换一个字母**转化 → 连一条边。

**构图方式**：隐式图（不提前构建图，而是在遍历过程中动态生成相邻节点）。

**起点**：`beginWord`，终点：`endWord`

**算法**：BFS 求最短路径

#### 核心思想

##### 将问题转化为状态图

**状态定义：**每一个单词就是一个状态节点

**状态转移：**两个单词之间能通过**变换一个字母**转化

##### 如何判断两个单词之间是否可以转化？（求节点的邻接点）

```java
    private boolean onlyOneDiff(String word1, String word2){
        if (Math.abs(word1.length()-word2.length())>=2) return false;

        if (word1.length() == word2.length()){
            int diff =0;
            for (int i=0; i< word1.length();i++){
                if (word1.charAt(i) != word2.charAt(i)){
                    diff++;
                }
            }
            if (diff >=2) return false;
        } else {
            int length = Math.min(word1.length(), word2.length());
            for (int i=0; i<length;i++){
                if (word1.charAt(i) != word2.charAt(i)){
                    return false;
                }
            }
        }

        return true;
    }

    //如何确定两个单词之间只有一个字符差别
    private List<String> getNexts(String word, List<String> wordList){
        List<String> list = new ArrayList<>();
        for (String wordInList : wordList){
            if (onlyOneDiff(word, wordInList)){
                list.add(wordInList);
            }
        }
        return list;
    }
```

##### 用BFS求最短转化路径即可

```java
//BFS 套路
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<String> queue  = new LinkedList<>();
        queue.offer(beginWord);

        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        int steps = 1;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i=0; i< size;i++){
                String current = queue.poll();
                if (current.equals(endWord)){
                    return steps;
                }
                List<String> nexts = getNexts(current, wordList);
                for (String next : nexts){
                    if (!visited.contains(next)){
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
            steps++;
        }

        return 0;

    }
```
