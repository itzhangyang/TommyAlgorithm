#图的遍历(结构探索、克隆图、连通块)

##场景描述-访问所有节点或者确定哪些节点彼此连通

在实际图结构中，需要访问所有节点或者确定哪些节点彼此联通。

例如：在地图中判断哪些区域连成块、社交网络中谁和谁是好友、深度抓取一个页面关联的全部子页面。

##通用应对策略

选择如下的遍历算法，并且注意**标记访问状态**

- DFS 深度优先遍历
- 递归遍历三大件
- BFS遍历图

##核心算法思路

通过**递归**或者**队列**访问所有和起点相连的节点，**通常使用`visited`避免重复访问**。

##实现套路模板

###复习-BFS：从某个起点一层一层遍历

```java
public void bfs(Map<Node,List<Node>> graph， Node start){
  Queue<Node> queue = new LinkedList<>();
  queue.offer(start);
  int steps=0;//记录层数
  //记录访问过的节点
  Set<Node> visisted = new HashSet<>();
  visited.add(start);
  
  while(!queue.isEmpty()){
    steps++;
    int size = queue.size();
    for (int i=0;i<size;i++){
      Node node = queue.poll();
      //TBD pricess the node
      System.out.println(node.val)
      List<Node> neighbors = grap.get(node)；
      for(Node neighbor: neighbors){
        if (!visited.contains(neighbor)){
          queue.offer(neighbor);
          visited.add(neighbor);
        }
      }
    }
  }
}
```

###复习- BFS：尝试逐个访问所有路径

###### current node的处理逻辑在函数的开始

业务逻辑的处理和base condition在函数的一开始就处理。

###### 迭代邻居节点的时候，只递归调用

在迭代邻居节点的时候，如果邻居节点没有被处理过，则**只调用dfs进行下一轮递归**



```java
List<Node> path = new ArrayList<>();
Set<Node> visited = new HashSet<>();
public void dfs(Node current, Map<Node,List<Node>> graph){
  visited.add(current);
  path.add(current);
  if(/*current 满足条件*/){
    return;
  }
  
  List<Node> neighbors = graph.get(node);
  
  for(Node neighbor:neighbors){
    if(!visited.contains(neighbor)){
     dfs(neighbor,graph);
    }
  }
  
}
```

##Leetcode 200L 岛屿数量- BFS解法

给定一个二维网络`grid` ，由`1` （陆地）和`0` （岛屿）组成，求有多少个岛屿。岛屿与被水平或者垂直方向相邻的`1` 组成，周围被水包围。

##### 核心思想

遍历整个网络，遇到`1`则说明发现了新岛屿，同时从这个点出发使用`BFS`将这个岛屿的所有`1` 标记为0，防止重复计数。

##### 实现原理

###### 遍历grid每个点

- 如果是`1`, 将岛屿数量+1
- 从该点出发，使用BFS，编辑所有与之连接的`1`为0

###### 利用BFS标记岛屿

- 使用Queue
- 起点入队
- 当队列不为空是，不断取出当前节点(x,y)
- 扩展它的上下左右节点，如有还是`1` ，就标记为`0`并加入队列

```java
class Cell{
    int row;
    int col;
    char val;
    public Cell(int row, int col, char val){
        this.row = row;
        this.col = col;
        this.val = val;
    }
}
class Solution {
    public int numIslands(char[][] grid) {
        int numberOfIslands = 0;
        int m = grid.length;
        int n = grid[0].length;
        boolean[][] visited = new boolean[m][n];

        for(int row = 0; row < m; row++ ){
            for(int col = 0; col < n; col++){
                if(grid[row][col] == '1'){
                    numberOfIslands++;
                    bfs(grid,row,col, visited);
                }
            }
        }
        return numberOfIslands;
    }

    private void bfs(char[][] grid, int row, int col, boolean[][] visited){
        int m = grid.length;
        int n = grid[0].length;
        Queue<Cell> queue = new LinkedList<>();
        queue.offer(new Cell(row,col,grid[row][col]));
        visited[row][col] = true;
        grid[row][col] = '0';

        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        while(!queue.isEmpty()){
            Cell curr = queue.poll();

            for(int[] dir : dirs){
                int nr = curr.row + dir[0];
                int nc = curr.col + dir[1];
                if(nr >= 0 && nr < m && nc >= 0 && nc < n
                && !visited[nr][nc] && grid[nr][nc] == '1'){
                    visited[nr][nc] = true;
                    grid[nr][nc] = '0';
                    queue.offer(new Cell(nr,nc,grid[nr][nc]));
                }
            }
        }
    }
}
```

## Leetcode 200L 岛屿数量 - DFS解法

基本思路和BFS解法类似，遇到一个岛屿cell之后，将和cell直接或者间接相连的所有岛屿全部淹没。

### 问题提别 - 多源DFS过程

DFS的多源过程，适用于具有**多个连通分量**的图。

我们遍历图中所有节点：

####DFS过程

- 将当前节点标记为已访问
- 对于当前节点的所有邻居节点，标记为已经访问

#### 访问下一个连通分量

完成DFS过程以后，继续检查图中是否有没有访问到的节点。

如果有的话，说明图中存在多个连通分量，则需要继续从这个没有访问的节点开始，运行DFS过程。

上述过程需要一直重复，直到图中不再存在未访问的节点为止。

### 问题的转化

在考试检查每个节点之前，我们需要定义一个记录岛屿数量的变量`numberOfIslands`

- 遍历`grid`中的每一个`cell`
- 如果`cell`值为1，说明是岛屿：
  - 将岛屿数量+1
  - 将该岛屿淹没(`grid[row][col] = '0'`)
  - 检查所有和该岛屿cell相邻的岛屿，执行DFS淹没过程

### 代码实现

```Java
class Solution {
    
    public int numIslands(char[][] grid) {
        int numberOfIslands = 0;
        int m = grid.length;
        int n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        for(int row = 0; row < m; row++){
            for(int col = 0; col < n; col++){
                if(grid[row][col] == '1'){
                    numberOfIslands++;
                    dfs(grid, row, col, visited);
                }
            }
        }
        return numberOfIslands;
    }

    private void dfs(char[][] grid, int row, int col,boolean[][] visited){
        int m = grid.length;
        int n = grid[0].length;
        visited[row][col] = true;
        grid[row][col] = '0';

        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        for(int[] dir : dirs){
            int nr = row + dir[0];
            int nc = col + dir[1];
            if(nr >= 0 && nr < m && nc >= 0 && nc < n 
            && grid[nr][nc] == '1'
            && !visited[nr][nc] ){
                dfs(grid, nr, nc, visited);
            }
        }
    }
}
```



##Leetcode 200L 岛屿数量-并查集解法(更简单一些)

###核心思想：将相邻的岛屿合并为一个岛屿群，计算岛屿群的数量

- 把二维网格中的每个`1` 看作一个独立的点
- 如果某个`1`和它上下左右的`1` 连通，就把它们合并成为一个集合（同一个岛屿）
- 最后统计有多少个独立的集合

###定制一个并查集 - 二维索引转化为一维索引

> 注意到我们多数情况下无法直接将算法模板的代码直接使用，需要做定制
>
> 原本的并查集定义是一个面向一维数组的，无法直接应用到二维数组，需要做变种

####并查集的元素数组怎么获得？

- 将二维数组grid[][]转为一个一维数组
  - `grid[i][j]` 对应的一维数组为`nodes[i*cols+j]`

####并查集的构造函数干了什么？

- 将二维数组`grid`转为一个一维数组(元素数组)

- 初始化每个node的老大（parent/root）: parent[i]=i;

```java
class UnionFind{
  // parent[i]表示岛屿i的老大
	int[] parent;
  //
  int count;
  
  public UnionFind(char[][] grid){
    int rows = grid.length;
    int cols = grid[0].length;
    count =0;
    
    for (int i=0;i<rows;i++){
      for(int j=0;j<cols;j++){
        if (grid[i][j]=='1'){
          int id = i*cols+j;//注意这个id生成公式
          //将每一个node的parent默认设置为自己
          parent[id]=id;
          //计算总节点的数量
          count++;
        }
      }
    }
  }
  
  public int find(int x){
    if (parent[x] !=x){
      parent[x] = find(parent[x]);
    }
    return parent[x];
  }
  
  public void union(int x, int y){
    int rootX = find[x];
    int rootY = find(y);
    if (rootX !=rootY){
      parent[rootX]=rootY;
      count --;
    }
  }
}
```

##### 在并查集中合并相邻节点

```java
public int numIslands(char[][] grid){
	if (grid == null || grid.length ==0) return 0;
  
  int rows = grid.length;
  int cols = grid[0].length;
  UnionFind uf = new UnionFind(grid);
  
  //注意只向下和向右查询，为了避免重复合并
  int directions = {{0,1},{1,0}}
  
  for(int i=0;i<rows;i++){
    for(int j=0;j<cols;j++){
     if (grid[i][j]=='1'){
       for (int[] d: directions){
         int ni = i+d[0];
         int nj = j+d[1];
         if (ni < rows && nj < cols && grid[ni][nj]=='1'){
           int id1 = i+cols+j;
           int id2 = ni*cols+nj;
           uf.union(id1,id2);
         }
       }
     }
    }
    return uf.getCount();
  }
}
```

##Leetcode 695 岛屿最大面积

给定一个二维网格 `grid`，由 `0`（水）和 `1`（陆地）组成。我们要找出网格中**最大的岛屿面积**，岛屿是指由**上下左右相邻的1组成的连通区域**。

###DFS解法

####使用双重循环来遍历grid

- 每当遇到1，递归调用DFS来计算该岛屿的面积

  ```java
  int rows = grid.length;
  int cols = grid[0].length;
  int maxArea = Integer.MIN_VALUE;
  for (int i=0;i<rows;i++){
    for (int j=0;j<cols;j++){
      if (grid[i][j]=='1'){
        int area = dfs(grid,i,j);
        if (area > maxArea){
          maxArea = area;
        }
      }
    }
  }
  
  return maxArea;
  ```

  

- 使用DFS来计算每个岛屿的面积

  - DFS 套路模板

    ```
    //Base condition
    //检查当前节点是否满足条件
    
    //处理当前节点
    
    //将当前节点标记为已处理
    
    //递归处理邻居节点
    
    //返回结果
    ```

    

  - DFS 是一个`递归过程`

  - 递归的Base Condition

    - i <0;
    - i>=rows;
    - j<0;
    - j>=cols;
    - `Grid[i][j]` ==0;

  - 需要将当前的位置修改为0: `grid[i][j]=0`,防止`重复计算`

  - [最佳实践] 定义一个上下左右移动的方向 `directions = {{0,1},{1,0},{0,-1},{-1,0}}`

  ```java
  public int dfs(grid[][], int i, int j){
  	//Base conditions
    int rows = grid.length;
    int cols = grid[0].length;
    
    if (i<0 || i >= rows || j<0 || j>= cols || grid[i][j]==0){
      return 0;
    }
    
    //处理逻辑
    grid[i][j]=0;
    int area =1;
    
    int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}}
    
    for (int[] d: directions){
      int ni = i+d[0];
      int nj = j+d[1];
      area+ = dfs(grid,ni,nj);
    }
    return area;
  }
  ```

### BFS 解法

```Java
class Cell{
    int row;
    int col;
    public Cell(int row, int col){
        this.row = row;
        this.col = col;
    }
}
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int maxArea = 0;
        boolean[][] visited = new boolean[m][n];
        for(int row = 0; row < m; row++){
            for(int col = 0; col < n; col++){
                if(grid[row][col] == 1){
                    int area = bfs(grid, row, col, visited);
                    maxArea = Math.max(area, maxArea);
                }
            }
        }
        return maxArea;
    }

    private int bfs(int[][] grid, int row, int col, boolean[][] visited){
        int m = grid.length;
        int n = grid[0].length;

        int area = 0;
        Queue<Cell> queue = new LinkedList<>();
        queue.offer(new Cell(row, col));
        visited[row][col] = true;
        area += 1;

        int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};
        while(!queue.isEmpty()){
            Cell curr = queue.poll();
            
            for(int[] dir : dirs){
                int nr = curr.row + dir[0];
                int nc = curr.col + dir[1];

                if(nr >= 0 && nr < m && nc >= 0 && nc < n 
                && grid[nr][nc] == 1
                && !visited[nr][nc]){
                    area += 1;
                    visited[nr][nc] = true;
                    grid[nr][nc] = 0;
                    queue.offer(new Cell(nr, nc));
                }
            }
        }

        return area;
    }
}
```



##Leetcode: 417: 太平洋大西洋水流问题-逆向思维

给定一个 `m x n` 的高度矩阵 `heights`，水从一个单元格流向四个方向（上、下、左、右），但只能流向高度相同或更低的邻接单元格。

要求找出**既可以流向太平洋（矩阵左边界和上边界），又可以流向大西洋（矩阵右边界和下边界）**的所有坐标。

##### 核心思想-反向遍历

本题的重要的一个点是反向思维：**从边界反向BFS/DFS向内遍历**

- 而不是从每个格子出发判断能否流向两个大洋，我们反过来
  - 从太平洋边界出发，找到能流到该边界
  - 从大西洋边界出发，找到能流到该边界的所有格子
- 最后找到两个集合的交集，就是既能流向太平洋又能流向大西洋的点

##### 实现原理

###### 搜索方向：

从边界出发，对每个单元格的上下左右邻居`(i+dx,j+dy)`：

如果邻居高度`>=`当前格子高度，继续DFS/BFS.

###### 两次遍历

- 第一次从太平洋边界遍历，记录能够达到的点`pacificVisisted`
- 第二次从大西洋边界遍历，记录能够达到的点`atlanticVisited`
- 两个`visited`数组都为`true`的坐标就是答案

##### 代码实现-DFS

###### 遍历的全局辅助变量-directions

- 方向移动辅助数组 `int[][] directions ={{0,1},{1,0},{-1,0},{{1,0}}}`
- 当前的grid size = `m*n` 

###### DFS实现- DFS套路

```java
private void dfs(int[][] heights, boolean visited[], int i, int j){
  visited[i][j] = true;
  for (int[] dir : directions){
    int ni = i+dir[0];
    int nj = j+dir[1];
    if (ni >=0 && ni < m && nj >=0 && nj < n && heights[ni][nj] >= heights[i][j]) && ! visited[ni][nj]){
      dfs(heights,visited,ni,nj);
    }
  }
}
```

###### 调用顺序和过程

```java
public List<List<Integer>> pacificAtlantic(int[][] heights){
  List<List<Integer>> result = new ArrayList<>();
  if (heights == null || heights.length ==0 || heights[0].length ==0) return result;
  
  m = heights.length;
  n = heights[0].length;
  
  boolean[][] pacific = new int[m][n];
  boolean[][] atlantic = new int[m][n];
  
  //从边界出发,这边控制边界的方法与经验
  for(int i=0;i<m;i++){
    //太平洋的接触边，第一行
    dfs(heights,pacific,i,0);
    //大西洋的接触边界，最后一行
    dfs(heights,atlantic,i,n-1);
  }
  
  for (int j=0;j<n;j++){
    //太平洋的接触边界，第一列
    dfs(heights,pacific,0,j);
    //大西洋的接触边界,最后一列
    dfs(heights,atlantic,m-1,j);
  }
  
  //求交集
  for(int i = 0; i < m; i++){
    for (int j = 0; j < n; j++){
      if (pacific[i][j] && atlantc[i][j]){
        //注意这里的用法，不过不重要
        result.add(Arrays.asList(i,j));
      }
    }
  }
}
```



##### 注意事项

###### 边界要控制好

只从矩阵的最外一圈（上下左右）出发

###### 避免重复遍历-visited集合或者数组

###### 注意遍历方向是反着的

从边界向内走的时候，只能能入位置更高或者等高的位置

最后求的是两个visited的交集

##### 基于 BFS的实现-总结起来就是更麻烦一些

###### 需要显式维护的队列结构

- BFS 需要用`Queue<int[]>`显式管理当前层待访问节点
- 每访问一个点，需要**手动检查并添加邻居**，过程比递归更加冗长

###### 需要处理初始化多源起点

- 从边界出发，BFS需要一次性将所有边界点加入队列
- DFS中之需要多个递归调用，BFS需要循环构造入队逻辑

```java
for (int i=0; i < m; i++){
  queue.offer(queue.offer(new int[i,0]));
  ...
}
```

###### 处理坐标/状态更显式、更频繁

- DFS参数`(x,y)`，**隐式维护**
- BFS每个节点需要用数组表示`new int[]{x,y}`，并从队列解析

###### 逻辑顺序必须显式处理

- 递归天然遵循**先处理当前，再处理下一层**
- BFS必须手动推进当前层，且判断**是否能够扩展时**逻辑频繁



##### BFS 

###### BFS遍历实现

```java
private void bfs(int[][] heights, Queue<int[]> queue, boolean[][]){
  while (!queue.isEmpty()){
    int[] cell = queue.poll();
    int x = cell[0], y = cell[1];
    for (int[] dir : directions){
      int nx = x + dir[0];
      int ny = y + dir[1];
      //剪枝
      // 边界越界
      if (nx < 0 || nx >= m || ny < 0 || ny >=n ) continue;
      //已经遍历
      if (visited[nx][ny]) continue;
      //不符合条件
      if (heights[nx][ny] < heights[x][y]) continue;
      //添加到queue
      visited[nx][ny] = true;
      queue.offer(new int[]{nx,ny});
    }
  }
}
```

###### 主逻辑实现

```java
public List<List<Integer>> pacificAtlantic(int[] heights){
  List<List<Integer>> result = new ArrayList<>();
  if (heights == null || heights.lengt == 0 || heights[0].length ==0) return result;
  
  m = heights.length;
  n = heights[0].length;
  
  boolean[][] pacific = new int[m][n];
  boolean[][] atlantic = new int[m][n];
  
  Queue<int[]> pacificQueue = new LinkedList<>();
  Queue<int[]> atlanticQueue = new LinkedList<>();
  
  for (int i=0;i<m;i++){
    
    //第一行，太平洋
    pacificQueue.offer(new int[i,0]);
    //最后一行，大西洋
    atlanticQueue.offer(new int[i,m-1]);
  }
  
  for (int j=0;j<n;j++){
    //第一列，太平洋
    pacificQueue.offer(new int{0,j});
    
    //最后一列，大西洋
    atlanticQueue.offer(new int{n-1,j});
  }
  
  bfs(heights,pacificQueue, pacific);
  bfs(heights, atlanicQueue,atlantic);
  
  //合并结果集
  
  for(int i=0;i<m;i++){
    for (int j=0;j<n;j++){
      if (pacific[i][j] && atlantic[i][j]){
        result.add(Arrays.asList(i,j));
      }
    }
  }
}
```

