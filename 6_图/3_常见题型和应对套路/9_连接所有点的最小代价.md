#连接所有节点的最小代价-最小生成树

##场景描述

- 建设通信网络，花费最少的钱连通所有城市
- 构建高速公路，尽可能省钱

##通用应对策略

###无权图的最小路径-BFS

###加权图的最小路径-Dijstra

###核心算法思想-(Kruskal)贪心选择最小边

贪心选择最小边，连接所有节点，不成环

##实现代码套路模板

###无权图中从`start`到`target` 的最短路径-BFS

```java
public int bfs(Map<Integer,List<Integer>> graph, int start, int target){
  if (start == target) return 0;
  
  Queue<Integer> queue = new LinkedList<>();
  Set<Integer> visited = new HashSet<>();
  
  queue.offer(start);
  visited.add(start);
  
  int step = 0;
  
  while (!queue.isEmpty()){
    int size = queue.size();
    for (int i=0;i<size;i++){
      int node = queue.poll();
      if (node == target) return steps;
      
      List<Integer> neighbors = graph.get(node);
      for(int neighbor : neighbors){
        if (!visited.contains(neighbor)){
          queue.offer(neighbor);
        }
      }
    }
  }
  
  return -1;
}
```

###有权图中从`start`到其他所有节点的最小路径-Dijkstra

####定义当前`start`到某个节点之间的距离状态

```java
class State{
  int node;
  int dist;
  public (int node, int dist){
    this.node = node;
    this.dist = dist;
  }
}
```

####初始化最小距离数组dist[]

`dist[i]`表示`start`节点到`i`节点之间的最小距离

```java
int[] dist = new int[n];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;
```

####初始化最小堆-用来排序所有的边的权重

```
PriorityQueue<State> pq = new PriorityQueue<>((a,b)->a.dist - b.dist);
pq.offer(new State(start,0));
```

####遍历和更新最小堆和最小距离数组

```java
while (!pq.isEmpty()){
  State current = pq.poll();
  if (current.dist < dist[current.node]) continue;
  
  List<int[]> neighbors = graph.get(current.node);
  for (int[] neighbor : neighbors){
    int neighborNode = neighbor[0];
    int weight = neighbor[1];
    if (dist[neighborNode] > dist[current.node]+weight){
      dist[neighborNode] = dist[current.node]+weight;
      pq.offer(new State(neighborNode,dist[neighborNode]));
    }
  }
}
```

##注意事项和陷阱

###Dijkstra不适用于负权图

###多状态最短路径要二维dist数组

##Leetcode 743: 网络延迟时间

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

### 问题的本质 - 标准的有向加权图最短路径问题

### 实现代码

```Java
//Dijkstra 算法
class Pair{
    int node;
    int dist;

    public Pair(int node, int dist){
        this.node = node;
        this.dist = dist;
    }
}

class Edge{
    int from;
    int to;
    int weight;

    public Edge(int from, int to, int weight){
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
}
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, List<Edge>> graph = getGraph(n, times);

        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[k-1] = 0;

        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a,b) -> a.dist - b.dist);
        minHeap.offer(new Pair(k,0));

        while(!minHeap.isEmpty()){
            Pair curr = minHeap.poll();
            
            if(curr.dist > dist[curr.node-1]) continue;

            List<Edge> edgeList = graph.get(curr.node);
            for(Edge edge : edgeList){
                int next = edge.to;
                if(dist[next-1] > curr.dist + edge.weight){
                    dist[next-1] =  curr.dist + edge.weight;
                    minHeap.offer(new Pair(next, dist[next-1]));
                }
            }
        }

        int ans = 0;
        for(int d : dist){
            ans = Math.max(ans, d);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

    }

    private Map<Integer,List<Edge>> getGraph(int n, int[][] times){
        Map<Integer, List<Edge>> graph = new HashMap<>();
        for(int i = 1; i <= n; i++){
            graph.putIfAbsent(i, new ArrayList<>());
        }

        for(int[] time : times){
            int from =time[0];
            int to = time[1];
            int weight = time[2];

            Edge edge = new Edge(from, to, weight);
            graph.get(from).add(edge);
        }

        return graph;
    }
}
```



##Leetcode 1928:[规定时间内到达终点的最小花费](https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/)