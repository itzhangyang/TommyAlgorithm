###欧拉通路 - 行程安排问题LC - 332

#### 问题要点

首先，我们提炼出问题的关键信息和约束条件：

**输入**: 一个字符串列表的列表 `List<List<String>> tickets`，其中每个 `[from, to]` 代表一张从 `from` 机场到 `to` 机场的**单程**机票。

**输出**: 一个字符串列表 `List<String>`，代表一个完整的行程，该行程使用掉了输入中的所有机票。

**起始点**: 行程必须从 "JFK" 机场开始。

**唯一性**: 每张机票必须且只能使用一次。

**多解情况**: 如果存在多个有效的行程，必须返回**字典序最小** (lexicographically smallest) 的那一个。

**保证有解**: 题目保证至少存在一个有效的行程。

**核心挑战**: 如何在满足“用完所有机票”的前提下，找到那条“字典序最小”的路径。

#### 问题本质和分析 (Problem Essence and Analysis) - 图论问题 - 欧拉通路

- **图的建模**: 这个问题可以非常自然地抽象成一个图论问题。

  - **顶点 (Vertices)**: 机场（如 "JFK", "SFO" 等）。
  - **边 (Edges)**: 机票。这是一张**有向图**，因为机票 `["JFK", "SFO"]` 只能从 JFK 飞往 SFO，不能反向。
  - **边的重数**: 两个机场之间可能有**多张机票**，例如 `[["JFK", "SFO"], ["JFK", "SFO"]]`，这意味着图中可能存在**重边**。

- **核心任务**: “用完所有机票恰好一次” 在图论中的术语叫做**欧拉通路 (Eulerian Path)**。

  欧拉通路指的是通过图中所有边一次且仅一次的路径。

- **问题转化**: 因此，原问题被转化为：在一个有向图中，寻找一条从 "JFK" 出发的，字典序最小的**欧拉通路**。

- **为什么是欧拉通路?**

  - 欧拉通路/回路的定义就是遍历图中所有的边一次。这与“用完所有机票”完美对应。
  - 题目保证有解，这意味着这个图（或者至少从"JFK"出发可达的部分）必然存在欧拉通路。

#### 模式匹配 - 欧拉通路

当你看到“遍历所有边一次”这类关键词时，就应该立刻联想到以下模式：

- **主要模式**: **欧拉通路/欧拉回路 (Eulerian Path/Circuit)**。
- **解决算法**: **Hierholzer 算法** (Hierholzer's Algorithm) 是解决欧拉通路问题的经典、高效算法。
- **实现方式**: Hierholzer 算法通常通过**深度优先搜索 (DFS)** 来实现。

这个问题的特殊性在于，它不仅要求找到一条欧拉通路，还要求这条通路是字典序最小的。

这个额外的约束会影响我们在DFS中**选择下一个节点**的策略。

#### 核心思想和套路

##### 通俗的解释算法的基本原理

这个算法就像一个非常谨慎的旅行者。

他会先一条路走到黑，直到找到那个终点站。

然后他一边往回走，一边把路过的站点从后往前地记录下来。

因为他总是优先选择字母表顺序靠前的路线去探索，所以他找到的这条完整路径，自然就是字典序最小的那一条。

解决这个问题的核心思想是 **“DFS + 贪心 + 逆序构建”**，这本质上就是 Hierholzer 算法的变种。

###### 想象你正在做一个连线画的题目

想象一下你正在完成一个 **“连线画”** (connect-the-dots)，目标是用一笔画完所有的线段，并且从 "JFK" 这个点开始。

###### 你第一个走到的“死胡同”，必然是你整个行程的真正终点

因为如果你在一个地方卡住了，说明你再也去不了别的地方了。

如果这还不是最终的终点，那就意味着还有别的机票没用，而你却被困住了，这说明你之前的选择是错误的。

但算法通过回溯保证了不会漏掉任何机票，所以你第一个卡住的地方，一定是整个旅程**画上句号**的地方。

###### 先把最难走的路走完

**什么是“死胡同”？** 

就是一条路，你一旦走进去，就可能没有其他路可以继续走了，导致你“卡住”。

**算法如何做？**

算法通过深度优先搜索（DFS），会一条路走到黑。当你到达一个机场，再也无路可走时（所有从这里出发的机票都用完了），你就到达了一个“局部终点”或“死胡同”。



##### **贪心策略 (Greedy)**:

 为了获得字典序最小的行程，当我们处于一个机场（节点）时，有多个目的地可以选择，我们应该**优先飞往字典序最小的那个机场**。

例如，在 JFK 可以飞往 "ATL" 和 "SFO"，我们应优先选择 "ATL"。

#####**DFS 陷阱与解决方案**:

######陷阱 - 过早掉入死胡同

- **陷阱**: 如果我们只是简单地进行贪心DFS（即，遇到一个节点就立即加入结果列表，然后访问字典序最小的邻居），可能会导致“过早陷入死胡同”。

  换句话说，可能会到了一个**无法飞往其他地方**的节点，即老板**手中剩下的机票中没有出发站为该节点的**。

- **例子**: 假设有以下机票: `JFK -> A`, `JFK -> B`, `B -> C`, `A -> D`。

  - 字典序 `A < B`。
  - 从 JFK 出发，贪心选择飞往 A。行程 `[JFK, A]`。
  - 从 A 出发，飞往 D。行程 `[JFK, A, D]`。
  - 在 D 卡住了，但 `JFK -> B -> C` 这条路还没走。我们失败了。

######怎么防止进入死胡同？- DFS后序遍历

- **正确思路 (Hierholzer)**: 我们不应该在访问一个节点时立即将其加入最终路径。

  相反，我们应该在**一个节点的所有出路都走完之后**，才将这个节点加入路径。

  为了实现这一点，我们将节点添加到结果列表的**头部**。这是一种**“后序遍历”**的思想。

######套路总结 (The "Sleeve")

- 使用一个 `Map<String, PriorityQueue<String>>` 来存储图。

  `PriorityQueue` (最小堆) 可以自动帮我们实现贪心策略，每次取出的都是**字典序最小**的目的地。

- 从 "JFK" 开始进行**深度优先搜索**。

- 在DFS函数中，不断从当前机场的优先队列中**取出并删除（`poll()`）**下一个目的地，然后对该目的地进行递归DFS。

- 当一个机场的所有出边都被访问完后（即它的优先队列为空），将这个机场**逆序添加**到结果列表中（即加到列表的头部）。

- 最终得到的列表就是正确的行程。

#### 实现原理和步骤

#####**构建图**

- 创建一个 `Map<String, PriorityQueue<String>> adj` 作为邻接表。
- 遍历所有 `tickets`。对于每一张机票 `[from, to]`，将 `to` 添加到 `from` 对应的 `PriorityQueue` 中。
- `adj.computeIfAbsent(from, k -> new PriorityQueue<>()).add(to);` 是一个简洁的写法。

##### 准备结果列表

创建一个 `LinkedList<String> result`。

使用 `LinkedList` 是因为它支持高效的**头部添加操作** (`addFirst`)，这对于逆序构建至关重要。

##### 实现 DFS函数

- 定义一个 `dfs(String airport)` 方法。

- **循环与递归**: 在 `dfs` 方法内部，检查 `adj` 中是否存在 `airport` 的条目，并且其优先队列不为空。

  只要不为空，就循环执行：

  - `String next = adj.get(airport).poll();` // 取出并移除字典序最小的目的地
  - `dfs(next);` // 对下一个机场进行递归调用

- **逆序添加**: 当循环结束时，意味着 `airport` 这个节点的所有出路都已经被探索完毕。

  此时，将它添加到结果列表的头部：`result.addFirst(airport);`。

##### 启动与返回

调用 `dfs("JFK")` 来启动整个过程。

DFS 结束后，`result` 中就存储了字典序最小的完整行程。直接返回 `result`。

#### 实现代码

```java
    //每个机票表示一个边？
    //类似拓扑排序不？
    List<String> res = new LinkedList<>();
    Map<String, PriorityQueue<String>> graph;
    public List<String> findItinerary(List<List<String>> tickets) {
        graph = new HashMap<>();
        //对于每一个节点，将其邻接点按照字母顺序添加到邻接表中
        //一张机票就是一个单向边
        for(List<String> ticket : tickets){
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.computeIfAbsent(from, x -> new PriorityQueue<>()).add(to);
        }
        dfs("JFK");
        return res;
    }

    private void dfs(String curr){
        PriorityQueue<String> pq = graph.getOrDefault(curr, new PriorityQueue<>());
        while (!pq.isEmpty()) {
            String next = pq.poll();
            dfs(next);  
        }
        res.addFirst(curr);
    }
```

#### 注意事项

#####**数据结构选择**

- `Map<String, PriorityQueue<String>>` 是本题成功的关键。`Map` 用于快速查找出发机场，`PriorityQueue` 用于自动实现“字典序最小”的贪心策略。
- 使用 `LinkedList` 作为结果容器是因为 `addFirst()` 操作的时间复杂度是 O(1)，而 `ArrayList` 的 `add(0, ...)` 是 O(N)，在大量添加时性能差距巨大。

##### **边的消耗**: 

在DFS中，必须“用掉”一张机票，即从优先队列中 `poll()` (取出并删除) 它。

如果不删除，当图中存在环时，程序会陷入**无限递归**。

##### 后序/逆序构建的重要性

这是最容易出错的地方。必须在节点的所有子路径都探索完毕后，才将该节点加入结果。

提前加入会导致路径顺序错误，无法通过上面的例子。

##### 起始点

始终从 "JFK" 开始，这是题目规定的。

####  经验总结

##### 问题识别

这是最容易出错的地方。

必须在节点的所有子路径都探索完毕后，才将该节点加入结果。提前加入会导致路径顺序错误，无法通过上面的例子。

##### 算法融合

本题完美地将图论（欧拉通路）、算法（DFS）、数据结构（优先队列）和贪心思想结合在一起。

##### Hierholzer算法的精髓

其精髓在于“死胡同”优先和逆序构建。

即，**先走那些容易让你“卡住”的路径**，走到底了，把这个终点加到结果里，然后**回溯**，走别的路。

最终把所有路都走通了，逆序的结果就是一条完整的通路。

##### 实践出真知

第一次做这道题很容易写出错误的“前序遍历”式DFS。只有通过分析失败的例子，才能深刻理解为什么必须采用后序（逆序）的方式来构建路径。这是一个非常好的学习案例。