### 判断图中是否有环-验证合法性或者构建顺序

#### 场景描述

- 判断是否存在无限循环依赖
- 判断图是否是**树结构**
- 验证网络结构是否稳定可用

#### 通用应对策略- DFS（三色标记）或者并查集

- DFS（三色图标记）检查是否再次访问**访问中**的节点
- 并查集检查重复合并

#### 实现套路 - 检测图中是否有环的两种方法

##### 检测有向图中是否有环 - DFS+三色标记

###### 应用场景有哪些？

- 判断**有向图**中是否有环
- 找出哪些节点**不会进入环**（安全节点）
- 在递归中标记状态，避免重复搜索和错误结论

###### 核心思想-使用三种颜色标记节点的访问状态

| 状态 | 颜色 | 含义                               |
| ---- | ---- | ---------------------------------- |
| 0    | 白色 | 未访问                             |
| 1    | 灰色 | 当前路径上正在访问（递归栈上）     |
| 2    | 黑色 | 已访问且确定不在环中（可安全返回） |

通过**DFS** 遍历图的节点，并用颜色标记访问节点

- 遇到**灰色**（`state[node]=1`）说明节点中存在环（因为**回到了当前路径中的节点**）
- 遇到**黑色**（`state[node]=2`）说明该节点**已经确认不会产生环**
- **递归完成以后标记为黑色**

###### 实现原理

1. 初始所有节点为白色(`color[i]=0`)
2. 对于每个**未访问节点**（白色）调用`dfs`
3. 进入`dfs[i]`时标记为**灰色**(`color[i]=1`)
4. 遍历当前的邻居节点：
   - 如果邻居是**灰色**：返回`false`(发现环)
   - 如果邻居是**白色**：递归调用`dfs`，若为`false`，返回`false`
5. 所有邻居遍历完成后标记为**黑色**(`color[i]=2`)，表示该路径安全
6. 最终根据结果**是否成功遍历所有节**点判断有无环

###### 实现代码

```java
private boolean dfs(int node, Map<Integer,List<Integer>> graph, int[] color){
  //1. Base condition: 检查当前节点的状态
  //1.1 如果状态为访问中，说明这个node已经在递归栈中，也就是在当前的路径中
  if (color[node] == 1) return false;
  //1.2 如果状态为已经访问，返回true
  if (color[node] == 2) return true;
  // 2 将当前节点标记为访问中
  color[node] = 1;
  
  // 3 调用dfs递归节点的每一个临界点
  List<Integer> neighbors = graph.get(node);
  for (int neighbor : neighbors){
    if (!dfs(neighbor,graph,color)){
      return false;
    }
  }
  //4.标记为已访问，已经出栈并且成功访问
  color[node] = 2;
  return true;
}
```

###### 注意事项

- **颜色枚举不能错：**灰色代表当前路径，遇到灰色说明存在环
- **有向图中环的检测适用：**无向图中使用`visited+parent`使用
- **需要避免重复DFS：**所以使用记忆数组可以记忆化
- **不要为尾部恢复颜色状态：**因为你需要记住访问结果
- **哪些节点是最终安全的：**Leetcode 802

###### 经验总结

- 三色DFS是一个在图搜索中典型的**剪枝+标记**技巧
- 相比较于`visited[]`数组，三色更精确表达了**当前访问状态**和**访问历史**
- 在解决**图中是否有环/找出安全节点**时更具表达力
- 三色图可以看作是**DFS+状态及**建模

##### 检测无向图图中是否存在环-并查集

并查集能够高效的判断两个节点是否已经连通，若尝试连接两个已经连通的节点，则说明存在环。

###### 常见应用场景

- 判断无向图中是否存在环
- Kruskal算法构建最小生成树，判断是否会形成环

###### 核心思想-并查集合并两个节点是否成功

若两个节点属于同一个集合，说明他们已经连通，若此时尝试再连接他们，则形成环。

因此，对于每条边`u->v`:

- 判断`u`和`v`是否属于同一个集合(`find(u) == find(v)`)
- 若时，则存在环
- 否则，将他们合并到同一个集合(`union(u,v)`)

###### 实现原理

并查集通过以下两个操作支持高效的集合管理：

- **find(x)**：查找元素 `x` 所属的集合代表（根节点）
  - 使用路径压缩优化：让每个节点直接指向根节点，提升效率。
- **union(x, y)**：将两个集合合并
  - 可使用按秩合并（按树的高度或大小）来减少树的高度，进一步加速 `find`。

##### 实现代码

```java
class UnionFind {
    int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return false; // 已连接，形成环
        parent[rootX] = rootY;
        return true; // 成功合并
    }
}

public boolean hasCycle(int n, int[][] edges) {
    UnionFind uf = new UnionFind(n);
    for (int[] edge : edges) {
        if (!uf.union(edge[0], edge[1])) {
            return true; // 找到环
        }
    }
    return false; // 无环
}

```

###### 注意事项

1. **只能用于无向图**：有向图不能用并查集检测环，需用 DFS+状态标记或拓扑排序。
2. **图节点编号从0开始，需注意索引范围是否需要映射**
3. 使用路径压缩和按秩合并可将并查集操作的时间复杂度优化为近似 `O(1)`
4. 并查集不适合动态添加/删除节点

###### 经验总结

| 点         | 说明                                |
| ---------- | ----------------------------------- |
| 🚀 效率高   | 对于边数量很多的稠密图，比 DFS 更快 |
| 🔒 简洁安全 | 合并过程天然避免重复连接            |
| 💡 适用性强 | 常用于构建最小生成树、图连通性判定  |
| 📛 适用范围 | 有向图检测环不能用，需要其他算法    |

#### Leetcode 261 以图判树

给定编号从 `0` 到 `n - 1` 的 `n` 个结点。给定一个整数 `n` 和一个 `edges` 列表，其中 `edges[i] = [ai, bi]` 表示图中节点 `ai` 和 `bi` 之间存在一条无向边。

如果这些边能够形成一个合法有效的树结构，则返回 `true` ，否则返回 `false` 。

##### 问题分析

- 图中有环就不是一棵树
- 图中有**无边节点**的情况，也不能称为一棵树

##### 实现方案-并查集

###### 在`union`函数中检查两个节点是否已经属于同一个集合

- 在`union(x,y)`检查`x`和`y`，是否属于一个集合，若属于，则返回`false`，否则合并

###### 并查集中记录剩余集合数量

- 每次成功合并两个节点之后，集合数量 `-1`;

##### 实现代码

```java
class UnionFind {
        int[] parent;
        int count;
        public UnionFind(int n){
            parent = new int[n];
            count = n;
            for (int i=0;i<n; i++){
                parent[i]=i;
            }
        }

        public int find(int x){
            if (parent[x] != x){
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public boolean union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY){
                return false;
            }
            parent[rootX] = rootY;
            count--;
            return true;
        }
    }
    public boolean validTree(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        for (int[] edge:edges){
            if (!uf.union(edge[0], edge[1])){
                return false;
            }
        }
        return uf.count == 1;
    }
```



#### 无向图中的环-Leetcode 684 冗余连接

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

##### 代码实现

```java
  public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        UnionFind uf = new UnionFind(n);
        int[] redundantEdge = new int[2]; 
        for (int[] edge: edges){
            int node1 = edge[0];
            int node2 = edge[1];
            int parent1 = uf.find(node1);
            int parent2 = uf.find(node2);
            if (parent1 == parent2){
                redundantEdge = edge;
            }else{
                uf.union(node1,node2);
            }
        }
        return redundantEdge;
    }


    class UnionFind{
	int[] parent;
	
	public UnionFind(int n){
        parent = new int[n+1];
    for (int i=1;i<=n;i++){
      parent[i]=i;
    }
	}
  
  public int find(int x){
    if (parent[x]!=x){
      parent[x] = find(parent[x]);
    }
    return parent[x];
  }
  
  public void union(int x, int y){
    int parentX = find(x);
    int parentY = find(y);
    if (parentX != parentY){
      parent[parentX] = parentY;
    }
  }
}
```

### 