#最大成功率/乘积路径-概率类图

#### 场景描述

从起点到终点，找**整体成功率**最大的路径，常见于推荐链条、任务依赖成功率、强化学习路径等。

#### 核心算法思想：Dijkstra+概率维护

最大路径概率=巨鹿概率乘积，堆优化

#### 实现套路 - 概率乘积可以变成log加法/贪心最大概率

##### Dijkstra 套路步骤一：定义当前节点State

```java
class State{
  int node;
  double probability;
  public State(int node, int probability){
    this.node = node;
    this.probability = probability;
  }
}
```

##### Dijkstra套路步骤二：初始化最大堆

```Java
PriorityQueue<State> pq = new PriorityQueue<>((a,b)->Double.compare(b.probability,a.probability));
pq.offer(new State(start,1.0d));
```

##### Dijkstra套路步骤三：初始化dist数组

```java
double[] probabilities = new double[n];
probabilities[start] = 1.0d;
```

##### Dijkstra套路步骤四：遍历更新优先队列和dist数组

```java
while (!pq.isEmpty()){
  State current = pq.poll();
  if (current.probability < probabilities[current.node]) continue;
  
  //注意这里的存储邻居节点的办法
  Map<Integer,Double> neighbors = graph.get(current.node);
  
  for (Map.Entry neighbor : neighbors){
    int neighborNode = neighbor.key;
    double weight = neighbor.value;
    if (probabilities[neighborNode] < probabilities[current]*weight){
      probabilities[neighborNode] = probabilities[current]*weight;
      pq.offer(new State(neighborNode, probabilities[neighborNode]));
    }
  }
}
```

##Leetocode 1514: Path with maximum probability 

##Leetcode 399: 除法问题