# 拓扑排序-任务调度或者依赖顺序执行

##场景描述

用于处理有依赖顺序的任务，如课程安排、构建系统的依赖库排序、编译顺序安排等

##通用应对策略 - BFS + 入度

- 拓扑排序（BFS/DFS）+入度记录

##核心算法思想

在**有向图**中，找一个线性排序，使得每条边从前向后

- 入度为`0`->可执行任务
- 依赖关系形成DAG

##实现策略

###基于BFS和入度的拓扑排序

####构造`indegree`数组和Graph

```java
int[] indegree = new int[n];
Map<Integer,List<Integer>> graph = new HashMap<>();
for(int[] edge : edges){
  int from = edge[0];
  int to = edge[1];
  
  graph.computeIfAbsent(from,x->new ArrayList<>()).add(to);
  indegree[to]++;
}
```

####将入度为0的节点加入队列

```java
Queue<Integer> queue = new LinkedList<>();
for (int i=0;i<n;i++){
  if (indegree[i]==0){
    queue.offer(i);
  }
}
```

####遍历和更新队列和入度数组

```java
while (!queue.isEmpty()){
  int node = queue.poll();
  res.add(node);
  
  List<Integer> neigbors = graph.get(node);
  for (int neighbor : neigbors){
    indegree[neighbor] -= 1;
    if (indegree[neighbor] == 0){
      queue.offer(neighbor);
    }
  }
}
```

###基于DFS+三色方案的拓扑排序-后续研究

```java
int[] state = new int[n]; // 0=未访问, 1=访问中, 2=已完成
Stack<Integer> order = new Stack<>();

boolean dfs(int node, Map<Integer, List<Integer>> graph) {
    if (state[node] == 1) return false;
    if (state[node] == 2) return true;

    state[node] = 1;
    for (int nei : graph.getOrDefault(node, new ArrayList<>())) {
        if (!dfs(nei, graph)) return false;
    }
    state[node] = 2;
    order.push(node);
    return true;
}
```

##注意事项与陷阱

###### 若图中有环，则无法进行拓扑排序

###### 注意入度数组初始化与边界

##Leetcode 802:[Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/)

There is a directed graph of `n` nodes with each node labeled from `0` to `n - 1`. The graph is represented by a **0-indexed** 2D integer array `graph` where `graph[i]` is an integer array of nodes adjacent to node `i`, meaning there is an edge from node `i` to each node in `graph[i]`.

A node is a **terminal node** if there are no outgoing edges. A node is a **safe node** if every possible path starting from that node leads to a **terminal node** (or another safe node).

Return *an array containing all the **safe nodes** of the graph*. The answer should be sorted in **ascending** order.

###问题分析

####场景和概念描述

- 有一个有`n`个节点的图，节点的编号从`0` 到`n-1`。

- 图是用一个从`0`开始的二维数组`graph[][]`来表示的：
  - `graph[i]`表示节点`i`所有的邻居节点，也就以为是从节点`i`到这些邻居节点之间各自有一条边
- 如果一个节点的**出度**为`0`，那么该节点被称为**终端节点**
  - 如果一个从一个节点所出发的所有路径的终点属于下列类型，那么这个节点是一个**安全节点**
    - 是一个**终端节点**
    - 或者是另外一个**安全节点**

###问题的本质要求 - 找出所有不会进入环的节点

返回一个包图中含所有**安全节点**的数组，并且按照**升序**排序。

####问题的本质-找出图中所有不会进入环的节点

如果说一条路径无法达到**终端节点**，那么一定说明该路径中存在**环**。

那么问题就变成：找到所有满足下列条件的节点：

**从该节点出发的所有的路径都不会存在环**

对于每个**安全节点**，最终都只能到达安全节点，或者终端节点，不会进入环。

###核心思想：反向图+拓扑排序

我们需要找到所有**不会到达环**的节点。

我们通过构造一个反向图，那么反向图中每一个节点的入度，就是原图中对应节点的出度。

将图反转之后，我们采用拓扑排序的方式对图进行遍历。

如果一个节点在反向图中的出度被更新为0，则说明该节点不在环中，也不会到达环。

将该节点标记为安全，并且入队。

采用反向图+拓扑排序判断哪些节点最终是安全的。

- 环上的节点是不安全的
- 非环上的节点，并且所有能够达到节点也是安全的，那么该节点也是安全的

###实现原理

####建立反向图：找到所有能从终端节点到达的节点

将所有的原图中的边**翻转**：`u->v`，反向为`v->u`

####记录反向图每个节点的入度

反向图中每个节点的入度，就是原图中每个节点的出度。

从出度为`0`的节点开始，进行反向BFS

- 每次移除一个节点，更新其前驱节点的出度
- **一旦出度为`0`，说明他的所有后继都是安全的**，它也是安全的

####所有被标记为安全的节点，按照升序返回

在BFS过程中持续更新每个节点的**出度**，如果节点的出度为0，将其**标记为安全**，并加入队列。

###实现代码

####构建反向图

```java
private Map<Integer,List<Integer>> reverseGraph(int[][] graph,int n){
  Map<Integer,List<Integer>> reversedGraph = new HashMap<>();
  int n = graph.length;
  for (int i=0; i<n;i++){
    int[] neighbors = graph[i];
    for (int neighbor: neighbors){
      map.computeIfAbsent(neighbor,x->new ArrayList<>()).add(i);
    }
  }
  
  for (int i = 0; i< n; i++){
    reversedGraph.putIfAbsent(i,new ArrayList<>());
  }
  
  return reversedGraph;
}
```

####计算原图中每个节点的出度 - 也就是反向图中的入度

```java
int[] outDegree = new int[n];
for(int i = 0; i < n; i++){
  outDegree[i] = graph[i].length;
}
```

####初始化BFS队列,将所有原图出度为0的节点入队

```java
Queue<Integer> queue = new LinkedList<>();
for (int i=0; i < n; i++){
  if (outDegree[i] == 0){
    queue.offer(i);
  }
}
```

####遍历和更新BFS 队列

```java
boolean[] safe = new int[];
while (!queue.isEmpty()){
  int current = queue.poll();
  safe[current] = true;
  for (int prev : reversedGrap.get(current)){
    outDegree[prev]--;
    if (outDegree[prev] == 0){
      queue.offer(prev);
    } 
  }
}
```

####查找并排序安全节点

```java
List<Integer> res = new ArrayList<>();
for (int i=0; i<n;i++){
  if (safe[i]){
    res.add(i);
  }
}

return res;
```

###注意事项

- **不能直接 DFS 判环后打标记返回结果**，否则可能反复访问某些状态，超时或错误。

- 使用 **反图** 关键在于：从终点出发往回找，可以确保安全性。

- 拓扑排序是关键：**如果某个点所有出边都指向安全节点，那么它也是安全的。**

###经验总结

| 方面     | 总结                                                       |
| -------- | ---------------------------------------------------------- |
| 图类型   | 有向图，可能存在环                                         |
| 技巧     | 拓扑排序（反向建图+出度统计）                              |
| 场景泛化 | 与判断课程是否能完成、检测是否有死锁等问题有相似建模方法   |
| 易错点   | DFS判环时未剪枝、未打缓存、反图构建错误、拓扑顺序处理失误  |
| 拓展     | 可扩展到需要判断**哪些任务最终一定能完成**的工作流分析场景 |

##Leetcode 269: 火星词典

现有一种使用英语字母的火星语言，这门语言的字母顺序对你来说是未知的。

给你一个来自这种外星语言字典的字符串列表 `words` ，`words` 中的字符串已经 **按这门新语言的字典序进行了排序** 。

如果这种说法是错误的，并且给出的 `words` 不能对应任何字母的顺序，则返回 `""` 。

否则，返回一个按新语言规则的 **字典递增顺序** 排序的独特字符串。如果有多个解决方案，则返回其中 **任意一个** 。

###问题分析与本质

####问题分析

- 每个字符都只包含小写字母
- `words`是按照该语言的字典顺序排序的
- 输出满足排序规则的所有字母的一个有效顺序，如果不存在，返回空字符串
- 若有多个合法顺序，返回其中任意一个

####问题的本质-拓扑排序

抽象建模：

- 字母是图中的节点
- 相邻的两个单词中，**第一个不同的字母**`a`和`b`，意味着`a->b`
- 我们基于这些关系构建有向图，对图进行排序即可得到字母顺序

###核心思想-图是怎么构建的？

####怎样构建图？- 相邻两个词语中第一个不同的字符构成一条有向边`c1->c2`

从相邻单词中提取字母顺序关系，构建有向图

####统计入度

注意一开始需要收集**所有单词中出现的每一个字母**，并且将其入度设置默认为0.

注意需要确保indegree中包含所有字母的信息，所以需要遍历单词中所有的字母。

外星文并不一定完整包含26个英文字母，因此不要使用数组的方式统计入度。

在遍历单词的时候，再次记录更新具体字母的入度。

####拓扑排序

- 将入度为 0 的节点加入队列。
- 每取出一个节点，就将它指向的节点入度减 1，若减为 0，则加入队列。
- **最后若排序结果长度 != 总字母数**，说明有环，返回 `""`。**注意不是按照剩余入度是否全部为0来判断**

###代码实现

####初始化图的邻接表和入度数组

找出所有字符串中的所有字符，对于每一个字符`c`：

- `indegree[c]=0`
- `graph[c]=[]`

```Java
        Map<Character,Set<Character>> graph = new HashMap<>();
        Map<Character, Integer> indegree = new HashMap<>();

        //初始化图和入度
        for(String word : words){
            for(char c : word.toCharArray()){
                graph.putIfAbsent(c, new HashSet<>());
                indegree.putIfAbsent(c, 0);
            }
        }
```

####填充图和入度数组-相邻两个词语中的第一个不同字符构成一条有向边

对比相邻的两个word：`word[i]`和`word[i+1]`

- 如果`word[i+1]`是`word[i]`的前缀，将会导致顺序无法确定，直接返回`""`(为什么呢？)
- 找出`word[i]`和`word[i+1]`中**第一个不同的字符**（`c1`和`c2`）,这样可以确定在有向图中，`c1 -> c2`
- 利用上述关系，更新图的邻接表
  - `graph[c1].add(c2)`
  - `indegree[c2]++`

```java
        int n = words.length;
        //
        for(int i = 0; i < n - 1; i++){
            String word1 = words[i];
            String word2 = words[i+1];
						//如果第二个词是第一个词的前缀，直接返回""，表示无法排序
            if(word1.length() > word2.length() && word1.startsWith(word2)){
                return "";
            }

            int minLen = Math.min(word1.length(), word2.length());
            for(int j = 0; j < minLen; j++){
                char c1 = word1.charAt(j);
                char c2 = word2.charAt(j);
                if(c1 != c2){
                    //注意检查，不要重复计算入度
                    if(graph.get(c1).add(c2)){
                        indegree.put(c2, indegree.get(c2) + 1);
                    }
                  //找到第一个不同的字符以后就立即停止循环
                    break;
                }
            }
        }
```

####使用拓扑排序对图中的节点进行排序-基于BFS的拓扑排序套路

```java
        StringBuilder res = new StringBuilder();
        Set<Character> visited = new HashSet();

        Queue<Character> queue = new LinkedList<>();
        for(char c : indegree.keySet()){
            if(indegree.get(c) == 0){
                queue.offer(c);
                visited.add(c);
            }
        }

        while(!queue.isEmpty()){
            char curr = queue.poll();
            res.append(curr);

            Set<Character> nexts = graph.getOrDefault(curr, new HashSet<>());
            for(char next : nexts){
                if(visited.contains(next)) continue;
                int in = indegree.get(next);
                indegree.put(next,in - 1);
                if(indegree.get(next) == 0){
                    queue.offer(next);
                    visited.add(next);
                }
            }
        }
```

###注意事项

####非法情况

如果一个字符串比后一个字符串长，并且后一个字符串是其前缀，在**任何排序情况下都不合法**

####多个起点

拓扑排序时可能有**多个入度为0 的节点，任意顺序都可以**

####图中不是每个字母都有边

所以在初始化入度表和图的时候必须对**所有字母**初始化

####有环检测

最后结果长度不等于所有字母总数，说明图中存在环，无法得到合法排序

#### 注意比较两个单词时找到第一个不同的字符之后跳出循环

一旦找到两个单词中第一个不相同的字符之后，就可以确定两个字符之间的先后顺序。

此时应单立即停止继续寻找后面的字符，继续寻找后面的字符就失去了意义，并且会污染最重的结果。

因此应该使用`break`关键字终止当前的比较循环。

#### 不要重复计算入度

发现两个单词之间的第一个不同字符时，更新两个字符之间的依赖关系时，有可能依赖关系是已经存在的。

因此每次添加新的依赖关系时，需要确认依赖关系是否已经存在，如果已经存在，则不能够更新入度记录，否则会出现错误的结果。

###经验总结

- 这是一个经典的**字母之间的顺序约束->拓扑排序**问题
- 面对排序问题，要能联想到**依赖关系**，**图建模**，**有向边**，**入度**这些关键词
- 注意构建图的过程中的非法输入判断
- 对BFS拓扑排序熟练掌握时关键，常常与**课程安排**、**任务依赖**等问题共通

##Leetcode 1136  Parallel Courses (平行课程)

###问题要点

**输入**: `N` 门课程（编号从 1 到 `N`），以及一个 `relations` 数组，其中 `relations[i] = [prevCourse_i, nextCourse_i]` 表示 `prevCourse_i` 是 `nextCourse_i` 的先修课程。

**目标**: 计算修完所有课程所需的最少学期数。

**规则**:

- 在一个学期内，你可以同时修任意多门课程。
- 要修一门课，它的所有先修课程都必须在前一个或更早的学期修完。

**特殊情况**: 如果课程之间存在循环依赖（例如，A是B的先修，B是C的先修，C又是A的先修），导致无法完成所有课程，则返回 -1。

###问题的本质和分析 - 图的BFS遍历问题

这个问题的本质可以抽象成一个图论问题。

1. **图的建模**:
   - **节点 (Vertices)**: 每一门课程可以看作是图中的一个节点。
   - **有向边 (Directed Edges)**: 每一个先修关系 `[prev, next]` 可以看作是一条从节点 `prev` 指向节点 `next` 的有向边。这条边 `prev -> next` 的含义是：必须先访问完节点 `prev`，才能访问节点 `next`。
2. **问题的转化**:
   - **“修完所有课程”**: 意味着需要遍历图中的所有节点。
   - **“先修课程要求”**: 这正是**拓扑排序 (Topological Sorting)** 的定义。拓扑排序是对有向无环图（DAG）的顶点进行排序，使得对于每一条有向边 `u -> v`，节点 `u` 都出现在节点 `v` 之前。
   - **“最少学期数”**: 在一个学期里，我们可以修完所有没有先修课程（或者所有先修课程都已完成）的课程。这相当于在图中，我们可以同时处理所有入度（in-degree）为 0 的节点。处理完这些节点后，它们的后继节点的入度会减少，其中一些新的节点入度也可能变为 0，成为下一个学期可以修的课程。这个逐层处理的过程，与**广度优先搜索 (BFS)** 的思想高度吻合。
   - **“无法完成”**: 如果图中存在**环 (Cycle)**，那么环上的节点入度永远不可能变为 0，导致拓扑排序无法完成。例如 `A -> B -> C -> A`，A依赖C，C依赖B，B依赖A，永远无法开始。

**结论**: 这个问题的本质是：**在一个有向图中，检测是否存在环。如果无环（即是一个有向无环图 DAG），则求出这个图的“最长路径”的长度。** 这里的“最长路径”是指从起点（入度为0的节点）到终点（没有后继节点的节点）所经过的节点数。每个学期处理一层节点，总学期数就等于这个分层图的总层数，也就是最长路径的长度。

### 实现代码

```Java
//n个课程 1-n
//relations[i] = [prev_i, next_i]
//每个学期你可以学习任意数量课程，前提是他们的前置课程都已经完成了
//BFS多源
class Solution {
    public int minimumSemesters(int n, int[][] relations) {
         Map<Integer,Set<Integer>> graph = new HashMap<>();
         Map<Integer, Integer> indegree = new HashMap<>();

         for(int i = 1; i <=n; i++){
            graph.put(i, new HashSet<>());
            indegree.put(i, 0);
         }

         for(int[] relation : relations){
            int prev = relation[0];
            int next = relation[1];
            if(graph.get(prev).add(next)){
                indegree.put(next, indegree.get(next) + 1);
            }
         }

         Queue<Integer> queue = new LinkedList<>();
         Set<Integer> visited = new HashSet<>();
         int semesters = 0;
        for(int i = 1; i <= n; i++){
            if(indegree.get(i) == 0){
                queue.offer(i);
                visited.add(i);
            }
        }

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int curr = queue.poll();
                Set<Integer> nexts = graph.get(curr);
                for(int next : nexts){
                    if(visited.contains(next)) continue;

                    int in = indegree.get(next);
                    if(in == 1){
                        queue.offer(next);
                        visited.add(next);
                    }
                    indegree.put(next, in-1);
                }
            }
            semesters++;
        }

        return visited.size() == n ? semesters : -1;
    }
}

    
```

