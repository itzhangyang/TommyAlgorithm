# 路径是否存在（判断某个节点能否到达另一个节点）

给定起点和终点，判断是否能从起点到达终点，例如：

- 验证服务 A 是否能请求到服务 B（微服务可达性）
- 判断网络中的两个节点是否联通
- 验证用户是否有权限进入某些“门”或“房间”

##通用应对策略：使用DFS或者BFS

##核心算法思想：连通性检测

从起点是否能够访问终点

##实现套路

###复习-BFS套路

```java
public boolean bfs(Map<Node, List<Node>> graph, Node start, Node target){
  if (start == target){
    return true;
  }
  
  Queue<Node> queue. = new Queue<>();
  queue.offer(start);
  
  Set<Node> visited = new HashSet<>();
  visited.add(start);
  
  while (!queue.isEmpty()){
    Node node = queue.poll();
    if (node == target){
      return true;
    }
    List<Node> neighbors = grap.getOrDefault(node, new ArrayList<>());
    for (Node neighbor:neighbors){
      if (!visited.contains(neighbor)){
        queue.offer(neighbor);
      }
    }
  }
  
  return true;
}
```

###复习- DFS 套路

```java
public boolean dfs(Map<Node, List<Node>> graph, Node current, Node target, Set<Node> visited){
  if (current == target){
    return true;
  }
  
  List<Node> neighbors = graph.get(current);
  
  for (Node neighbor:neighbors){
    if (dfs(graph,neighbor,target,visited)){
      return true;
    }
  }
  
  return false;
}
```

##Leetcode 1971:寻找图中是否存在路径

### 问题要点

有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。

图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。

 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。

给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。

####问题本质

####掉坑里了-什么是他妈的双向图？

双向图就是两个点之间存在一个边，这个边是双向的，说白了大约就是一个**有向图**。

####双向图构建邻接表的时候的逻辑-需要添加两次map

- `map.get(edge[0]).add(edge[1])`
- `map.get(edge[1].add(edge[0]))`

```java
    for (int[] edge : edges ){
            List<Integer> neighbors1 = map.get(edge[0]);
            if (neighbors1 == null){
                neighbors1 = new ArrayList<>();
            }
            neighbors1.add(edge[1]);
            map.put(edge[0],neighbors1);

            List<Integer> neighbors2 = map.get(edge[1]);
            if (neighbors2 == null){
                neighbors2 = new ArrayList<>();
            }
            neighbors2.add(edge[0]);
            map.put(edge[1],neighbors2);
        }
```

####所以问题就变成了在双向图中寻找是否存在路径

使用简单的BFS或者DFS套路就可以搞定。

###代码实现

```java
   public boolean validPath(int n, int[][] edges, int source, int destination) {
        if(source == destination){
            return true;
        }
        Map<Integer,List<Integer>> graph = getGraph(n, edges);


        Queue<Integer> queue = new LinkedList<>();
        queue.offer(source);

        boolean[] visited = new boolean[n];
        visited[source] = true;

        while (!queue.isEmpty()){
            int current = queue.poll();
            if (current == destination){
                return true;
            }
            List<Integer> nexts = graph.get(current);
            for (int next : nexts){
                if (!visited[next]){
                    queue.offer(next);
                    visited[next] = true;
                }
            }
        }

        return false;


    }

    private Map<Integer, List<Integer>> getGraph(int n, int[][] edges){
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int[] edge : edges ){
            List<Integer> neighbors1 = map.get(edge[0]);
            if (neighbors1 == null){
                neighbors1 = new ArrayList<>();
            }
            neighbors1.add(edge[1]);
            map.put(edge[0],neighbors1);

            List<Integer> neighbors2 = map.get(edge[1]);
            if (neighbors2 == null){
                neighbors2 = new ArrayList<>();
            }
            neighbors2.add(edge[0]);
            map.put(edge[1],neighbors2);
        }

        for (int i = 0; i < n; i++){
            if (map.get(i) == null){
                map.put(i, new ArrayList<>());
            }
        }

        return map;
    }
```

##Leetcode 841 钥匙和房间

有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套 **不同的钥匙**，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。

##### 将问题转化为有向图

##### 实现原理-BFS

##### 实现代码

```java
// BFS + visited?
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        visited[0]=true;
        int visitedCount = 1;

        while (!queue.isEmpty()){
            int room = queue.poll();
            List<Integer> nexts = rooms.get(room);

            for (int next: nexts){
                if (!visited[next]){
                    queue.offer(next);
                    visited[next] = true;
                    visitedCount++;
                }
            }
        }
        
        return visitedCount == n;
    }
```

##Leetcode 1466 重新规划路线-最小反转路径数量

### 问题要点

给定 `n` 个城市，编号从 `0` 到 `n-1`，以及 `n-1` 条路 `connections`。

这是一个**树形结构**（`n` 个城市，`n-1` 条路，保证连通）。

`connections[i] = [ai, bi]` 表示一条从城市 `ai` 到 `bi` 的单向道路。

**目标**：你需要从城市 `0` 出发，能够到达所有其他城市。为了实现这个目标，你可以改变一些道路的方向。请计算需要改变方向的**最少**道路数量。

简单来说，就是要让整个路网形成一个以 `0` 为根节点的有向树，所有边都指向根节点 `0` 的方向。

问最少需要翻转多少条边？

###问题本质 - 最小反转边数的问题

#### 最终状态 - 所有城市都能够到达首府

所有城市都能到达城市 `0`。

这意味着，对于任何一个非 `0` 的城市 `c`，都必须存在一条路径 `c -> ... -> 0`。

#### 树形结构 - 保证每个城市都有一条无向边通向首府

题目保证了图的结构是一棵树。

这意味着任意两个城市之间都存在**唯一**的一条"无向"路径。

这个特性非常重要，它简化了问题，我们不需要考虑环路或者多个路径选择的问题。

#### 反转代价: 当前的路是否朝向城市0？

每条路都有一个初始方向。

如果这个方向与我们期望的“朝向 `0`” 的方向一致，那么代价是 `0`；

如果不一致，我们就需要翻转它，代价是 `1`。

#### 核心任务 - 计算方向背离的边的数量

计算有多少条边的初始方向是“背离 `0`”的。

#### 想象一下具体的场景

想象一下，我们从城市 `0` 开始，像水流一样向外扩散，遍历整个城市网络。

当我们从一个已访问的城市 `A` 走向一个未访问的城市 `B` 时：

- 如果原始的道路是 `A -> B`，这意味着这条路是指向**远离** `0` 的方向。为了让 `B` 能够回到 `0`，这条路的方向必须被翻转。所以，需要翻转的边数量 `+1`。
- 如果原始的道路是 `B -> A`，这意味着这条路本身就是指向**朝向** `0` 的方向。我们不需要做任何改变。

因此，问题被转化为：**从 `0` 节点开始遍历整个图，统计所有“出度”的边的数量。**

### 核心思想和套路 - 树的遍历（深度优先或者广度优先）

将问题转化为图的遍历问题，从节点 `0` 开始，统计所有与遍历方向相同的原始边的数量。

#### 建立图的邻接表

因为我们需要双向遍历（从 `0` 出发，不管原始方向），但同时又要能区分原始边的方向，所以邻接表的结构需要特殊设计。

一个常见的做法是，对于一条边 `u -> v`，我们在邻接表中同时添加 `u` 到 `v` 的边和 `v` 到 `u` 的边，但给它们一个标记来区分方向。

- 例如，`adj[u]` 中可以存储一个 `Pair` 或 `int[]`，如 `{v, 1}` 表示一条原始的 `u -> v` 的边（正向边）。
- 相应地，在 `adj[v]` 中存储 `{u, 0}` 表示这是一条“反向”添加的、为了遍历而存在的边（反向边）。

#### 从0开始遍历

使用 DFS 或 BFS，从节点 `0` 开始。

#### 维护`visited`记录

创建一个 `boolean` 数组 `visited` 来防止重复访问节点，避免在树（无向图）中来回走。

#### 更新计数

在遍历过程中，当我们从节点 `u` 访问到邻居节点 `v` 时：

- 检查我们添加在 `adj[u]` 中的这条边的标记。
- 如果标记是 `1`（表示原始方向是 `u -> v`），说明这是一条背离 `0` 的边，计数器加一。
- 如果标记是 `0`（表示原始方向是 `v -> u`），说明这是一条朝向 `0` 的边，无需操作。

遍历结束后，计数器的值就是最终答案。

###实现原理 - 基于 DFS

####构建双向图结构，同时记录原始方向的信息

- 用`Map<Integer, List<Integer>>`构建双向图
- 用`Set<String> directedEdges`记录原始边的方向

####DFS 从节点0开始遍历

对于任何一个节点，从节点一直到末梢，它需要反转的路径的数量是

- 如果当前节点和后续节点之间的边需要反转 则+1，以及
- 后续路径上需要反转的边的数量



- 如果遇到的方向是`current-neighbor`，并且这个方向存在于原始输入里，就要反转，计数+1
- 如果边方向是`neighbor->current`，代表已经是从`neighbor`到`current`,也就是目标方向，不需要反转

###实现代码

####DFS 统计需要反转的边的数量

```java
private int dfs(int current,Map<Integer,List<Integer>> graph, Set<String> directedEdges, boolean[] visited){
  visited[cur] = true;
  //对于任何一个节点，需要反转的数量 
  int change = 0;
  
  for (int neighbor : graph.getOrDefault(current, new ArrayList<>())){
    if (!visited(neighbor)){
      if (directedEdges.contains(current +"->"+"neighbor")){
        change++;
      }
      
      change += dfs(neighbor,graph,directedEdges,visted);
    }
  }
  
  return change;
}
```

####构建双向图并保存原来的方向

```java
Map<Integer, List<Integer>> graph = new HashMap<>();
String<String> directedEdges = new HashSet<>();

for (int[] conn : connections){
  int from  = conn[0];
  int to = conn[1];
  
  grap.computeIfAbsent(from, x -> new ArrayList<>()).add(to);
  graph.computeIfAbsent(to, x-> new ArrayList<>()).add(from);
  
  directedEdges.add(from+"->"+to);
}
```

####调用DFS过程遍历双想吐

```java
boolean[] visited = new boolean[n];
return dfs(0,graph,directedEdges,visited);
```

###注意事项

- **图建错方向会导致遍历不全或死循环**。一定要构建**无向图进行遍历**，同时用单独结构记录“哪些是原始方向”。

- **不要直接在原图上改方向**，这道题只要求你统计需要修改的边数。

- 遍历使用 DFS 和 BFS 都可以，推荐 DFS 更直观。

###经验总结

| 点       | 内容                                                 |
| -------- | ---------------------------------------------------- |
| 核心算法 | 图遍历（DFS）+ 有向边记录                            |
| 难点     | 如何构建图并判断边方向是否需要反转                   |
| 技巧     | 将所有边当作无向边建图，再从城市0开始 DFS 遍历       |
| 应用     | 有向图转无向图、原始方向记录、多源可达路径问题       |
| 常见错误 | 直接在原始方向上遍历、没有处理访问标记、方向判断错误 |

## Leetcode 490: 足球走迷宫

//详细见回溯章节

###基于BFS的实现

```Java
//足球走迷宫的逻辑
//参考是否能够在目的地停下
//一次走的步数需要注意
class Cell{
    int row;
    int col;
    public Cell(int row, int col){
        this.row = row;
        this.col = col;
    }
}
class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        int rows = maze.length;
        int cols = maze[0].length;
        int startRow = start[0];
        int startCol = start[1];

        int endRow = destination[0];
        int endCol = destination[1];

        Queue<Cell> queue = new LinkedList<>();
        boolean[][] visited = new boolean[rows][cols];
        queue.offer(new Cell(startRow, startCol));
        visited[startRow][startCol] = true;
        
        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
        while (!queue.isEmpty()) {
            Cell curr = queue.poll();
            if(curr.row == endRow && curr.col == endCol){
                return true;
            }

            for(int[] dir : dirs){
                int nextRow = curr.row+dir[0];
                int nextCol = curr.col+dir[1];
                int finalRow = curr.row;
                int finalCol = curr.col;
                while (isValidPosition(nextRow, nextCol, maze)) {
                    finalRow = nextRow;
                    finalCol = nextCol;
                    nextRow = nextRow + dir[0];
                    nextCol = nextCol + dir[1];
                }

                if(!visited[finalRow][finalCol]){
                    queue.offer(new Cell(finalRow, finalCol));
                    visited[finalRow][finalCol] = true;
                }
            }
        }

        return false;
        
    }

    private boolean isValidPosition(int row, int col,int[][] maze ){
        int rows = maze.length;
        int cols = maze[0].length;

        if(row < 0 || row >= rows){
            return false;
        }
        if(col < 0 || col >= cols){
            return false;
        }

        if(maze[row][col] == 1){
            return false;
        }

        return true;
    }
}
```



## Leetcode 505: 迷宫II

### 问题要点

**网格图 (Grid)：** 题目背景是一个 0-1 矩阵，0 是通路，1 是墙。

**移动规则：** 球不是一格一格走的。它一次 "移动" 是指选定一个方向（上、下、左、右）然后一直滚动，直到遇到墙或边界才停止。

**"停止点"：** 只有在 "停止点"，球才能改变方向。

**"代价" (Cost)：** 题目要求的是 "最短距离"。一次 "移动" 的代价（cost）不是 1，而是这次滚动所经过的**步数**（格数）。

**目标：** 计算从 `start` 到 `destination` 的**最小总代价（总距离）**。

**不可达：** 如果无法到达终点，返回 -1。

### 问题本质和分析 - 边的权重 (Edge Weight) 是什么

- **这是图论问题吗？** 是的。
- **节点 (Nodes) 是什么？** 迷宫中的每一个**格子 `(r, c)`** 都可以被视为一个图的节点。
- **边 (Edges) 是什么？** 边是连接两个**"停止点"** 的路径。如果球从 `(r1, c1)`（一个停止点）开始朝某个方向滚动，最终停在了 `(r2, c2)`，那么在 `(r1, c1)` 和 `(r2, c2)` 之间就有一条有向边。
- **边的权重 (Edge Weight) 是什么？** 这条边的权重**不是 1**，而是从 `(r1, c1)` 滚动到 `(r2, c2)` 所经过的**步数**（距离）。
- **问题转化：** 整个问题被转化为：在一个**带权有向图**中，找到从 `start` 节点到 `destination` 节点的**最短路径**。

### 规律观察 - 加权图的最短路径问题

**与 "The Maze I" (LC 490) 的对比：**

- LC 490 只问 "是否可达"。我们不关心路径长度，只关心连通性。因此，边的权重是 1（代表 "一次移动"），使用标准 BFS 或 DFS 即可。BFS 可以找到 "最少移动次数"，但不是 "最短滚动距离"。

**与标准 BFS 的对比：**

- 标准 BFS (Breadth-First Search) 用于解决**无权图**的最短路径问题。它假设每条边的权重都是 1。
- 在本题中，边的权重（滚动的距离）是**可变的**。
- 例如，从 `(0,0)` 到 `(0,5)` 可能 cost = 5，而从 `(0,0)` 到 `(3,0)` 可能 cost = 3。
- 如果使用标准 BFS（基于 FIFO 队列），我们可能会先处理一个总距离为 10 的路径（因为它可能只需要 2 次移动），而忽略一个总距离为 8 但需要 3 次移动的路径。这是错误的。

**结论：** 既然是**带权图**（且所有权重都是非负的）的最短路径问题，我们应该使用 **Dijkstra 算法**。



### 模式套路匹配 - Dijstra算法

- **模式：** 网格图 (Grid) + 最短路径 (Shortest Path)。
- **子模式：** 边的权重不统一 (Non-uniform edge weights)。
- **匹配算法：** **Dijkstra 算法**。
- **Dijkstra 的核心：** 它是一种贪心算法。它不使用先进先出的队列（Queue），而是使用**优先队列 (Priority Queue)**。优先队列确保我们总是优先处理 "当前总距离最小" 的节点。

### 核心思想和套路 - Dijstra + 模拟球滚动

####**状态定义：** `dist`

我们需要一个数据结构来记录从 `start` 到达迷宫中**每一个格子** `(r, c)` 的最短距离。

- `int[][] dist = new int[m][n]`
- `dist[r][c]` 表示从 `start` 滚到 `(r, c)` 这个格子的**最短总距离**。
- 初始化所有 `dist[r][c]` 为无穷大（例如 `Integer.MAX_VALUE`），表示尚未访问。
- `dist[start[0]][start[1]] = 0`，因为起点到起点的距离是 0。

####**优先队列 (Min-Heap)：**

- `PriorityQueue<int[]> pq`
- 队列中存储的是 `[row, col, distance]`。
- `distance` 是从 `start` 到 `(row, col)` 的**当前已知**的最短距离。
- 优先队列会根据 `distance` **从小到大**排序。

####**Dijkstra 算法流程：**

- 将起点 `[start[0], start[1], 0]` 加入 `pq`。

- 当 `pq` 不为空时，循环执行：

   a.  从 `pq` 中取出**当前距离最小**的节点 `curr = [r, c, d]`。

   b.  **（重要优化）** 如果 `d > dist[r][c]`，说明这是一个 "过时" 的状态。我们之前已经通过另一条更短的路径到达过 `(r, c)`，所以直接 `continue`，跳过这个状态。 

  c.  从 `(r, c)`（这是一个停止点）出发，模拟向 4 个方向（上、下、左、右）的滚动。 

  d.  **模拟滚动（以 "向右" 为例）：** * 从 `(r, c)` 开始，`steps = 0`。 * `new_c = c`。 * 当 `(r, new_c + 1)` 仍在边界内且不是墙时： * `new_c++` * `steps++` * 循环停止时，球停在了 `(r, new_c)`。 

  e.  **松弛 (Relaxation)：** * 我们从 `(r, c)` 滚到了新的停止点 `(r, new_c)`，花费了 `steps` 步。

   到达 `(r, c)` 的最短距离是 `d` (即 `dist[r][c]`)。 

   到达 `(r, new_c)` 的**新路径总距离**为 `newDist = d + steps`。 

  **判断：** 如果 `newDist < dist[r][new_c]`： 

  说明我们找到了一个到达 `(r, new_c)` 的**更短**的路径！

  更新 `dist[r][new_c] = newDist`。 

  将这个新状态 `[r, new_c, newDist]` 加入优先队列 `pq`，以便后续从这个新停止点出发继续探索。

- 循环结束后，`dist[destination[0]][destination[1]]` 就是答案。

- 如果它仍然是 `Integer.MAX_VALUE`，说明终点不可达，返回 -1。

### 实现原理和步骤

#### 初始化距离数组`dist[row][col]`: 从start到`grid[row][col]`的最短路径

获取迷宫的行数 `m` 和列数 `n`。

创建 `dist[m][n]` 数组，并用 `Integer.MAX_VALUE` 填充。

####创建和初始化优先队列：按照Pair.dist进行排序

创建优先队列 `pq`，排序规则是比较数组的第 3 个元素（距离）。

初始化起点：`dist[start[0]][start[1]] = 0`，并将 `[start[0], start[1], 0]` 加入 `pq`。

#### 遍历所有节点不断更新最短距离

定义 4 个方向数组 `dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}`。

`while (pq.isEmpty() == false)` 循环：

`curr = pq.poll()`，获取 `r, c, d`。

检查是否为**过时状态**：`if (d > dist[r][c]) continue;`。

`for (int[] dir : dirs)` 遍历 4 个方向：

初始化滚动模拟：`nr = r`, `nc = c`, `steps = 0`。

##### **模拟滚动 `while` 循环：**

 检查**下一个**位置 `(nr + dir[0], nc + dir[1])` 是否有效（在边界内且不为墙）。

`while (isValid(nr + dir[0], nc + dir[1], m, n, maze))`：

- `nr += dir[0]`
- `nc += dir[1]`
- `steps++`

`while` 循环结束后，`(nr, nc)` 是新的停止点，`steps` 是滚动的距离。

#####**松弛操作：**

`if (d + steps < dist[nr][nc])`：

- `dist[nr][nc] = d + steps`
- `pq.offer(new int[]{nr, nc, dist[nr][nc]})`

循环结束后，获取 `result = dist[destination[0]][destination[1]]`。



返回 `result == Integer.MAX_VALUE ? -1 : result`。

### 实现代码

```Java
//返回最小路径
//最小路径应该使用啥算法？
//注意一条路径的长度应当是滚动一次的长度
//所以每条边的长度是不一样的
//求加权最小路径长度，应该使用Dijstra算法（求无权最小路径长度，应该使用BFS）
//Dijstra算法套路是啥？
//初始化
//定义结构Pair{ int node, int dist}
//定义dist[i] = start到i的最短距离
//定义优先级队列PriorityQueue<Pair> 按照dist从小到大排序

//本题的主要思路？
//构造Graph，每一次滚动的两端则是两个端点，滚动的格子数量就是边的长度
//并非是每一个格子都是node
//
class Pair{
    int row;
    int col;
    int dist;
    public Pair(int row, int col, int dist){
        this.row = row;
        this.col = col;
        this.dist = dist;
    }
}
class Solution {
    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        int rows = maze.length;
        int cols = maze[0].length;
        int[][] dist = new int[rows][cols];

        for(int[] d : dist){
            Arrays.fill(d, Integer.MAX_VALUE);
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.dist - b.dist);
        pq.offer(new Pair(start[0], start[1], 0));

        while(!pq.isEmpty()){
            Pair curr = pq.poll();
            int currentDist = curr.dist;
            int currentRow = curr.row;
            int currentCol = curr.col;

            if(currentDist > dist[currentRow][currentCol]){
                continue;
            }

            for(int[] dir : dirs){
                int nextRow = currentRow;
                int nextCol = currentCol;
                int weight = 0;

                while(nextRow+dir[0] >= 0 && nextRow + dir[0] < rows
                && nextCol + dir[1] >= 0 && nextCol + dir[1] < cols
                && maze[nextRow + dir[0]][nextCol + dir[1]] == 0){
                    nextRow += dir[0];
                    nextCol += dir[1];
                    weight += 1;
                }

                if(dist[nextRow][nextCol] > currentDist + weight){
                    dist[nextRow][nextCol] = currentDist + weight;
                    pq.offer(new Pair(nextRow, nextCol,dist[nextRow][nextCol]));
                }
            }
        }

        return dist[destination[0]][destination[1]] == Integer.MAX_VALUE ? -1 : dist[destination[0]][destination[1]] ;
    }

    
}
```

### 注意事项

**Dijkstra vs. BFS：** 本题最大的陷阱是使用标准 BFS (FIFO `Queue`)。标准 BFS 只能找到**边数最少**（即 "移动次数" 最少）的路径，而本题要求**权重之和最小**（即 "滚动距离" 最短）。

**`dist` 数组即 `visited`：** 在 Dijkstra 算法中，`dist` 数组隐式地起到了 `visited` 数组的作用。`if (d > dist[r][c]) continue;` 这个判断是至关重要的。它防止了我们处理旧的、较长的路径，也避免了死循环。

**模拟滚动的 `while` 循环：** 循环条件必须检查**下一个**格子，而不是当前格子。当循环停止时，`nr` 和 `nc` 才代表合法的**停止点**。

**起点和终点：** `start` 和 `destination` 本身必须是通路（值为 0），虽然题目通常会保证这一点。

**`dist` 的更新时机：** 只有在 `if (newDist < dist[nr][nc])` 成立时，我们才更新 `dist[nr][nc]` 并将新状态加入 `pq`。



### 经验总结

**识别 Dijkstra：** 看到 "网格/图" + "最短/最小" + "代价/权重不为1" 的组合，要立刻想到 Dijkstra 算法。

**Dijkstra 的模板：** 核心就是 `dist` 数组 + `PriorityQueue`。

**图的隐式构建：** 很多网格问题，图都不是显式给出的。节点就是格子，边由 "移动规则" 定义。在本题中，"移动规则"（一直滚直到停）就是定义边的逻辑。

**状态的定义：** `pq` 中存储的状态 `[row, col, distance]` 是解决问题的关键。`distance` 必须是**从起点开始的累积总距离**，而不是上一步的距离。

## Leetcode 499: 走迷宫 III

//非高频题目，有时间在刷
