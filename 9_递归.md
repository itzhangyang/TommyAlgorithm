# 8.递归

> 递归 = 把“大问题”拆成“结构相同但规模更小”的子问题，直到最小情况可以直接解决，再一点点拼回去。

### 理解递归最重要的三/四件套

| 套件               | 你需要问自己：                                       |
| ------------------ | ---------------------------------------------------- |
| **递归函数的含义** | 这个函数到底在“干什么”？它的**输入输出含义是什么？** |
| **终止条件**       | 什么情况下，我**不再继续递归**？（避免死循环）       |
| **递归关系式**     | 当前的结果要如何**依赖子问题的结果**？               |

### 掌握递归的三类题型（常见套路）

#### 分治：最常见的是二叉树

返回值由左右子问题合并。

#### Leetcode  236: 最近公共祖先

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        if(p == null && q == null){
            return null;
        }  
        if(p== null){
            return q;
        }
        if(q == null){
            return p;
        }
        if(root == p || root == q){
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left != null && right != null){
            return root;
        }
        if(left != null){
            return lowestCommonAncestor(left, p, q);
        }else{
            return lowestCommonAncestor(right, p, q);
        }
    }
```



#### Leetcode 104: 二叉树的最大深度

```Java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth,rightDepth) + 1;
    }
}
```



####判断型递归题目

#### Leetcode 112: 是否存在和为targetSum的根到叶子节点的路径

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        return dfs(root, targetSum);
    }

    private boolean dfs(TreeNode node, int target){
        if(target == node.val && node.right == null && node.left == null){
            return true;
        }

        boolean leftResult = node.left == null ? false : dfs(node.left, target - node.val);
        boolean rightResult = node.right == null ? false : dfs(node.right, target - node.val);

        return leftResult || rightResult;
    }
}
```

### 枚举型递归题目

枚举一般是要配合回溯？

#### [复习]二叉树的回溯过程 - 基于当前节点

```Java
private void backtrack(TreeNode curr,List<Integer> path, int target){
  if(curr == null) return;
  
  if(curr is leaf && target == curr.val){
    save(path);
    return;
  }
  
  path.add(curr.val);
  
  if(curr.left != null){
    backtrack(curr.left, path, target - node.val);
  }
  
  if(curr.right != null){
    backtrack(curr.right, path, target - node.val);
  }
  
  path.remove(path.size()-1);
}
```



#### Leetcode 113: 枚举和为targetSum的根到叶子节点的路径

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 //考虑回溯
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        backtrack(root, path, targetSum);
        return res;
    }

    private void backtrack(TreeNode curr, List<Integer> path, int target){
        if(curr == null){
            return;
        }
        path.add(curr.val);
        if(target == curr.val && curr.left == null && curr.right == null){
            res.add(new ArrayList<>(path));
        }
        if(curr.left != null){
            backtrack(curr.left, path, target - curr.val);
        }
        if(curr.right != null){
            backtrack(curr.right, path, target - curr.val);
        }
        path.remove(path.size() - 1);
    }
}
```



| 类型     | 特征                         | 示例题                | 通用模板                       |
| -------- | ---------------------------- | --------------------- | ------------------------------ |
| ✅ 分治型 | 返回值由左右子问题合并       | 236 LCA、104 maxDepth | `return combine(left, right)`  |
| ✅ 判断型 | 判断是否存在某种情况         | 112 路径和            | `return left`                  |
| ✅ 枚举型 | 所有路径、组合、排列（回溯） | 113、22、46           | `path.add → dfs → path.remove` |

### 实战中如何掌控递归？（五步法）

#### 明确「你这个递归函数的定义」

**不要一上来就写代码**，先用中文描述：

> “我这个函数 `dfs(node, sum)` 的意思是 —— 从当前节点出发，判断是否存在一条路径到叶子节点，路径和为 sum。”

🌟 如果你能清楚描述出这个含义，基本就成功一半了！

#### 明确终止条件：何时该停？

- 最常见的：`if (node == null) return ...;`
- 或：`if (isLeaf(node)) return 当前值`
- 回溯中常见：`if (满足条件) res.add(...)`

#### 写出递归调用语句（左右 / 下一级）

- dfs(node.left, ...)
- dfs(index+1, path, sum...)
- 多叉树：`for (child : node.children) dfs(child)`

####  返回值或中间处理（是否有组合 / 加总）

- 有时候你要把左右子树结果合并 `return left + right`
- 有时候只判断是否成立 `return left || right`
- 有时候收集路径，需要在 path 中加入再移除

#### 你要牢记的几句“递归口头禅”

- **不要想着从上往下解决问题**，你要相信 `子问题会帮你解决`

- **递归函数只干一件事，别贪心**，把其余任务交给子问题

- **明确定义 + base case + 推导递归逻辑** → 成功三要素

- **把递归看作一棵树在展开，return 是从底向上拼的结果**

#### 推荐的训练路线

| 难度  | 类型      | 例子                           |
| ----- | --------- | ------------------------------ |
| 🌱入门 | 树递归    | 104 最大深度、112 路径和       |
| 🍃进阶 | 分治      | 236 最近公共祖先、124 最大路径 |
| 🌳高阶 | 回溯+剪枝 | 46 全排列、39 组合总和         |
| 🎯综合 | 图DFS     | 200 岛屿数量、797 所有路径     |

## 常见数据结构 x 场景

| 类型           | 子类型                      | 应用场景               | 是否常考 |
| -------------- | --------------------------- | ---------------------- | -------- |
| 一、树结构处理 | 二叉树遍历（前/中/后序）    | 遍历节点获取信息       | ✅ 常考   |
|                | 树的路径/深度/直径          | 求最大值、路径和等     | ✅ 常考   |
|                | 树的构建                    | 从前序中序构造树等     | ✅ 常考   |
| 二、图结构处理 | DFS（递归版）               | 判断连通分量、搜索路径 | ✅ 常考   |
|                | Flood Fill / 岛屿问题       | 图像填充、岛屿数量     | ✅ 常考   |
| 三、回溯搜索   | 子集/组合/排列              | 组合类搜索问题         | ✅ 常考   |
|                | N皇后 / 解数独 / 单词搜索   | 高复杂度约束搜索       | ✅ 高频   |
| 四、分治法     | 快排 / 归并 / 二分 / 线段树 | 分解后合并结果         | ✅ 常考   |
| 五、动态规划   | 记忆化搜索（top-down）      | 避免重复计算           | ✅ 高频   |
| 六、数学构造   | 递归公式实现                | 斐波那契、Catalan数    | 常见     |

### 核心思想和总结

#### 树形结构天然适配递归

每个子问题都是树结构相同的更小的问题

#### 回溯是带剪枝的递归

在递归的过程中判断是否满足条件，不满足则回退

#### 分治 = 分解 + 合并

将问题分为子问题，递归解决并合并结果

#### 记忆化 = 递归 + 缓存

避免重复计算

#### 递归函数返回的不一定是题目求的

可以通过递归对某个全局变量进行求职，但是递归本身并不返回最终的结果。

比如求最大路径问题。



### 树状结构

#### 二叉树的遍历（前序/中序/后序）

##### 核心思想

- 树的结构天然适合递归：每个子树本质上是结构一致的更小问题
- 本质是“访问当前节点 + 递归子树”
- 区别在于访问当前节点的时机：前序 / 中序 / 后序

##### 应用场景

对二叉树的所有节点按特定顺序访问：

- **前序遍历**：复制/序列化树结构（如重建树）
- **中序遍历**：验证二叉搜索树（BST）
- **后序遍历**：**释放资源**、**自底向上累加**（如求树的深度）

##### 递归的四要素

| 要素                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ✅ 1. 函数定义              | 定义递归函数的意义。例如：`void traverse(TreeNode root)` 表示从 root 出发遍历整棵树 |
| ✅ 2. 终止条件              | 当递归无法继续时返回：`if (root == null) return;`            |
| ✅ 3. 子问题递归调用        | 通常递归左子树和右子树：`traverse(root.left); traverse(root.right);` |
| ✅ 4. 合并子结果 / 操作结果 | 在前/中/后序位置进行当前节点处理，或合并左右子树结果（本例无需返回合并） |

##### 应对策略

| 遍历方式 | 顺序           | 典型用途                          |
| -------- | -------------- | --------------------------------- |
| 前序     | 当前 → 左 → 右 | 重建树、树序列化、路径构造        |
| 中序     | 左 → 当前 → 右 | 判断是否为 BST、构建有序数组      |
| 后序     | 左 → 右 → 当前 | 删除树节点、自底向上的和/最大路径 |

##### 实现步骤

定义 `traverse(TreeNode root)`，表示从当前节点出发遍历子树

若节点为空，结束递归

根据顺序处理节点并递归其左右子树：

- 前序：处理 → 左递归 → 右递归
- 中序：左递归 → 处理 → 右递归
- 后序：左递归 → 右递归 → 处理

##### 代码套路模板

###### 前序遍历

```java
public void preorder(TreeNode root, List<TreeNode> path){
  if (root == null) return;
  
  path.add(root);
  
  preorder(root.left,path);
  preorder(root.right,path);
}
```

###### 中序遍历

```java
public void inorder(TreeNode root, List<TreeNode> path){
  if (root == null) return;
  
  inorder(root.left, path);
  path.add(root);
  inorder(root.right.path);
}
```



###### 后序遍历

```java
public void postorder(TreeNode root, List<TreeNode> path){
  if (root == null) return;
  
  postorder(root.left,path);
  postorder(root.right,path);
  path.add(root);
}
```

如果需要保存遍历结果而不是打印，可传入 `List<Integer> result` 或用全局变量收集。



##### 注意事项

- 必须在函数开头加上终止条件判断 `if (root == null) return;` 否则会 NPE
- 三种遍历只是“处理节点”的时机不同，递归结构相同
- 遇到嵌套逻辑（如路径和、深度）时，需要使用后序遍历（因为要先得到子树结果）
- Java 中递归过深时需注意栈溢出（StackOverflowError）

##### 实战经验总结

| 场景                  | 建议遍历方式       | 原因                         |
| --------------------- | ------------------ | ---------------------------- |
| 重建树                | 前序 / 中序        | 利用遍历顺序定位子树边界     |
| 判断是否为 BST        | 中序               | 中序结果为升序               |
| 树的最大深度 / 路径和 | 后序               | 要在递归“归”阶段合并子树结果 |
| 序列化与反序列化      | 前序               | 保证先记录根节点及左右结构   |
| 树问题调试            | 前中后序打印节点值 | 可验证结构和逻辑是否正确     |

#### 树的路径/深度/直径

##### 应用场景

- 树的最大深度、最小深度
- 从根到叶路径是否存在 / 返回所有路径
- 树的直径（最长路径）
- 是否存在某路径和（如路径和为 target）

##### 递归四要素

| 要素         | 内容                                                         |
| ------------ | ------------------------------------------------------------ |
| ✅ 函数定义   | 例：`int dfs(TreeNode node)` 表示返回以当前节点为根的某种“子树信息”（如深度、路径和） |
| ✅ 终止条件   | `if (node == null) return 0;`                                |
| ✅ 子问题调用 | 对左右子树分别调用递归函数：`dfs(node.left)` 与 `dfs(node.right)` |
| ✅ 合并子结果 | 常见为：`return Math.max(left, right) + 1` 或更新全局变量如直径 |

##### 核心思想-树形结构上的归纳计算

- 这类问题的本质是**树形结构上的归纳计算**，多数采用**后序遍历**，因为必须先知道左右子树的结果，再处理当前节点
- 关注**以节点为根**的定义，比如最大深度、包含路径、结果**从下往上**聚合

##### 应对策略

| 问题类型         | 应对方式                                                |
| ---------------- | ------------------------------------------------------- |
| 求最大深度       | 后序递归求` max(left, right) + 1`                       |
| 判断路径是否存在 | **前序遍历**带路径和，遇到**叶子节点**判断              |
| 返回路径列表     | **回溯** + **路径记录**                                 |
| 求树的直径       | **后序递归**返回**深度**，并更新全局最大` left + right` |

##### 实现步骤

- 定义递归函数的定义
- 终止条件：通常空节点返回0；
- 分别递归左子树和右子树
- 组合左右子树信息并返回
- 如果涉及到**全局更新**，在当前节点更新最大值等全局变量

##### 套路代码模板

###### 最大深度-后序

```java
public int maxDepth(TreeNode root){
  if (root == null) return 0;
  
  int leftDepth = maxDepth(root.left);
  int rightDepth = maxDepth(root.right);
  
  return Math.max(leftDepth,rightDepth)+1;
}
```

###### 是否存在路径和-前序

```java
public boolean has pathSum(TreeNode root, int target){
  if (root == null) return false;
  
  // Base condition 十分关键
  if (root.left == null 
     && root.right == null
     && root.val = target){
    return true;
  }
  
  return hasPathSum(root.left,target-root.val)
    || hashPathSum(root.right, target-root.val);
  
}
```

###### 树的直径-后序

```java
int maxDiameter = 0;
public int maxDepth(TreeNode root){
  if (root == null) return 0;
  
  int leftDepth = maxDepth(root.left);
  int rightDepth = maxDepth(root.right);
  // 直径是两个端点之间的边数量
  maxDiameter = Math.max(maxDiameter,leftDepth+rightDepth);
  
  // 返回最大深度
  return Math.max(leftDepth,rightDepth)+1;
}
```

##### 注意事项

- 若递归返回的是**深度/路径和**，不要遗漏`+1`或者`当前节点的值`
- 求**路径类**问题，路径列表应该**回溯清除最后一个节点**
- 求直径类问题涉及**以当前节点为根的最长路径**，通常需要**更新全局变量**
- 判断路径时注意**终止条件**是否为**叶子节点**而不是空节点

##### 实战经验总结

| 问题类型        | 推荐策略                     | 特别提示                    |
| --------------- | ---------------------------- | --------------------------- |
| 路径存在性      | 前序剪枝+终止在叶子节点      | 保证目标节点是“叶子”        |
| 路径构造        | 前序 + 回溯                  | 路径用 `List<Integer>` 记录 |
| 最大深度 / 直径 | 后序，递归左右子树深度后合并 | 可全局更新最大路径          |
| 多路径和问题    | 回溯路径 + 累加              | 注意路径撤销顺序            |

#### 树的构建

##### 应用场景

- 从前序+中序数组构建二叉树
- 从中序+后序数组构建二叉树
- 从前序+后序构建二叉树
- 构建平衡二叉树

##### 递归四要素

###### 函数定义：返回构建的子树

返回构建某个区间内的子树

```java
TreeNode build(int[] preorder,int preLeft, int preRight,int inLeft, int inRight)
```

###### 终止条件

`if (preLeft > preRight)`

###### 子问题调用

- 确定**左子树长度**
- **利用左子树的长度确定右子树在前序和中序数组中的区间范围**
- 递归构建左右子树

###### 合并结果

- 当前节点构造`TreeNode root = new TreeNode(val)`
- 设置当前节点的左子树`root.left = build(左子树的中序和后序数组)`
- 设置当前节点的右子树`root.right = build(右子树的中序和后序数组)`

##### 核心思想-递归分治

- 找到当前子树的**根节点**
- 根据根节点在**中序数组**中的位置，划分左子树和右子树的**中序子数组区间**
- 对应的推导出前序或者后序的左右子树的子数组区间
- 分别递归的构造左右子树

必须对前序/中序/后序遍历的定义和特征非常熟悉

##### 应对策略

| 组合        | 根节点位置                     | 划分逻辑                                       |
| ----------- | ------------------------------ | ---------------------------------------------- |
| 前序 + 中序 | 前序首元素是根                 | 用中序中根节点位置划分左右子树                 |
| 后序 + 中序 | 后序末元素是根                 | 用中序中根节点位置划分左右子树                 |
| 前序 + 后序 | 前序首元素是根，后序末元素是根 | **无法唯一确定结构**（但题目会保证**可构建**） |

##### 实现步骤

- **使用 HashMap 保存中序序列中每个值的位置**，便于查找

- 从前序序列中取出当前子树的根节点值

- 在中序中查找该根节点位置 `idx`，计算左子树节点数 `leftSize = idx - inL`

- 递归构建左右子树

- 返回根节点

##### 代码套路模板

###### 从前序和中序数组构建二叉树（Leetcode 105）

```java
public TreeNode buildTree(int[] preorder, int[] inorder){
  if(preorder == null || preorder.length == 0) return null;
  int n = preorder.length;
  int rootVal = preorder[0];
  
  Map<Integer, Integer> inorderIndexMap = new HashMap<>();
  for (int i=0; i<n; i++){
    inorderIndexMap.put(inorder[i],i);
  }
  
  int rootIndex = inorderIndexMap.get(rootVal);
  
  TreeNode root = new TreeNode(rootVal);
  
  int[] leftInorder = Arrays.copyOfRange(0,rootIndex);
  int leftSize = leftInorder.length;
  int[] rightInorder = Arrays.copyOfRange(rootIndex+1,n);
  
  int[] leftPreorder = Arrays.copyOfRange(1,leftSize-1);
  int[] roghtPreorder = Arrays.copyOfRange(leftSize,n);
  
  //递归调用
  root.left = buildTree(leftPreorder,leftInorder);
  root.right = buildTree(rightPreorder,rightInorder);
  
  return root;
}
```

##### 注意事项

- 使用 `HashMap` 存中序索引是必要优化，否则查找时间复杂度 O(n²)
- 构建过程中**要特别注意区间的左闭右闭，且左右子树边界要写对**
- 题目保证所有节点值唯一，否则无法定位根位置
- 注意 base case 是 `preL > preR` 而不是 `preL == preR`，否则可能漏掉节点或重复构建

##### 经验总结

| 场景       | 建议                                                         |
| ---------- | ------------------------------------------------------------ |
| 构建树题目 | 必须理解前序/中序/后序的结构特性                             |
| 模板优化   | 使用 HashMap 加速中序索引查找                                |
| 写代码建议 | 不推荐先切数组再传递，推荐传 index 区间参数，避免大量数组复制 |
| 调试建议   | 打印当前递归区间参数，可帮助快速定位错误构造                 |

##### Leetcode 889:根据前序遍历和后序遍历构造二叉树

###### 问题分析和本质

- 输入：
  - `pre[]` 前序遍历结果(根-左-右)
  - `post[]`后序遍历结果(左-右-根)
- 输出
  - 构造出的可能的二叉树根节点（不唯一，允许返回任何符合条件的结果）
- 问题本质：
  - 从两个不完整的遍历序列中构造二叉树
  - 由于缺乏中序，不能唯一确定树结构，但是可以构造一个合理解
  - 只能采用**递归构建子树**

###### 核心思想

- 观察规律
  - 前序的第一个是根元素
  - 后序的第一个元素是根
  - **前序的第二个元素是左子树的根节点**
    - 在后序中找到这个节点的位置`L`
    - 那个`L+1`就是左子树的节点的数量
- 递归切分
  - `pre[1...L+1]`是左子树，`pre[L+2...]`就是右子树
  - `post[0...L]`是左子树，`post[L+1,...n-2]`是右子树

###### 递归函数的定义

返回构造之后的二叉树的根

```
public TreeNode constructFromPrePost(int[] preorder, int[] postorder) ;
```

###### 实现代码

```java
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        if (preorder == null || preorder.length ==0) return null;
        if (preorder.length == 1){
            return new TreeNode(preorder[0]);
        }

        int n = preorder.length;
        int rootVal = preorder[0];
        Map<Integer,Integer> postorderIndexMap = new HashMap<>();
        for (int i=0;i<n;i++){
            postorderIndexMap.put(postorder[i],i);
        }
        TreeNode root = new TreeNode(rootVal);
        int leftVal = preorder[1];
        //找到左子树根节点在后序数组中的位置，
        //按照后序数组的性质，左子树根节点就是左子树数组的最后一个节点
        int leftIndex = postorderIndexMap.get(leftVal);
        //因此左子树的size = leftIndex+1
        int leftSize = leftIndex+1;
        int[] leftPreorder = Arrays.copyOfRange(preorder,1,leftSize+1);
        int[] rightPreorder = Arrays.copyOfRange(preorder,leftSize+1,n);

        int[] leftPostorder = Arrays.copyOfRange(postorder,0,leftSize);
        int[] rightPostorder = Arrays.copyOfRange(postorder,leftSize, n-1);

        root.left = constructFromPrePost(leftPreorder,leftPostorder);
        root.right = constructFromPrePost(rightPreorder,rightPostorder);
        return root;
    }
```

###### 注意事项

- `postEnd - 1`：因为 post 最后一个元素是当前根，不属于子树
- 有多个构造结果，返回任意一个即可（不必考虑唯一性）
- 如果 pre 或 post 为空、长度不等、数据非法，可加入健壮性校验
- 寻找 post 中位置时可以提前构造 `Map<Integer, Integer>` 加速查找

###### 经验总结

| 维度       | 经验                                                         |
| ---------- | ------------------------------------------------------------ |
| 分治思路   | 前序提供“根+左”，后序提供“左边界+右边界”，配合能切分左右子树 |
| 递归边界   | 最小子问题是单个节点                                         |
| 多解问题   | 无需唯一解，只需构造合法解                                   |
| 预处理优化 | 用 HashMap 缓存 post 中每个值的位置可提升效率                |
| 难点       | 找到子树边界是关键（尤其是左子树大小的推导）                 |

### 图结构处理

#### 图的深度优先搜索(DFS)

##### 深度优先搜索的本质

- 沿着一条路径不断深入，直到不能继续为止

##### DFS的应用场景

- 图遍历

- 连通块统计

- 拓扑排序（有向图）

- 判断环（有/无向图）

- 路径搜索 / 所有路径

- 图染色（如二分图）

- 等价类划分（如并查集）

##### 核心思想

- **起始点入栈 ->标记访问 -> 遍历所有邻居 ->对未访问邻居递归DFS**
- 对于有向图和无向图，邻居访问的方式略有不同
- 若需要记录路径/连通块信息等，需要在递归过程中组合结果

##### 递归函数的定义

```java
void dfs(int node, Map<Integer,List<Integer>> graph, boolean[] visited);
```

- `node`:当前节点
- `graph`:邻接表
- `visited`:记录节点是否访问过

如果需要记录路径、连通块等内容，可以扩展返回值或者传参

##### 递归终止条件

- 如果`visited[node] == true`，说明访问过，直接返回
- 在部分场景下，若要剪枝或者终止查找（如找到路径），也可提前返回

##### 递归过程结果组合方式

| 场景     | 组合方式                      |
| -------- | ----------------------------- |
| 找路径   | 在递归路径中记录路径列表      |
| 拓扑排序 | 后序加入结果列表              |
| 判断环   | 使用栈/回溯栈标记进行组合判断 |
| 染色问题 | 尝试为每个邻居染不同颜色      |

##### 代码套路模板

###### 邻接表DFS模板

```java
void dfs(int node,Map<Integer,List<Integer>> graph, boolean[] visited){
  if (visited[node]) continue;
  
  visited[node] = true;
  
  List<Integer> neighbors = graph.get(node);
  for (int neighbor : neighbors){
    dfs(neighbor,graph,visited);
  }
}
```



###### 路径记录版本（用于寻找所有路径-回溯）

```java
void dfs(int node, int target, Map<Integer, List<Integer>> graph, boolean[] visisted, List<Integer> path){
  //添加节点到路径
  path.add(node);
  //判断是否符合条件
  if (node == target){
    res.add(new ArrayList<>(path));
  }else{
    
    visited[node] = true;
    
    for (int neighbor : graph.ge(node)){
      if (!visited(neighbor)){
        dfs(neighbor,target,graph,visited,path);
      }
    }
  }
  
  path.remove(path.size() - 1);
}
```

##### 注意事项

| 类型         | 建议                                            |
| ------------ | ----------------------------------------------- |
| 图构建       | 使用邻接表 `Map<Integer, List<Integer>>` 更通用 |
| 防止重复访问 | 使用 `visited[]` 数组，或 `Set<Integer>`        |
| 避免死循环   | 无向图需排除“回到父节点”的边                    |
| 回溯问题     | 需要恢复 `visited` 或 `path`                    |
| 多源起点     | 常用于统计连通分量时对每个未访问节点都启动 dfs  |

##### 经验总结

| 维度         | 经验                                           |
| ------------ | ---------------------------------------------- |
| 实用性       | DFS 通常用于结构探索、路径查找、状态遍历       |
| 与 BFS 区别  | DFS 先深入再回溯，BFS 层层推进更适合最短路径   |
| 最佳应用场景 | 回溯问题、路径枚举、子集/排列/组合、拓扑排序   |
| 防止死循环   | visited 数组必须加！无向图还需记录 parent 节点 |
| 配套技巧     | 配合回溯路径、染色、栈记录等技术更强大         |

##### Leetcode 329. 矩阵中的最长递增路径-带缓存的DFS

给定一个 `m x n` 的整数矩阵 `matrix`，找出其中 **最长递增路径** 的长度。
 你可以从一个单元格移动到 **上下左右** 相邻的单元格，但 **不能对角线移动或移动到值不大于当前值的单元格**。

这是一道**图搜索+记忆化递归**问题，可以将矩阵转化为一个图问题，边指向**更大的相邻节点**

###### 核心思想

- 每个点`[i,j]`作为起点，查找它能走出的最长递增路径
- 每个点偏向更大的上下左右移动，构建递归树
- 用 **DFS+记忆化搜索**缓存每个点的搜索结果，避免重复搜索

###### 实现原理

**状态定义：**

`dp[i,j]`表示从`[i,j]`出发的最长递增路径的长度

**状态转移方程：**

若从当前`[i,j]`可以走向`next(ni,nj)`,即`matrix[ni,nj] > matrix[i,j]`，则有

```
dp[i][j] = max(dp[i][j],1+dfs(ni,nj))
```

**遍历方式：**

- 外部循环所有点作为起点
- 内部使用DFS+缓存搜索每个起点的最长路径

###### 实现代码

```java
private int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
private int[][] memo;
private int m,n;

public int longestIncreasingPath(int[][] matrix){
  if (matrix == null || matrix.lengt ==0) return 0;
  
  m = matrix.length;
  n = matrix[0].length;
  memo = new int[m][n];
  
  for (int i=0; i<m; i++){
    for (int j=0; j<n; j++){
      maxLength = Math.max(maxLength, dfs(matrix,i,j));
    }
  }
  
  return maxLength;
}

private int dfs(int[][] matrix, int i, int j){
  //已经计算出来了就不需要再计算了，直接返回
  if (memo[i][j] !=0 ) return memo[i][j];
  
  if max = 1;
  for (int[] dir : dirs){
    int x = i+dir[0], y = j+dir[1];
    
    for (x >= 0 && x <m && y>=0 && y<n
        && matrix[x][y] >matrix[i][j]){
      max = Math.max(max, 1+dfs(matrix, x,y));
    }
  }
  memo[i][j] = max;
  return max;
}
```

###### 注意事项

1. **不能用简单的 BFS**：
   - 因为 BFS 不能天然处理递增路径长度的叠加问题。
   - 并且没有天然的拓扑顺序，必须依赖记忆化DFS。
2. **避免重复搜索**：
   - 使用 `memo` 数组缓存每个点的最长路径，避免指数级递归。
3. **不要忘记边界判断**：
   - 坐标 `x, y` 的合法范围 `0 <= x < m, 0 <= y < n`。

###### 经验总结

| 点         | 说明                                     |
| ---------- | ---------------------------------------- |
| 算法类型   | DFS + 记忆化搜索（记忆化递归）           |
| 数据结构   | 二维数组、递归栈、方向数组               |
| 优化策略   | 记忆化缓存，避免重复搜索                 |
| 时间复杂度 | `O(m * n)`，每个点最多只被搜索一次       |
| 空间复杂度 | `O(m * n)` 递归栈深 + memo缓存           |
| 易错点     | 不做 memo 处理会导致 TLE；边界处理要细心 |

#### Flood Fill/岛屿问题

Flood Fill 和“岛屿问题”是一类特殊的图问题，通常以**网格（二维数组）**表示图结构。常见题目包括：

- 图像填充（Leetcode 733. Flood Fill）
- 岛屿数量（Leetcode 200）
- 最大岛屿面积（Leetcode 695）
- 被围绕的区域（Leetcode 130）
- 省份数量（Leetcode 547，邻接矩阵）

##### 递归要素

| 要素         | 内容                                                         |
| ------------ | ------------------------------------------------------------ |
| ✅ 函数定义   | 例：`void dfs(int[][] grid, int x, int y)`，表示从某个位置出发填充区域或计数 |
| ✅ 终止条件   | 出界或遇到障碍/非目标值时返回：`if (x < 0`                   |
| ✅ 子问题调用 | 递归调用上下左右四个方向的 dfs                               |
| ✅ 合并子结果 | 可累计面积/数量/路径长度，或直接修改网格值实现染色           |

##### 核心思想

- **Flood Fill（洪水填充）**是从一个起点开始，将所有与之连接、且值相同的点替换为**新颜色**
- **岛屿类问题**是对每一个陆地点启动 DFS，将一整块连通区域标记/遍历一遍
- 实质是**图的连通块识别问题**，采用 DFS/BFS 均可，但 DFS 更容易递归表达

##### 应对策略

| 问题类型 | 策略                                        |
| -------- | ------------------------------------------- |
| 染色填充 | 从起点向四周扩展，改变目标值为新值          |
| 岛屿数量 | 网格遍历，遇到 '1' 就 DFS，计数并染色为 '0' |
| 岛屿面积 | DFS 返回每块区域面积，记录最大值            |
| 图环问题 | DFS 结合 visited 记录状态                   |

##### 实现步骤

- 定义DFS函数并处理边界条件
- 对当前单元格进行处理（染色、累计面积）
- 遍历四个方向递归
- 处理返回值（累计总数/合并子面子）

##### Leetcode 744: 图像渲染

给定一个二维的图像 `image`，其中 `image[i][j]` 表示像素值。再给定一个起始点 `(sr, sc)` 和一个新颜色 `color`，你需要将与起始点连通（上下左右）且原颜色相同的区域的像素值都改为 `color`。

###### 问题的本质-图的遍历

- 图的每一个节点是像素点`[i,j]`
- 邻接关系是上下左右四个方向的连通
- 要求修改与起点**连通**的、颜色相同的所有像素的颜色

###### 核心思想

1. 记录起始点的原始颜色`originalColor`
2. 使用DFS或者BFS向四个方向遍历扩展
3. 只有当邻居节点和原始的颜色`orginalColor`相同时，**通过修改颜色来避免重复访问**

###### 实现原理

**使用DFS或者BFS的方式来实现遍历**

###### 实现代码

```java
public class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int originalColor = image[sr][sc];
        if (originalColor != newColor) {
            dfs(image, sr, sc, originalColor, newColor);
        }
        return image;
    }

    private void dfs(int[][] image, int r, int c, int color, int newColor) {
        //Base condition: 越界处理或颜色不匹配
        if (r < 0 || r >= image.length || c < 0 || c >= image[0].length || image[r][c] != color) {
            return;
        }
				// 逻辑处理
        image[r][c] = newColor;
				//邻居节点递归调用
        dfs(image, r + 1, c, color, newColor);
        dfs(image, r - 1, c, color, newColor);
        dfs(image, r, c + 1, color, newColor);
        dfs(image, r, c - 1, color, newColor);
    }
}
```

###### 注意事项

1. **起始颜色等于目标颜色**：直接返回，防止死循环；
2. **边界检查**：注意递归/队列操作中是否越界；
3. **避免重复访问**：通过修改颜色标记访问状态，避免无限递归；
4. **递归深度**：大图像建议使用 BFS，防止栈溢出。

###### 经验总结

| 项目     | 总结                                                         |
| -------- | ------------------------------------------------------------ |
| 核心算法 | DFS / BFS 图遍历                                             |
| 典型特征 | 4 个方向传播 + 同色判断                                      |
| 易错点   | 没判断 `oldColor == newColor`、边界检查、重复访问            |
| 推荐做法 | DFS 更清晰，BFS 更安全                                       |
| 扩展应用 | 岛屿数量（200）、围绕区域（130）、最大岛屿面积（695）等图结构问题 |



### 回溯搜索

//详细见回溯的部分

### 分治法

#### 快速排序

#### 归并排序

#### 二分

#### 线段树

### 数学构造

#### 递归公式实现

