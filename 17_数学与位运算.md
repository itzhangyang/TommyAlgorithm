# 位运算

## 位运算的定义

位运算是直接对整数在内存中的二进制位进行操作的运算。

相比于常规的算术运算，位运算通常速度更快。

###**特征与常用公式:**



### 常用技巧

#### 判断一个数字是奇数还是偶数

- 判断奇偶: `x & 1 == 1` 为奇数，`x & 1 == 0` 为偶数。

#### 清除二进制数末尾的1

- 清除末尾的1: `x & (x - 1)`。

#### 获取末尾的1所代表的数值

- 获取末尾的1: `x & -x` (或 `x & (~x + 1)`)。

#### 交换两个数字的数值

- 交换两个数 (无需额外空间): `a ^= b; b ^= a; a ^= b;`

### Leetcode 231: 判断一个数是否是2的幂次方($2^x$)

#### 问题要点

给定一个整数 `n`，编写一个函数来判断它是否是 2 的幂。

**输入：** 一个整数 `n`。 **输出：** 一个布尔值。如果 `n` 是 2 的幂，则返回 `true`；否则，返回 `false`。

**示例：**

- 输入: `1` -> 输出: `true` (因为 20=1)
- 输入: `16` -> 输出: `true` (因为 24=16)
- 输入: `3` -> 输出: `false`
- 输入: `0` -> 输出: `false`
- 输入: `-1` -> 输出: `false`

#### 问题的本质和分析

问题的本质是识别出符合 $n=2^x$ 形式的数，其中 `x` 是一个非负整数。

从数学角度看，2 的幂就是 {1, 2, 4, 8, 16, 32, ...} 这个序列中的数。这些数除了 1 之外，都是偶数，并且它们**唯一的质因数**就是 2。

从计算机科学（二进制）的角度看，这个问题变得异常简单。2 的幂的数在二进制表示下有一个非常显著的特征：**有且仅有一个比特位是 '1'，其余所有比特位都是 '0'**。

- $1\rightarrow(0001)_2$
- $2\rightarrow(0010)_2$
- $4\rightarrow(0100)_2$
- $8\rightarrow(1000)_2$
- $16\rightarrow(10000)_2$

这个二进制特性是解决此问题的金钥匙，它引导我们使用高效的位运算来求解。

#### 背景知识 - 位运算

##### 数的二进制表示

计算机内部使用二进制存储整数。正数的二进制表示即为其原码。

##### 按位与运算(AND)

对两个数的每一个比特位进行比较，只有当两个位都为 `1` 时，结果的对应位才为 `1`，否则为 `0`。

- 例如: `8 & 7`
  - $8=(1000)_2$
  - $7=(0111)_2$
  - $8 \& 7 = (0000)_2 = 0$

##### `n-1` 的二进制特性

对任意正整数 `n`，`n-1` 的二进制表示相当于将 `n` 的二进制表示中的 **最右边的那个 '1' 变为 '0'，并将其右侧所有的 '0' 都变为 '1'**。

- $n=8\rightarrow(1000)_2$

- $n−1=7\rightarrow(0111)_2$

- $n=12\rightarrow(1100)_2$

- $n−1=11\rightarrow(1011)_2$

##### 补码 (Two's Complement)

计算机使用补码来表示负数。

`-n` 的补码等于 `(~n) + 1`（`~` 是按位非运算符）。

**一个有用的特性是 `n & (-n)` 可以得到 `n` 的二进制表示中最低位的 `1` 所代表的值**。

- $n=8\rightarrow(00...1000)_2$
- $−n=−8\rightarrow(11...1000)_2$ (补码)
- $ n \& (-n)$ = 8

#### 考察点

- **基础编程能力：** 能否写出循环判断的逻辑。
- **问题转化能力：** 能否将数学问题“2的幂”转化为计算机科学中的“二进制只有一个1”的问题。
- **位运算的熟练度：** 这是本题的核心考察点。面试官期望看到应聘者能够熟练使用位运算来解决问题，因为它通常是最高效的方法。
- **边界条件处理：** 是否考虑了 `n` 为 0 或负数的情况。

#### 模式匹配

- **模式：** 位运算技巧判断数字特性。

- **核心思想：** 当题目涉及到整数的二进制特性、奇偶性、特定位的操作时，应优先考虑位运算。

  `n & (n - 1)` 是一个极其常见的位运算技巧，用于：

  1. **消除最右边的 '1'**: 如本题，可以判断是否只有一个 '1'。
  2. **计算 '1' 的个数 (汉明权重)**: LeetCode 191 "位1的个数"，通过不断执行 `n = n & (n-1)` 直到 `n` 变为 0，循环的次数就是 '1' 的个数。

- **套路：** 遇到判断“2的幂”、“4的幂”等问题，首先思考其二进制表示的规律，然后尝试用位运算来高效地验证这个规律。

#### 实现原理和步骤

##### 传统方法： 循环除法

这是最直观的思路。如果一个数是 2 的幂，那么它一定能被 2 整除，且不断除以 2 最终会得到 1。

- **原理：** 反复将 `n` 除以 2，检查余数。
- **步骤：**
  1. **处理边界：** 如果 `n <= 0`，直接返回 `false`。**2的幂一定是正数**。
  2. **循环：** 当 `n > 1` 时，进入循环。
     - 检查 `n` 是否能被 2 整除 (`n % 2 != 0`)。如果不能，说明它含有除 2 以外的质因数，直接返回 `false`。
     - 更新 `n`：`n = n / 2`。
  3. **返回结果：** 循环正常结束后（意味着 `n` 最终变成了 1），返回 `true`。

##### 位运算 : n & (n-1)

**原理：**

- 如果 `n` 是 2 的幂，其二进制表示中只有一个 `1` (例如 $8\rightarrow1000_2$)。
- `n-1` 的二进制会将这个 `1` 变成 `0`，并把后面的 `0` 都变成 `1` (例如 $7\rightarrow0111_2$)。
- **将 `n` 和 `n-1` 进行按位与 (`&`) 运算，结果必然为 `0`**。
- 反之，如果 `n` 不是 2 的幂，它的二进制中至少有两个 `1` (例如 $12\rightarrow1100_2$)。`n-1` ($11\rightarrow1011_2$) 只会改变最右边的 `1`，而更高位的 `1` 不受影响。因此 `n & (n-1)` ($1100_2 \& 1011_2 = 1000_2 = 8$) 的结果不为 `0`。

**步骤：**

**处理边界：** `n` 必须是正数，所以检查 `n > 0`。

**核心判断：** 计算 `(n & (n - 1)) == 0`。

**返回结果：** 将两个条件合并，即 `n > 0 && (n & (n - 1)) == 0`。

##### 位运算： n & (-n)

这是一个较为巧妙但不那么常见的位运算方法。

**原理：**

- 对于任何正整数 `n`，`n & (-n)` 的结果是提取出 `n` 的二进制表示中最右边的那个 `1` 所代表的数值。
- **如果 `n` 是 2 的幂，它本身就只有一个 `1`，所以 `n & (-n)` 的结果就是 `n` 自己**。

**步骤：**

1. **处理边界：** 同样，`n` 必须是正数，检查 `n > 0`。

2. **核心判断：** 计算 `(n & -n) == n`。

3. **返回结果：** 合并条件 `n > 0 && (n & -n) == n`。



# 数论

## 质数的定义

大于1的自然数，仅能被1和自身整除。

## 关键点

### 如何判断一个数是否是素数？- 试除法

从`2`到 $\sqrt {n}$ 是否存在一个能够整除 n 的整数？

### 怎样快速找到 `2 ~ N`之间的所有素数？ - 素数筛法

素数筛法的根本目的，是在一个给定的范围内（例如，从 2 到 N）找出所有的素数。

#### 试除法的性能问题 - 尝试 $n \div {x} (x = [2....\sqrt{n}])$

如果我们采用最朴素的方法（**试除法**），即对范围内的每一个数 `n` 都进行一次素性测试（从 2 除到 $\sqrt {n}$），那么当 N 非常大时，这个计算量是巨大的。

#### 素数筛法的核心思想 - 批量剔除合数

素数筛法则提供了一种截然不同的、更为高效的思路。

##### 一个合数肯定可以被某个比它小的素数整数

它不是去逐一“验证”谁是素数，而是反其道而行之，**系统性地、批量地“剔除”所有已知的合数（非素数），那么剩下的就必然是素数了。**

这个核心思想可以概括为：**“一个合数，一定可以被某个比它小的素数整除。”**

##### 一个素数的倍数一定是一个合数

基于这个定理，筛法的逻辑就变得清晰了：

我们从小到大遍历数字，每当我们遇到一个素数 `p`，我们就知道，所有 `p` 的倍数（`2p`, `3p`, `4p`, ...）都必然是合数。

于是，我们就可以像筛子一样，将这些合数批量地“筛掉”。

当这个过程不断进行，所有合数都会被某个素数的倍数这个身份而被筛掉，最终留在筛子上的，就是我们想要的素数。

#### 最经典的实现 - 埃拉托斯特尼筛选法

埃拉托斯特尼筛法（简称埃氏筛）是素数筛法中最古老、最直观、也是最经典的实现方式。

它的原理完美地诠释了上述的核心思想。

##### 初始化标记列表 - 假设所有数字都是素数

 创建一个从 0 到 N 的布尔数组（或类似结构），我们称之为 `is_prime`。

初始时，将所有元素都标记为 `true`，表示我们“假设”所有数都是素数（除了 0 和 1，它们是已知的非素数）。

- `is_prime[0] = is_prime[1] = false`
- `is_prime[2], is_prime[3], ..., is_prime[N] = true`

##### 遍历每一个素数p，将$p\times x$ 标记为合数

从 `p = 2` 开始，这是第一个素数。

- 如果 `is_prime[p]` 的值为 `true`（意味着 `p` 尚未被前面的数筛掉，因此它是一个素数），我们就进行下一步的筛选操作。
- 如果 `is_prime[p]` 的值为 `false`（意味着 `p` 已经被更小的素数筛掉了，它是个合数），则直接跳过，检查下一个数 `p+1`。int 

##### 标记所有倍数, 从$p \times p$ 开始

当我们确认 `p` 是一个素数后，我们就将它所有的倍数 `2p`, `3p`, `4p`, ... 直到 `N`，都在 `is_prime` 数组中标记为 `false`，因为它们都是合数。

实际上，我们可以从 `p*p` 开始标记。

为什么呢？

因为像 `2p`, `3p`, ... `(p-1)p` 这些 `p` 的较小倍数，它们必然含有一个比 `p` 更小的质因子（例如 `2`, `3`, ...）。

因此，它们在之前的遍历中（遍历 `2`, `3`, ... 时）就已经被筛掉了。

我们只需要从 `p*p` 这个第一个“新出现”的合数开始筛即可。

##### 重复过程，直到$p \times p > N$

继续遍历下一个数 `p = 3`, `p = 4`, ... 直到 `p*p > N`。

**遍历上界优化：** 为什么遍历到 `sqrt(N)` 就可以了？

因为任何一个大于 `sqrt(N)` 的合数 `m`，它的质因数分解 `m = a * b` 中，必然有一个因子是小于 `sqrt(N)` 的。

所以，这个合数 `m` 肯定在遍历到那个小于 `sqrt(N)` 的质因子时，就被筛掉了。

因此，我们只需要检查到 `sqrt(N)` 即可确保所有合数都被筛选完毕。

##### 收集结果

遍历结束后，`is_prime` 数组中所有仍然标记为 `true` 的下标，就是我们所求的素数。

### 什么是最小质因数？

要理解“最小质因数”，我们首先要把它拆成两个部分来看：“质因数”和“最小”。

#### 什么是A的因数？- 能够整除A的数

一个整数 `A` 如果能被另一个整数 `B` 整除（没有余数），那么 `B` 就被称为 `A` 的**因数**（或约数）。

例如，12 的因数有 1, 2, 3, 4, 6, 12。

#### 什么是质因数 ？- 因数中的质数

**质因数**（Prime Factor）是指一个数的因数中，本身也是**质数**（素数）的那个数。

我们再以 12 为例：

- 它的因数是 1, 2, 3, 4, 6, 12。
- 在这些因数中，是质数的有 2 和 3。
- 所以，12 的质因数就是 2 和 3。

每个大于1的正整数，都可以唯一地分解成一系列质因数的乘积，这被称为**唯一分解定理**或**算术基本定理**。 例如：

- `12 = 2 × 2 × 3`
- `30 = 2 × 3 × 5`
- `7 = 7` (7本身就是质数)
- `18 = 2 × 3 × 3`

#### 什么是最小质因数？- 质因数中的最小者

**最小质因数**（Smallest Prime Factor, SPF）就非常直观了：**在一个数所有的质因数中，最小的那一个。**

我们来看几个例子：

- **对于数字 12：**
  - 它的质因数是 2 和 3。
  - 其中最小的是 2。
  - 所以，12 的最小质因数是 **2**。
- **对于数字 35：**
  - 它的唯一分解是 `5 × 7`。
  - 它的质因数是 5 和 7。
  - 其中最小的是 5。
  - 所以，35 的最小质因数是 **5**。
- **对于数字 77：**
  - 它的唯一分解是 `7 × 11`。
  - 它的质因数是 7 和 11。
  - 其中最小的是 7。
  - 所以，77 的最小质因数是 **7**。
- **对于一个质数（比如 13）：**
  - 它只有一个质因数，就是它本身。
  - 所以，13 的最小质因数是 **13**。

### 进阶筛法 - 线性筛法

#### 埃氏筛法的问题 - 一个合数可能会被它的多个质因数重复筛选。

埃氏筛虽然高效，但存在一个缺陷：**一个合数可能会被它的多个质因子重复筛选**。

例如，数字 12 会在 `p=2` 时被筛一次，在 `p=3` 时又被筛一次。

#### 线性筛法的核心思想- 每个合数只被其最小质因数筛选一次

**线性筛的核心思想**就是为了解决这个重复筛选的问题。

它通过一个巧妙的规则，**确保了每个合数都只被其“最小质因子”筛选一次**。

这使得它的时间复杂度达到了理论上的最优——*线性时间复杂度 O(N)*。

#### 线性筛法的核心思想

线性筛在埃氏筛的基础上，增加了一个 `primes` 数组来存储已经找到的素数。

它同样是从 2 开始遍历到 N：

1. 如果当前数 `i` 未被标记，说明 `i` 是一个素数，将其存入 `primes` 数组。

2. 接下来，**关键步骤来了**：遍历 `primes` 数组中已存的素数 `p`，将 `i * p` 标记为合数。

3. **保证“最小质因子”筛选的规则：** 

   在上述标记过程中，如果 `i % p == 0`，则立刻停止对当前 `i` 的标记循环。

   **为什么？** 如果 `i` 能被 `p` 整除，说明 `p` 是 `i` 的最小质因子。

   那么对于下一个更大的素数 `p_next`，合数 `i * p_next` 的最小质因子必然也是 `p`（因为 `i * p_next = (i/p) * p * p_next`），而不是 `p_next`。

   为了遵守“只被最小质因子筛选”的原则，这个合数 `i * p_next` 应该在后续遍历到 `(i/p) * p_next` 时，由 `p` 去筛选它。

   因此，当前循环必须终止。

通过这个简单的 `if (i % p == 0) break;` 

规则，线性筛优雅地实现了每个合数只被精确地筛选一次，从而达到了线性时间复杂度。

## LeetCode 204: Count Primes (计数质数)

### 问题要点

给定一个非负整数 `n`，统计所有小于 `n` 的质数的数量。

**示例:**

- **输入:** `n = 10`
- **输出:** `4`
- **解释:** 小于 10 的质数有 2, 3, 5, 7，共 4 个。
- **输入:** `n = 0`
- **输出:** `0`
- **输入:** `n = 1`
- **输出:** `0`

**约束条件:**

- `0 <= n <= 5 * 10^6`

### 问题的本质和分析 - 高效地找出 `[0, n-1]` 区间内所有的质数

问题的本质是**高效地找出 `[0, n-1]` 区间内所有的质数**。

#### 暴力解法 - 尝试使用$[2...\sqrt{n}]$整除

最直观的想法是，对于每个小于 `n` 的数 `i`（从 2 开始），我们都去判断它是不是质数。

如何判断一个数 `x` 是不是质数？

 根据质数的定义（除了 1 和它自身，不能被其他任何正整数整除），我们可以尝试用 `[2, x-1]` 之间的所有数去除 `x`。

如果都不能整除，那么 `x`就是质数。

这个判断过程可以优化：我们只需要检查到 $\sqrt{n}$ 即可。

因为**如果 `x`有一个大于 $\sqrt{n}$ 的因子 `a`，那么它必然有一个小于$\sqrt{n}$ 的因子 `b`，即 `x = a * b`**。

#### 暴力解法的时间复杂度

外层循环从 2 到 `n-1`，复杂度为 O(n)。

内层循环（判断是否为质数）对于每个数 `i`，需要 $O(\sqrt{i})$ 的时间。

总时间复杂度约为 $O(n\sqrt{n})$。

#### 背景知识 - 埃拉托斯特尼筛法

##### 埃拉托斯特尼筛法的详细原理和步骤

埃氏筛是一种古老而高效的用于寻找一定范围内所有质数的算法。其工作原理如下：

1. 创建一个布尔数组 `isPrime`，长度为 `n`，并全部初始化为 `true`。`isPrime[i]` 表示数字 `i` 是否是质数。
2. 将 0 和 1 标记为非质数 (`isPrime[0] = isPrime[1] = false`)。
3. 从第一个质数 2 开始遍历。
4. 如果 `isPrime[i]` 为 `true`（即 `i` 是一个质数），则将 `i` 的所有倍数（`2*i`, `3*i`, `4*i`, ... 直到不超过 `n-1`）都标记为**非质数**（`isPrime[j] = false`）。
5. 继续遍历下一个 `isPrime` 值为 `true` 的数（下一个质数），重复步骤 4。
6. 这个过程一直持续到遍历完所有小于 `n` 的数。
7. 最后，统计数组 `isPrime` 中值为 `true` 的个数即可。

##### 举例：找出小于 20 的所有质数

1. 创建数组 `isPrime[0...19]`，全部设为 `true`。
2. `isPrime[0] = isPrime[1] = false`。
3. 从 `i = 2` 开始。`isPrime[2]` 是 `true`。
   - 将 2 的倍数（4, 6, 8, 10, 12, 14, 16, 18）标记为 `false`。
4. `i = 3`。`isPrime[3]` 是 `true`。
   - 将 3 的倍数（6, 9, 12, 15, 18）标记为 `false`。
5. `i = 4`。`isPrime[4]` 是 `false`，跳过。
6. `i = 5`。`isPrime[5]` 是 `true`。
   - 将 5 的倍数（10, 15）标记为 `false`。
7. ... 以此类推。

##### 一个重要的优化

**外层循环只需要遍历到 $\sqrt{n}$ 即可**。

**因为任何一个大于 `sqrt(n)` 的合数，它的最小质因子必然小于或等于 `sqrt(n)`。**

当我们的外层循环处理到这个最小质因子时，这个合数就已经被筛掉了。

例如，`n = 30`，`sqrt(30) ≈ 5.4`。

合数 21 的最小质因子是 3，当 `i=3` 时，21 就被筛掉了。

合数 25 的最小质因子是 5，当 `i=5` 时，25 就被筛掉了。

### 考察点

- **基础数论知识:** 对质数、合数概念的理解。
- **算法思维:** 能否跳出暴力解法的思维定式，想到一种“批量处理”的思路。筛法就是一种典型的空间换时间、批量处理的思想。
- **代码实现能力:** 能否将筛法正确、无误地翻译成代码。
- **效率优化意识:** 对时间复杂度的分析能力，以及能否想到并实现 `sqrt(n)` 等优化。

### 模式匹配 (Pattern Matching) - 素数筛法

当你遇到需要在**一定连续范围内**，找出所有满足某种性质（通常是与“整除”、“因子”相关）的数字时，就应该联想到筛法。

筛法的核心是从一个已知的满足性质的数出发，排除掉所有由它衍生出的不满足性质的数。

例如：

- 求 `[1, n]` 内所有数的最大质因子。
- 求 `[1, n]` 内所有数的**欧拉函数值**。
- 求 `[1, n]` 内所有数的**因子个数**。

这些问题都可以用类似筛法的思想来高效解决。

### 核心思想和套路 (Core Idea and Approach)

#### 核心思想 - 空间换时间

我们使用一个大小为 `n` 的辅助数组来记录每个数的状态（是不是质数），从而避免了对每个数的重复计算。

#### 套路过程

1. **初始化:** 创建一个布尔数组 `isPrime`，假设所有数都是质数。
2. **遍历和标记:** 从最小的质数 2 开始，遍历这个数组。
3. **筛选:** 如果当前数字 `p` 是质数，那么它的所有倍数 `2p, 3p, 4p, ...` 就都不是质数，将它们在数组中标记为 `false`。
4. **优化:** 外层循环到 $\sqrt{n}$，内层循环可以从 `p*p` 开始（因为 `2p, 3p, ..., (p-1)p` 已经被更小的质数筛过了）。
5. **统计:** 最后遍历一遍标记数组，得出结果。

### 实现原理和详细步骤

以 `countPrimes(n)` 为例：

1. **处理边界情况:** 如果 `n <= 2`，直接返回 0。因为小于 0, 1, 2 的质数个数都是 0。
2. **创建状态数组:** `boolean[] isPrime = new boolean[n];`
3. **初始化:** 使用 `Arrays.fill(isPrime, true);` 将数组所有元素初始化为 `true`。我们假设一开始所有数字（从 2 到 n-1）都是质数。
4. **外层循环:** `for (int i = 2; i * i < n; i++)`
   - 这个循环遍历所有可能的质因子。我们只需要检查到 `sqrt(n)`。
5. **判断当前数是否为质数:** `if (isPrime[i])`
   - 如果 `isPrime[i]` 仍然是 `true`，说明 `i` 没有被比它小的质数筛掉，所以 `i` 是一个质数。
6. **内层循环（筛掉倍数）:** `for (int j = i * i; j < n; j += i)`
   - 从 `i*i` 开始。为什么？因为像 `2*i`, `3*i` 这些倍数，它们肯定有一个比 `i` 更小的质因子（比如 2 或 3），所以在遍历到 `i` 之前，它们就已经被筛掉了。例如，当 `i=5` 时，`2*5=10` 已被 `i=2` 时筛掉，`3*5=15` 已被 `i=3` 时筛掉，`4*5=20` 已被 `i=2` 时筛掉。第一个需要由 5 来筛的合数是 `5*5=25`。
   - 将 `isPrime[j]` 设置为 `false`。

### 实现代码

```java
import java.util.Arrays;

class Solution {
    /**
     * 使用埃拉托斯特尼筛法 (Sieve of Eratosthenes) 统计小于 n 的质数数量。
     *
     * @param n 上限（不包含 n）
     * @return 小于 n 的质数数量
     */
    public int countPrimes(int n) {
        // 边界情况处理：小于等于 2 的数范围内没有质数
        if (n <= 2) {
            return 0;
        }

        // 创建一个布尔数组 `isPrime`，大小为 n。
        // isPrime[i] = true 表示数字 i 是质数，false 表示不是。
        // 数组索引天然地代表了数字 0, 1, 2, ..., n-1。
        boolean[] isPrime = new boolean[n];
        
        // 步骤 1: 初始化
        // 假设从 2 到 n-1 的所有数都是质数。
        // 0 和 1 不是质数，boolean 数组默认值为 false，所以无需显式处理。
        Arrays.fill(isPrime, 2, n, true);

        // 步骤 2: 遍历和筛选
        // 外层循环从 2 开始，到 sqrt(n) 结束。
        // 因为任何一个合数 N，都必然有一个小于或等于 sqrt(N) 的质因子。
        for (int i = 2; i * i < n; i++) {
            // 如果 isPrime[i] 是 true，说明 i 是一个质数。
            if (isPrime[i]) {
                // 步骤 3: 将 i 的倍数标记为非质数
                // 内层循环从 i*i 开始。
                // 优化：因为像 2*i, 3*i, ..., (i-1)*i 这样的数，
                // 它们必然有比 i 更小的质因子（2, 3, ...），
                // 所以在之前的外层循环中已经被筛掉了。
                // 例如，当 i=5 时，10(2*5), 15(3*5) 在 i=2 和 i=3 时就已被标记。
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // 步骤 4: 统计质数数量
        // 遍历 isPrime 数组，从 2 到 n-1，统计值为 true 的个数。
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) {
                count++;
            }
        }

        return count;
    }
}
```

### 注意事项

- **数组大小:** 数组需要开到 `n`，因为我们要判断 `n-1` 这个数。`new boolean[n]` 的索引范围是 `0` 到 `n-1`。
- **循环边界:**
  - 外层循环是 `i * i < n` 而不是 `i < sqrt(n)`。`i * i` 可以避免浮点数计算，更精确且效率略高。同时，需要注意 `i*i` 可能导致的整型溢出问题，但在此题 `n <= 5 * 10^6` 的约束下，`i` 最大约为 2236，`i*i` 不会超过 `int` 的范围，是安全的。
  - 内层循环从 `i*i` 开始，这是关键优化。
- **0 和 1 的处理:** 0 和 1 不是质数。在 Java 中，`boolean` 数组的默认值是 `false`，所以 `isPrime[0]` 和 `isPrime[1]` 天然就是 `false`，无需额外处理。统计时从 `i=2` 开始即可。
- **空间复杂度:** 算法需要一个大小为 `n` 的布尔数组，所以空间复杂度是 O(n)。
- **时间复杂度:** 虽然有两层循环，但内层循环不是每次都执行完整的。对于每个质数 `p`，内层循环执行 `n/p` 次。所有质数加起来，总的时间复杂度近似为 $O(nloglogn)$，这比 O(n) 稍大，但在实际工程中可以认为它几乎是线性的，效率非常高。

### 经验总结

- **从暴力到优化:** 解决算法题时，先思考最直观的暴力解法，然后分析其瓶颈（通常是时间复杂度），再寻找优化的思路。对于此题，瓶颈在于对每个数的重复、独立的判断。
- **筛法是处理范围问题的利器:** 当问题涉及一个连续整数范围内的数论属性时，筛法是首先要考虑的高效算法模式。它将孤立的判断转化为批量的筛选，大大降低了总计算量。
- **理解算法背后的数学原理:** 深刻理解为什么外层循环到 `sqrt(n)` 即可，以及为什么内层循环可以从 `i*i` 开始，是能否写出最优解的关键。这不仅是背代码，而是真正掌握了算法的精髓。
- **代码实现的细节:** 注意边界条件、数据类型溢出、循环起始和结束条件等细节，是保证代码正确性的基础。

# 组合数学

## 排列与组合

###排列公式 - 从n个元素中取m个按照顺序排列

$A_n^m = \frac {n!}{(n-m)!} $

###组合公式 - 从n个元素中取m个不考虑顺序

$C_n^m = \frac {n!}{m!(n-m)!}$

###杨辉三角公式

$C_n^m = C_{n-1}^{m-1} + C_{n-1}^{m}$

###**相关 LeetCode 题目:**

- 1. Next Permutation
- 1. Permutations
- 1. Permutations II (含重复元素)
- 1. Permutation Sequence
- 1. Combinations
- 1. Subsets (幂集)
- 1. Subsets II (含重复元素)

### Leetcode 2929 在小孩中分配糖果 II (Distribute Candies Among Children II) 

#### 问题要点

- **输入**: 整数 `n` (糖果总数) 和 `limit` (每个小孩能收到的糖果上限)。
- **目标**: 将 `n` 个完全相同的糖果分给 3 个不同的小孩。
- **约束**: 每个小孩得到的糖果数必须在 `[0, limit]` 区间内。
- **输出**: 返回满足条件的分配方案总数。

**示例:**

- `n = 5, limit = 2`
- 可能的分配方案: (1, 2, 2), (2, 1, 2), (2, 2, 1)
- 输出: 3

#### 问题本质和分析 - 一道纯粹的数学题！

这个问题的本质是一个经典的**组合数学**问题，属于“不定方程整数解计数”的范畴。

我们可以将问题转化为一个数学方程： 假设三个小孩分别得到 $x_1,x_2,x_3$ 个糖果。我们需要找到满足以下条件的非负整数解 $(x_1,x_2,x_3)$ 的数量：

$x_1+x_2+x_3=n$

$0\le{x_1}\le limit$

$0\le{x_2}\le limit$

$0\le{x_3}\le limit$

这里的核心挑战是如何处理上限 `limit` 这个约束。

#### 背景知识

要解决这个问题，需要两个关键的组合数学知识点：

##### 隔板法

隔板法用于解决“将 `n` 个相同物品放入 `k` 个不同盒子，允许盒子为空”的问题。

这等价于求解方程 $x_1+x_2+\dots+x_k=n$ 的非负整数解的个数。

其思想是，想象有 `n` 个糖果（星星 `*`）排成一排。

要在 3 个小孩之间分配，我们只需要在这 `n` 个糖果之间插入 3−1=2 个隔板 `|`。

例如，`***|*|**` 表示第一个小孩3个，第二个1个，第三个2个。

总共有 `n` 个星星和 `k-1` 个隔板，我们需要从 `n + k - 1` 个总位置中选择 `k-1` 个位置放隔板。

因此，方案数为：

$C(n+k−1,k−1)= (_{k-1}^{n+k-1})$

对于本题而言，如果没有约束，方案总数就是

$C_{n+k-1}^{k-1} = C_{n+2}^{2} = \frac {(n+2)(n+1)}{2}$

##### 容斥原理

容斥原理是用来计算多个集合并集大小的工具。对于三个集合 A, B, C，其并集大小为：

$∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−(∣A∩B∣+∣A∩C∣+∣B∩C∣)+∣A∩B∩C∣$

在我们的问题中，`limit` 约束意味着某些解是“不合法”的。

我们想求的是“合法”解的数量。

一个常见的思路是：

**合法解数量 = 总解数量 - 不合法解数量**

容斥原理在这里用来精确计算**不合法解数量**。

- 设 S 为所有满足 $x_1+x_2+x_3=n$ 的非负整数解的集合（无上限约束）。
- 设 $P_1$ 为属性“小孩1的糖果数超过limit”（即 $x_1\gt limit$）。
- 设 $P_2$ 为属性“小孩2的糖果数超过limit”（即 $x_2\gt limit$）。
- 设 $P_3$ 为属性“小孩3的糖果数超过limit”（即 $x_3 \gt limit$）。

我们想求的是**不具备任何这些属性**的解的数量。

根据容斥原理， 我们假设我们的结果是R，总数为T，那么：

$R = T - |P_1∪P_2∪P_3|$



**总数 - (至少1个违规) + (至少2个违规) - (至少3个违规)**

#### 核心思想和套路 - 隔板法 + 容斥原理

核心思想就是刚才提到的 **“隔板法 + 容斥原理”**。

##### 计算总的方案数

不考虑任何 `limit` 约束，使用隔板法计算 $x_1+x_2+x_3=n$ 的非负整数解个数。

$C_n = (_2^{n+2})$

##### 减去至少一个孩子违规的方案数

“违规”指 $x_i \gt limit$，等价于 $x_i \ge limit+1$。

假设小孩1违规 ($x_1\ge limit+1$)。

我们可以先给他 `limit+1` 个糖果，确保他违规。

剩下的 $n′=n−(limit+1)$ 个糖果再任意分配给**3个小孩**。

此时问题变为 $x_1′+x_2′+x_3′=n−(limit+1)$，同样按照上述理论推导，方案就变成了数为 $\binom{n−(limit+1)+2}2$。

有3个小孩，任何一个都可能违规，所以总共要减去的方案数是 $C(3,1)\times\binom{n−(limit+1)+2}2$。



#####加回至少两个孩子违规的方案数

在第2步中，两个孩子都违规的情况被减了两次，所以要加回来一次。

假设小孩1和小孩2都违规。我们先给他们每人 `limit+1` 个糖果。

剩下 $n′′=n−2(limit+1)$ 个糖果再任意分配给三个孩子。

方案数为 $\binom{n′′+2}2$。

有 $\binom{3}2$=3 种方式选择两个孩子，

所以要加回的方案数是 $\binom{3}2\times\binom{n−2(limit+1)+2}2$。



##### **减去三个孩子都违规的方案数 (C_3)**

同理，需要减掉所有三个孩子都违规的情况。

- 给每个孩子 `limit+1` 个糖果，剩下 $n′′′=n−3(limit+1)$ 个糖果。
- 方案数为 $\binom{3}3\times\binom{n−3(limit+1)+2}2$。

##### 最终公式

$最终结果 = C_0 - C_1 + C_2 -C_3$

#### 实现原理和步骤

**创建一个辅助函数**: 创建一个名为 `combinations2(k)` 的函数，用于计算将 `k` 个糖果分给3个小孩的无限制方案数，即 $\binom {k+2}2$。

- `combinations2(k)` 应该返回 `(long)(k + 2) * (k + 1) / 2`。
- **关键**: 如果 `k < 0`，说明糖果不够分，方案数为0。这个函数必须处理负数输入并返回0。
- 使用 `long` 类型进行计算，防止中间结果溢出。

**主函数中应用容斥原理**:

- 计算 $C_0=combinations2(n)$。
- 计算 $C_1=3\times combinations2(n−limit−1)$。
- 计算 $C_2=3\times combinations2(n−2\times(limit+1))$。
- 计算 $C_3=1\times combinations2(n−3\times(limit+1))$

**返回最终结果**:

- 返回 $C_0−C_1+C_2−C_3$。

#### 实现代码

```java

class Solution {
    public long distributeCandies(int n, int limit) {
        if(n/3 > limit) return 0;
        long c0 = combinations(n);
        long c1 = 3 * combinations(n-limit -1);
        long c2 = 3 * combinations(n-2*(limit+1));
        long c3 = combinations(n - 3*(limit + 1));
        return c0 - c1 + c2 + c3;
    }
    //C(n+3,3) = (n+1)(n+2)/2
    private long combinations(int n){
        if (n < 0) {
            return 0;
        }
        return (long)(n+1)*(n+2)/2;
    }
}
```

#### 注意事项 (Important Notes)

- **数据类型**: `combinations2` 函数中的计算 `(n + 2) * (n + 1)` 可能会超过 `Integer.MAX_VALUE`，因此必须使用 `long` 来存储中间结果和最终返回值，以避免溢出。
- **边界条件**: 辅助函数 `combinations2(n)` 必须正确处理 `n < 0` 的情况。当我们在计算 $C_1,C_2,C_3$ 时，传入的参数很有可能为负数。此时，物理意义是糖果不够这样分，所以方案数为0，这对于容斥原理的正确性至关重要。
- **公式理解**: 理解每一步的含义比死记公式更重要。$C_0$是总数，减去所有违规情况$C_1$，加回被重复减去的“双重违规”情况C_2，再减去被错误加回的“三重违规”情况$C_3$。

#### 经验总结

LeetCode 2929 是一个典型的将数学理论（组合数学）应用于编程问题的例子。它考察的不是复杂的算法或数据结构，而是对问题进行数学建模和求解的能力。

**识别模式是关键**。一旦你识别出“隔板法”和“上限约束->容斥原理”这个模式，问题就迎刃而解了。

在处理计数问题时，**容斥原理**是一个非常强大的工具，用于处理带有“至多”、“至少不”等否定性或上限性约束的场景。

代码实现通常很简单，但前提是数学推导必须正确。在面试中，清晰地向面试官解释你的数学推导过程和其中每一步的含义，比直接写出代码更重要。



### 

## 卡特兰数 - 常在计数问题中出现的数列

卡特兰数是组合数学中一个常在各种计数问题中出现的数列。

**特征与公式:**

- 递推公式: $C_n=∑_{i=0}^{n−1}C_iC_{n−1−i}$，其中 $C_0=1$。
- 通项公式: $C_n= \frac{1}{n+1}(_n^{2n})=\frac {(2n)!}{(n+1)!n!}$
- 应用场景：二叉树计数、出栈序列、凸多边形三角划分等。

