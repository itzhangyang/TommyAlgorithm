# 4. **哈希表**

## 哈希表的核心思想和套路

哈希表的根本思想是空间换时间。

它通过一个哈希函数将键映射到一个存储位置，从而实现快速访问。

在Leetcode中，万变不离其宗的套路可以分为两个大类：

### 快速查找与计数

**套路：** 当你需要快速判断一个元素是否在集合中出现过，或者需要统计每个元素出现的次数时。

**核心：** 利用哈希表的 O(1) 查询特性，避免线性搜索的 O(n) 开销。

**数据结构：**

- `HashSet` 或 `unordered_set`：只关心元素是否存在，不关心其数量。
- `HashMap` 或 `unordered_map`：关心每个元素出现的次数，Key存储元素，Value存储频率。

###建立映射关系

**套路：** 当题目中的**元素之间存在某种需要快速访问的对应关系**时。

**核心：** 将一种数据（或其属性）作为Key，将另一种相关数据作为Value，建立直接映射，方便快速查询。

**数据结构：** `HashMap` 或 `unordered_map`。

## 查找类

这是哈希表最直接的应用，用于加速查找和统计过程。

### 寻找配对或者互补元素：LeetCode #1 - 两数之和

**场景 + 目标:** 在数组中找到和为 `target` 的两个数的下标。

**模式匹配:** 遍历到 `nums[i]` 时，需要快速判断 `target - nums[i]` 是否存在。这正是“查找表”模式。

**实现原理和步骤:**

1. 初始化一个 `HashMap<Integer, Integer>`，Key存数字，Value存下标。
2. 遍历数组，对每个数 `num`，计算其配对数 `complement = target - num`。
3. 在哈希表中查找 `complement` 是否存在。
4. 若存在，则返回 `map.get(complement)` 和当前下标 `i`。
5. 若不存在，将当前数 `num` 和其下标 `i` 存入哈希表，供后续元素查询。

**实现代码 (Java):**

```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

### 存在性判断：Leetcode 128: 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

#### 核心思想和套路 - 使用HashSet判断相邻元素是否存在

遍历所有数组中的连续序列，记录并比较每个连续序列的长度。

##### 将所有元素加入Set

##### 检查set中的每一个元素num

##### 如果`num-1`在set中

说明当前的数字已经被上一个序列计算过了，不需要再次计算。

直接跳过。

#####如果`num-1`不在set中

说明当前数字是一个序列的**起点**，我们开始尝试判断num后面有多少连续数字在数组中。

依次判断`n+1`,`n+2`,`n+3`...直到某个数字不存在于数组当中为止。

```Java
int next = num + 1;
int len = 1;
while(set.contains(next)){
  next = next + 1;
  len += 1;
}
maxLen = Math.max(len,maxLen);
```

#### 实现代码

```Java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num: nums){
            set.add(num);
        }
        int maxLength = 0;
        for (int num: set){
            if (!set.contains(num-1)){
               int next = num+1;
               int length = 1;
               while (set.contains(next)) {
                next = next+1;
                length += 1;
               }
               maxLength = Math.max(maxLength, length);
            }
        }
        return maxLength;
        
    }
}
```



##频率统计

### 核心思想

使用Map统计元素出现的频率，适用于`第一个不重复字符`、`出现次数最多/最少`等问题

### 实现原理

哈希表存储字符 → 次数的映射，快速查询和更新频次。

### 代码模板

```java
Map<Character, Integer> freq = new HashMap<>();
for (char c : s.toCharArray()) {
    freq.put(c, freq.getOrDefault(c, 0) + 1);
}
```

### 注意事项

- 避免直接使用 `map.get()` 导致 `NullPointerException`
- **对于 int[] 数组或仅涉及 26 个小写字母，可用 `int[26]` 代替 `Map<Character, Integer>` 提升性能**

### Leetcode 387:第一个唯一字符

给定一个字符串 `s`，找出其中**第一个不重复**的字符，并返回它的**索引**。如果不存在，则返回 -1。

#### 问题本质

- **计数统计+顺序查找**
- 要找到**第一个只出现一次** 的字符，需要：
  - 既能统计字符出现次数
  - 又能保持字符出现的顺序

#### 核心思想-两次遍历

- 第一次：统计每个字符出现的次数-**哈希表或者数组**
- 第二次： 按照字符顺序查找第一个次数为1的字符

#### 实现原理

##### 数据结构选择-int[26]

因为只涉及到**小写字母a-z**，可用用一个`int[26]`数组替代`Map`，提高效率

##### 实现步骤

1. 初始化一个`int[26]`的数组，用于记录每个字母出现的次数
2. 遍历字符串，更新频次数组
3. 再次遍历字符串，按照顺序找出频次为1的第一个字符并返回索引
4. 如果没有找到，则返回-1.

#### 代码实现

```java
public int firstUniqChar(String s){
  int[] frequencies = new int[26];
  char[] chars = s.toCharArray();
  
  for (char ch : chars){
    frequencies[ch-'a']++;
  }
  
  for (int i=0;i<chars.length;s++){
    char ch = chars[i];
    if (frequencies[ch-'a']==1){
      return i;
    }
  }
  
  return -1;
}
```

### Leetcode 451. 根据字符出现频率排序

给定一个字符串 `s` ，根据字符出现的 **频率** 对其进行 **降序排序** 。一个字符出现的 **频率** 是它出现在字符串中的次数。

返回 *已排序的字符串* 。如果有多个答案，返回其中任何一个。

#### 核心思想

##### 使用哈希表统计字符出现频率

注意字符串中的字符范围为**大小写字母+数字**，超出了**小写字母a-z**范围

因此我们使用数组的方式会比较复杂，使用HashMap会更加灵活。

##### 使用大顶堆按照频率对字符进行排序

###### 创建一个按照字符频率降序排序的大顶堆

注意降序排序的方式

```java
PriorityQueue pq = new PriorityQueue((a,b)->value(b)-value(a));
```

###### 将哈希表中的Key加入大顶堆

```Java
for(char c : counter.keySet()){
  pq.offer(c);
}
```

###### 依次从大顶堆堆顶取出字符并根据出现次数构建结果字符串

```Java
while(!pq.isEmpty()){
  char c = pq.poll();
  int freq = counter.getOrDefault(c,0);
  for(int i = 0; i < freq; i++){
    sb.append(c);
  }
}
```



#### 代码实现

```java
   public String frequencySort(String s) {
        Map<Character, Integer> frequencyMap = new HashMap<>();

        for (char ch: s.toCharArray()){
            frequencyMap.put(ch,frequencyMap.getOrDefault(ch, 0)+1 );
        }

        PriorityQueue<Character> pq = new PriorityQueue<>((a,b)->frequencyMap.get(b)-frequencyMap.get(a));
        for(char c : frequencyMap.keySet()){
            pq.offer(c);
        }
        StringBuilder sb = new StringBuilder();
        while (!pq.isEmpty()){
            char c = pq.poll();
            int freq = frequencyMap.get(c);
            for (int i=0;i<freq;i++){
                sb.append(c);
            }
        }

        return sb.toString();
    }

```

## 判重类

### 核心思想-HashSet

利用`Set`只存**唯一元素的特性**，快速判断某个元素是否已经出现

### 实现原理

遍历数组，逐个添加到`Set`中，如果已经存在则显示重复

### 代码模板

```java
Set<Integer> seen = new HashSet<>();
for (int num : nums) {
    if (seen.contains(num)) return true;
    seen.add(num);
}
return false;
```

### 注意事项

- `HashSet.add()`返回值可以直接判断是否添加成功
- 注意数据范围，避免数组越界，比如使用`boolean[]`时

### LeetCode #3 - 无重复字符的最长子串(滑动窗口+哈希表)

**场景 + 目标:** 找到字符串中没有重复字符的最长子串长度。

**模式匹配:** 滑动窗口问题。

需要在 O(1) 时间内判断加入窗口的新字符是否已在窗口内存在，并获取其位置。

**实现原理和步骤:**

1. 用 `HashMap<Character, Integer>` 记录字符及其最新出现的位置。
2. 用双指针 `start` 和 `end` 维护一个窗口。
3. `end` 指针不断右移，当遇到重复字符 `c` 且**其上一次出现的位置 `map.get(c)` 在当前窗口内 (`>= start`) 时**，将 `start` 指针移动到重复字符的下一位，即 `map.get(c) + 1`，从而保证窗口内无重复。
4. 每次移动 `end` 后，都更新 `c` 的最新位置到 map 中，并计算当前窗口长度 `end - start + 1` 来更新最大长度。

**实现代码 (Java):**

```Java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0;
        for (int end = 0, start = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            if (map.containsKey(c)) {
                start = Math.max(start, map.get(c) + 1);
            }
            map.put(c, end);
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }
}
```



### Leetcode 217

#### 问题要点

Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.

#### 核心思想和套路 - HashSet

本题**不需要完整统计每一个元素出现的频率**。

只需要遍历并将当前元素加入set，如果加入之前发现已经存在，直接返回true.

```Java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            if (set.contains(num)){
                return true;
            }else{
                set.add(num);
            }
        }
        return false;
    }
}
```



### Leetcode 219

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。



#### 核心思想-滑动窗口+HashSet

##### 定义一个`capacity=k`的Set滑动窗口

###### 如果窗口内有重复元素则返回结果

窗口应当被定义成`Set`,因为一旦有重复元素，窗口则不再有意义，直接返回结果即可

###### 如果窗口内没有重复元素则继续扩展

如果窗口不包含当前元素，则将当前元素加入到窗口

###### 如果窗口大小超过K则收缩窗口

如果窗口大小超过K则收缩窗口

##### 滑动窗口是怎样扩展的？

当元素`nums[i]`没有出现在滑动窗口中时，将`nums[i]`加入到窗口中

##### 滑动窗口是怎样收缩的？

当窗口的`size > k`，删除窗口中最早出现的元素，也就是`nums[i-k]`，来维持滑动窗口的大小不超过k.



#### 代码实现

```java
public boolean containsNearbyDuplicate(int[] nums, int k){
  Set<Integer> window = new HashSet<>();
  
  for (int i=0;i<nums.length;i++){
    if (window.contains(nums[i])){
      return true;
    }
    
    window.add(nums[i]);
    
    if (window.size() > k){
      window.remove (nums[i-k]);
    }
  }
  
  return false;
}
```

## 缓存类

用于图、树、复杂链表的遍历和复制，避免重复访问或创建。

### 典型题目

- `#138` 复制带随机指针的链表 (Copy List with Random Pointer)
- `#141` 环形链表 (Linked List Cycle)
- `#133` 克隆图 (Clone Graph)

### LeetCode #138 - 复制带随机指针的链表

**场景 + 目标:** 深拷贝一个包含 `next` 和 `random` 指针的复杂链表。

**模式匹配:** “深拷贝”图结构，需要建立新旧节点的一一对应关系，防止指针指向旧图。这是典型的“缓存/记忆化”模式。

**实现原理和步骤:**

1. 初始化 `HashMap<Node, Node>` 作为 `visited` 缓存，映射“旧节点 -> 新节点”。
2. 第一次遍历原链表，仅创建新节点，并填充 `visited` 映射：`map.put(oldNode, new Node(oldNode.val))`。
3. 第二次遍历原链表，利用 `visited` 映射来连接新节点的 `next` 和 `random` 指针。对于每个 `oldNode`: `newNode.next = map.get(oldNode.next)` 和 `newNode.random = map.get(oldNode.random)`。

实现代码

```Java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> map = new HashMap<>();
        Node curr = head;
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }
        curr = head;
        while (curr != null) {
            Node newNode = map.get(curr);
            newNode.next = map.get(curr.next);
            newNode.random = map.get(curr.random);
            curr = curr.next;
        }
        return map.get(head);
    }
}
```



##元素索引映射类-解决两数之和问题

### 核心思想-建立元素->索引的映射

建立元素 → 索引的映射，用于快速查找是否存在特定目标元素或某种关系。

### 实现原理

常与“补数”有关（例如“target - num”），是经典的两数之和解法。

### 代码模板

```java
Map<Integer, Integer> map = new HashMap<>();
for (int i=0;i<nums.length;i++){
  int complement = target-nums[i];
  if (map.containsKey(complement)){
    return new int[]{map.get(complement),i};
  }
  
  map.put(nums[i],i);
}
```

### 注意事项

- 索引不能覆盖自己 ->放在`map.put()`之后判断

### Leetcode 1 两数之和

见上述代码模板

### Leetcode 454 四数相加 II

给定四个整数数组 `A`, `B`, `C`, `D`，每个长度都是 `n`，你需要计算有多少个元组 `(i, j, k, l)`，使得：

```java
A[i] + B[j] + C[k] + D[l] == 0
```

#### 问题本质

这是一个求**四元组和为0的个数**，如果你暴力枚举，时间复杂度是O(N^4)，不可接受。

所以要利用`哈希表`，把4sum问题转化为两个**2sum**的问题：

两两配对，转化为**两个数组的两数之和为目标数**的形式。

#### 核心思想：哈希表+分治+折半枚举

将原问题转化为**两个数组的两数之和**问题：

1. 预处理A+B的所有组合数，记录每种和出现的次数
2. 遍历C+D所有组合的和，对于每个`sum2=c+d`, 查看`-sum2`在哈希表中是否存在，统计出现次数

这样做，时间复杂度从`O(N^4)`变成`O(N^2)`，可以接受。

#### 实现原理

1. 使用一个`HashMap<Integer,Integer>`， 统计所有`A[i]+B[j]`的和出现的次数
2. 遍历`C[k]+D[l]`的所有组合，对于每个`sum2`，查找`map.get(-sum2)`;
3. 如果存在，记忆将这个频次加到结果中。

#### 实现代码

```java
public int forSumCount(int[] A, int[] B, int[] C, int D[]){
  Map<Integer, Integer> abSumCount = new HashMap<>();
  for (int a:A){
    for (int b:B){
      int sum = a+b;
      abSumCount.put(sum,abSumCount.getOrDefault(sum,0)+1);
    }
  }
  
  int count =0;
  
  for (int c:C){
    for (int d:D){
      int sum = c+d;
      count += abSumCount.getOrDefault(-sum,0);
    }
  }
  
  return count;
}
```

## 前缀和 + 哈希表类-子数组求和问题

### 核心思想

通过前缀和简化子数组求和问题，哈希表记录**历史前缀**和**出现次数**

前缀和+哈希表的组合问题在Leetcode中有几个不同的题型，在解决方法中，使用map保存前缀和相关的属性。

- Key一般为前缀和
- Value： 根据不同的使用场景，可能会有不同的value

### 实现原理

对于每个 `sum[j]`，判断是否存在`sum[i]== sum[j]-k`，有则说明**区间`[i+1,j]`的和为`k`**.

### 代码模板套路

```java
Map<Integer, Integer> map = new HashMap<>();
//前缀和为0的有一个子数组，即空数组
map.put(0,1);

int sum=0; count=0;

for (int num:nums){
  sum +=num;
  count += map.getOrDefault(sum-k,0);
  map.put(sum, map.getOrDefault(sum,0)+1);
}

return count;
```

### 注意事项

- **初始map中必须放入`(0,1)`表示sum=0出现过一次**
- 适用于**和为K的子数组个数**这一类题

### 类别一： 求子数组/子串的 **数量**

这类问题的共同点是要求统计满足特定和（或性质）的子数组有多少个。

####Leetcode 560 : 和为K的子数组:`<前缀和，前缀和出现的次数>`

给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

##### Key和Value

- Key : PrefixSum
- Value: 前缀和出现的次数

##### 核心思想 - 在`nums[i]`之前有多少`nums[i]`满足 `currentSum - prefixSum[i-1] = k`

在遍历到索引 `j` 时，我们计算出当前的前缀和 `currentSum`。

我们想知道有多少个 `i` (i < j) 满足 `currentSum - prefixSum[i-1] = k`。

这等价于寻找 `prefixSum[i-1] = currentSum - k`。

因此，我们需要一个哈希表来记录在 `j` 之前，每个前缀和值出现了多少。

##### 实现原理

1. 初始化哈希表 `map`，放入 `{0: 1}`，表示和为0的前缀（空数组）出现过1次。
2. 遍历数组，累加 `currentSum`。
3. 在哈希表中查找 `currentSum - k` 这个 `key` 对应的 `value`（出现次数），并累加到最终结果 `count` 中。
4. 将当前的 `currentSum` 存入哈希表，更新其出现次数。

##### 实现代码

```Java
//前缀和 + 哈希表
//Key：前缀和
//Value: 最后一次出现前缀和的次数
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSumCounter = new HashMap<>();
        prefixSumCounter.put(0,1);//前缀和为0的出现一次，即空数组
        int currSum = 0;
        int count = 0;
        for(int i = 0; i < nums.length;i++){
            currSum += nums[i];
            int target = currSum - k;
            count += prefixSumCounter.getOrDefault(target,0);
            prefixSumCounter.put(currSum,prefixSumCounter.getOrDefault(currSum,0) + 1);
        }
        return count;
    }
}
```

##### 注意事项

- 必须初始化 `map.put(0, 1)`，否则会漏掉从索引 0 开始且和为 `k` 的子数组。
- 数组中可能包含负数，所以前缀和可能减小。

**经验总结**：这是该模式的母题。**求数量，`value` 就存次数**。理解了这道题，就掌握了 80% 的同类问题。

#### LeetCode 1248：统计「优美子数组」 - 转换思想:<前缀和，前缀和出现的次数>

##### 问题要点

**题目描述**：给你一个整数数组 `nums` 和一个整数 `k`。如果某个连续子数组中恰好有 `k` 个奇数，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。

##### 前缀和Map的定义

- `key`: 奇数的个数（即转换后的前缀和）。
- `value`: 该奇数个数出现的 **次数**。

##### 核心思想

问题可以转换为求“和为 k 的子数组个数”。

我们将奇数看作 `1`，偶数看作 `0`。那么原问题就变成了：在这个新数组中，有多少个子数组的和恰好为 `k`？这与 LeetCode 560 完全一样。

##### 实现原理

1. 创建一个前缀和变量 `oddCount`，表示从数组开头到当前位置的奇数总数。
2. 初始化哈希表 `map`，放入 `{0: 1}`，表示有0个奇数的前缀出现了1次。
3. 遍历数组，如果当前数字是奇数，`oddCount++`。
4. 在哈希表中查找 `oddCount - k` 出现的次数，并累加到结果中。
5. 将当前的 `oddCount` 存入哈希表，更新其出现次数。

##### 实现代码

```Java
//前缀和 + 哈希表
//Key： 奇数的个数
//Value：该奇数的个数出现的次数
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        Map<Integer,Integer> counter = new HashMap<>();
        counter.put(0,1);

        int currSum = 0;
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            int num = nums[i] % 2 == 1 ? 1 : 0;
            currSum += num;
            int target = currSum - k;
            count += counter.getOrDefault(target,0);

            counter.put(currSum,counter.getOrDefault(currSum,0) + 1);
        }
        return count;
    }
}
```

##### 注意事项

关键在于将问题抽象和转换。识别出什么可以作为 "1"，什么可以作为 "0"，从而套用前缀和模板。

##### 经验总结

很多问题不会直接让你求和，而是统计某种性质。学会将这种性质 **量化**（比如奇数个数），就可以转化为前缀和问题。



#### Leetcode 930: 和相同的二元子数组：<前缀和，前缀和出现的次数>

##### 问题要点

**题目描述**：给你一个二元数组 `nums` 和一个整数 `goal`，请你统计并返回和为 `goal` 的非空子数组的总数。

##### 前缀和Map的定义

- `key`: 前缀和 `prefixSum`。
- `value`: 该前缀和出现的 **次数**。

##### 核心思想

与 LeetCode 560 一模一样，只是数组元素限定为 0 和 1，这使得问题更简单，但解法完全相同。

##### 实现代码

```Java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        Map<Integer,Integer> counter = new HashMap<>();
        counter.put(0, 1);

        int currSum = 0;
        int count = 0;
        for(int i = 0; i < nums.length;i++){
            currSum += nums[i];
            int target = currSum - goal;
            count += counter.getOrDefault(target, 0);

            counter.put(currSum, counter.getOrDefault(currSum, 0) + 1);
        }

        return count;
    }
}
```

### 类别二： 求子数组/子串 最大/最小长度 - 求长度，value就用索引

#### Leetcode 525: 连续数组 ：<前缀和，前缀和首次出现的索引>

##### 问题要点

给定一个二进制数组 `nums` , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

##### 核心思想  - 求长度，value就用索引

######将0视为-1：求和为0的最长子数组

“相同数量的 0 和 1” 意味着子数组中 `1 的数量` 等于 `0 的数量`。

将 `0` 转换为 `-1` 后，问题就变成了 “找到和为 0 的最长子数组”。

######前缀和：寻找`prefixSum[j] == prefixSum[i-1]`

如果 `prefixSum[j] == prefixSum[i-1]`，则说明 `i` 到 `j` 之间的子数组和为 0。

为了让 `j - (i-1)` 最长，对于每个 `prefixSum` 值，我们只需要记录它第一次出现的索引。

##### 实现原理

1. 初始化哈希表 `map`，放入 `{0: -1}`。

   - `0` 表示初始前缀和

   - `-1` 表示在**数组开始之前**的位置， 注意这是我们用前缀和HashMap存储索引的标准套路。

2. 遍历数组，将 `0` 视为 `-1` 累加到 `currentSum`。
3. 检查 `currentSum` 是否已存在于哈希表中：
   - 如果存在，说明找到了一个和为 0 的子数组，其长度为 `当前索引 i - map.get(currentSum)`。更新最大长度。
   - 如果不存在，将 `{currentSum: i}` 存入哈希表。

##### 实现代码

```Java
//寻找0和1数量相当的最大子数组
//转化为和为0的最大子数组问题
//将所有0视为-1，原问题就变成了和为0的最大子数组
//前缀和哈希表的定义
//key：前缀和
//value：前缀和第一次出现的索引

class Solution {
    public int findMaxLength(int[] nums) {
        Map<Integer, Integer> prefixSumFirstIndexMap = new HashMap<>();
        //前缀和为0的第一个索引设置为-1（索引作为value的固定套路）
        prefixSumFirstIndexMap.put(0, -1);
        int currSum = 0;
        int ans = 0;

        for(int i = 0; i < nums.length;i++){
            int num = nums[i] == 0 ? -1 : 1;
            currSum += num;
            if(prefixSumFirstIndexMap.containsKey(currSum)){
                int firstIndex = prefixSumFirstIndexMap.get(currSum);
                int len = i - firstIndex;
                ans = Math.max(ans, len);
            }else{
                prefixSumFirstIndexMap.put(currSum, i);
            }
        }
        return ans;
    }
}
```

##### 注意事项

初始化 `map.put(0, -1)` 是为了能正确计算从索引 0 开始的满足条件的子数组。

因为要求最长，所以哈希表中只记录每个前缀和 **第一次** 出现的索引。如果后面再次遇到相同的前缀和，不要更新索引。

##### 经验总结

**求长度，`value` 就存索引**。

这是与求数量问题最核心的区别。

#### Leetcode 325:和为K得最大子数组长度:<前缀和，前缀和首次出现的索引>

##### 问题该要

给定一个数组 `nums` 和一个目标值 `k`，找到和等于 `k` 的最长子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

##### 前缀和Map的定义

- `key`: 前缀和 `prefixSum`。
- `value`: 该前缀和 **首次** 出现的 **索引**。

##### 核心思想

我们寻找 `prefixSum[i-1] = prefixSum[j] - k`。

当我们遍历到 `j` 时，我们计算出 `currentSum` (即 `prefixSum[j]`)，然后去哈希表中寻找 `currentSum - k` 这个 `key`。

如果找到了，说明存在一个子数组和为 `k`，其结束位置是 `j`，开始位置是 `map.get(currentSum - k) + 1`。

长度即为 `j - map.get(currentSum - k)`。为了使长度最长，我们只需要记录每个前缀和首次出现的索引。

##### 实现原理

初始化哈希表 `map`，放入 `{0: -1}`。

遍历数组，计算 `currentSum`。

计算 `complement = currentSum - k`，在哈希表中查找它。

如果 `complement` 存在，则计算长度 `i - map.get(complement)` 并更新最大长度。

如果当前的 `currentSum` 不在哈希表中，则存入 `{currentSum: i}`。

##### 实现代码

```Java
//和为K得最长子数组
//前缀和 + Map
//Key：前缀和
//Value： 前缀和第一次出现的索引
class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        Map<Integer,Integer> preSumFirstIndexMap = new HashMap<>();
        preSumFirstIndexMap.put(0, -1);

        int ans = 0;
        int currSum = 0;
        for(int i = 0; i < nums.length; i++){
            currSum += nums[i];
            int target = currSum - k;
            if(preSumFirstIndexMap.containsKey(target)){
                int firstIndex = preSumFirstIndexMap.get(target);
                int len = i - firstIndex;
                ans = Math.max(len, ans);
            }
            if(!preSumFirstIndexMap.containsKey(currSum)){
                preSumFirstIndexMap.put(currSum, i);
            }
        }
         return ans;
    }
}
```

##### 注意事项

与 525 题一样，只记录前缀和首次出现的索引。

##### 经验总结

- 这是将 "求数量" 的 560 题和 "求长度" 的 525 题思想结合的完美范例。它清晰地展示了 `value` 存索引的用法。

###类别三 ： 前缀和 + 同余定理：<mod,mod出现的次数或者索引>

####Leetcode 942 和可被K整除的子数组：<前缀和 %K, 前缀和 %K出现的次数>

给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中 **和能被 `k` 整除的连续子数组的个数**。

- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `2 <= k <= 10^4`

#### 问题的本质-**前缀和+模运算+哈希计数**

这是一个典型的**前缀和+模运算+哈希计数**的问题

- 子数组的和能够被`k`整除, 子数组的**前缀和差**是`k` 的倍数 -> **前缀和 `mod k` 相等**？
- 求的是**满足条件的数组的个数**，不是子数组本身，所以可以使用**统计`前缀和模值`频率**的方式来快速计算
  - 求个数的话，哈希表中存储前缀和的频率
  - 求具体的子数组的话，哈希表中存储什么呢？

#### 核心思想

求和满足特定特定的子数组的个数，Map的value必然是**子数组出现的次数**。

##### 核心结论

若两个前缀和`sum[i]`和`sum[j]`满足

```java
(sum[j]-sum[i]) % k ==0 -> sum[j] %k == sum[i] %k
```

那么**`nums[i+1...j]`之间的和是能被k整除的**

##### 解法思路

- **前缀和：**用一个变量`preSum`表示当前前缀和
- **哈希表：**用一个`HashMap<Integer,Integer>`表示**前缀和模** `preSum % k`的出现次数
- **遍历数组**
  - 计算每个元素的**前缀和模**，如果之前出现过相同的`前缀和模`， 则说明有若干子数组否和条件
  - 最后返回统计值即可

#### 实现原理

##### 初始化前缀和模频率Map

- 初始值为`map.put(0,1)`，表示**前缀和为0的情况**

##### 遍历数组：

- 计算前缀和 `preSum += num`;
- 计算**前缀和模**`mod = ((preSum % k)+k)% k ->多加一个K防止余数出现负数的情况`
  - 注意多加一个k是为了**防止出现负数的情况**
- 如果 `mod`在`map`中已经出现，则累加结果，这些是**之前出现过的相同的余数**
- 将`mod`出现次数+1

#### 实现代码

```java
//和可以被K整除的子数组的数量
//Key: prefix sum % k
//Value: number of prefix sum % k
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> counter = new HashMap<>();
        counter.put(0,1);

        int currSum = 0;
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            int num = nums[i];
            currSum += num;
            //防止正数变成负数，确保余数都是正数
            //注意求余数的具体套路
            int mod = (currSum+k) % k;
            if(counter.containsKey(mod)){
                count += counter.get(mod);
            }
            counter.put(mod, counter.getOrDefault(mod, 0) + 1);
        }
        return count;
    }
}
```



#### 注意事项

- **负数处理**：Java 中 `%` 运算可能为负，需要 `(mod + k) % k` 规范为正（**重要**）。
- **初始化 map.put(0,1)**：必须初始化，表示空前缀（或从数组头开始的子数组）。
- **不能直接枚举所有子数组**：时间复杂度是 O(n²)，会超时；必须使用前缀和+哈希降为 O(n)。
- **空间复杂度 O(k)**：最多 `k` 种不同的余数。
- 时间复杂度：`O(n)`
- 空间复杂度：`O(k)`

#### 总结

| 维度           | 内容                                                  |
| -------------- | ----------------------------------------------------- |
| **问题类型**   | 前缀和 + 模运算 + 哈希统计                            |
| **核心判断**   | `(preSum[j] - preSum[i]) % k == 0 ⇨ mod[j] == mod[i]` |
| **实现技巧**   | map 记录余数频次，初始值 map.put(0,1)                 |
| **负数处理**   | `((mod % k) + k) % k`                                 |
| **时间复杂度** | O(n)                                                  |

#### Leetcode 523: 是否连续的子数组和为K的倍数：<前缀和mod K, 首次索引>

##### 问题要点

给你一个整数数组 `nums` 和一个整数 `k`，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

- 子数组大小 **至少为 2**
- 且子数组元素总和为 `k` 的倍数。

##### 前缀和HashMap的定义：<前缀和mod K, 首次索引>

- `key`: 前缀和 `prefixSum` 对 `k` 取模后的 **余数**。
- `value`: 该余数 **首次** 出现的 **索引**。

##### 核心思想：求子数组和是否K的倍数即求两者的前缀和%k是否相同

与 974 题一样，我们寻找两个前缀和，它们的余数相同。

即 `prefixSum[j] % k == prefixSum[i-1] % k`。

但本题有额外要求：子数组长度至少为 2，即 `j - (i-1) >= 2`，化简得 `j - i >= 1`。

当我们遍历到索引 `j` 时，如果发现当前的余数 `mod` 在哈希表中已经存在（假设是在索引 `i` 处出现的），我们只需要检查 `j - i` 是否大于等于 2 即可。

因为我们只需要判断“存在性”，所以哈希表的 `value` 存储索引更方便计算长度。

##### 实现原理

处理特殊情况 `k=0`（这在题目约束中可能需要讨论，但在 LeetCode 的测试用例中 `k` 不会为 0）。

初始化哈希表 `map`，放入 `{0: -1}`。这表示余数 0 在索引 -1 处出现。如果 `prefixSum[j]` 本身是 `k` 的倍数，那么 `j - (-1) >= 2` 即 `j >= 1`，这个条件是满足的。

遍历数组，计算 `currentSum` 和 `remainder`。

在哈希表中检查 `remainder` 是否存在：

- 如果存在，获取其索引 `prevIndex`，并检查 `i - prevIndex >= 2`。如果满足，立即返回 `true`。
- 如果不存在，将 `{remainder: i}` 存入哈希表。

遍历结束仍未找到，返回 `false`。

##### 实现代码

```Java
//前缀和 + HashMap
//求是否K的倍数即prefix[i-1] % k == prefix[j] %k
//Key： 前缀和 % k，确保排除负数应当(前缀和 + K) % k
//Value: 首次出现索引
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer,Integer> firstIndexMap = new HashMap<>();
        firstIndexMap.put(0, -1);//使用索引作为Value的统一套路
        int currSum = 0;
        for(int i = 0; i < nums.length; i++){
            currSum += nums[i];
            int mod = currSum % k;
            if(firstIndexMap.containsKey(mod)){
                int firstIndex = firstIndexMap.get(mod);
              //前缀和firstIndex是上一个周期的最后一个元素，因此应当取其后面一个元素的索引作为子数组的第一个元素
                if(i > firstIndex + 1){
                    return true;
                }
            }else{
                firstIndexMap.put(mod, i);
            }
        }
        return false;
    }

}
```

##### 注意事项

1. `k` 可能为 0，但 LeetCode 的约束通常是 `k` 为正整数。如果是 `0`，则需要找和为 `0` 的子数组。
2. `value` 存索引是为了判断长度。因为要求长度至少为2，所以只记录**首次**出现的索引可以保证我们计算出的 `i - prevIndex` 是最长的，如果连最长的都不满足2，短的更不可能。
3. `map.put(0, -1)` 的初始化非常精妙，统一了对 "从头开始的子数组" 和 "中间部分的子数组" 的处理逻辑。

##### 经验总结

这道题融合了**同余定理**和**求长度/位置**的思想。当问题既有“整除”条件，又有“长度”或“存在性”判断时，`key` 就是余数，`value` 就是索引。

#### Leetcode 1590: 删除最小子数组使数组能够被P整除：<余数, 最后一个索引>

给你一个正整数数组 `nums`，请你移除一个最短的子数组（可以为空），使得剩余元素的和能被 `p` 整除。 如果无法实现，请返回 -1。

##### 前缀和Map的定义：求最小数组应当使用最后一个index作为值

`key`: 前缀和 `prefixSum` 对 `p` 取模后的 **余数**。

`value`: 该余数对应的最新 **索引**。

##### 核心思想

首先计算整个数组的和 `totalSum`。

如果 `totalSum % p == 0`，则无需移除，答案为 0。

否则，设 `targetMod = totalSum % p`。

我们的目标是移除一个子数组，其和 `subArraySum` 满足 `subArraySum % p == targetMod`。

这样 `(totalSum - subArraySum) % p` 就会等于 0。



问题转化为：**寻找和对 `p` 取模等于 `targetMod` 的最短子数组**。

设 `(prefixSum[j] - prefixSum[i-1]) % p == targetMod`。

移项得 `prefixSum[i-1] % p = (prefixSum[j] % p - targetMod + p) % p`。

$mod[i-1] = (mod[j] - targetMod + p) %p$

我们遍历 `j`，计算 `prefixSum[j]` 的余数 `mod_j`，然后去哈希表中寻找一个 `mod_{i-1}` 满足上述等式。

为了使子数组 `j - (i-1)` 最短，**我们需要 `i-1` 的索引尽可能大，所以 `value` 应该存储最新的索引**。



##### 实现原理

- 计算 `totalSum` 和 `targetMod`。

- 初始化哈希表 `map`，放入 `{0: -1}`。

- 遍历数组，计算 `currentSum` 及其余数 `currentMod`。

- 计算需要寻找的 `complementMod = (currentMod - targetMod + p) % p`。

- 如果在哈希表中找到了 `complementMod`，则计算出一个候选长度 `i - map.get(complementMod)`，并更新最短长度。

- 将当前的 `{currentMod: i}` 放入哈希表，**覆盖**旧的索引，因为我们需要最新的位置来计算最短的长度。

##### 实现代码

```Java
//移除一个数组，使得剩余元素和可以被P整除
//返回最小的可移除数组
//求整个数组的和
//求和为sum - sum % p的最小子数组
class Solution {
    public int minSubarray(int[] nums, int p) {
        long sum = 0;
        for (int num : nums){
            sum += num;
        }
        // if(sum % p == 0) return 0;

        int targetMod = (int)(sum % p);
        if(targetMod == 0) return 0;
        int ans = nums.length;
        long currSum = 0;
        //求最小子数组，应当使用<前缀和，最后一个索引>
        Map<Integer, Integer> lastIndexMap = new HashMap<>();
        lastIndexMap.put(0, -1);//相同的初始化方式
        //我们要找一个最小的子数组，使得sub_sum % p == k
        //这个时候的前缀数组的key应该是什么呢？应该是currSum mod p
        //(preSum[j] % p - preSum[i-1] %p + p) % p = targetMod
        //preSum[i-1] % p = (preSum[j] - targetMod +p) % p
        for(int i = 0; i < nums.length;i++){
            currSum += nums[i];
            int mod = (int)(currSum % p);
            int target = (mod - targetMod + p ) % p;
            if(lastIndexMap.containsKey(target)){
                int lastIndex = lastIndexMap.get(target);
                int len = i - lastIndex;
                ans = Math.min(len, ans);
            }
            lastIndexMap.put(mod, i);
        }
        return ans == nums.length? -1 : ans;
    }
}
```

##### 注意事项

1. 求最短长度，所以 `value` 存索引，并且每次遇到相同的 `key` 都要**更新**为最新的索引。
2. 本题是逆向思维，先求出需要移除的子数组应满足的条件，再套用模板。

##### 经验总结

本题是同余类问题中最复杂的一种，它结合了逆向思维和求最短长度的需求。清晰地展示了 `value` 存最新索引的场景。

### 类别四： 树和矩阵的前缀和

#### 怎样计算和存储树或者矩阵的前缀和呢？



#### Leetcode 437: 树形结构的前缀和：路径总和 ： <路径前缀和，路径前缀和出现的次数>

##### 问题要点

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

路径不需要从根节点开始，也不需要在叶子节点结束，但路径方向必须是向下的。

##### 前缀和Map的定义

- `key`: 从根节点到当前节点路径上的前缀和。
- `value`: 该前缀和出现的 **次数**。

##### 核心思想 - DFS深度优先搜索 + 回溯

树的向下路径可以看作是一种线性的“数组”。

我们用 DFS (深度优先搜索) 遍历树。

在遍历过程中，维护一个**从根节点到当前节点的前缀和** `currentSum`。

当我们到达节点 `node` 时，我们希望找到它的祖先节点 `ancestor`，使得从 `ancestor` 的某个子节点到 `node` 的路径和为 `targetSum`。

这等价于 `currentSum - prefixSum_ancestor = targetSum`，即 `prefixSum_ancestor = currentSum - targetSum`。

我们用哈希表来存储遍历路径上遇到的所有前缀和及其出现次数。

##### 实现原理 - DFS

###### 注意Leetcode平台的坑

在 LeetCode 平台上，同一个 `Solution` 对象实例可能会被用来连续调用 `pathSum` 方法以运行多个不同的测试用例。

你的代码没有在每次调用时重置这些成员变量，导致上一个测试用例的数据会污染下一个用例的计算结果。

所以应当:

- 尽量避免使用成员变量。
- 非用不可的话，一定记得每次都要在入口函数中初始化成员变量

###### 实现过程

1. 定义一个 DFS 函数，参数包括当前节点、当前路径和 `currentSum`、以及存储前缀和的哈希表。

2. 在进入一个节点时，更新 `currentSum`。
3. 查找哈希表`currentSum - targetSum`的出现次数，并累加到全局结果。
4. 将`currentSum`的计数加入哈希表，即**更新该前缀和出现的次数**
5. 递归进入该节点的左右子树
6. **回溯：** 当该节点及其所有子树都访问完毕，必须`currentSum`从哈希表中移除（计数-1）,以确保它不会影响其兄弟节点的计算

##### 实现代码

```Java
 //前缀和 + DFS
 //Key: 路径前缀和
 //Value： 路径前缀和出现的次数
class Solution {
     Map<Long,Integer> map = new HashMap<>();
     private long currSum = 0;
     private int count = 0;
    public int pathSum(TreeNode root, int targetSum) {
        map.put(0L, 1);
        //记得每次初始化这个变量，不然可能会被其他的Test Case污染
        currSum = 0;
        count = 0;
        dfs(root, targetSum);
        return count;
    }

    private void dfs(TreeNode node, int targetSum){
        if(node == null) return;

        int val = node.val;
        currSum += val;
        long target = currSum - targetSum;
        count += map.getOrDefault(target, 0);
        map.put(currSum, map.getOrDefault(currSum, 0) + 1);
      // 

        dfs(node.left, targetSum);
        dfs(node.right, targetSum);

        map.put(currSum, map.getOrDefault(currSum, 0) - 1);
        currSum -= val;
    }
}
```

##### 注意事项

- **回溯**是树形问题中的关键。当一个节点的递归调用返回时，必须恢复哈希表的状态，就像你从未访问过这个节点一样。
- **前缀和可能非常大，导致整数溢出，使用 `long` 类型存储前缀和更安全**[重点]。
- `map` 在任意时刻存储的是当前节点所有祖先节点的“前缀和”信息。计算 `count` 是为了查找【以当前节点为终点】的路径，所以我们必须在**只包含祖先信息**的 `map` 中查找，而**不能把当前节点自己的信息也加进去**，否则会产生错误计算

##### 经验总结

这道题展示了前缀和思想可以从线性数组扩展到树形结构中。

核心的 `value` 存次数（因为是求数量）和公式 `currentSum - targetSum` 依然不变，但增加了回溯操作的复杂性。

#### Leetcode 1074 ： 矩阵前缀和：元素为目标值的子矩阵数量: <前缀和，前缀和出现次数>

##### 问题要点

给出矩阵 `matrix` 和目标值 `target`，返回元素总和等于目标值的非空子矩阵的数量。

##### 前缀和Map的定义

- `Key`:在降维后的一维数组的前缀和
- `Value`:该前缀和出现的次数

##### 核心思想： 将二维数组降维维一维数组

**维度约减**：直接暴力枚举所有子矩阵的左上角和右下角是 $O(N⁴)$，无法接受。

我们可以通过固定子矩阵的 **上下边界** (或左右边界)，将二维问题转化为一维问题。

###### 固定边界：枚举子矩阵的上边界`top`和下边界`bottom`

我们枚举子矩阵的上边界 `top` 和下边界 `bottom`。

###### 拍扁成一维数组 - rowSum[j] 表示第j列从top到bottom的所有元素之和

对于固定的 `top` 和 `bottom`，我们可以计算出一个一维数组 `rowSum`。

其中 `rowSum[j]` 表示 `matrix` 第 `j` 列从 `top` 行到 `bottom` 行所有元素的和。

###### 套用模版 - 在这个一维数组 `rowSum` 中，有多少个连续子数组的和等于 `target`

现在问题就变成了：在这个一维数组 `rowSum` 中，有多少个连续子数组的和等于 `target`？

为了快速计算 `rowSum[j]`，我们可以预先处理一个二维前缀和数组，但更直接的方法是在 `bottom` 边界向下移动时，直接累加新一行的值到 `rowSum` 数组上。

这正是 LeetCode 560 的原题！

##### 实现原理

1. 外层循环枚举上边界 `top` 从 `0` 到 `rows-1`。

2. 第二层循环枚举下边界 `bottom` 从 `top` 到 `rows-1`。

3. 对于每一个 `[top, bottom]` 组合，我们创建一个一维数组 `rowSum` 来存储各列的和。

   当 `bottom` 移动时，我们把 `matrix[bottom]` 这一行的数据累加到 `rowSum` 上。

4. 在内部，对 `rowSum` 数组应用 LeetCode 560 的解法：

   - 初始化一个哈希表 `map` 并放入 `{0: 1}`。

   - **遍历 `rowSum` 数组，计算其前缀和 `currentSum`** ->这是真正的前缀和。

   - 查找 `map` 中 `currentSum - target` 的数量并累加到最终结果 `count`。

   - 更新 `currentSum` 在 `map` 中的计数。

##### 实现代码

```Java
class Solution {
    
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        int count = 0;
        //遍历每一个[topRpw, Bottom]
        for(int top = 0; top < rows; top++){
            int[] rowSum = new int[cols];
            for(int bottom = top; bottom < rows; bottom++){
                //遍历[top,bottom]区域中的每一个列，计算行和
                //行和 = [top,bottom]中的每一行的列之和
                //rowSum[j] 表示什么呢？
                //现在固定了bottom和top
                //rowSum[j] 表示从第j列从[top...bottom]的和
                //同时计算列和的前缀和prefixSum
                for(int col = 0; col < cols; col++ ){
                    //计算当前列和
                    rowSum[col] += matrix[bottom][col];
                }
                //使用列和的前缀和计算子区域的面积
                //key：列和的前缀和
                //Value：出现的次数
                Map<Integer,Integer> map = new HashMap<>();
                map.put(0, 1);
                int currSum = 0;
                for(int val : rowSum){
                    currSum += val;
                    int diff = currSum - target;
                    count += map.getOrDefault(diff, 0);
                    map.put(currSum, map.getOrDefault(currSum, 0) + 1);
                }
            }
        }
        return count;
    }
}
```

##### 注意事项

算法的整体时间复杂度是 O(Rows² * Cols)。如果列数远小于行数，可以考虑固定左右边界，对行进行压缩，以获得更好的性能 O(Cols² * Rows)。

理解将二维问题降维的核心思想是关键。一旦降维成功，内部的逻辑就是我们已经非常熟悉的模板了。

##### 经验总结

这道题是“前缀和+哈希表”模式从一维到二维的经典推广。

它教会我们，当遇到高维问题时，可以尝试通过**固定部分维度**的方式，将其转化为我们擅长解决的低维问题。这种“降维打击”的思路在算法题中非常常见和有效。

### 类别五：前缀和与属性转换

#### Leetcode 2488: 统计中位数为 K 的子数组

##### 问题要点

给你一个数组 `nums` 和一个整数 `k`。

子数组的 **中位数** 是将子数组排序后位于中间的元素。请你返回 `nums` 中中位数为 `k` 的子数组的数目。

##### 核心思想 

###### 问题转换 - 大于K的元素和小于K的元素数量相同或者差一个

一个子数组的中位数是 `k`，等价于它是该子数组中第 `(m+1)/2` 小的元素（`m`为子数组长度）。

这个定义很难直接用。

我们可以转换思路：

一个包含 `k` 的子数组，如果其中大于 `k` 的元素数量等于小于 `k` 的元素数量，那么 `k` 就是中位数（当子数组长度为奇数时）。

如果大于 `k` 的元素数量比小于 `k` 的多一个，`k` 也可能是中位数（当子数组长度为偶数时）。

###### 数值转换

我们将数组进行转换：

- 大于 `k` 的数变为 `1`，
- 小于 `k` 的数变为 `-1`，
- `k` 本身变为 `0`。

现在，问题变成了：**寻找一个包含 `k` 的子数组，其在新数组中的和为 `0` 或 `1`**。

###### 分离计算

我们首先找到 `k` 的位置 `k_idx`。

所有满足条件的子数组都必须跨越 `k_idx`。

我们可以计算 `k_idx` 右侧部分的前缀和，然后看左侧部分是否有能与之匹配的前缀和。

##### 前缀和Map的定义

`key`: 转换后数组的“前缀和” (也称为平衡因子 `balance`)。

`value`: 该前缀和出现的 **次数**。

##### 实现原理

######找到 `k` 的索引 `k_idx`。

找到 `k` 的索引 `k_idx`。

######计算右半部分 - 计算转换后的前缀和

从 `k_idx` 开始向右遍历，计算转换后的前缀和（这里称为 `balance`）。

对于每个 `balance`，我们知道一个以 `k` 开始的子数组，其和为 `balance`。

如果 `balance` 是 `0` 或 `1`，这本身就是一个合法的子数组，结果 `count++`。

同时，将这些右半部分的前缀和存入哈希表 `map` 中，`key` 为 `balance`，`value` 为出现次数。

###### 计算左半部分

从 `k_idx - 1` 开始向左遍历，同样计算 `balance`。

在每个位置，我们需要寻找一个右半部分的 `balance_right`，使得 `balance_left + balance_right` 等于 `0` 或 `1`。

这等价于 `balance_right = 0 - balance_left` 或 `balance_right = 1 - balance_left`。

我们去 `map` 中查找这两个目标值的出现次数，并累加到 `count` 中。

##### 实现代码

```Java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int countSubarrays(int[] nums, int k) {
        int kIndex = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == k) {
                kIndex = i;
                break;
            }
        }

        // Map to store balances from the right side of k
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1); // A balance of 0 is found before starting (empty part)

        int balance = 0;
        int count = 0;

        // Iterate from k's position to the right
        for (int i = kIndex + 1; i < nums.length; i++) {
            balance += (nums[i] > k ? 1 : -1);
            map.put(balance, map.getOrDefault(balance, 0) + 1);
        }

        // Check the left side (including k itself) and match with the right side
        balance = 0;
        for (int i = kIndex; i >= 0; i--) {
            balance += (i == kIndex) ? 0 : (nums[i] > k ? 1 : -1);
            // We need the total balance to be 0 or 1
            // target_balance_right = 0 - balance_left
            count += map.getOrDefault(-balance, 0);
            // target_balance_right = 1 - balance_left
            count += map.getOrDefault(1 - balance, 0);
        }

        return count;
    }
}
```

##### 注意事项

此题的巧妙之处在于将中位数问题转化为 `+1/-1` 的和问题。

思路是固定必须包含的元素 `k`，然后向其两侧扩展，统计符合条件的组合。

##### 经验总结

对于非直接求和的“性质”类问题，思考如何将该性质 **量化** 并转化为可计算的前缀和，是解题的关键。



#### Leetcode 1542: 找出最长的超赞子字符串

较难的问题，后续拔高可以尝试

### 类别六：异或/积 前缀和

#### Leetcode 2588:统计美丽子数组数目：<前缀异或和，出现的次数>

##### 问题要点

**输入**: 一个0-indexed的整数数组 `nums`。

**操作**: 在一次操作中，可以选择子数组中的两个不同索引 `i` 和 `j`，以及一个非负整数 `k`。

要求 `nums[i]` 和 `nums[j]` 的二进制表示中第 `k` 位都为1。

然后，从 `nums[i]` 和 `nums[j]` 中同时减去 2k。

**美丽子数组**: 如果一个子数组可以通过任意次（包括零次）上述操作，使其所有元素都变为0，那么这个子数组就是“美丽”的。

**目标**: 返回数组 `nums` 中美丽子数组的数量。

**示例:** 输入: `nums = [4, 3, 1, 2, 4]` 输出: `2` 解释: 美丽子数组是 `[3, 1, 2]` 和 `[4, 3, 1, 2, 4]`。

##### 问题的本质和分析 

这道题目的核心在于理解“美丽子数组”的真正含义。

操作看起来很复杂，但我们深入分析一下它的效果。



操作的核心是选择两个数，在它们共同拥有`1`的二进制位上，将这个`1`“消掉”（即减去$2^k$）。

例如，`nums[i] = 6 (110)`，`nums[j] = 3 (011)`。

我们可以选择 `k=1`，因为它们的第1位都是1。

操作后变为 `nums[i] = 4 (100)`，`nums[j] = 1 (001)`。



一个子数组能通过此操作全变为0，意味着什么呢？

让我们考虑每一个二进制位 `k`。

要将所有数字的第 `k` 位变为0，每次操作我们能消除两个数字的第 `k` 位的`1`。

因此，要最终将该位全部清零，子数组中第 `k` 位为`1`的数字个数必须是**偶数**。

这个条件需要对**所有**二进制位都成立。



一个数组中，如果对于任意二进制位 `k`，该位为 `1` 的数字个数都是偶数，这等价于这个数组所有元素的**异或和(XOR sum)为0**。



**为什么？** 

异或运算的本质是二进制下的**不进位加法**。

当我们将一串数字异或起来时，对于每一个二进制位 `k`，结果位是`1`还是`0`取决于这一位上`1`的个数。

- 如果`1`的个数是偶数，那么两两异或后结果为`0`。
- 如果`1`的个数是奇数，那么最终结果为`1`。

因此，**“子数组中所有元素的异或和为0”** 是 “子数组是美丽的” 的充要条件。

问题就从一个复杂的操作问题，**转化为了一个经典的子数组问题：统计 `nums` 中有多少个连续子数组，其元素的异或和为0。**

##### 模式套路匹配

这个问题转化以后，就完全符合一个非常经典并且重要的算法模式：前缀和+哈希表。

###### 子数组和/异或和问题

当题目要求计算关于连续子数组的某种**聚合值**（和/积/异或和）并满足特定条件时，首先就要想到前缀和/异或和。

###### O(n)的时间复杂度

为了在O(n)时间内解决这类问题，通常需要借助哈希表来存储和快速查找之前计算过的前缀值。



###### 详细的推导结论 - 子数组[i...j]的异或和 = prefixXOR(i-1) ^ prefixXOR(j)

具体到本题，我们要找的是`subarray(i,j)`的异或和为0。

令`prefixXOR(k)`为`nums[0]`到`nums[k-1]`的异或和。

- `prefixXOR[0] = 0`
- `prefixXOR[i] = nums[0] ^ nums[1] ^ ... ^ nums[i-1]`

**异或运算的两个关键属性：**

- **自反性**： 任何数和它本身异或的结果都是0。即 `A ^ A = 0`。
- **结合律**: `(A ^ B) ^ C = A ^ (B ^ C)`。这意味着一连串的异或运算，顺序可以任意改变。

现在我们来推导`nums[i] ^ ... ^ nums[j]`:

现在，我们把 `prefixXOR(j)` 和 `prefixXOR(i-1)` 展开：

- `prefixXOR(j) = nums[0] ^ nums[1] ^ ... ^ nums[i-1] ^ nums[i] ^ ... ^ nums[j]`
-  `prefixXOR(i-1) = nums[0] ^ nums[1] ^ ... ^ nums[i-1]`

现在我们将两部分异或起来：

`prefixXOR(j) ^ prefixXOR(i-1)` `= (nums[0] ^ ... ^ nums[i-1] ^ nums[i] ^ ... ^ nums[j]) ^ (nums[0] ^ ... ^ nums[i-1])`

由于异或操作满足结合律，我们可以重新组合这个公式：

`= (nums[0] ^ ... ^ nums[i-1] ^ nums[0] ^ ... ^ nums[i-1]) ^ (nums[i] ^ ... ^ nums[j])`

现在，我们来看前半部分 `(nums[0] ^ ... ^ nums[i-1] ^ nums[0] ^ ... ^ nums[i-1])`。

根据结合律，我们可以把相同的数放在一起：

`= (nums[0] ^ nums[0]) ^ (nums[1] ^ nums[1]) ^ ... ^ (nums[i-1] ^ nums[i-1])`

根据**自反性** (`A ^ A = 0`)，上面这个表达式的每一项 `(nums[k] ^ nums[k])` 都等于 `0`。

```
= 0 ^ 0 ^ ... ^ 0
```

一堆0异或起来的结果还是 `0`。

所以，前半部分整个都变成了 `0`。

那么，我们最初的表达式就简化为：

```
= 0 ^ (nums[i] ^ ... ^ nums[j])
```

**任何数和 `0` 异或，结果都是它本身 (`0 ^ B = B`)**。

因此，最终结果是： `= nums[i] ^ ... ^ nums[j]`



###### 回到问题中继续推导 - 寻找前缀异或和相同的情况

现在我们已经知道：子数组`[i...j]`的异或和 = `前缀异或和[i-1] ^ 前缀异或和[j]`。

我们的任务是要找到异或和为0的子数组的数量：也就是找到`前缀异或和[i-1] ^ 前缀异或和[j]=0` 的数量。

根据自反性我们已经知道，当前缀和[i-1] == 前缀和[j]的时候，`前缀异或和[i-1] ^ 前缀异或和[j]=0`

因此现在的问题就变成了寻找**前缀异或和相同**的情况。



##### 核心思想和套路

核心思想是**利用哈希表来记录每个前缀异或值出现的次数**。

###### 初始化

- 创建一个哈希表 `map`，用于存储 `<前缀异或值, 出现次数>`。

- 初始化 `count = 0` 作为最终结果。

- 初始化 `prefixXOR = 0`。？为什么呢？一样为0，不一样为1，因此 0 ^ x = x;

- 在哈希表中放入 `{0: 1}`。这是至关重要的一步，它代表了空前缀（在数组开始之前）的异或和是0，出现了一次。这用于处理那些从索引0开始的美丽子数组。

###### 遍历数组

- 从左到右遍历数组 `nums` 中的每个元素 `num`。

更新当前的前缀异或和：`prefixXOR = prefixXOR ^ num`。

**查找与配对**: 在哈希表中查找 `prefixXOR` 这个键。

如果 `map` 中已经存在 `prefixXOR`，假设其值为 `c`，这意味着在当前位置之前，已经有 `c` 个位置的前缀异或和等于当前的 `prefixXOR`。这 `c` 个位置中的任何一个都可以作为美丽子数组的起始点（的前一个位置），而当前位置是结束点。

因此，我们找到了 `c` 个新的美丽子数组。将 `c` 加到 `count` 上。

**更新哈希表**: 将当前 `prefixXOR` 的计数在哈希表中加1。

即 `map.put(prefixXOR, map.getOrDefault(prefixXOR, 0) + 1)`。

###### 返回结果

遍历结束后，`count` 就是美丽子数组的总数。

##### 实现原理

1. 初始化哈希表 `map`，放入 `{0: 1}`，代表值为 0 的前缀异或和（空前缀）出现过1次。
2. 遍历数组，维护一个 `currentXOR`。
3. 在每个位置 `i`，`currentXOR` 更新为 `currentXOR ^ nums[i]`。
4. 去哈希表中查找 `currentXOR` 已经出现了多少次，将这个次数累加到结果 `count` 中。
5. 将当前的 `currentXOR` 的计数加一，更新到哈希表中。

##### 实现代码

```Java
class Solution {
    public long beautifulSubarrays(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int prefixXOR = 0;
        long count = 0;

        for(int i = 0; i < nums.length; i++){
            prefixXOR ^= nums[i];
            count += map.getOrDefault(prefixXOR, 0);
            map.put(prefixXOR, map.getOrDefault(prefixXOR, 0) + 1);
        }

        return count;
    }
}
```

##### 注意事项

逻辑与 LeetCode 560 (和为K) 几乎完全一致，只是把 `+` 换成了 `^`，`k` 固定为 `0`。

#### Leetcode : 形成两个异或和相等的数组的三元组数目 (LeetCode 1442) - 进阶应用

//todo

## 滑动窗口+哈希表类- 滑动窗口内频率或者数量问题

### 核心思想

双指针维护一个**动态窗口**，哈希表维护窗口内频率或者数量，适合子串类问题

- 用一对指针 `left` 和 `right` 定义一个窗口 `[left, right)` (左闭右开) 或 `[left, right]` (左闭右闭)。

- `right` 指针负责向右移动，不断扩大窗口，将新元素纳入窗口中，并更新哈希表中的数据。

- `left` 指针则在窗口不满足题目条件时向右移动，缩小窗口，将旧元素移出窗口，并更新哈希表。

- 在 `right` 扩大窗口的每一步（或者在 `left` 缩小窗口之后），我们都可以根据当前窗口的状态来更新最终结果。

### 实现原理

- 窗口右移扩展
- 窗口左移缩小
- 哈希表记录当前窗口内字符的状态

### 代码套路模板

```java
public ResultType slidingWindowTemplate(String s, String t) {
    // 1. 初始化哈希表 (needs, window)
    Map<Character, Integer> needs = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    // for (char c : t.toCharArray()) needs.put(c, needs.getOrDefault(c, 0) + 1);

    // 2. 初始化窗口指针和计数器
    int left = 0, right = 0;
    int validCount = 0; // 表示窗口中满足 needs 条件的字符个数
    // ... 其他需要记录的结果变量 ...

    // 3. 主循环，right 指针不断向右探索
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s.charAt(right);
        right++; // 扩大窗口

        // ... 进行窗口内数据的一系列更新 ...
        // if (needs.containsKey(c)) {
        //     window.put(c, window.getOrDefault(c, 0) + 1);
        //     if (window.get(c).equals(needs.get(c))) {
        //         validCount++;
        //     }
        // }

        // 4. 判断左侧窗口是否需要收缩
        while (/* window needs shrink */) {
            // ... 更新结果 ...

            // d 是将移出窗口的字符
            char d = s.charAt(left);
            left++; // 缩小窗口

            // ... 进行窗口内数据的一系列更新 ...
            // if (needs.containsKey(d)) {
            //     if (window.get(d).equals(needs.get(d))) {
            //         validCount--;
            //     }
            //     window.put(d, window.get(d) - 1);
            // }
        }
    }
    return /* 最终结果 */;
}
```

### 注意事项

- 滑动窗口的左边界更新前后顺序很关键
- **哈希表操作要确保值为0时删除key**

### 场景一：寻找最长/最短的满足条件的子串/子数组

####Leetcode 3: 无重复字符的最长子串

给定一个字符串 `s`，找出其中不含有重复字符的 **最长子串** 的长度。

#####问题本质

- **本质：**在字符串中，寻找一个最长的连续子串，该子串的所有字符都是不重复的
- **约束**： 只要求返回该子串的长度，不需要返回具体的内容
- **目标：** 滑动串口中维护不重复字符的状态，尽可能的扩展窗口

#####核心思想-滑动窗口+哈希集合

- 使用双指针`left`和`right` 表示一个滑动窗口
- 使用哈希集合`set`来记录当前窗口中的字符
- 每次指针右移扩展（扩大窗口）时
  - 如果遇到重复子串，就不断移动左指针直到没有重复
- 在**每一步**更新最大窗口长度

##### HashMap的角色

- **Key**: `Character` - 窗口中出现的字符。
- **Value**: `Integer` - 该字符在窗口中最后出现的位置索引。
- *优化*: 当字符集较小时（如 ASCII），可以直接使用 `int[128]` 或 `int[256]` 数组代替 `HashMap`，以索引代表字符，值为该字符的位置。

#####实现原理

######初始化Set和左右指针

- `Set<Character> set = new HashSet<>()`
- 左指针`left=0`
- 右指针`right=0`
- 最大长度`maxLength=0`

######遍历字符串，使用右指针指向当前字符

- 如果字符不再`set`中，就添加，更新`maxLength = max(maxLength, right-left+1);`
- 如果字符串已经在`set`中，说明有重复，需要**从左边开始移除字符，直到移除掉重复的字符为止**

######最终返回maxLength

#####实现代码

```java
public int lengthOfLongestSubstring(String s){
  Set<Character> set = new HashSet<>();
  int left = 0;
  int maxLength = 0;
  for (int right=0;right<s.length();right++){
    char c = s.charAt(right);
    while (set.contains(c)){
      set.remove(s.charAt(left));
      left++;
    }
    set.add(c);
    maxLength = Math.max(maxLength, left-right+1);
  }
  
  return maxLength;
}
```

#### Leetcode 76: 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。

返回 `s` 中涵盖 `t` 所有字符的最小子串。

如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

##### 核心思想 - 滑动窗口

- 先扩展窗口（移动 `right`），直到窗口内的字符完全 **覆盖** 了 `needs` 表中的所有字符和数量要求。

- 一旦覆盖，就开始收缩窗口（移动 `left`），寻找最小的能满足覆盖条件的子串。

- 在收缩过程中，如果移除了一个关键字符导致不再满足覆盖条件，则停止收缩，重新开始扩展。

##### 哈希表的角色

###### Needs Map：统计字符串t中每个字符的数量

- **Key**: `Character` - 目标字符串 `t` 中的字符。

- **Value**: `Integer` - 该字符在 `t` 中需要的数量。

###### Window Map: 统计窗口内每个字符的数量

- **Key**: `Character` - 窗口中的字符。
- **Value**: `Integer` - 该字符在当前窗口中出现的数量。

##### 实现原理

- 先用 `needs` 表统计 `t` 中各字符的需求量。

- `right` 指针向右移动，将字符加入 `window` 表。如果该字符是 `needs` 中需要的，并且 `window` 中该字符的数量等于 `needs` 中的数量，则 `validCount`（满足条件的字符种类数）加一。

- 当 `validCount` 等于 `needs.size()` 时，说明找到了一个可行解。此时记录长度，并尝试移动 `left` 指针来优化解。

- 移动 `left` 时，将移出窗口的字符从 `window` 表中减一。如果该字符是 `needs` 中需要的，并且移出前 `window` 中的数量等于 `needs` 中的数量，则 `validCount` 减一，表示窗口不再满足条件。

- 循环步骤 2-4 直到 `right` 到达字符串末尾。

##### 实现代码

```Java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer> needMap = new HashMap<>();
        for(char c : t.toCharArray()){
            needMap.put(c, needMap.getOrDefault(c, 0) + 1);
        }

        int left = 0;
        Map<Character, Integer> windowMap = new HashMap<>();
        int count = 0;
        String ans = "";
        int minLen = Integer.MAX_VALUE;
        for(int right = left; right < s.length(); right++){
            char rc = s.charAt(right);
            if(needMap.containsKey(rc)){
                windowMap.put(rc, windowMap.getOrDefault(rc, 0) + 1);
                if(windowMap.get(rc).equals(needMap.get(rc))){
                    count++;
                }
            }

            while(count == needMap.size()){
                //记录结果
                int len = right - left + 1;
                if(len < minLen){
                    ans = s.substring(left, right+1);
                    minLen = len;
                }

                //前移left指针
                char lc = s.charAt(left);
                if(needMap.containsKey(lc)){
                    int charCount = windowMap.get(lc);
                    if(charCount == 1){
                        windowMap.remove(lc);
                    }else{
                        windowMap.put(lc, charCount - 1);
                    }
                    if(windowMap.getOrDefault(lc,0) < needMap.get(lc)){
                        count--;
                    }
                }
                left++;
            }
        }
        return ans;
    }
}
```

### 场景二：寻找固定/不固定长度的、满足特定排列/组合条件的子串

#### Leetcode 438: 找到字符串中所有字母异位词

#####问题该要

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。

不考虑答案输出的顺序。

##### 核心思想

维持一个 **固定长度** 等于目标字符串 `s1` 长度的滑动窗口。在窗口滑动的过程中，判断窗口内的字符及其频率是否与 `s1` 完全一致。

##### 哈希表角色

与 "最小覆盖子串" 类似，使用 `needs` 和 `window` 两个哈希表。

- **Key**: `Character`
- **Value**: `Integer` (字符计数)

##### 实现原理 - 最小覆盖子串的一个特例

这其实是 "最小覆盖子串" 的一个特例。

我们只需要判断 `validCount == needs.size()` 是否成立，并且窗口长度 `right - left` 是否等于目标字符串的长度。

1. 初始化 `needs` 表和 `window` 表。
2. `right` 指针向右移动，更新 `window` 和 `validCount`。
3. **核心区别**: `while` 循环收缩窗口的条件变为 `right - left >= s1.length()`。即当窗口大小达到 `s1` 的长度时，就开始判断并收缩。
4. 在收缩前，如果 `validCount == needs.size()`，说明找到了一个排列，记录下当前的 `left` 索引。
5. 然后移动 `left` 指针，更新 `window` 和 `validCount`，以维持窗口大小。

##### 实现代码

```Java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character,Integer> needMap = new HashMap<>();
        for(char c : p.toCharArray()){
            needMap.put(c, needMap.getOrDefault(c, 0) + 1);
        }
        List<Integer> list = new ArrayList<>();
        int left = 0;
        Map<Character,Integer> windowMap = new HashMap<>();
        int validCount = 0;

        for(int right = 0; right < s.length(); right++){
            char rc = s.charAt(right);
            if(needMap.containsKey(rc)){
                windowMap.put(rc, windowMap.getOrDefault(rc, 0) + 1);
                if(windowMap.get(rc).equals(needMap.get(rc))){
                    validCount++;
                }
            }

            while(right -left + 1 >= p.length()){
                if(validCount == needMap.size()){
                    list.add(left);
                }
                char lc = s.charAt(left);

                if(needMap.containsKey(lc)){
                    int count = windowMap.get(lc);
                    if(count == needMap.get(lc)){
                        validCount--;
                    }
                    if(count == 1){
                        windowMap.remove(lc);
                    }else{
                        windowMap.put(lc, count - 1);
                    }
                }
                left++;
            }
        }
        return list;
    }
}
```



## 哈希映射+排序/映射-匹配或者还原结构

### 核心思想

通过哈希表映射某些结构（比如**数字->出现位置/原序号**），配合**双指针** /**排序**完成**匹配或者还原原结构**。

### 实现原理

常用于：

- 记录中间结果
- 辅助还原
- 映射关系处理

### 代码模板

```java
Map<Integer,List<Integer>> indexMap = new HashMap<>();
for (int i=0;i<nums.length;i++){
  indexMap.computeIfAbsent(nums[i],new ArrayList<>()).add(i);
}
```

### 注意事项

- 注意value为list时`getOrDefault()`的**浅拷贝**问题->推荐使用`computeIfAbsent`
- 自定义key时注意重写`equals()`和`hashCode()`

### Leetcode 347 前k个高频元素

给你一个整数数组 `nums` 和一个整数 `k`，请你返回其中出现频率前 `k` 高的元素。你可以按任意顺序返回答案。

#### 问题本质：Top K

从一堆数据中找出 **频率最高的 K 个元素**，属于**频率统计 + Top K 问题**。

#### 核心思想

##### 思路一： 堆排序思想（小顶堆维护Top K）

- 先统计每个元素的频率
- 用**最小堆**保存频率最高的K个元素
  - 堆中存储`(freq,num)`元祖
  - 若堆大小超过k，就弹出频率最小的

##### 思路二：桶排序思想（适用于不让用PriorityQueue的情况）

1. 统计每个元素的频率
2. 创建一个桶数组，索引是**频率**，桶里面存储出现该频率的数字
3. 从高频往低频遍历桶，收集前K个元素

#### 实现原理（以堆排序思想为例）

**构建频率表：** `Map<Integer, Integer>` 记录每个元素出现的频率。

**维护一个小顶堆（PriorityQueue）：** 大小为 K，堆顶是频率最小的。

**遍历频率表：**

- 若堆未满，加入堆；
- 若当前频率比堆顶大，替换堆顶。

**最终堆中即为频率前 K 高的元素。**

#### 实现代码

```java
 public int[] topKFrequent(int[] nums, int k) {
       Map<Integer, Integer> frequencyMap = new HashMap<>();
       for (int num:nums){
        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0)+1);
       }

       PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->frequencyMap.get(a)-frequencyMap.get(b));

       for (int num: frequencyMap.keySet()){
        pq.offer(num);
        if (pq.size()>k){
            pq.poll();
        }
       }
       return pq.stream().mapToInt(Integer::intValue).toArray();
    }
```

#### 注意事项

##### 小顶堆适用于Top K的问题

遇到**找前K个最大值或者最小值的问题**，优先考虑`小顶堆`或者`大顶堆`

##### 哈希表+堆排序是经典组合

- 哈希表统计频率
- 堆维护K个最大值

##### 桶排序适合数据范围不大的时候优化性能

- 时间复杂度O(N)，空间换时间

##### **时间复杂度：**

- 构建频率表：O(N)
- 堆操作：O(N log K)
- 总体：O(N log K)

##### 空间复杂度

哈希表 + 堆：O(N)



### Leetcode 49: 字母异位词分组（哈希+排序）

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

#### 核心思想：字符串字符排序+Map分组

**如果两个字符串是异位词，那么他们字符排序之后一定是一样的**

我们可以将每个字符串都进行排序之后，将排序之后的字符串作为Key，具有相同排序结果的字符串列表作为value。

#### 实现原理

1. 定义一个`HashMap<String,List<String>>`

   - Key为每个字符串排序之后的字符串
   - value为具有相同排序结果的字符串集合

2. 遍历并分组字符串

   - 遍历字符串，对每个字符串的字符数组进行排序
   - 排序之后的字符串作为Key, 将原字符串添加到Map中key所对应的列表中

3. 返回分组结果

   将Map的values转化为`List<List<String>>`即可

#### 实现代码

```java
    public List<List<String>> groupAnagrams(String[] strs) {
      Map<String, List<String>> map = new HashMap<>();
      for (String s: strs){
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        List<String> strList = map.getOrDefault(key, new ArrayList<>());
        strList.add(s);
        map.put(key, strList);
      }

      return map.values().stream().toList();
    }
```

## 循环检测问题 

### Leetcode 166 Fraction to Recurring Decimal

#### 问题要点

##### 输入数据

给定两个整数，分别代表分数的分子 (numerator) 和分母 (denominator)，要求将其转换为字符串格式。

#####具体要点如下：

- 如果小数部分是循环的，则需要将循环节用括号括起来。
- 如果分数是整数（即余数为0），则不应有小数点。
- 如果分子为0，结果为 "0"。
- 结果字符串的长度在给定约束下不会超过 10<sup>4</sup>。

##### 示例

```
numerator = 1, denominator = 2` -> `"0.5"
numerator = 2, denominator = 1` -> `"2"
numerator = 4, denominator = 333` -> `"0.(012)"
numerator = 1, denominator = 3` -> `"0.(3)"
numerator = -50, denominator = 8` -> `"-6.25"
```

#### 问题的本质和分析 - 模拟长除法过程

这个问题的本质是**模拟长除法**的过程。

长除法的核心在于不断地**用余数乘以 10**，然后继续除以分母，得到小数的下一位。

##### 可以被除尽的情况

当某一步的余数为 0 时，小数部分结束。例如 `1 / 8 = 0.125`。

#####不可以被除尽的情况

当我们手动计算一个分数的小数表示时，例如 4/333，我们会执行以下步骤：

1. 整数部分 `4/333 = 0`

2. 余数为`4`

3. 将余数乘以10，得到`40`。

   -  `40/333 =0`,将`0`加入小数部分。
   - 得到新的余数`40`

4. 将余数乘以10，得到`400`:

   - `400/333 =1`， 将`1`加入小数部分。
   - 得到新的余数`67`

5. 将余数乘以10，得到`670`:

   - `670 / 333 =2`， 将`2`加入小数部分
   - 新的余数是`670 - 333*2 = 4`

此时，我们发现余数`4`**再次出现**了。

这意味着接下来的计算过程将会**完全重复**步骤3到步骤5，从而产生**循环小数**`012`。

因此，解决此题的关键就是**识别并记录出现过的余数**。

#### 考察点

这道题综合考察了以下几个知识点：

- **整数与小数处理**：正确分离整数部分和小数部分。

- **长除法算法**：对基本数学运算的程序化模拟能力。

- **哈希表（HashMap）的使用**：哈希表是检测重复出现的余数的关键。它的键（Key）是计算过程中出现的余数，值（Value）是该余数对应的小数在结果字符串中的位置（索引）。

- **字符串处理（StringBuilder）**：高效地构建最终的字符串结果。

- **边界条件处理**：

  - **符号**：结果的正负号由分子和分母的符号决定。

  - **整数溢出**：`numerator` 和 `denominator` 可能是 `Integer.MIN_VALUE`，取绝对值时会发生溢出。

    因此，在计算前需要将它们转换为 `long` 类型。

  - **分子为0**：直接返回 "0"。

  - **整除**：没有小数部分的情况。

#### 模式匹配 - 哈希表

**模拟（Simulation）**：直接模拟手动计算的数学过程。许多算法题都依赖于对现实世界或数学过程的精确模拟。

**使用哈希表检测循环/重复状态**：

这是一个非常经典的应用模式。

在链表问题中，我们用哈希表（或快慢指针）检测环；

在图的遍历中，用哈希集合记录已访问节点。

在这里，我们用哈希表记录**已经出现过的余数**，以判断小数是否**进入循环**。

#### 核心思想和套路 - 哈希表

解决这类“检测循环状态”的问题，最经典、最高效的套路是**使用哈希表 (HashMap)**。

##### 核心思想

- 在模拟长除法计算小数部分时

  - 将每一步的**余数**作为 `key`；
  - 将当前小数部分的**长度（即商的插入位置）**作为 `value`，存入哈希表中。

- 在计算下一个余数之前，先检查这个新的余数是否已经在哈希表中存在。

  - 如果存在，说明我们找到了循环节的开始。

    哈希表中记录的 `value` 就是循环节开始的位置，我们在此位置插入左括号 `(`，并在字符串末尾添加右括号 `)` 即可

  - 如果不存在，就将新的`（余数，位置）`对存入哈希表，继续计算


##### 套路总结

1. 处理符号和整数部分。
2. 进入小数部分计算循环。
3. 在循环中，用哈希表记录`余数 -> 位置`的映射。
4. 当余数重复时，利用哈希表找到循环起点，并构造最终字符串。

#### 难点分析和应对

#####难点1：如何正确处理符号和整数部分？

1. **符号**：在计算开始前，先通过判断分子分母是否异号来确定最终结果的符号。确定后，将分子分母都转为正数处理，可以极大简化后续计算。
2. **整数部分**：直接计算 `numerator / denominator`，得到整数部分并存入结果。
3. **余数**：计算 `numerator % denominator`，作为小数部分计算的起始余数。

##### 难点2：如何处理数据溢出？

- **问题**：当分子是 `Integer.MIN_VALUE` (-2147483648) 时，直接取绝对值 `Math.abs(Integer.MIN_VALUE)` 会因为溢出而返回其自身（一个负数）。
- **应对**：为了从根本上避免溢出问题，在进行任何计算之前，**先将分子和分母都转换为 `long` 类型**。这是处理整数运算边界问题的标准做法。

##### 难点3：如何精确地在字符串中插入括号？

**应对**：使用 `StringBuilder` 来构建字符串。

哈希表中存储的值是循环节开始的字符在 `StringBuilder` 中的索引。当检测到循环时，可以直接使用 `StringBuilder.insert(index, '(')` 方法在正确的位置插入左括号。

#### 实现原理和详细步骤

假设输入为 `numerator = 4`, `denominator = 333`。

##### 预处理被除数为0的情况

- `numerator` 为 0？不是。返回 "0"。

- 将 `numerator` 和 `denominator` 转为 `long` 类型，即 `num = 4L`, `den = 333L`。

##### 处理数字的符号（正或者负）

- 两者同号，结果为正
- 取绝两个数字的对值

##### 判断是否除尽

- `integerPart = num / den = 4 / 333 = 0`。

- `StringBuilder sb = new StringBuilder("0")`。

- `remainder = num % den = 4 % 333 = 4`。

##### 小数部分 - 保存每一个余数第一次出现的位置

- 初始化 `HashMap<Long, Integer> map` 用于存放 `余数 -> 位置`。

| 循环次数 | 当前余数 `remainder` | `map` 中是否存在? | `map` 操作                                 | 计算 `remainder * 10` | 商   | `sb` 状态      | 新余数 `remainder % den` |
| -------- | -------------------- | ----------------- | ------------------------------------------ | --------------------- | ---- | -------------- | ------------------------ |
| 1        | 4                    | 否                | `map.put(4L, 2)` (小数点后第一位，索引为2) | 40                    | 0    | `sb = "0.0"`   | 40                       |
| 2        | 40                   | 否                | `map.put(40L, 3)`                          | 400                   | 1    | `sb = "0.01"`  | 67                       |
| 3        | 67                   | 否                | `map.put(67L, 4)`                          | 670                   | 2    | `sb = "0.012"` | 4                        |
| 4        | 4                    | **是**            | `map.get(4L)` 返回 2                       | -                     | -    | -              | -                        |

##### 发现循环

- 当前余数 `4` 在 `map` 中已存在，其对应的位置（value）是 `2`。

- 这意味着循环从 `sb` 的索引 `2` 处开始。

- 在 `sb` 的索引 `2` 处插入 `(`：`sb.insert(2, '(')`，`sb` 变为 `"0.(012"`。

- 在 `sb` 末尾追加 `)`：`sb.append(')')`，`sb` 变为 `"0.(012)"`。

- 跳出循环。

##### 返回结果

返回 `sb.toString()`，即 `"0.(012)"`。

#### 实现代码

```java
    public String fractionToDecimal(int numerator, int denominator) {
        // 边界情况：分子为0
        if (numerator == 0) {
            return "0";
        }

        StringBuilder sb = new StringBuilder();

        // 1. 处理符号
        // 使用异或(^)判断符号是否不同，不同则为负
        if ((numerator > 0) ^ (denominator > 0)) {
            sb.append("-");
        }

        // 2. 转换为long处理，避免溢出
        long num = Math.abs((long) numerator);
        long den = Math.abs((long) denominator);

        // 3. 计算整数部分
        sb.append(num / den);
        long remainder = num % den;

        // 如果余数为0，直接返回结果
        if (remainder == 0) {
            return sb.toString();
        }

        // 4. 处理小数部分
        sb.append(".");
        
        // 使用哈希表记录 余数 -> 该余数出现时在sb中的位置
        Map<Long, Integer> map = new HashMap<>();

        while (remainder != 0) {
            // 检查当前余数是否已出现过
            if (map.containsKey(remainder)) {
                // 找到了循环节
                int startIndex = map.get(remainder);
                sb.insert(startIndex, '(');
                sb.append(')');
                break;
            }
            
            // 将当前余数和它对应的插入位置存入哈希表
            map.put(remainder, sb.length());
            
            // 模拟长除法，余数乘以10
            remainder *= 10;
            
            // 计算商并追加到结果中
            sb.append(remainder / den);
            
            // 更新余数
            remainder %= den;
        }

        return sb.toString();
    }
```

#### 注意事项

1. **数据溢出是第一大坑**：务必将分子分母提升到 `long` 类型进行计算，特别是取绝对值的操作。
2. **哈希表的键值对**：要清晰地定义 `key` 和 `value` 的含义。在这里，`key` 是余数 (`Long`)，`value` 是循环节开始的插入点在 `StringBuilder` 中的索引 (`Integer`)。
3. **同号异号判断**：使用 `(numerator > 0) ^ (denominator > 0)` 是一个简洁且不易出错的判断异号的方法。
4. **使用 `StringBuilder`**：对于频繁的字符串拼接和修改，`StringBuilder` 的性能远优于 `String`。

#### 经验总结

**识别问题模式**：凡是涉及“状态重复” -> “产生循环”的问题，无论是链表环、还是数字计算循环，都应第一时间想到**哈希表**或**快慢指针**。对于非链表结构，哈希表是检测循环的更通用工具。

**模拟是核心**：很多算法题并不需要高深的理论，而是考察能否将一个现实或数学过程（如本题的长除法、计算器实现等）准确地用代码模拟出来，并处理好其中的边界和状态转换。

**防御性编程**：在处理数值计算时，要对数据范围保持警惕。当看到 `int` 类型时，就要思考 `Integer.MIN_VALUE` 和 `Integer.MAX_VALUE` 是否会引起溢出，并提前采用 `long` 等更大范围的数据类型来规避风险。

## 矩阵或者有效数独的判断 - 数独三部曲

### Leetcode 2133.检查是否每一行每一列都包含全部整数

#### 问题要点

- **输入**: 一个 `n x n` 的二维整数矩阵 `matrix`。
- **任务**: 判断该矩阵是否满足以下两个条件：
  1. **每一行**都包含了从 `1` 到 `n` 的所有整数，且每个整数只出现一次。
  2. **每一列**都包含了从 `1` 到 `n` 的所有整数，且每个整数只出现一次。
- **输出**: 如果同时满足以上两个条件，返回 `true`；否则，返回 `false`。

**核心约束**: 矩阵是正方形的 (`n x n`)，并且要检查的数字范围恰好是 `1` 到 `n`。

#### 问题的本质和分析 - 完整性和唯一性检测

这个问题的本质是**检验完整性和唯一性**。

对于一个大小为 `n` 的集合（行或列），我们需要验证它是否包含了 `1` 到 `n` 的所有数字，并且没有重复。

换句话说，每一行和每一列都必须是数字 `1, 2, ..., n` 的一个**排列 (Permutation)**。

这个问题可以分解为两个独立的子问题：

1. 检查所有行是否满足条件。
2. 检查所有列是否满足条件。

只有当两个子问题都通过时，最终结果才是 `true`。任何一个子问题失败，都可以立即判定整个矩阵无效，并返回 `false`。

#### 背景知识

##### 集合 - Set

数学上，集合是一个包含不同对象的集体。

其关键特性是**元素的唯一性**。

例如，集合 `{1, 2, 3}` 是合法的，但 `{1, 1, 2}` 在集合中会自动简化为 `{1, 2}`。这个特性是解决本题的关键。

##### 排列

 一个排列是从一个集合中选取元素进行排序的序列。

对于集合 `{1, 2, ..., n}`，它的一个排列就是将这些数字以任意顺序排列，例如 `{2, 1, 3}` 是 `{1, 2, 3}` 的一个排列。

问题要求每一行和每一列都是 `{1, 2, ..., n}` 的一个排列。

##### 哈希表/哈希集合

 这是实现集合概念最常用的数据结构。它允许我们以接近常数时间 O(1) 的效率完成添加、删除和查找操作。

利用哈希集合可以非常高效地检测重复元素。

#### 考察点

面试官通过这道题主要考察以下几点：

1. **基本编程能力**: 是否能熟练地遍历二维数组（矩阵）的行和列。
2. **数据结构的选择**: 能否意识到这是一个关于“唯一性”和“存在性”的检查，并选择合适的数据结构（如 `HashSet` 或布尔数组）来高效地完成任务。
3. **逻辑严谨性**: 能否考虑到需要同时检查行和列，并且理解“清空/重置”状态的重要性（即每检查新的一行或一列时，都需要一个全新的状态记录工具）。
4. **时间和空间复杂度分析**: 能否分析出所写算法的效率。
5. **代码整洁度**: 代码是否易于阅读和理解。

#### 模式匹配

这个问题的模式与以下经典问题非常相似：

- **LeetCode 36. 有效的数独 (Valid Sudoku)**: 这是本题最直接的“亲戚”。
  - “有效的数独”要求检查行、列和 3x3 小方格内的数字唯一性。
  - 其核心解法思路——使用哈希集合或数组来跟踪已出现的数字——与本题完全一致。
  - 本题可以看作是“有效数独”的简化版本（因为它不包含 3x3 小方格的规则，并且数字范围是固定的 `1` 到 `n`）。
- **LeetCode 217. 存在重复元素 (Contains Duplicate)**: 
  - 这是本题核心逻辑在一维数组上的体现。
  - 解决“存在重复元素”的经典方法就是使用哈希集合。
  - 本题相当于对矩阵的每一行和每一列都执行了一遍“存在重复元素”的检查。

当你看到“检查唯一性”、“是否有重复”这类字眼时，就应该立刻联想到**哈希集合 (HashSet)** 或**频率数组 (Frequency Array)** 这个模式。

#### 核心思想 - 逐行逐列的验证

核心思想是**“逐行逐列，独立验证”**。

**套路：使用一个辅助数据结构来记录“已见过”的元素。**

##### 遍历检查所有的行

对于每一行 `i`：

- 创建一个全新的、空的哈希集合 `rowSet`。
- 遍历该行的所有元素 `matrix[i][j]`。
- 尝试将元素添加到 `rowSet` 中。如果添加失败（因为元素已存在），说明有重复，该行无效，直接返回 `false`。
- 检查元素是否在 `1` 到 `n` 的范围内（虽然题目保证了，但这是一个好习惯）。

如果所有行都检查完毕且没有发现重复，则所有行都满足条件。

##### 遍历检查所有的列

- 对于每一列 `j`：
  - 创建一个全新的、空的哈希集合 `colSet`。
  - 遍历该列的所有元素 `matrix[i][j]`。
  - 尝试将元素添加到 `colSet` 中。如果添加失败，说明有重复，该列无效，直接返回 `false`。
- 如果所有列都检查完毕，则所有列都满足条件。

**最终结果**: 如果行和列的检查都通过了，返回 `true`。

由于题目保证了矩阵大小为 `n x n`，且要包含的数字是 `1` 到 `n`。如果一行（或一列）包含了 `n` 个不重复的数字，那么这些数字必然是 `1` 到 `n` 的排列组合。因此，我们只需要检查**是否有重复**即可，无需再检查数字是否完整覆盖 `1` 到 `n`。

#### 实现原理和步骤

1. 获取矩阵的维度 `n`。
2. **第一轮：检查所有行**
   - 外部循环 `for i from 0 to n-1`，遍历每一行。
   - 在循环开始时，初始化一个空的 `HashSet<Integer> set`。
   - 内部循环 `for j from 0 to n-1`，遍历当前行的每一个元素 `matrix[i][j]`。
   - 对于每个元素，调用 `set.add(matrix[i][j])`。`add` 方法如果返回 `false`，表示该元素已存在于集合中，即发现重复。此时可以直接 `return false`。
   - 如果内部循环正常结束，说明该行没有重复元素。继续检查下一行。
3. **第二轮：检查所有列**
   - 外部循环 `for j from 0 to n-1`，遍历每一列。
   - 在循环开始时，初始化一个空的 `HashSet<Integer> set`。（**注意**：必须重新创建，不能复用上一轮的！）
   - 内部循环 `for i from 0 to n-1`，遍历当前列的每一个元素 `matrix[i][j]`。
   - 对于每个元素，调用 `set.add(matrix[i][j])`。如果返回 `false`，则 `return false`。
   - 如果内部循环正常结束，继续检查下一列。
4. **最终返回**
   - 如果所有检查都顺利通过，程序会执行到最后。此时返回 `true`。

**替代方案**: 因为数字范围是 `1` 到 `n`，且 `n` 不会超过 100，我们可以用一个大小为 `n+1` 的布尔数组 `boolean[] seen = new boolean[n + 1]` 来代替哈希集合，这样做可以略微提升性能，因为它避免了哈希计算和对象装箱/拆箱的开销。`seen[k] = true` 表示数字 `k` 已经出现过。

#### 实现代码

```java
class Solution {
    //
    public boolean checkValid(int[][] matrix) {
        int n = matrix.length;

        
        for(int i = 0; i < n; i++){
            int[] row = matrix[i];
            Set<Integer> rowSet = new HashSet<>();
            for(int num : row){
                if(!rowSet.add(num)){
                    return false;
                }
            }
        }

        for(int j = 0; j < n; j++){
            Set<Integer> colSet = new HashSet<>();
            for(int i = 0; i < n; i++){
                if(!colSet.add(matrix[i][j])){
                    return false;
                }
            }
        }

        return true;
    }
}
```

####注意事项 (Important Notes/Caveats)

**状态重置**: 最常见的错误是忘记为每一行或每一列的检查**重新初始化**哈希集合或数组。如果使用同一个集合来检查所有行，那么第二行会因为第一行的数字而误判为重复。

**行和列都要检查**: 不要只检查了行就忘了列，或者反之。

**理解题目保证**: 题目明确了输入是 `n x n` 并且值在 `1` 到 `n` 之间。这极大地简化了问题。如果题目没有这个保证（例如，值可能是负数或大于 `n`），那么除了检查重复性，你还需要检查值的范围是否合法。

**空矩阵处理**: 虽然 LeetCode 的测试用例通常不会有 `null` 或 `length=0` 的矩阵，但在实际工程中，最好加上这些边界条件的判断。



#### 经验总结

**识别核心模式**: “唯一性校验”是算法题中的一个高频模式。看到它，你的第一反应就应该是 **HashSet** 或 **频率数组**。

**分解问题**: 面对一个看似复杂的校验规则（如本题的行列，或数独的行列宫），学会将其分解为多个独立的、更简单的子校验任务。逐个击破，代码逻辑会非常清晰。

**空间换时间**: 使用 O(n) 的额外空间（`HashSet`）使得每次查找重复元素的时间从 O(n)（暴力搜索）降低到了 O(1)，从而将整体时间复杂度从 O(n3) 优化到了 O(n2)。这是典型的空间换时间策略。

**选择最优工具**: 对于限定范围的正整数，使用布尔或整型数组通常比 `HashSet` 更快、更省内存。了解这个技巧可以在追求极致性能时派上用场。但从代码可读性和通用性来说，`HashSet` 往往是首选。

### LeetCode 36. 有效的数独 (Valid Sudoku)

#### 问题要点

这是一个**验证型**问题，而非求解型问题。

你需要根据给定的一个 9x9 数独棋盘（可能只填充了一部分），判断当前的状态是否“有效”。

有效性的判断标准遵循数独的三条基本规则：

1. **行唯一性**：每一行从 1 到 9 的数字只能出现一次。
2. **列唯一性**：每一列从 1 到 9 的数字只能出现一次。
3. **九宫格唯一性**：每一个 3x3 的子网格（九宫格）内，从 1 到 9 的数字只能出现一次。

需要特别注意：

- 棋盘中的空格由字符 `.` 表示。
- 我们**只验证已填入的数字**是否满足规则，不需要推断空格处能否填入数字。
- 给定的棋盘不一定是可解的，我们只关心当前状态是否有效。

#### 问题的本质和分析

问题的本质是在 27 个不同的集合中检查是否存在重复元素。这 27 个集合分别是：

- 9 个行集合
- 9 个列集合
- 9 个 3x3 九宫格集合 ->为什么是9个九宫格？因为题目已经明确表明了划分的方式。

只要其中任何一个集合内出现了重复的数字，整个数独就是无效的。

如果遍历完所有已填写的数字，在它们各自所属的行、列、九宫格中都没有发现重复，那么这个数独就是有效的。

因此，问题的核心就转化为了：**如何高效地记录和查询一个数字是否在某个特定的行、列或九宫格中已经出现过？**

#### 模式匹配

**哈希表 (Hash Table) / 集合 (Set)**: 这是解决此问题的最经典、最直接的模式。哈希表提供了平均 O(1) 时间复杂度的插入和查找操作，是检查“是否存在/重复”这类问题的首选数据结构。

**矩阵遍历 (Matrix Traversal)**: 我们需要遍历整个 9x9 的二维数组来检查每一个单元格。

**空间换时间**: 我们使用额外的存储空间（哈希表）来记录数字的出现情况，从而将查找时间从 O(N) 降低到 O(1)，优化了整体性能。

#### 核心思想 - 一次遍历 + 哈希表记录

##### 核心思路 - 检查每一行/列/九宫格

我们遍历棋盘中的每一个单元格 `board[i][j]`。

如果这个单元格不是空的（即不为 `.`），我们就需要检查这个数字在它所属的第 `i` 行、第 `j` 列以及对应的九宫格中是否已经出现过。

为了实现这个检查，我们可以使用三个数据结构来分别记录：

1. 每一行中已经出现过的数字。
2. 每一列中已经出现过的数字。
3. 每一个**九宫格**中已经出现过的数字。

当检查 `board[i][j]` 的数字 `num` 时：

1. 在“行记录”中查询第 `i` 行是否已有 `num`。
2. 在“列记录”中查询第 `j` 列是否已有 `num`。
3. 在“九宫格记录”中查询 `(i, j)` 所在的九宫格是否已有 `num`。

如果任何一个查询结果为“是”，则说明存在重复，数独无效，立即返回 `false`。

如果三个查询都为“否”，则将 `num` 添加到这三个记录结构中，然后继续遍历下一个单元格。

如果成功遍历完整个棋盘都没有返回 `false`，则说明数独有效，最后返回 `true`。

##### 如何确定当前元素属于哪一个九宫格？

我们假设九个九宫格编号从0到8。

现在我们来看如何确定一个格子`[i,j]`属于哪一个九宫格？

这个过程分为两个步骤：

- **第一步：** 将 9x9 的单元格坐标 `(i, j)` 映射到 3x3 的九宫格坐标 `(box_row, box_col)`。
- **第二步：** 将 3x3 的九宫格坐标 `(box_row, box_col)` 映射到最终的 0-8 线性索引。

###### 第一步： 从 `(i, j)` 推导九宫格的行列号 `(box_row, box_col)`

我们先观察一下规律。

九宫格本身也构成了一个 3x3 的网格。

我们称这个网格的坐标为 `(box_row, box_col)`，其中 `box_row` 和 `box_col` 的取值都是 0, 1, 2。

**推导九宫格的行号**

- 当单元格的行 `i` 是 0, 1, 2 时，它们都位于**第 0 行**的九宫格中 (`box_row = 0`)。
- 当单元格的行 `i` 是 3, 4, 5 时，它们都位于**第 1 行**的九宫格中 (`box_row = 1`)。
- 当单元格的行 `i` 是 6, 7, 8 时，它们都位于**第 2 行**的九宫格中 (`box_row = 2`)。

我们需要一个数学运算，能将 `{0, 1, 2}` 映射到 `0`，将 `{3, 4, 5}` 映射到 `1`，将 `{6, 7, 8}` 映射到 `2`。

这个运算就是**整数除法 ` / 3`**。

- `0 / 3 = 0`, `1 / 3 = 0`, `2 / 3 = 0`
- `3 / 3 = 1`, `4 / 3 = 1`, `5 / 3 = 1`
- `6 / 3 = 2`, `7 / 3 = 2`, `8 / 3 = 2`

因此，我们得到了第一个关系式： `box_row = i / 3`

**推导九宫格的列号**

同理，我们观察单元格的列 `j`：

- 当 `j` 是 0, 1, 2 时，它们位于**第 0 列**的九宫格中 (`box_col = 0`)。
- 当 `j` 是 3, 4, 5 时，它们位于**第 1 列**的九宫格中 (`box_col = 1`)。
- 当 `j` 是 6, 7, 8 时，它们位于**第 2 列**的九宫格中 (`box_col = 2`)。

这和行号的规律完全一样，所以我们得到了第二个关系式： `box_col = j / 3`

###### 第二步： 从九宫格坐标 `(box_row, box_col)` 推导最终索引 `0-8`

我们现在的问题是，如何将一个 2D 坐标 `(row, col)` 映射到一个 1D 的线性索引？这是一个非常经典的 "二维地址一维化" 问题。

假设我们有一个 `M x N` 的网格，要把它展开成一维数组，最常见的方式是**行优先 (row-major)** 展开，就像我们读书一样，从左到右，再从上到下。 索引的计算公式是： `index = row * (每行的元素个数) + col`

在我们的场景中，九宫格是一个 3x3 的网格，所以“每行的元素个数”是 3。 将 `(box_row, box_col)` 代入上面的通用公式： `final_index = box_row * 3 + box_col`

我们来验证一下：

- `(box_row=0, box_col=0)` -> `0 * 3 + 0 = 0` （左上角）
- `(box_row=0, box_col=2)` -> `0 * 3 + 2 = 2` （右上角）
- `(box_row=1, box_col=0)` -> `1 * 3 + 0 = 3` （中左）
- `(box_row=2, box_col=2)` -> `2 * 3 + 2 = 8` （右下角） 这个公式完全符合我们对 0-8 的编号预期。

###### 第三步：整合推导 - 推导出映射公式

现在我们把第一步和第二步的结果结合起来：

1. 我们有 `box_row = i / 3`
2. 我们有 `box_col = j / 3`
3. 我们有 `final_index = box_row * 3 + box_col`

将 (1) 和 (2) 代入 (3)，就得到了最终的映射公式：

```
final_index = (i / 3) * 3 + (j / 3)
```

这就是我们想要的公式！它并非凭空而来，而是通过“降维”和“地址转换”两个逻辑步骤清晰推导出来的。

#### 实现原理和步骤

##### 初始化27个数据结构

###### 每一行出现过的数字

创建 9 个 `HashSet` 用于存储每一行出现过的数字，可以放在一个数组里：`HashSet<Character>[] rows = new HashSet[9];`

###### 每一列出现的数字

创建 9 个 `HashSet` 用于存储每一列出现过的数字：`HashSet<Character>[] cols = new HashSet[9];`

###### 每一个九宫格出现的数字

创建 9 个 `HashSet` 用于存储每一个九宫格出现过的数字：`HashSet<Character>[] boxes = new HashSet[9];`

- 别忘了初始化数组中的每一个 `HashSet` 对象。

##### 遍历棋盘

使用嵌套循环，外层循环 `i` from 0 to 8，内层循环 `j` from 0 to 8。

##### 处理单元格

- 在循环内部，获取当前单元格的字符 `char c = board[i][j]`。

- 如果 `c == '.'`，说明是空格，直接 `continue` 到下一个单元格。
  - 计算九宫格的索引 `boxIndex = (i / 3) * 3 + (j / 3)`。
  - 检查行：`if (!rows[i].add(c))`，如果 `add` 方法返回 `false`，说明该数字已存在于当前行的 `HashSet` 中，直接 `return false`。
  - 检查列：`if (!cols[j].add(c))`，如果 `add` 方法返回 `false`，说明该数字已存在于当前列的 `HashSet` 中，直接 `return false`。
  - 检查九宫格：`if (!boxes[boxIndex].add(c))`，如果 `add` 方法返回 `false`，说明该数字已存在于当前九宫格的 `HashSet` 中，直接 `return false`。
  - `HashSet.add()` 方法的返回值非常巧妙：当元素成功添加时返回 `true`，当元素已存在导致添加失败时返回 `false`。我们可以利用这个特性同时完成检查和添加两个操作。

##### 返回结果

如果嵌套循环正常结束，说明没有在任何行、列或九宫格中发现重复数字，函数最后 `return true`。

#### 实现代码

```Java

class Solution {
    public boolean isValidSudoku(char[][] board) {
      Set<Character>[] rowSets = new HashSet[9];
      for(int i = 0; i < 9; i++){
        rowSets[i] = new HashSet<>();
      }

      Set<Character>[] colSets = new HashSet[9];
      for(int i = 0; i < 9; i++){
        colSets[i] = new HashSet<>();
      }

      Set<Character>[] boxSets = new HashSet[9];
      for(int i = 0; i < 9; i++){
        boxSets[i] = new HashSet<>();
      }

      for(int row = 0; row < 9; row++){
        for(int col = 0; col < 9; col++){
            if(board[row][col] == '.'){
                continue;
            }
            //检查行是否已经存在
            if(!rowSets[row].add(board[row][col])){
                return false;
            }
            //检查列是否已经存在
            if(!colSets[col].add(board[row][col])){
                return false;
            }
            //检查九宫格中是否已经存在
            int boxIndex = (row/3)*3 + col/3;
            if(!boxSets[boxIndex].add(board[row][col])){
                return false;
            }
        }
      }
      return true;
    }
}
```

#### 注意事项

1. **数据类型**：棋盘中的是 `char` 类型的 `'1'` 到 `'9'`，不是 `int` 类型的 `1` 到 `9`。使用 `HashSet<Character>` 可以直接存储。
2. **提前返回**：一旦发现任何一个规则被违反（即发现重复），应立即返回 `false`，无需继续检查，这可以提高效率。
3. **空间复杂度**：该解法使用了额外的空间。在最坏情况下（棋盘全满），每个 `HashSet` 最多存储 9 个数字。总空间是 `9 * 9 + 9 * 9 + 9 * 9` 个字符的存储空间。由于 9 是一个常数，所以空间复杂度是 O(1)。
4. **时间复杂度**：我们只需要遍历一次棋盘。对于棋盘中的每个单元格，我们执行了三次哈希表的 `add` 操作，其平均时间复杂度是 O(1)。因此，总的时间复杂度是 O(N^2)，其中 N=9。因为 N 是常数，所以时间复杂度也可以认为是 O(1)。

#### 经验总结

**识别问题本质**：将“验证数独”这个看似复杂的问题，拆解为对 27 个独立集合进行“重复元素检查”的子问题，是解题的关键。

**选择合适的数据结构**：对于“检查重复/是否存在”的需求，要立刻想到**哈希表/哈希集合**。它是这类问题的标准高效解决方案。

**掌握常用技巧**：二维坐标到一维索引的映射（如本题中的 `boxIndex` 计算）是处理网格类问题时非常有用的技巧，值得记忆和掌握。

**代码简洁性**：巧妙利用 `Set.add()` 的布尔返回值，可以让代码更紧凑、更优雅，将“检查”和“添加”两个步骤合二为一。

**区分验证与求解**：务必仔细读题，分清题目是要求“验证当前状态”还是“求解最终结果”。这两类问题的难度和解法截然不同。本题是前者，比求解型问题（如 LeetCode 37. Sudoku Solver）简单得多。

### Leetcode 37: 解数独 - 回溯

#### 问题要点

**输入**: 一个 `9x9` 的 `char[][]` 棋盘，其中 `'.'` 代表空格子，`'1'` 到 `'9'` 代表已经填好的数字。

**输出**: 无需返回值，直接在原棋盘上修改，填满所有空格，使其成为一个有效的数独解。

**约束**: 题目保证输入数独有且仅有一个唯一解。

**数独规则**:

- **行唯一**: 每一行 1-9 的数字只能出现一次。
- **列唯一**: 每一列 1-9 的数字只能出现一次。
- **宫唯一**: 每一个 3x3 的九宫格内 1-9 的数字只能出现一次。

#### 问题本质和分析

这个问题本质上是一个**搜索问题**，或者更具体地说，是一个**约束满足问题 (Constraint Satisfaction Problem, CSP)**。我们需要在一系列空格中填入数字，同时满足数独的三个约束条件。

##### 朴素的暴力方法

由于每个空格都有 9 种可能的选择，如果空格数量为 N，那么总的搜索空间将是 $9^N$ 级别，这是一个非常巨大的数字。

暴力穷举所有可能性是行不通的。

##### 符合回溯的特征

当我们尝试在一个格子 `(row, col)` 填入一个数字时，这个选择会立刻影响到后续其他格子的选择。

如果这个选择导致后续的格子无解，我们就必须撤销当前的选择，换一个数字再试。

这个“尝试-失败-回退”的过程，正是**回溯算法**的标志性特征。

因此，我们可以确定，解决这个问题的核心算法是回溯法。

#### 模式套路匹配 - 回溯法

此问题完美匹配**回溯算法 (Backtracking)** 的经典模式。

#####回溯法适用的问题场景

1. **组合问题**: 寻找所有满足条件的组合（如 Combination Sum）。
2. **排列问题**: 寻找所有可能的排列（如 Permutations）。
3. **子集问题**: 寻找所有子集（如 Subsets）。
4. **搜索问题**: 在一个决策树中寻找一个（或所有）可行的解（如 N-Queens, Sudoku Solver）。

##### 回溯法可以被看作是DFS+剪枝

回溯算法的框架可以被看作是**深度优先搜索 (DFS) + 剪枝 (Pruning)**。

- **DFS**: 我们沿着一条路径（一种决策序列）深入探索。
- **剪枝**: 在探索过程中，一旦发现当前的选择不满足约束条件，就立刻停止深入，返回上一层，从而“剪掉”了整个无效的子树，极大地提高了搜索效率。

#### 核心思想和套路

##### 回溯法解决本问题的思路

核心思想是**模拟人类手动解数独**的过程：

1. 找到一个空格。
2. 尝试从 1 到 9 填入一个数字。
3. 检查这个数字是否符合数独的规则（行、列、九宫格内不重复）。
   - 如果符合，就暂时将这个数字“固定”下来，然后去解决下一个空格（递归调用）。
   - 如果下一个空格的求解最终成功了（递归函数返回 `true`），说明我们当前的选择是正确的，任务完成。
   - 如果下一个空格的求解最终失败了（递归函数返回 `false`），说明我们当前的选择是错误的，导致了“死路”。
   - 我们需要**撤销**当前的选择（将格子恢复为 `.`），然后尝试下一个数字。
4. 如果 1 到 9 都尝试完了，仍然无法找到一个可行的解，说明是之前的某一步填错了，返回 `false` 给上一层调用。

这个过程形成了一个递归的决策树。

##### 回溯法的三要素

1. **选择 (Choice)**: 在当前空格可以填入的数字（1-9）。
2. **约束 (Constraint)**: 填入的数字是否满足行、列、九宫格的唯一性规则。
3. **目标 (Goal)**: 成功填满棋盘上所有的空格。

#### 实现原理和步骤

##### 主函数 - 程序的入口

这是程序的入口，它调用递归的回溯辅助函数。

##### 回溯函数

- **遍历棋盘**: 从 `(0, 0)` 开始，一行一行地遍历棋盘，找到第一个为空（值为 `.`）的格子 `(row, col)`。

###### Base Case : 整个棋盘都没有空格

- **Base Case (递归出口)**: 如果遍历完整个棋盘都没有找到空格，说明数独已经解决，返回 `true`。

###### 循环尝试1-9

- 在循环中，对每个数字 `num`，调用 `isValid(board, row, col, num)` 来检查其合法性。

- **如果合法**:

  -  a. **做出选择**: `board[row][col] = num`。

  -  b. **向下递归**: 调用 `backtrack(board)`。

    - 如果这个递归调用返回 `true`，说明基于当前选择，后续的空格都成功填满了。
    - 那么我们直接返回 `true`，将成功信号传导上去。

  -  c. **撤销选择**: 如果 `backtrack(board)` 返回 `false`，说明当前的选择 `num` 是错误的，它导致了后续的死胡同。

    我们需要撤销选择，`board[row][col] = '.'`，然后继续循环，尝试下一个数字。

###### 返回失败

如果从 '1' 到 '9' 的所有数字都尝试过，但都无法最终解决问题，说明是上一步的决策导致了当前这个空格无解。因此，返回 `false`，通知上一层调用它做出的选择是错误的。

##### 校验函数`isValid(board, row, col, num)`

- 检查 `board` 的第 `row` 行是否已经存在 `num`。

- 检查 `board` 的第 `col` 列是否已经存在 `num`。

- 检查 `(row, col)` 所在的 3x3 九宫格是否已经存在 `num`。计算九宫格的起始坐标：`startRow = (row / 3) * 3`, `startCol = (col / 3) * 3`。

如果以上三项检查都通过，返回 `true`，否则返回 `false`。

#### 实现代码 - 基于回溯

```Java
class Solution {
    private boolean[][] rows = new boolean[9][9];
    private boolean[][] cols = new boolean[9][9];
    private boolean[][] boxes = new boolean[9][9];
    public void solveSudoku(char[][] board) {
        //Generate the data of the array of whether every number appears in its row/col/box
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                char c = board[i][j];
                if(c == '.'){
                    continue;
                }
                int num = c - '1';
                rows[i][num] = true;
                cols[j][num] = true;
                //Remember this formula to calcuate the 3*3 box index
                int boxIndex = (i / 3) * 3 + (j / 3);
                boxes[boxIndex][num] = true; 
            }
        }
        backtrack(board,0, 0);
    }

    private boolean backtrack(char[][] board, int row, int col){
        //Very Important practice
        //Find out the next empty cell
        while(row < 9 && board[row][col] != '.'){
            col++;
            //If the col arrives the end in the current row
            //Switch to the next row
            if(col == 9){
                col = 0;
                row++;
            }
        }

        //The row arrives the end, which means the board has been filled successfully
        //Return true
        if(row == 9){
            return true;
        }

        //Start the backtrack process
        for(int num = 0; num < 9; num++){
            //If the current number has been used, continue to the next one
            //Note that, it is continue not to return false;
            if(rows[row][num]){
                continue;
            }
            if(cols[col][num]){
                continue;
            }
            int boxIndex = (row / 3) * 3 + col / 3;
            if(boxes[boxIndex][num]){
                continue;
            }
            //Place the number to the cell
            rows[row][num] = true;
            cols[col][num] = true;
            boxes[boxIndex][num]  = true;
            board[row][col] = (char)(num + '1');
            //If left cells can be placed, return truel;
            if(backtrack(board,row,col)){
                return true;
            }
            //Otherwise, remove the number from the cell
            rows[row][num] = false;
            cols[col][num] = false;
            boxes[boxIndex][num]  = false;
            board[row][col] = '.';
        }
        //If all number tried but still unsuccessful, return false;
        return false;
    }
}
```

#### 复习回溯的过程

```Java
if(base condition){//如何判断base condition比较重要
  return;
}

for(each option){
  if(option 不符合条件){
    continue;
  }
  execute(option);
  backtrack(context,next);
  cancel(option);
}
```

#### 注意事项

**char 与 int 的转换**: 棋盘是 `char` 类型，在用作数组索引或计算时需要转换为 `int`。`char c = '5'; int num = c - '0';` (得到数字5) 或 `c - '1';` (得到索引4)。

**递归函数的返回值**: `boolean` 返回值至关重要。它用于告知上层调用，当前路径是否能找到解。`if (backtrack(...)) { return true; }` 这个判断是回溯算法提前终止的关键，一旦找到解，就层层返回 `true`，不再进行其他尝试。

**原地修改**: 题目要求在原数组上修改，所有操作都直接作用于传入的 `board`。

**九宫格索引**: 计算九宫格索引的公式 `(row / 3) * 3 + (col / 3)` 是一个常用技巧，需要掌握。

#### 经验总结

**识别回溯**: 当问题涉及在一个庞大的搜索空间中寻找一个（或所有）满足特定约束的解时，应首先考虑回溯法。其“决策树”模型和“尝试-回退”的特征非常明显。

**回溯模板**: 掌握回溯算法的通用模板（选择、约束、目标、递归、撤销）。这个模板可以套用在很多类似问题上。

**性能优化**: 对于回溯过程中的频繁校验操作，要思考是否可以通过预处理或维护状态（空间换时间）来优化。`isValid` 检查从 O(N) 优化到 O(1) 是本题的关键性能提升点。

**状态传递**: 思考如何在递归中有效地传递状态。在本题的优化版本中，我们通过成员变量 `rows`, `cols`, `boxes` 维护全局状态。另一种方式是作为递归函数的参数传递，但这通常更繁琐。

**练习同类问题**: 将此题与 N-Queens, Combinations, Permutations 等经典回溯问题进行对比，加深对回溯模式的理解。它们的框架几乎一样，只是“选择”和“约束”的具体定义不同。

## 分组和分类

用哈希表的 Key 对具有相同特征的元素进行归类。

- **典型题目:**
  - `#49` 字母异位词分组 (Group Anagrams)
  - `#438` 找到字符串中所有字母异位词 (Find All Anagrams in a String)

###LeetCode #49 - 字母异位词分组

#### **场景 + 目标:**

 将字符串数组中所有字母异位词归到同一组。

#### **模式匹配:**

 题目要求“分组”，核心是为同一组的元素找到一个共同的、唯一的“身份标识”，即“签名”。

####实现原理和步骤: - 排序 + HashMap

1. 初始化 `HashMap<String, List<String>>`。
2. 遍历每个字符串 `s`。
3. 计算 `s` 的签名 `key`。最简单的方法是将 `s` 的字符排序后生成新字符串。
4. 将原字符串 `s` 添加到 `key` 对应的列表中。可使用 `map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);` 简化代码。
5. 最后，`map.values()` 就是所有分组的集合。

####**实现代码 (Java):**

```Java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String s : strs) {
            char[] charArray = s.toCharArray();
            Arrays.sort(charArray);
            String key = new String(charArray);
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
        }
        return new ArrayList<>(map.values());
    }
}
```

