### 对撞指针：两个指针分别从两边向中间靠拢

##### **常见场景**

- 判断是否为回文串
- 有序数组中找和为某个数的两个数
- 盛最多水的容器

#####套路模版要记住！

```java
int left=0;right = arr.length-1;

while (left<right){
  int sum = arr[left]+arr[right];
  if (sum == target){
    // 找到答案
  } else if (sum < target){
    left++;
  } else{
    right--;
  }
}
```

##### Leetcode 125. Valid Palindrome

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

```java
public boolean isPalindrome(String s){
  int n = s.length();
  int left = 0;
  int right = n-1;
  while (left<right){
    //如果left字符不合法，left指针前移
    if (!Character.isLetter(s.charAt(left)) && ! Character.isDigit(s.charAt(left))){
      left++;
    }
    //如果right字符不合法，右指针左移
    if(!Character.isLetter(s.charAt(right)) && !Character.isDigit(s.charAt(right))){
      right--;
    }
    
    char a = Character.toLowerCase(s.charAt(left));
    char b = Character.toLowerCase(s.charAt(right));
    if (a!=b){
      return false;
    }
    i++;
    j--;
  }
  return true;
}
```



##### Leetcode 11. Container With Most Water

You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that, together with the x-axis, form a container that holds the most water.

Return *the maximum amount of water a container can store*.

**Notice** that you may not slant the container.

```Java
class Solution {
    public int maxArea(int[] height) {

        if(height == null || height.length <=1){
            return 0;
        }
        int n = height.length;
        int left = 0;
        int right = n-1;
        int ans = 0;
        while(left < right){
          // calculate the area 
            int area = Math.min(height[left],height[right]) * (right - left);
            ans = Math.max(area, ans);
          //Try to find out the next area
            if(height[left] < height[right]){
                left++;
            }else{
                right--;
            }
        }
        return ans;
    }
}
```



##### Leetcode 167. Two Sum II - Input array is sorted



```java
class Solution {
    //找出和为target的两个数字
    //必须使用常数级别额外空间
    public int[] twoSum(int[] numbers, int target) {
        int n = numbers.length;
        int left = 0;
        int right = n-1;
        while( left < right){
            int sum = numbers[left] + numbers[right] ;
            if(sum == target){
                return new int[]{left+1,right+1};
            }else if(sum < target) {
                left++;
            }else{
                right--;
            }
        }
        return null;
    }
}
```

##### Leetcode 1099: 小于K的两数之和

给你一个整数数组 `nums` 和整数 `k` ，返回最大和 `sum` ，满足存在 `i < j` 使得 `nums[i] + nums[j] = sum` 且 `sum < k` 。如果没有满足此等式的 `i,j` 存在，则返回 `-1` 。

###### 实现代码

```java
    public int twoSumLessThanK(int[] nums, int k) {
        //数组排序
        Arrays.sort(nums);
        
        int left=0;
      	//定义默认值为-1
        int max=-1;
        int right = nums.length-1;
      // 对撞指针
        while (right >left) {
            int sum = nums[left]+nums[right];
          //如果sum已经小于k
          //更新max
          //尝试看看nums[left+1]+nums[right]是否依然小于k
            if (sum<k){
                max = Math.max(max, sum);
                left++;
              //如果sum>=k，直接收缩右指针
            }else{
                right--;
            }
        }
        return max;
    }
```

### 