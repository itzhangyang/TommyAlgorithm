## 恰好有K个符合条件的元素的子串 - atMost(k) - atMost(k-1)

### 问题要点

- 统计子串个数，满足：同时包含 a/e/i/o/u（每个至少一次）且**辅音数 = k**。
- n 可达 2e5，需 O(n)。
- 用恒等式：`exact(k) = atMost(k) - atMost(k-1)`。

### 问题的本质和分析

- **恰好 K**的经典拆法：用两个**至多 K**的计数相减。

- “包含全部目标字符”的计数关键：

  对固定右端 r，若窗口已覆盖 5 个元音，则**可行起点**是 `i ∈ [l..m]`，其中：
   `m = min(五个元音在窗口内的最后出现位置)`；

   于是本轮贡献 = `m - l + 1`。

### 背景知识

####计数恒等式（exact/atMost）

`exact(k) = atMost(k) - atMost(k-1)`

#####双指针滑动窗口

维护统计量（辅音数、元音种类覆盖、每个元音出现次数、最后位置）

### 考察点

- 滑窗 + 差分计数（exact = atMost 差）。
- 覆盖类子串一次性计数（通过五个元音的最小“最后位置”）。
- 边界处理与大数（答案用 `long`）。

### 模式匹配

- 字符串·覆盖/包含类 + “恰好 K”
- 套路：`atMost(k) - atMost(k-1)` + “last seen 最小值一次性累加”。

### 核心思想和套路

1. 写 `countAtMost(k)`：返回“**辅音 ≤ k 且包含 5 元音**”的子串数。
2. 窗口维护：
   - `vowelCount: Map<Character,Integer>`：记录窗口内 **每个元音的计数**；
   - `lastSeen: Map<Character,Integer>`：记录 **每个元音最后出现的下标**；
   - `unique`：窗口中**已覆盖的元音种类数**（`count>0` 的种类数）；
   - `consonants`：窗口内辅音个数。
3. 扩右端 r，更新两个 Map；若辅音数超标则移动 l 并维护统计量。
4. 若 `unique==5`，取 `m = min(lastSeen['a'..'u'])`，本轮贡献 `m - l + 1`。
5. 答案 `atMost(k) - atMost(k-1)`。

### 实现原理和步骤

预处理：`isVowel(c)`；准备 5 个元音的集合 `Set<Character> V`。

在 `atMost(s,k)` 中：

1. `k<0` 返回 0；
2. 初始化 `l=0, ans=0, consonants=0, unique=0`；`vowelCount` 初值 0；`lastSeen` 初值 -1；
3. 遍历 r：
   - 若元音：`vowelCount[c]++`；若从 0→1，`unique++`；更新 `lastSeen[c]=r`；
     若辅音：`consonants++`。
   - 当 `consonants > k`，左缩：若 `s[l]` 是元音，`vowelCount--`，若从 1→0，`unique--`；否则 `consonants--`；`l++`。
   - 若 `unique==5`：计算 `m = min(lastSeen[a],...,lastSeen[u])`，`ans += (m - l + 1)`。
4. 返回 `ans`。

主函数：`atMost(k) - atMost(k-1)`。

### 实现代码

```java
class Solution {
    public long countOfSubstrings(String word, int k) {
        long atMostK = atMost(word, k);
        long atMostKMinus1 = atMost(word,k-1);
        return atMostK - atMostKMinus1;
    }

    private long atMost(String word, int k){
        if(k < 0){
            return 0;
        }
        //窗口中每一个元音字母的数量
        Map<Character, Integer> vowelCounter = new HashMap<>();
        //每一个元音最后出现的位置
        Map<Character, Integer> lastSeen = new HashMap<>();
        Set<Character> vowels = Set.of('a','e','i','o','u');
        //窗口中辅音的数量（包含重复）
        int consonantCount = 0;
        //初始化结果
        long ans = 0;

        int left = 0;
        for(int right = 0; right < word.length(); right++){
            char rc = word.charAt(right);
            if(vowels.contains(rc)){
                vowelCounter.put(rc, vowelCounter.getOrDefault(rc, 0) + 1);
                //记录该元音字母出现的最后一个位置
                lastSeen.put(rc, right);
            }else{
                consonantCount++;
            }
            //触发收缩窗口
            while (consonantCount > k ) {
                char lc = word.charAt(left);
                if(vowels.contains(lc)){
                    int count = vowelCounter.getOrDefault(lc, 0);
                    if(count == 1){
                        vowelCounter.remove(lc);
                        lastSeen.remove(lc);
                    }else{
                        vowelCounter.put(lc, count - 1);
                    }
                }else{
                    consonantCount--;
                }
                left++;
            }

            if(vowelCounter.size() == 5){
                int min  = Integer.MAX_VALUE;
                //取得最小的元音lastSeen位置
                for(int lastSeenIndex : lastSeen.values()){
                    min = Math.min(min, lastSeenIndex);
                }
                //在[left,right]区间内符合条件的子串有 m - l + 1个
                ans = ans + min -left + 1;
            }
        }
        return ans;
    }
}
```

### 注意事项

- **为什么需要 `lastSeen`？**
  仅用“计数”能判断是否覆盖，但**无法 O(1) 地知道最小可行起点**。`lastSeen` 的最小值正好给出“在不丢失任一元音的前提下，起点最远能到哪里”；所以用两个 Map（计数 + 最后位置）既直观又高效。

- 计数与覆盖维护的细节：

  - `unique` 只在某元音计数由 0→1 时增、由 1→0 时减。

  - 左缩时别忘了先根据 `s[l]` 更新计数/辅音，再移动 `l`。

- 结果用 `long`，因为子串数可达 O(n²)。

- `k=0`、所有元音都集中在右端、长串辅音等边界都能自然覆盖。

### 经验总结

- “**恰好 K**”优先做成 `atMost(K) - atMost(K-1)`。

- 覆盖类问题要学会用“**最后出现位置取最小**”来一次性计数。

- 小字符集时，用 `Map` 也足够清晰；追求极致性能再换数组。

- 模板可复用到相近问题（如 3305/其它覆盖+K 变体）。