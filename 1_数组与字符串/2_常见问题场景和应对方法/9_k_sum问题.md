#K - sum 问题 - 找出含有k个元素并且和为target的子集 - 回溯+滑动窗口

## 2-sum问题解析 - 是否存在和为target的对- Leetcode 1

- 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中两数之和等于目标值 `target` 的两个数的下标。
- **输入**：
  - 数组 `nums`：长度为 `n` 的整数数组。
  - `target`：一个整数值，表示目标和。
- **输出**：
  - 返回一个长度为2的数组 `[index1, index2]`，表示数组中两个数的下标，其中 `nums[index1] + nums[index2] = target`。假设每个输入只有一个解。

### 问题本质和分析 - 查找配对问题

**问题本质**：这是一个典型的查找问题。我们需要从给定的数组中找出两个数，它们的和为目标值。

**映射到算法模型**：这类问题可以映射为 **查找配对问题**，最基本的方式是**暴力枚举**，但显然暴力解法时间复杂度较高。

因此需要借助**哈希表**来优化查找效率。

**时间复杂度优化**：通过使用**哈希表（HashMap）来**存储已遍历的元素，快速查找剩余需要的配对值，从而将暴力解法的时间复杂度从 `O(n^2)` 降低到 `O(n)`。

### 核心思想和套路 - 哈希表

#### 暴力解法

对于数组中的每一对元素，检查他们的和是否等于`target`。如果是，则返回两个元素的下标。

这种方法简单，但是效率低，时间复杂度为$O(N^2)$

#### 哈希表解法优化

##### 基本思想 - 计算target - cur_num是否已经存在

通过哈希表存储已访问的元素，在遍历数组时，计算 `target - current_num`（即所需的补充值）。如果补充值已经在哈希表中，说明找到了这两个数。若没有，则将当前数存入哈希表，继续查找。

##### 哈希表的作用

哈希表提供了常数时间的查找操作，使得查找补充值的操作非常高效，时间复杂度降为 `O(n)`。

### 难点分析和应对

- **难点**：
  - 需要确保哈希表的使用正确，尤其是在处理数组中元素的顺序时。
  - 对于每个元素，必须保证只返回一个解，因此要避免重复解。
- **应对方式**：
  - 使用哈希表来存储之前遍历过的元素，使得每次查找补充值的时间复杂度为 `O(1)`。
  - 在遍历过程中，对于每个数，如果找到其补充值（即 `target - current_num`），则返回对应下标。

### 实现代码

```java
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
```

### 实现原理和详细步骤

1. 初始化一个空的哈希表，用来存储已经遍历的数字和它们的下标
2. 遍历数组：
   - 对于当前元素`num[i]`， 计算它需要的**补充值**`target - num[i]`
   - 检查不充值是否已经存在于哈希表中
     - 如果存在，则继续寻找答案，返回当前数字和数值的下标
     - 如果不存在，将当前数字及其下标存入哈希表
3. 继续遍历，直到找到配对，或者遍历结果

### 注意事项

- **哈希表的使用**：在使用哈希表时，需要注意 **插入顺序**，即将当前元素的值和下标存储在哈希表中，以便后续查找。
- **异常处理**：如果没有找到满足条件的两数，需要抛出异常或返回特定的标志值，避免返回错误结果。
- **性能优化**：哈希表提供 `O(1)` 时间复杂度的查找，确保此解法可以应对较大的输入规模。

### 经验总结

1. **暴力解法 vs 哈希表优化**：
   - 暴力解法是最直接的方法，但其时间复杂度较高，适用于小规模数据。哈希表优化后的解法大大提高了效率，使得该问题可以在更大的数据规模下快速解决。
2. **哈希表的优势**：
   - 哈希表作为一种数据结构，提供了非常高效的查找能力。在这类查找问题中，它能够将时间复杂度从 `O(n^2)` 降到 `O(n)`，对于大数据输入尤为重要。
3. **考虑特殊情况**：
   - 要保证输入数组中的元素的唯一性，如果题目要求返回的是所有满足条件的组合，则需要对结果进行适当的处理，避免重复。
4. **注意返回值的格式**：
   - 本题的解法要求返回数组的下标，因此需要存储每个元素及其对应的下标，这在哈希表中实现非常简洁。

## Two - Sum ： 列举不重复的和为target的对

### 问题要点

给定一个整数数组 `nums` 和一个目标值 `target`，要求列举数组中所有和为 `target` 的不重复的数对。**[1, 2] 和 [2, 1] 被认为是重复对**，因此返回的是**唯一的组合**。

**输入**：

- 整数数组 `nums`。
- 目标值 `target`。

**输出**：

- 一个列表，包含所有和为 `target` 的不重复数对。

### 问题本质和分析

**问题本质**：这实际上是一个 **查找配对** 问题，不同之处在于，我们需要考虑 **去重**，避免返回重复的数对。

**映射到算法模型**：这个问题是典型的 **查找配对问题**，可以通过 **哈希表** 来实现高效查找。但与经典的 Two-Sum 不同，我们不仅要查找一对数，还要保证这些数对不重复。

### 核心思想和套路：排序 + 双指针

#### 排序 + 双指针 - 去重逻辑很重要

- 通过排序数组，并且使用双指针（左右指针），可以避免返回重复的配对
- 左指针从数组的起始位置开始，右指针从数组的末尾开始，然后通过移动指针寻找符合条件的数对

#### 去重

对数组进行排序后，左右指针遇到重复元素时跳过。避免同样的数对被多次列举。

### 难点分析和应对

####怎样做去重控制

通过 **排序 + 双指针** 可以有效地避免重复对。左指针和右指针在遇到相同元素时可以跳过。

使用哈希表时，需要确保每次插入的元素是唯一的。

#### 双指针确保正确移动

**双指针法**：需要确保左指针和右指针正确移动，保证不会漏掉任何可能的数对。

### 实现原理和步骤

#### 排序以便于去重

首先对数组进行排序，确保相同的元素会排在一起，有利于去重。

#### 双指针过程

设置左指针 `left` 和右指针 `right`，当 `left < right` 时：

- 计算当前的和：`sum = nums[left] + nums[right]`。

- 如果 `sum == target`，则找到一对数，保存该对，并且移动左右指针：

  - 跳过两端重复的元素

    - 跳过左侧重复元素, 跳到**最后一个和当前元素重复的元素**

      `left++` 只会将 `left` 指针 **移动到下一个相同的元素**，而不是跳到与当前元素不同的位置。所以，在跳过所有连续重复元素时，`left` 指针会 **停在最后一个重复元素的位置**。

      ```
      while (left < right && nums[left] == nums[left + 1]) left++;
      ```

    - 如果右侧下一个元素重复，跳到**最后一个和当前元素重复的元素**

      ```
      while (left < right && nums[right] == nums[right - 1]) right--;
      ```

  - 移动左右指针

    ```
    left++;
    right--;
    ```

    

- 如果 `sum < target`，则将左指针右移（增加当前和）。

- 如果 `sum > target`，则将右指针左移（减少当前和）。

#### 去重

1. **去重**：当左指针或右指针遇到相同的元素时，跳过，避免重复的组合。

### 实现代码 - 双指针

```java
import java.util.*;

public class TwoSumUniquePairs {

    public List<List<Integer>> twoSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 2) return result;

        Arrays.sort(nums);  // 排序，便于双指针法和去重

        int left = 0, right = nums.length - 1;

        while (left < right) {
            int sum = nums[left] + nums[right];
            
            if (sum == target) {
                result.add(Arrays.asList(nums[left], nums[right]));
                // 跳过重复的元素
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;
               //左右指针同时移动
                left++;
                right--;
            } else if (sum < target) {
                left++;  // 当前和小于target，增加左指针
            } else {
                right--;  // 当前和大于target，减少右指针
            }
        }

        return result;
    }

    public static void main(String[] args) {
        TwoSumUniquePairs solution = new TwoSumUniquePairs();
        int[] nums = {1, 2, 3, 2, 4, 3, 5, 0};
        int target = 5;
        List<List<Integer>> result = solution.twoSum(nums, target);
        System.out.println(result);  // 输出不重复的数对
    }
}

```

### 注意事项

- **排序**：排序是解决这个问题的关键，它为使用双指针法提供了基础，并且确保了相同元素被连续排列，方便去重。
- **双指针的正确性**：
  - 确保左指针和右指针只会向内移动，避免重复处理同一对数。
  - 每次找到一个合法的数对后，要跳过相同的元素，避免重复组合。
- **时间复杂度**：
  - 排序：`O(n log n)`。
  - 双指针扫描：`O(n)`。
  - 因此，总的时间复杂度是 `O(n log n)`，主要由排序步骤决定。
- **空间复杂度**：`O(k)`，其中 `k` 是满足条件的数对的数量。

### 经验总结

1. **双指针法是解决此类问题的经典解法**，通过排序数组可以有效地利用左右指针来避免重复并优化查找过程。
2. **去重的关键**：
   - 排序数组使得重复元素相邻，通过跳过重复元素来避免重复对。
3. **这种问题对于时间和空间的考量都较为重要**，通过 **排序 + 双指针** 的组合可以在合理的时间复杂度内解决。
4. **需要注意边界条件**：
   - 如果数组为空或者长度不足2，直接返回空结果。
   - 确保每次发现一个合法组合后，要跳过重复的元素。

## K-sum 问题

**输入**: 一个整数数组 `nums`，一个目标值 `target`，以及一个正整数 `k`。

**输出**: 一个列表，其中包含所有**不重复**的、由 `k` 个来自 `nums` 的整数组成的组合（List of Lists），这些整数的和恰好等于 `target`。

**核心要求**:

1. **数量约束**: 每个组合必须正好有 `k` 个整数。
2. **和值约束**: 这 `k` 个整数的和必须等于 `target`。
3. **唯一性约束**: 最终结果中不能包含重复的组合。例如，对于 `k=4`，`[1, 2, 3, 4]` 和 `[4, 3, 2, 1]` 是同一个组合。

###问题本质和分析 - 子集组合问题

 K-Sum 本质上是一个在集合中寻找满足特定约束（大小为k，和为target）的**子集组合问题**。它是组合数学在算法领域的一个典型应用。

**算法模型映射**：K-Sum问题本质上是一个多阶段的组合问题。它要求在数组中找到 `K` 个数，使得它们的和等于 `target`，这个过程可以通过递归和回溯法来逐步减少问题的维度，将一个 `K`-Sum 问题转化为更小的 `K-1`-Sum 问题。当 `K=2` 时，问题可以通过双指针法来高效解决（即2-Sum问题）。

###核心思想和套路 - 将问题分解为 Two - sum问题

解决 K-Sum 问题的通用核心套路可以总结为一句话： **排序 + 递归降维 + 双指针基石 (Sorting + Recursive Dimension Reduction + Two-Pointer Base Case)**

从一个 `K`-Sum问题开始，在每次递归中减少 `K`，直到最终变成一个2-Sum问题。每次递归时，选择一个数并将目标值 `target` 减去该数，然后递归解决剩余 `K-1` 个数的组合问题。

**K-Sum问题的递归映射**：

- 如果 `K = 2`，问题变成了经典的2-Sum问题，可以使用双指针法。
- 如果 `K > 2`，可以通过递归调用的方式，逐步减小 `K`，并在每一层递归中选取一个数，剩下的数继续处理。

#### 利用回溯将问题分解为Two-sum问题

##### 回溯算法的套路

```java
if(base condition){
  //process result;
  return;
}

for(each options){
  choose option;
  backtrack();
  unchoose option;
}
```

回溯法在每一层递归中选择一个数，并尝试寻找其他可能的数。当一个解不符合要求时，通过撤销选择（回溯）来探索其他可能的解。

#### 利用 双指针+排序计算Two-sum问题

**去重**：在递归和回溯过程中，必须确保同一组合不重复。可以通过在选择数时跳过重复元素来实现去重。

### 难点分析和应对

**去重问题**：由于数组中可能有重复元素，如何有效避免重复的组合是K-Sum问题中的一大难点。

在递归的每一层，需要判断当前数与前一个数是否相同，若相同则跳过，防止重复组合。

**递归深度**：递归的深度为 `K`，当 `K` 较大时，递归的调用次数也会增加，可能导致效率低下。因此，必须合理设计递归条件和剪枝策略。

**计算效率**：回溯法的时间复杂度通常较高，最坏情况下为 `O(n^K)`。为提高效率，常常结合排序和双指针法减少搜索空间。



### 实现原理和步骤

#### 排序

首先对输入数组进行排序，便于使用双指针法处理2-Sum问题，并确保在递归过程中避免重复组合。

#### 利用回溯做递归降维

从 `K` 开始递归，逐步递减为 `K-1`，直到最后转化为2-Sum问题。

```java
private void backtrack(int[] nums, int target, int k, int start, List<Integer> path){
  if(k == 2){
    twoSum(nums, target, start, current); 
    return;
  }
  
  for(int i = start; i < nums.length; i++){
    //去重
    if(i > start && nums[i] == nums[i-1]) continue;
    
    path.add(nums[i]);
    backtrack(nums,target-nums[i],k-1,i+1,path);
    path.remove(path.size()-1);
  }
}
```



#### 利用双指针计算 two-sum问题

当 `K = 2` 时，使用双指针法在数组中寻找两个数，满足它们的和为目标值。

```java
private void twoSum(int[] nums, int target, int start, List<Integer> combination){
  int left = start;
  int right = nums.length - 1;
  
  while(left < right){
    int sum = nums[left] + nums[right];
    if(sum == target){
      //组装结果，并加入结果集
      List<Integer> list = new ArrayList<>(combination);
      list.add(nums[left]);
      list.add(nums[right]);
      res.add(list);
      
      //跳过到最后一个重复元素的位置
      while(left < right && nums[left] == nums[left+1]) left++;
      while(left < right && nums[right] == nums[right - 1]) right--;
      
      //移动左右指针进入下一轮循环
      left++;
      right--;
    } else if(sum < target){
      left++;
    }else{
      right--;
    }
  }
}
```

### 实现代码

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int k = 4;
        List<Integer> path = new ArrayList<>();
        backtrack(nums, target, 0, k, path);
        return res;
    }

    private void backtrack(int[] nums, int target, int start, int k, List<Integer> path){
        if(k == 2){
            twoSum(nums, target, start, path);
            return;
        }

        for(int i = start; i < nums.length; i++){
           if ((long) target - nums[i] < Integer.MIN_VALUE || (long) target - nums[i] > Integer.MAX_VALUE) {
                continue; // 如果溢出，跳过当前数
            }
            //注意这个去重条件
            if(i > start && nums[i] == nums[i-1]) continue;
            //回溯过程
            path.add(nums[i]);
            backtrack(nums, target-nums[i], i+1, k-1, path);
            path.remove(path.size()-1);
        }
    }

    private void twoSum(int[] nums, int target, int start, List<Integer> combination){
        int left = start;
        int right = nums.length-1;

        while(left < right){
            int sum = nums[left] + nums[right];

            if (sum == target){
                List<Integer> list = new ArrayList<>(combination);
                list.add(nums[left]);
                list.add(nums[right]);
                res.add(list);

                while(left < right && nums[left] == nums[left+1]) left++;
                while(left < right && nums[right] == nums[right - 1]) right--;

                left++;
                right--;
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
    }
}
```

### 注意事项

**递归的终止条件**：递归时，必须有明确的递归终止条件。在 `K=2` 时，使用双指针法进行处理；当 `K=1` 时，剩下的唯一一个数就是解。

**避免重复解**：在每一层递归时，需要跳过重复的元素。特别是在递归的第一层，若当前数字和前一个数字相同，则跳过该数字。

**剪枝**：在递归过程中，某些情况下可以提前结束搜索。例如，当当前数字比目标值大时，就没有必要再继续递归。

### 经验总结

**回溯法是解决K-Sum问题的核心方法**：通过递归的方式逐步降低问题的维度，最终将问题转化为2-Sum问题。

**双指针法在K=2时的应用**：当 `K=2` 时，使用双指针法来高效地处理问题，这样可以大大减少时间复杂度。

**去重的关键**：为了避免重复组合，每次递归都要判断当前数字是否与前一个数字相同，若相同则跳过。

**剪枝优化**：通过提前结束不可能的分支，提高算法效率。

**递归与回溯的结合**：回溯法中的递归调用非常重要，它能帮助我们在解空间中遍历所有可能的组合。

### Leetcode 16 3Sum Closest 最接近的三数之和

#### 问题要点

- **输入**: 一个包含 n 个整数的数组 `nums` 和一个目标值 `target`。
- **输出**: 数组 `nums` 中三个整数的和，这个和需要**最接近（closest）**给定的目标值 `target`。
- **约束 (Constraints)**:
  - 数组 `nums` 的长度 `n` 介于 3 和 500 之间。
  - 每个元素 `nums[i]` 的值介于 -1000 和 1000 之间。
  - 目标值 `target` 的值介于 -104 和 104 之间。
  - **重要假设**: 每组输入都恰好只有一个解。这意味着我们不需要处理有多个同样接近的和的情况。

#### 问题本质和分析 

从本质上讲，这道题是 **“在一个集合中寻找满足特定条件的三个元素”** 的变种。

暴力的解法是使用三层循环，遍历所有可能的三数组合，计算它们的和并与 `target` 比较，记录下差值最小的和。

这种方法的时间复杂度是 $O(n^3)$，考虑到 `n` 的最大值为 500， $500^3$ 的计算量是相当大的，很可能会超时（Time Limit Exceeded）。

因此，我们需要寻找更高效的算法。

这类 "K-Sum"（K数之和）问题通常可以通过 **降低问题的维度** 来解决。

对于本题（3Sum），我们可以**先固定一个数**，然后问题就转化为**在剩余的数中寻找两个数**，使它们的和与一个**新目标值**最接近。

这个 "2-Sum Closest" 的子问题，就可以通过更高效的方法来解决。

#### 模式匹配 (Pattern Matching)

这道题与 LeetCode 第 15 题 "3Sum"（三数之和）非常相似。两道题都要求从数组中找出三个数。不同之处在于：

- **3Sum**: 寻找所有和为 0 的不重复三元组。
- **3Sum Closest**: 寻找一个三元组，使其和最接近 `target`，并返回这个和。

这种相似性提示我们，可以借鉴 "3Sum" 问题的解题模式。解决 "3Sum" 的经典方法是 **“排序 + 双指针” (Sorting + Two Pointers)**。这个模式同样完美适用于 "3Sum Closest"。

>  当你遇到需要在数组中寻找满足特定和（或接近特定和）的多个元素（通常是两个或三个）时，首先应该想到的就是**排序**，然后利用 **双指针** 技巧。

#### 核心思想和套路

##### 对数组进行升序排序

首先对输入的数组 `nums` 进行升序排序。排序是使用双指针方法的前提。排序的好处在于：

- **有序性**: 我们可以根据当前和与 `target` 的大小关系，有方向地移动指针来调整和的大小。

- **避免重复**: 虽然本题保证唯一解，但在其他类似问题中，排序有助于跳过重复元素。

##### **降维与双指针 (Dimensionality Reduction & Two Pointers)**

- 遍历排序后的数组，用一个 `for` 循环来固定第一个数 `nums[i]`。

- 对于固定的 `nums[i]`，问题就变成了在数组 `nums` 的 `i+1` 到 `n-1` 这个子数组中，寻找两个数：使得 `nums[i]` + `nums[left]` + `nums[right]` 最接近 `target`。

  这等价于寻找 `nums[left]` + `nums[right]` 最接近 `target - nums[i]`。

- 我们使用两个指针，`left` 指向 `i+1`，`right` 指向数组末尾 `n-1`。

- 在 `left < right` 的条件下，计算当前三个数的和 `sum = nums[i] + nums[left] + nums[right]`。

- **更新最接近的和**: 假设当前的和为`sum`, 当前最接近`target`的和为`closestSum`:

  比较 `|sum - target|` 和 `|closestSum - target|` 的大小。

  如果当前的差值更小，就更新 `closestSum` 为 `sum`。

- **移动指针**:

  - 如果 `sum < target`，说明和太小了，需要增大。由于数组是排序的，我们应该将 `left` 指针右移 (`left++`)，以选择一个更大的数。
  - 如果 `sum > target`，说明和太大了，需要减小。我们应该将 `right` 指针左移 (`right--`)，以选择一个更小的数。
  - 如果 `sum == target`，那么这就是最接近的和（差值为0），直接返回 `target`。

#### 实现原理和步骤

#####**初始化** - 对数组进行升序排序:

- 对数组 `nums` 进行排序。
- 初始化一个变量 `closestSum` 用于存储最接近的和。可以将其初始化为数组前三个元素的和，这是一个合理的初始值。

##### 主要循环过程 - 遍历每一个 $i = [0...n-3)$

遍历数组，`for i from 0 to n-3` (**因为我们需要至少三个数**)。

##### 双指针遍历剩余两个元素

- 在主循环内，初始化左指针 `left = i + 1` 和右指针 `right = n - 1`。

- 进入 `while (left < right)` 循环。

- 计算当前和 `currentSum = nums[i] + nums[left] + nums[right]`。

- 判断 `|currentSum - target|` 是否小于 `|closestSum - target|`。如果是，则更新 `closestSum = currentSum`。

- 根据 `currentSum` 与 `target` 的比较结果移动指针：

  - 如果 `currentSum < target`，`left++`。

  - 如果 `currentSum > target`，`right--`。

  - 如果 `currentSum == target`，直接返回 `currentSum`。

##### 返回结果

主循环结束后，`closestSum` 中存储的就是最接近 `target` 的和，返回该值。

#### 实现代码

```java
    public int threeSumClosest(int[] nums, int target) {
        int closestSum = nums[0] + nums[1] + nums[2];
        int n = nums.length;
        Arrays.sort(nums);

        for(int i = 0; i  < n - 2; i++ ){
            int left = i+1;
            int right = n - 1;
            while (left < right) {
                int currSum = nums[i] + nums[left] + nums[right];
                int currDiff = Math.abs(target - currSum);
                int prevDiff = Math.abs(target - closestSum);
                if(currDiff < prevDiff) closestSum = currSum; 

                if(currSum < target){
                    left++;
                }else if (currSum > target){
                    right--;
                }else{
                    return currSum;
                }
            }
        }
        return closestSum;
    }
```

#### 注意事项

- **排序的必要性**: 双指针法的核心依赖于数组的有序性，所以第一步必须是排序。
- **循环边界**: 主循环的边界是 `nums.length - 2`，因为需要为 `left` 和 `right` 指针留出至少两个元素。
- **`Math.abs()` 的使用**: 在比较哪个和更接近时，需要比较差值的绝对值。
- **初始化 `closestSum`**: 选择一个好的初始值可以简化代码。例如，使用前三个元素的和。避免使用 `Integer.MAX_VALUE`，因为这可能导致在计算差值时发生整数溢出，虽然在本题的约束下问题不大，但不是一个好习惯。
- **时间与空间复杂度**:
  - **时间复杂度**: $O(n^2)$。其中，排序的时间复杂度是 $O(nlogn)$，双指针部分是 $O(n^2)$（外层循环 `n` 次，内层双指针最多 `n` 次）。总体由更高阶的 $O(n^2)$ 决定。
  - **空间复杂度**: $O(log^n)$ 或 $O(n)$。这取决于 Java `Arrays.sort()` 的实现。对于基本类型数组，它使用的是快速排序的变种，其空间复杂度平均为 $O(logn)$，最坏情况下为 $O(n)$。如果我们不考虑排序所需的空间，那么算法本身的空间复杂度是 O(1)。

#### 经验总结

- **识别 K-Sum 模式**: 对于在数组中寻找 K 个元素之和等于或接近某个目标值的问题，"排序 + 双指针" 是一个非常强大且通用的模式。

- **从暴力解法思考优化**: 当遇到一个问题时，先思考最直接的暴力解法。然后分析其瓶颈（通常是时间复杂度），再考虑如何利用数据结构的特性（如排序后的有序性）来优化算法。

- **双指针的威力**: 双指针是一种简单而高效的技巧，常用于处理有序数组中的区间、配对等问题。它通过两个指针的协同移动，以线性的时间复杂度扫描数组，从而替代了嵌套循环。

- **举一反三**: 掌握了 "3Sum Closest" 的解法，可以轻松应对 "3Sum"、"4Sum" 以及 "2-Sum" 系列的各类变种问题。核心思想都是降维，最终转化为 "2-Sum" 问题来解决。

## 排列组合类问题

### 使用回溯列举排列或者组合

### 计算当前排列的下一个排列 - Leetcode 31

#### 问题要点

**输入**: 一个整数数组 `nums`。

**输出**: `nums` 的下一个字典序更大的排列。

**原地修改**: 必须在原数组上进行修改，**不能分配额外的数组空间**（除了常数级别的额外空间）。

**特殊情况**: 如果数组已经是最大的排列（即降序排列），则需要将其重新排列为最小的排列（即升序排列）。

#### 实例

- `[1, 2, 3]` → `[1, 3, 2]`
- `[3, 2, 1]` → `[1, 2, 3]`
- `[1, 1, 5]` → `[1, 5, 1]`
- `[1, 5, 8, 4, 7, 6, 5, 3, 1]` -> `[1, 5, 8, 5, 1, 3, 4, 6, 7]`

#### 问题的本质和分析

#####问题的本质 - 降序排列是最大的数字

这个问题的本质是寻找给定数字序列在所有可能的全排列中的“下一个”序列，这里的“下一个”是按照**字典序 (Lexicographical Order)** 来定义的。

想象一下查字典的过程：`apple` 的下一个是 `apply`。我们希望做出**尽可能小的改变**，来得到一个比当前“单词”更大的“单词”。

为了让改变尽可能小，我们应该从**右向左**看。

以 `[1, 5, 8, 4, 7, 6, 5, 3, 1]` 为例：

- 我们希望找到一个比它大的数。

- 如果只改变最右边的 `1`，无法变得更大。

- 如果只改变 `3, 1`，`[1, 3]`已经是最大排列，无法变得更大。

- 同样，`[5, 3, 1]`, `[6, 5, 3, 1]`, `[7, 6, 5, 3, 1]` 它们各自都已经是**降序排列**，是其元素能组成的**最大排列**。

- 当我们看到 `4` 时，情况发生了变化。后缀 `[7, 6, 5, 3, 1]` 是降序的，但 `4` 小于 `7`。

  这意味着，我们可以通过改变 `4` 以及它右边的数字，来得到一个更大的排列。

##### 问题分析 - 通过交换获得一个更大的数字

###### **如何得到一个更大的数？** 

我们需要将一个“小数”和一个“大数”交换。

###### 如何让增幅近可能的小？

选择最靠右的那个“小数”来进行交换。

**找到最右侧的较小数**

这个“小数”的特征是，它**右边的数字序列是降序**的。

例如，在 `...4, 7, 6, 5...` 中，`4` 就是我们要找的那个“小数”。

**交换过程**

将这个“小数”与它右边序列中，**比它大的数中“最小”的那个“大数”进行交换**。

- 数字应当比当前数字大
- 应该是最小的比当前数字大的数

在 `4` 右边的 `[7, 6, 5, 3, 1]` 中，比 `4` 大的数有 `7, 6, 5`，其中最小的是 `5`。

###### 交换后如何保证是“下一个”排列？

- 当我们把 `4` 和 `5` 交换后，序列变为 `[1, 5, 8, 5, 7, 6, 4, 3, 1]`。
- 此时，前缀 `[1, 5, 8, 5]` 已经确定了。为了得到字典序中紧邻的下一个排列，我们需要让后缀 `[7, 6, 4, 3, 1]` 尽可能小。
- 如何让一个序列最小？将其变为升序排列。
- 一个重要的观察是：在我们找到“小数” `4` 之前，它右边的序列 `[7, 6, 5, 3, 1]` 本身就是**降序**的。当我们用 `5` 替换了 `4`，并将 `4` 放入后缀后，新的后缀 `[7, 6, 4, 3, 1]` 仍然是**降序**的。
- 将一个降序的序列变为升序，只需要将其**翻转 (Reverse)** 即可。

#### 模式匹配 - 没什么鸟模式可以匹配

这一类观察类的题目是挺讨厌的，临场发挥能观察到这种规律是很难的

这个问题属于**数组操作**和**构造性算法 (Constructive Algorithm)**。

它不遵循典型的 DP、BFS、DFS 等模式，而是基于对字典序排列规律的观察和逻辑推导。

其核心模式是：**从右向左寻找第一个破坏降序的拐点，然后与右侧序列中合适的元素交换，最后将右侧序列整理成最小的排列。**

这个模式在处理与排列、组合相关的“下一个”或“上一个”问题时非常有用，例如 LeetCode 60. Permutation Sequence。

#### 核心思想和套路

##### **找拐点 (Find Pivot)** -找到第一个破坏递减的元素

从右向左遍历数组，找到第一个 `nums[i] < nums[i+1]` 的元素。这个 `nums[i]` 就是我们要操作的“小数”，我们称之为 `pivot`。`i` 就是它的索引。如果找不到这样的 `i`（即整个数组是降序的），说明这已是最大排列。

#####**找交换点并交换 (Find Swap Target and Swap)**

再次从右向左遍历数组（从末尾到 `i+1`），找到第一个 `nums[j] > nums[i]` 的元素。

这个 `nums[j]` 就是我们要用来和 `pivot` 交换的“大数”。

找到后，交换 `nums[i]` 和 `nums[j]`。

##### **翻转后缀 (Reverse Suffix)** - 为啥？

将索引 `i+1` 到数组末尾的这部分子数组进行翻转。

这能保证交换后的后缀是最小的排列。

#### 实现原理和步骤

我们用 `nums = [1, 5, 8, 4, 7, 6, 5, 3, 1]` 来完整走一遍流程。

**数组**: `[1, 5, 8, 4, 7, 6, 5, 3, 1]` **长度 n**: 9

**步骤 1: 找拐点 `i`**

- 从 `i = n-2 = 7` 开始向前找。
- `i=7`: `nums[7]=3`, `nums[8]=1`。`3 > 1`，不满足 `nums[i] < nums[i+1]`。继续。
- `i=6`: `nums[6]=5`, `nums[7]=3`。`5 > 3`，不满足。继续。
- `i=5`: `nums[5]=6`, `nums[6]=5`。`6 > 5`，不满足。继续。
- `i=4`: `nums[4]=7`, `nums[5]=6`。`7 > 6`，不满足。继续。
- `i=3`: `nums[3]=4`, `nums[4]=7`。`4 < 7`，满足条件！
- 我们找到了**拐点 `i = 3`**，对应的值是 `4`。

**步骤 2: 找交换点 `j` 并交换**

- 从 `j = n-1 = 8` 开始向前找，直到 `i+1`。
- `j=8`: `nums[8]=1`。`1 > nums[i]=4` 不成立。继续。
- `j=7`: `nums[7]=3`。`3 > 4` 不成立。继续。
- `j=6`: `nums[6]=5`。`5 > 4` 成立！
- 我们找到了**交换点 `j = 6`**，对应的值是 `5`。
- **交换** `nums[i]` 和 `nums[j]` (即 `nums[3]` 和 `nums[6]`)。
- 交换前: `[1, 5, 8, **4**, 7, 6, **5**, 3, 1]`
- 交换后: `[1, 5, 8, **5**, 7, 6, **4**, 3, 1]`

**步骤 3: 翻转后缀**

- 翻转从索引 `i+1 = 4` 到结尾的子数组。
- 需要翻转的子数组是 `[7, 6, 4, 3, 1]`。
- 翻转后变为 `[1, 3, 4, 6, 7]`。
- 将这部分放回原数组，得到最终结果:
- `[1, 5, 8, 5, 1, 3, 4, 6, 7]`

**特殊情况处理**: 如果 `nums = [3, 2, 1]`，在步骤1中，`i` 会一直递减到 `-1` 都找不到拐点。这时，我们直接进入步骤3（可以认为 `i=-1`），翻转整个数组（从 `i+1=0` 到结尾），得到 `[1, 2, 3]`。

#### 代码实现

```java
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length <= 1){
            return;
        }
        //寻找拐点元素
        //nums[i] < nums[i+1]
        int n = nums.length;
        int i = n-2;
        
        while(i >= 0 && nums[i] >= nums[i+1]){
            i--;
        }
        // 如果找到了这样的 i (即 i 不是 -1)
        if(i >= 0){
            int j = n - 1;
            while(j > i && nums[j] <= nums[i]){
                j--;
            }
            swap(nums, i, j);
        }
        // 步骤 3: 翻转从 i+1 到末尾的子数组
        // 如果 i 是 -1 (整个数组降序)，这将翻转整个数组
        reverse(nums, i+1, n-1);
    }

    private void swap(int[] nums, int i , int j ){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    private void reverse(int[] nums, int start, int end){
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }
```

#### 注意事项

**边界条件**: `i` 的循环条件是 `i >= 0`，`j` 的循环条件是 `j > i`。这些边界要非常小心，避免数组越界。

**原地操作**: `swap` 和 `reverse` 辅助函数都是原地操作，满足题目要求。

**处理降序数组**: 算法能自然地处理完全降序的数组。此时，`while` 循环结束后 `i` 会是 `-1`。`if (i >= 0)` 条件不满足，直接执行 `reverse(nums, 0, n - 1)`，将整个数组翻转，得到正确结果。

**重复数字**: 这个算法对含有重复数字的数组同样有效。因为比较用的是 `>=` 和 `<=`，这保证了我们找到的是正确的“拐点”和“交换点”，不会因为重复数字而出错。

#### 经验总结

1. **直观理解是关键**: 不要死记硬背代码。理解“从右边开始，做最小的改动以形成一个更大的数”这个核心思想，算法步骤就会自然而然地推导出来。
2. **化繁为简**: 这个问题可以分解为三个清晰的子问题：找拐点、找交换点、翻转后缀。将复杂问题分解是解决算法题的有效策略。
3. **辅助函数**: 将 `swap` 和 `reverse` 提取为辅助函数，能让主逻辑 `nextPermutation` 更加清晰、易读，也更容易调试。
4. **举例推演**: 对于这类构造性算法，拿一个稍微复杂一点的例子（比如 `[1, 5, 8, 4, 7, 6, 5, 3, 1]`）在纸上完整地走一遍流程，是检验自己思路是否正确的最佳方法。同时也要考虑 `[3, 2, 1]` 和 `[1, 2, 3]` 这样的边缘情况。
5. **代码的健壮性**: 代码中的 `while` 循环条件 (`>=`, `<=`) 的选择非常精妙，确保了即使有重复元素也能正确工作。这是高质量代码的体现。