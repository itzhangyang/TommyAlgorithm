## 数组某段区间和为目标值 - 前缀和

###场景

- 给定数组，查找某段区间和为目标值的子数组
- 求某类前缀和差值匹配问题

###目标

- 统计子数组数量
- 找到总和最长/最短满足条件的子数组

###应对套路 - 前缀和 + 哈希表

通过`preSum[j] - preSum[i] == k`转化为**差值为K**的前缀和问题，利用**哈希表**存储前缀和的历史信息来加速查找。

###什么是前缀子数组？

从数组开始都某个位置的一段子数组，被称为该位置的**前缀子数组**。

比如：`arr[0...i-1]`

### 为什么使用前缀和数组？

一个连续子数组 `nums[i..j]` 的和等于 `prefixSum[j] - prefixSum[i-1]`。

我们要求这个和等于 `k`，即 `prefixSum[j] - prefixSum[i-1] = k`。

变形后得到 `prefixSum[i-1] = prefixSum[j] - k`。 

因此，当遍历到 `j` 并计算出当前的前缀和 `currentSum` (即 `prefixSum[j]`) 时，我们只需要查找**在 `j` 之前，有多少个前缀和等于 `currentSum - k` **即可。

哈希表可以 O(1) 完成这个查找。

###原理和步骤

1. 初始化一个哈希表`map`用于存放前缀和`{前缀和 ： 出现次数}`
2. 关键一步：在 `map` 中放入 `map.put(0, 1)`。这用于处理那些从数组开头就满足条件的子数组。
3. 初始化 `currentSum = 0` 和结果 `count = 0`。
4. 遍历数组，对每个元素：
   - a.  更新 `currentSum`。 
   - b.  计算需要的“互补前缀和” `complement = currentSum - k`。 
   - c.  在 `map` 中查找 `complement` 的出现次数，并累加到 `count` 上。 
   - d.  将当前的 `currentSum` 存入 `map`，更新其出现次数。

###模板代码 - 求和为K的子数组数量

```java
public int subarraySum(int[] nums, int k){
  //初始化前缀和数组
  //前缀和 - 前缀和出现的次数
  Map<Integer,Integer> map = new HashMap<>();
  //前缀和为0的情况出现1次，空数组
  map.put(0,1);
  
  int sum = 0 ; count = 0;
  for (int num : nums){
    sum += num;
    // 找到前缀和为sum - k的前缀子数组的数量
    count += map.getOrDefault(sum - k,0);
    map.put (sum, map.getOrDefault(sum,0)+1);
  }
  
  return count;
}
```

###注意事项

- 初始化哈希表时需要放入`map.put(0,1)`，避免漏掉为0的情况
- 不能使用前缀和数组对所有子数组进行暴力枚举，会超时

###难点分析

- 可能会难以理解为什么使用**前缀和差值**来统计
- 边界处理（从0开始的子数组）

###经验总结

- 适合计数类子数组的问题

- 注意不能处理乘积等非线形问题

###Leetcode 325: **Maximum Size Subarray Sum Equals k**.

Given an integer array `nums` and an integer `k`, you need to find the maximum length of a contiguous subarray where the sum of its elements equals `K`.

####Approach

The algorithm leaves a **prefix sum** strategy combined with a **hash map** to efficiently find the longest subarray with a sum equal to `k`.

The general idea is to track the running sum of elements and store the **first occurrence** of each sum in a hash map.

By checking if the current sum minus `k` has appeared earlier, we can determine the length of the subarray with sum `k`.

This approach utilizes a single pass through the array and is efficient in both time and space.

####Step-by-step Explanation

#####Initialize Variables

- `map`: A hash map to store the **First Occurrence** of each prefix sum
- `sum`: A running total of the prefix sum as we iterate through the array
- `maxLength`: A variable to track the maximum length of the subarray found so far

#####Iterate through the Array

For each element in the array:

1. Add the current element to the running `sum`.
2. Check if the `sum - k` has been seen in the map. If so, it means there exists a subarray (ending at the current index) that has a sum of `k`.
3. If `sum` has not been seen before, store its first occurrence in the map (only if it’s not already present).

#####Return the result

Once the iteration is complete, the variable `maxLength` will contain the length of the longest subarray that sums to `k`.

####Code Breakdown

```java
public int maxSubArrayLen(int[] nums, int k) {
    // Hash map to store the first occurrence of each prefix sum
    Map<Integer, Integer> map = new HashMap<>();
    // Initialize with sum 0 at index -1 to handle edge case where the sum is exactly k at some point
    map.put(0, -1);

    int sum = 0;  // Running sum of the array elements
    int maxLength = 0;  // Variable to store the maximum length of the subarray

    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];  // Update the running sum

        // If sum - k is in the map, it means there is a subarray ending at index i with sum k
        if (map.containsKey(sum - k)) {
            int lastIndex = map.get(sum - k);  // Get the first index where sum - k occurred
            int length = i - lastIndex;  // Calculate the length of the subarray
            maxLength = Math.max(maxLength, length);  // Update maxLength
        }

        // Only put sum in the map if it hasn't been seen before to ensure the earliest index is recorded
        if (!map.containsKey(sum)) {
            map.put(sum, i);
        }
    }

    return maxLength;  // Return the result
}
```

#####Code Analysis

- **Edge Case Handling**:
  - The base case `map.put(0, -1)` handles the scenario where a subarray starting from index `0` directly sums to `k`. This ensures we can find such subarrays that don't need to rely on earlier indices.
- **Main Logic**:
  - The sum is updated at each step, and the algorithm checks if the difference `sum - k` has appeared in the map. This allows us to find subarrays whose sum is equal to `k`. The hash map only stores the first occurrence of each sum to maximize the subarray length.
- **Optimization Considerations**:
  - This approach uses a **hash map** to store the prefix sum, enabling constant-time lookups for previously seen sums.
  - We only process the array once, ensuring a time complexity of **O(n)**, where `n` is the length of the array.

####Efficiency

**Time Complexity**:

- The time complexity is **O(n)** because we iterate through the array once, and for each element, we perform constant-time operations like adding to the sum, checking the hash map, and updating the map.

**Space Complexity**:

- The space complexity is **O(n)** due to the hash map that stores at most `n` unique sums.

####Consideration & Edge Cases

- **Empty Array**: If the input array is empty or null, the result will be `0` since no subarray exists
- **All Negative Numbers**: The algorithm will handle cases where all numbers are negative and `k` might be negative.
- **Subarray Length**: The map only stores the **first occurrence** of each prefix sum to ensure we find the **longest subarray**.
- **Duplicates**: The solution efficiently handles cases with duplicate values by only considering the **first occurrence** of each sum, ensuring the longest valid subarray is found.

### 判断子数组和和是否为K的倍数