## 查找缺失的元素

### Leetcode 163: Missing Ranges 完整解析

#### 问题要点

給定一個**已排序**的**唯一**整數陣列 `nums`，所有元素都在閉區間 `[lower, upper]` 內。

你需要找出所有在該區間內但**不在** `nums` 陣列中的缺失數字，並以一個代表「範圍」的列表形式返回。

**返回格式要求:**

- 一個缺失的範圍 `[start, end]` 應被表示為一個包含兩個整數的列表 `[start, end]`。
- 最終結果是所有這些「範圍列表」組成的列表。

**示例:**

- **輸入:** `nums = [0, 1, 3, 50, 75]`, `lower = 0`, `upper = 99`
- **輸出:** `[[2,2], [4,49], [51,74], [76,99]]`
  - `[2,2]` 代表數字 `2` 缺失。
  - `[4,49]` 代表從 `4` 到 `49` 的所有數字都缺失。

**約束條件 (Constraints):**

- `lower` 和 `upper` 的範圍可以很大（例如，在 `int` 的邊界附近）。
- `nums` 的長度相對較小（例如，0 到 100）。
- `nums` 中的元素都在 `[lower, upper]` 範圍內。

#### 问题本质和分析 - 不要暴力遍历每一个数字

此問題的本質是在一個由 `[lower, upper]` 定義的連續整數集合中，尋找 `nums` 陣列這個子集之外的補集。

關鍵的洞察點在於 **`nums` 是已排序的**。

這個特性意味著我們**不需要檢查 `lower` 到 `upper` 之間的每一個數字**。

相反，我們可以把 `nums` 中的數字看作是數軸上的一系列「標記點」。

我們的任務就是找出這些標記點之間，以及邊界與標記點之間的「空白間隙」。

高效的分析思路是**一次線性掃描**。

我們只需要維護一個指標，代表「下一個我們期望出現的數字」，然後遍歷 `nums` 陣列，通過比較期望值與實際值來識別這些間隙。

#### 考察点

#####演算法選擇 (Algorithm Choice):

能否意識到利用**排序特性**進行 O(N) 的間隙掃描，而不是 O(M) 的暴力遍歷（其中 N 是 `nums` 的長度，M 是 `upper - lower` 的範圍大小）。

##### 整數溢位 (Integer Overflow)

這是本題最大的陷阱。

`lower`、`upper` 和 `nums` 中的元素可能接近 `Integer.MAX_VALUE`。

在計算下一個期望值時（例如 `num + 1`），如果 `num` 是 `Integer.MAX_VALUE`，直接加一會導致溢位變成負數，引發嚴重錯誤。

這是對程式碼健壯性的核心考察。

##### 邊界情況處理 (Edge Case Handling)

- `nums` 陣列為空：整個 `[lower, upper]` 都是缺失範圍。

- 開頭缺失：`nums[0]` 大於 `lower`。

- 結尾缺失：`nums` 的最後一個元素小於 `upper`。

- `nums` 陣列恰好覆蓋了整個範圍。

#### 模式匹配 - 间隙查找

此問題屬於 **「有序陣列的間隙查找」(Gap Finding in Sorted Array)** 模式。它要求我們在一個有序序列中識別出未被佔用的部分。

#### 核心思想和套路 - 下一个期望值

維護一個「下一期望值」（`next`）。這個 `next` 指標隨著我們對 `nums` 的掃描而向前移動。

- `next` 初始化為 `lower`。

- 遍歷 `nums` 中的每個數字 `num`。

- 如果 `num > next`，說明從 `next` 到 `num - 1` 的所有數字都是缺失的。

  我們就找到了一個缺失範圍 `[next, num - 1]`。

- 處理完 `num` 後，下一個期望值就變成了 `num + 1`。

  我們將 `next` 更新為 `num + 1`（注意溢位問題）。

- 遍歷完所有 `nums` 元素後，如果 `next` 仍然小於或等於 `upper`，說明從 `next` 到 `upper` 是最後一段缺失的範圍。

**套路 (Routine):** 將上述思想轉化為程式碼的標準套路是定義一個 `long` 型別的 `next` 變數來貫穿始終，用它統一處理開頭、中間和結尾的所有情況。

#### 实现原理和步骤

**初始化結果列表**: `List<List<Integer>> result = new ArrayList<>();`

**定義防溢位指標**: 定義一個 `long` 型別的變數 `next`，並初始化為 `(long) lower`。使用 `long` 是為了在後續 `+1` 操作中絕對安全。

**遍歷 `nums` 陣列**:

- 對於 `nums` 中的每一個數字 `num`：
- **比較與查找間隙**: 檢查 `(long)num > next` 是否成立。
  - 如果成立，說明找到了缺失範圍 `[next, num - 1]`。調用一個輔助函數，將這個範圍 `[next, num - 1]` 加入 `result` 列表中。
- **更新指標**: 無論是否找到間隙，在檢查完 `num` 之後，都需要將 `next` 更新為 `(long)num + 1`，為檢查下一個間隙做準備。

**處理結尾的間隙**:

- 當 `nums` 遍歷結束後，`next` 代表了從 `nums` 最後一個元素之後開始的期望值。
- 檢查 `next <= (long)upper` 是否成立。
  - 如果成立，說明最後還有一段缺失範圍 `[next, upper]`。將其加入 `result` 列表。

**實現輔助函數 `addRange`**:

- 該函數接收 `result` 列表和 `long` 型別的範圍起點 `start` 和終點 `end`。
- 在函數內，創建一個新的 `ArrayList<Integer>`。
- 將 `start` 和 `end` 從 `long` 安全地轉型回 `int`，並加入這個新的 `ArrayList`。
- 將這個新的列表加入最終的 `result` 列表中。

**返回結果**: 返回 `result`。

#### 实现代码

```java
import java.util.ArrayList;
import java.util.List;

class Solution {

    /**
     * 找到在 [lower, upper] 範圍內，但不在 nums 陣列中的缺失區間。
     * 輸出格式為 List<List<Integer>>，例如 [[2,2], [4,49]]。
     *
     * @param nums  已排序的唯一整數陣列
     * @param lower 範圍下界
     * @param upper 範圍上界
     * @return 缺失區間的列表
     */
    public List<List<Integer>> findMissingRanges(int[] nums, int lower, int upper) {
        List<List<Integer>> result = new ArrayList<>();
        // 使用 long 來防止 'num + 1' 時的整數溢位，這是處理邊界情況的關鍵
        long next = (long) lower;

        // 遍歷 nums 陣列，尋找內部的間隙
        for (int num : nums) {
            // 如果當前數字大於期望值，說明 [next, num - 1] 是缺失的
            if ((long) num > next) {
                addRange(result, next, (long) num - 1);
            }
            
            // 優化：如果 num 已經是 upper，後續不可能再有缺失，可以提前結束
            if (num == upper) {
                return result;
            }

            // 更新下一個期望值
            next = (long) num + 1;
        }

        // 處理遍歷完 nums 後，到 upper 的最後一段間隙
        if (next <= (long) upper) {
            addRange(result, next, (long) upper);
        }

        return result;
    }

    /**
     * 輔助函數，將一個缺失的範圍 [start, end] 加入結果列表。
     * 格式為一個包含兩個整數的 List。
     *
     * @param result 結果列表
     * @param start  缺失範圍的起始值 (long)
     * @param end    缺失範圍的結束值 (long)
     */
    private void addRange(List<List<Integer>> result, long start, long end) {
        List<Integer> range = new ArrayList<>();
        // 由於題目限制 lower/upper/nums 都在 int 範圍內，
        // 這裡的 start/end 可以安全地轉回 int
        range.add((int) start);
        range.add((int) end);
        result.add(range);
    }
}
```

#### 注意事项

- **`long` 的使用是強制性的**：這是本題**最核心**的細節。任何時候當你對可能接近 `Integer.MAX_VALUE` 的整數做加法時，都必須考慮使用 `long` 來進行計算，否則程式碼在極端測試案例下會失敗。
- **演算法效率**：此解法的時間複雜度是 O(N)，其中 N 是 `nums` 的長度。空間複雜度是 O(K)，其中 K 是缺失範圍的數量，用於儲存結果。這遠比遍歷整個 `[lower, upper]` 範圍的 O(M) 解法要高效得多。
- **轉型安全**：在 `addRange` 函數中將 `long` 轉回 `int` 是安全的，因為我們知道這些範圍的邊界 `start` 和 `end` 最終都源於 `int` 型別的輸入 `lower` 和 `upper`，`long` 只是為了計算過程的安全。

#### 经验总结

這道題目是一個絕佳的範例，它告訴我們：

1. **仔細閱讀題目要求**：確認輸入輸出的確切格式是解題的第一步，避免像我們最初那樣產生誤解。
2. **充分利用輸入條件**：「已排序」是這道題最高效解法的鑰匙。忽略這個條件會導致走向複雜或低效的解法。
3. **永遠警惕邊界和陷阱**：在處理數字和範圍時，永遠要將「整數溢位」和「邊界情況」（空集合、單元素、頭尾等）放在心上。養成使用更安全的資料類型（如 `long`）進行中間計算的習慣，是專業程式師的標誌。

