# 什么事前缀/后缀最值数组

## 前缀最值数组 - 前i个元素中的最值

```Java
int[] prefixMax = new int[n];
prefixMax[0] = nums[0];
for(int i = 1; i < n; i++){
  if(nums[i] > prefixMax[i-1]){
    prefixMax[i] = nums[i];
  }else{
    prefixMax[i] = prefixMax[i-1];
  }
}
```



## 后缀最值数组 - 后i个元素中的最值

```Java
int[] suffixMax = new int[n];
suffixMax[n-1] = nums[n-1];
for(int i = n-2; i >= 0; i--){
  if(nums[i] > suffixMax[i+1] ){
    suffixMax[i] = nums[i];
  }else{
    suffixMax[i] = suffixMax[i+1];
  }
}
```

## Leetcode 2874: Maximum Value of an Ordered Triplet II

### 问题要点

**输入**: 一个 0-indexed 的整数数组 `nums`。

**目标**: 找到所有满足 `i < j < k` 条件的有序三元组 `(i, j, k)`。

**计算**: 对于每个三元组，计算表达式 `(nums[i] - nums[j]) * nums[k]` 的值。

**输出**: 返回所有计算结果中的最大值。

**特殊规则**: 如果所有可能的三元组计算出的值都是负数，则返回 0。

这意味着我们只关心非负的结果。

### 问题的本质和分析

#### 问题本质

问题的本质是在一个有序的、有三个变量的约束条件 (`i < j < k`) 下，寻找一个表达式 `(nums[i] - nums[j]) * nums[k]` 的最大值。

#### 直观的解法 - 暴力法

最直观的想法是遍历所有可能的三元组 `(i, j, k)`。

```Java
// 伪代码
max_val = 0
for i from 0 to n-3:
  for j from i+1 to n-2:
    for k from j+1 to n-1:
      current_val = (nums[i] - nums[j]) * nums[k]
      if current_val > max_val:
        max_val = current_val
return max_val
```

这种方法的时间复杂度是 $O(n^3)$。根据 LeetCode 的通常数据范围（`n` 可能达到 105），$O(n^3)$ 甚至 $O(n^2)$ 的算法都会超时（Time Limit Exceeded, TLE）。因此，我们必须寻找更高效的解法。

#### 优化思路

表达式为 `(nums[i] - nums[j]) * nums[k]`。为了使其最大化，我们需要分析这个表达式的结构。

- `nums[k]` 应该尽可能大。
- `(nums[i] - nums[j])` 这一项也应该尽可能大。
- 由于最终结果不能是负数（否则取0），所以 `(nums[i] - nums[j])` 和 `nums[k]` 必须同号。但题目要求返回非负最大值，所以我们只需要考虑结果为正的情况，即 `nums[i] > nums[j]`。

一个常见的优化技巧是**“固定中间，看两边”**。我们尝试固定中间的索引 `j`，然后去寻找最优的 `i` 和 `k`。

当我们固定了 `j` 时，我们的目标就变成了：

1. 在 `j` 的左边（即 `i < j`）找到一个 `nums[i]`，使得 `nums[i]` 最大。
2. 在 `j` 的右边（即 `k > j`）找到一个 `nums[k]`，使得 `nums[k]` 最大。

为什么是这样？因为要让 `(nums[i] - nums[j]) * nums[k]` 最大，并且 `nums[i] - nums[j]` 要大于0，那么：

- `nums[k]` 必须是 `j` 右侧所有数中的最大值。
- `nums[i]` 必须是 `j` 左侧所有数中的最大值，这样 `nums[i] - nums[j]` 的差值才可能最大。

这样，对于每一个 `j`，我们都可以计算一个潜在的最大值： `candidate_max = (max(nums[0...j-1]) - nums[j]) * max(nums[j+1...n-1])`

如果我们能快速地得到 `max(nums[0...j-1])` (前缀最大值) 和 `max(nums[j+1...n-1])` (后缀最大值)，问题就解决了。

###背景知识

####前缀和/最大/最小值

创建一个数组 `prefixMax`，其中 `prefixMax[i]` 存储了原数组从 `0` 到 `i` 这个区间的最大值。这可以通过一次从左到右的遍历完成。

- 递推公式: `prefixMax[i] = max(prefixMax[i-1], nums[i])`

####后缀和/最大/最小值

创建一个数组 `suffixMax`，其中 `suffixMax[i]` 存储了原数组从 `i` 到 `n-1` 这个区间的最大值。这可以通过一次从右到左的遍历完成。

- 递推公式: `suffixMax[i] = max(suffixMax[i+1], nums[i])`

通过花费 $O(n)$ 的时间进行预处理，我们就可以在 O(1) 的时间内查询任何前缀或后缀的最大值，这是一种典型的**“空间换时间”**策略。

###模式匹配

当你遇到一个涉及 **有序三元组 (i < j < k)** 并且需要在它们之间进行某种计算的问题时，可以优先考虑以下模式：

- **固定中间元素 `j`**: 将问题分解为与 `j` 左侧（`0` 到 `j-1`）和右侧（`j+1` 到 `n-1`）相关的子问题。
- **预处理左右信息**: 如果子问题需要在左侧或右侧区间内进行 O(1) 查询（如最大值、最小值、和等），立即联想到使用前缀/后缀数组。

类似的问题还有：

- LeetCode 1395. Count Number of Teams: `nums[i] < nums[j] < nums[k]` or `nums[i] > nums[j] > nums[k]`. 也可以通过固定 `j`，然后统计左边比它小/大的数的数量和右边比它小/大的数的数量来解决。
- 寻找最长山脉数组等。

###核心思想和套路**核心思想**:

#### 核心思想 -固定 中间索引 `j`

将三层循环的依赖关系解耦。

通过固定中间索引 `j`，原问题中 `i` 和 `k` 的选择范围被清晰地分成了 `j` 的前后两部分。这两部分的最优解（`max(nums[i])` 和 `max(nums[k])`）是独立于对方的，只与 `j` 的位置有关。

#### 套路

**分析问题**: 识别出 `i < j < k` 结构和性能瓶颈。

**固定变量**: 选择固定中间变量 `j`。

**预计算**: 分析对于固定的 `j`，需要哪些关于其左侧和右侧的聚合信息（本题是最大值）。

**实现预计算**: 使用前缀和/后缀和（或最大/最小）数组在 O(n) 时间内完成预处理。

**主循环**: 遍历所有可能的 `j`（从 `1` 到 `n-2`），利用预计算好的数组在 O(1) 时间内计算出当前 `j` 的最优解。

**整合结果**: 在遍历 `j` 的过程中，维护一个全局最大值。

### 实现原理和步骤

**处理边界情况**: 如果数组 `nums` 的长度小于 3，不可能形成三元组，直接返回 0。

**创建并填充前缀最大值数组 (`prefixMax`)**:

- 创建一个与 `nums` 等长的数组 `prefixMax`。
- `prefixMax[0] = nums[0]`。
- 从 `i = 1` 遍历到 `n-1`，计算 `prefixMax[i] = max(prefixMax[i-1], nums[i])`。

**创建并填充后缀最大值数组 (`suffixMax`)**:

- 创建一个与 `nums` 等长的数组 `suffixMax`。
- `suffixMax[n-1] = nums[n-1]`。
- 从 `i = n-2` 遍历回 `0`，计算 `suffixMax[i] = max(suffixMax[i+1], nums[i])`。

**遍历 `j` 计算结果**:

- 初始化一个 `long` 类型的变量 `maxVal = 0` 来存储最终结果。
- 遍历 `j` 从 `1` 到 `n-2`（因为 `j` 必须是中间元素）。
- 对于每个 `j`：
  - 获取左侧最大值 `leftMax = prefixMax[j-1]`。
  - 获取右侧最大值 `rightMax = suffixMax[j+1]`。
  - 计算差值 `diff = leftMax - nums[j]`。
  - 如果 `diff > 0`（满足 `nums[i] > nums[j]` 的条件），计算当前三元组的值 `currentVal = (long)diff * rightMax`。
  - 更新全局最大值 `maxVal = max(maxVal, currentVal)`。

**返回结果**: 返回 `maxVal`。

### 实现代码

```java
class Solution {
    public long maximumTripletValue(int[] nums) {
        int n = nums.length;
        int[] prefixMax = new int[n];
        prefixMax[0] = nums[0];
        for(int i = 1; i < n; i++){
            prefixMax[i] = Math.max(nums[i], prefixMax[i-1]);
        }

        int[] suffixMax = new int[n];
        suffixMax[n-1] = nums[n-1];
        for(int i = n-2; i >= 0; i--){
            suffixMax[i] = Math.max(nums[i], suffixMax[i+1]);
        }

        long ans = 0;
        for(int j = 1; j < n-1; j ++){
            int leftMax = prefixMax[j-1];
            int rightMax = suffixMax[j+1];
            if(leftMax > nums[j]){
                long curr = (long)(leftMax - nums[j]) * rightMax;
                ans = Math.max(curr, ans); 
            }
        }

        return ans;
    }
}
```

### 注意事项

**数据类型**: `nums[i]` 的值可能很大，`nums[i] - nums[j]` 和 `nums[k]` 的乘积很可能超出 32位 `int` 的范围（-2,147,483,648 到 2,147,483,647）。因此，在进行乘法运算和存储最终结果时，必须使用 `long` 类型。

**索引边界**: `j` 的循环范围必须是 `[1, n-2]`，这样才能保证 `j-1` 和 `j+1` 都是有效的数组索引。

**时间与空间复杂度**:

- 时间复杂度: O(n)。三次独立的线性遍历（一次前缀，一次后缀，一次主循环），总共是 O(n)+O(n)+O(n)=O(n)。
- 空间复杂度: O(n)。需要两个额外的数组 `prefixMax` 和 `suffixMax` 来存储预处理的结果。

### 经验总结

LeetCode 2874 是一个将问题从 O(n3) 优化到 O(n) 的绝佳范例。它完美地展示了**动态规划**和**预处理**思想在解决数组问题中的威力。

**“固定一点，看两边”** 是处理涉及多个有序索引（如 `i < j < k`）的数组问题的黄金法则。它能有效地将多维依赖关系降维，简化问题。

当你发现算法中存在大量的重复计算（例如，对于每个 `j` 都要重新计算其左边的最大值），就应该立刻想到用预处理的方式（如前缀/后缀数组）来缓存这些计算结果，实现**空间换时间**。

始终对题目的数据范围和数值大小保持警惕，这是避免整数溢出等常见错误的关键。
