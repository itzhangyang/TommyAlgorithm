##求符合条件约束的最大/最小子连续数组连续/子串 - 滑动窗口

###场景

- 求最长无重复子串
- 最小覆盖子串
- 求固定条件的子数组/子串

###目标

- 找出满足条件的最小/最大窗口
- 统计所有满足条件的窗口数量

###核心思想 - 滑动窗口 + 哈希表

- 通过维护一个动态窗口`[left,right]`来表示当前可行解空间，通过移动窗口边界寻找目标。
- 通过维护一个索引`Map`保存每一个字符串出现的索引位置

###应对套路

- 右指针不断扩展窗口直到满足条件
- 左指针不断收缩直到不满足条件
- 每次窗口满足条件后更新答案

###套路模板代码 

####最大不重复子串

###### 使用右指针扩展窗口

###### 使用HashMap保存每一个字符在窗口内第一次出现的位置

不需要在map中删除在窗口内已经过期的字符。

###### 怎样判断字符RC在窗口内已经存在？

因为我们没有从Map中删除已经过期的字符，因此我们在判断窗口内是否已经有和RC重复的字符的时候，需要**判断重复的字符是否在窗口内**。

```Java
if(map.containsKey(rc) && map.get(rc) >= left){
  ....
}
```

###### 处理出现重复的情况 - 左指针移动到RC第一次出现的位置之后

右指针向前移动过程中增加字符串的长度，如果当前右指针指向的字符`rc`已经出现在了子串中（出现在Map中），那么需要**将左指针移动到RC在窗口内出现的位置+1**；

```Java
if(map.containsKey(rc) && map.get(rc) >= left){
  left = map.get(rc) + 1;
}
```

###### 实现代码

```java
    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0) return 0;
        if(s.length() == 1) return 1;

        int n = s.length();
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int right = 0;
        int maxLength = 0;
        while (right < n){
            char rc = s.charAt(right);
          	//出现重复之后立即更新左指针
            //左指针移动到rc第一次出现的位置+1
            if ((map.containsKey(rc) && map.get(rc) >= left)){
                left = map.get(rc) + 1;
            }
          	//注意更新left之后不要使用else更新，因为更新left之后已经是合法的子串了，需要更新一下记录信息
            map.put(rc, right);
            int length = right - left + 1;
            maxLength = Math.max(length, maxLength);
            right++;
        }
        return maxLength;
    }
```

####最长的连续为1的子串长度

##### 使用while条件控制而不是for控制right指针的走向

当right指针的移动需要根据内部逻辑计算的时候，使用`while`循环。

当right指针的移动无论如何都是只前进一步的时候，使用`for`循环。

##### 出现不符合条件的元素的情况的处理 

###### 计算长度的时候应当排除right节点

当前的right值不符合条件的时候，当前的长度计算**应当排除right节点**

###### left指针应当移动到right + 1

- `left`指针应该移动到right+1的位置，即不符合条件的节点的下一个位置
- `right`指针重新移动到`left`指针的位置

##### Edge Case - Right符合条件并且是最后一个元素

在这种情况下，窗口长度的计算应当包含right节点。

```java
public int findMaxConsecutiveOnes(int[] nums){
  int left = 0;
  int right = 0; 
  int maxLength = 0;
  int n = nums.length;
 
  
  while (right < n ){
    if (nums[right] != 1){
      //更新记录
      int length = right -left;
      maxLength = Math.max(maxLength, length);
      //更新指针
      left = right + 1;
      right = left;
    }else{
      //Edge Case : 如果right 为最后一个元素
      if (right == n -1){
        //更新记录信息
        int length = right - left + 1;
        maxLength = Math.max(maxLength, length); 
      }
      right++;
    }
  }
  
  return maxLength;
}
```

### Leetcode 1877： Minimize Maximum Pair Sum in Array - 对撞指针

给定一个长度为偶数的整数数组 `nums`，需要将其中的元素两两配对，每个元素恰好属于一个配对。对于一个配对，其「配对和」定义为两元素之和。定义所有配对中最大的配对和为答案，要求在所有可能的配对方案中，使该最大配对和最小化，返回这个最小值。

#### 问题本质 - 最大的和最小的配对

在一组数里，两两配对，目标是「缩小最坏情况」——即最小化最大配对和。这属于典型的**极值优化**问题，可用**贪心**策略。

#### 核心思想与套路 - 排序 + 对撞双指针

**排序 + 双指针配对**
 将数组升序排序后，使用一头一尾两个指针，分别指向最小和最大元素，配对并计算和；然后向内收缩指针。

- 原理：最大元素只有与最小元素配对，才能让其和最小化，从而降低整体最大配对和。

**时间/空间复杂度**

- 排序：O(n·log n)
- 扫描配对：O(n)
- 空间：O(1)（原地排序）

#### 难点分析与应对方法

| 难点                           | 应对方法                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| 为什么两端配对是最优？         | 若最大元素与次大元素配对，则该配对和会更大；与最小元素配对，可“平衡”极端值。 |
| 边界情况（相等元素、大范围值） | 排序和双指针不依赖元素唯一性；若值很大，注意使用足够类型（Java 中 `int` 范围足矣）。 |

#### 实现原理和步骤

**检查输入**：若 `nums==null` 或 `nums.length` 为奇数，可抛出异常或直接返回特殊值。

**排序数组**：`Arrays.sort(nums);`

**初始化**：`int i = 0, j = nums.length - 1, ans = 0;`

**双指针遍历**：

- 每次令 `sum = nums[i] + nums[j]`
- 更新 `ans = Math.max(ans, sum)`
- `i++`, `j--`

**返回 `ans`**。

#### 实现代码

```java
    public int minPairSum(int[] nums) {
        if (nums == null || nums.length >> 1 == 1){
            throw new IllegalArgumentException("数组长度必须为偶数");
        }
        Arrays.sort(nums);
        int n = nums.length;
        int i = 0;
        int j = n - 1;
        int maxSum = 0;
        while (i < j) {
            int sum = nums[i] + nums[j];
            maxSum = Math.max(sum, maxSum);
            i++;
            j--;
        }
        return maxSum;
    }
```

#### 注意事项

1. **输入校验**
   - 确保 `nums` 不为 `null` 且长度为偶数；可根据业务要求选择抛异常或返回特定值。
2. **类型问题**
   - `nums[i]` 最大可能到 10⁶ 级别，配对和最大 2×10⁶，无需用 `long`。
3. **排序影响原数组**
   - 如果题意或后续还需保持原序，需先复制数组：`int[] a = nums.clone();`。

#### 经验总结

- **贪心两端配对** 是「最小化极值」类问题的常见套路，多出现在「配对」「分组」「摊平」等题目中。
- 排序之后的**双指针**，是一种很直接高效的思路，避免了复杂的数据结构。
- 面试时要能够**清晰证明**该贪心策略的正确性：最大值若与更小值配对可减弱峰值。
- 该题变形：若需最小化**最小**配对和，则应将最小与次小配对（即两端倒置配对）；套路对称。

### Leetcode 32 最大合法括号子串 -最长平衡子串- 两次遍历

#### 问题本质和分析

给定一个只包含 `'('` 和 `')'` 的字符串，找出其中最长的**有效括号子串**的长度。

### ❗ 合法括号串定义：

- 必须左右括号**一一匹配**；
- 匹配顺序必须正确：`"()"`, `"(())"`, `"()()"` 都合法；
- `")("`, `"(()"` 等都**不合法**。

#### 核心思想

一段有效的括号子串需要符合下列条件：

- 左右括号的数量完全相等
- 并且左右的出现顺序也要合理

因此我们的任务不是简单找数量相等的部分，而是要找**从某个点出发，到另一个点为止，是一组刚好能组成一对一对括号的连续片段**

我们要让两个小蜜蜂从两端出发，个字负责自己的括号，遇到不平衡就重来，当它们数到一样多，我们发现了一段刚好匹配的区域：

- 左蜜蜂从左到右，负责数左括号
- 右蜜蜂从右往左走，负责数右括号
- 它们各自自己维护一个计数器
- 每次当左边的数量和右边的数量相等，说明这一段刚好是合法配对
- 如果某一侧数的比另外一侧多，即多余的左括号或者多余的右括号，说明这一段不能再延续合法配对，需要将计数器清零，重新从下一位开始再计数

#### 基本套路 - 两次遍历

用两个指针和两个计数器遍历两遍，排除掉两种不平衡的情况

| 蜜蜂   | 方向  | 数什么     | 何时更新答案                | 何时发现不平衡＆重置            |
| ------ | ----- | ---------- | --------------------------- | ------------------------------- |
| 左蜜蜂 | 左→右 | `(` 的数量 | 左数 == 右数 → 更新最大长度 | 右数（`)`）> 左数（`(`） → 重置 |
| 右蜜蜂 | 右→左 | `)` 的数量 | 左数 == 右数 → 更新最大长度 | 左数（`(`）> 右数（`)`） → 重置 |

##### 从左到右遍历，统计左括号和右括号的数量

##### 从右到左，反过来再统计一次

#### 难点分析和应对

| 难点                           | 为什么普通滑窗/前缀不好用          | 我们怎样解决                         |
| ------------------------------ | ---------------------------------- | ------------------------------------ |
| 1. 只看数量不看顺序会错过 `)(` | 滑窗只关注长度，无法知道“先右后左” | 双向数，分别去除“先多右”和“先多左”   |
| 2. 合法段可能在中间            | 无法“一次滑完”整段                 | 一旦出错就清零，从下一个位置重新开始 |
| 3. 嵌套深、连续配对            | 嵌套需要逐对扫描                   | 累加计数，平衡时记录长度             |

#### 实现原理和步骤

1. 初始化

   ```java
   left = 0;
   right = 0;
   maxLen = 0;
   ```

2. 从左到右扫描

   - 遇到`(` -> `left++`，遇到`)` -> `right++`
   - 如果`right == left`， 更新`maxLen = max(maxLength, 2*right)`
   - 如果`right > left`， 说明出现了**多余的右括号**，清零`left = right = 0`

3. 从右到左扫描

   - 重置 `left=right=0`。
   - 从末尾往前，同理：遇 `)`→`right++`，遇 `(`→`left++`。
   - 若 `left == right` → 更新 `maxLen = max(maxLen, 2*left)`。
   - 若 `left > right` → 出现“先多余左括号”，**清零**。

4. 返回`maxLen`

#### 实现代码 - 一定要记住套路！

```java
    public int longestValidParentheses(String s) {
        int left = 0;//左括号数量
        int right = 0;//右括号数量
        int maxLen = 0;

        //从左往右计数
        for (int i = 0; i < s.length(); i++){
            if (s.charAt(i) == '('){
                left++;
            }else{
                right++;
            }
            if (left == right){
                maxLen = Math.max(2*left,maxLen);
            }
            if (right > left){
                left = 0;
                right = 0;
            }
        }

        left = 0;
        right = 0;
        for (int i = s.length()-1; i>=0; i--){
            if (s.charAt(i) == '('){
                left++;
            }else{
                right++;
            }
            if (left == right){
                maxLen = Math.max(2*right,maxLen);
            }
            if (left > right){
                left = 0;
                right = 0;
            }
        }

        return maxLen;
    }
```



#### 注意事项

**双向扫描**：单向只能发现一种“多余”情况。

**及时重置**：一旦数到多余的括号，就重置，从下一个字符重新算。

**连续性**：每次更新答案时，都保证了当前段从重置点到当前位置完全配对。

#### 经验总结

1. 本质是“数括号，找平衡”——平衡时就能确定一段合法。
2. **数不平衡就清零** 是跳过所有非法前缀/后缀的关键。
3. 类似问题（最长平衡子数组、其他配对验证）也可用此思路。

### Leetcode 713 乘积小于 K 的子数组数量

#### 问题要点

**输入**: 一个正整数数组 `nums` 和一个整数 `k`。

**输出**: 数组 `nums` 中，所有“连续子数组”的数量，要求这些子数组中所有元素的乘积严格小于 `k`。

**约束**:

- 数组 `nums` 的长度在 `[1, 30000]` 之间。
- `nums` 中的元素 `nums[i]` 在 `[1, 1000]` 之间。
- `k` 在 `[0, 10^9]` 之间。

#### 问题本质与分析

问题的本质是 **计数问题**，统计所有满足特定条件的 **连续子数组**

##### 初步想法 - 暴力遍历每一个长度的子数组

最直观的想法是枚举所有的连续子数组。

- 第一层循环确定子数组的起始位置 `start`。
- 第二层循环确定子数组的结束位置 `end`。
- 第三层循环计算从 `start` 到 `end` 的子数组的乘积，并与 `k` 比较。
- 这个方法的时间复杂度为 O(n3)，即使稍作优化（在第二层循环中直接累乘）也需要 O(n2)。考虑到 `n` 最大可达 30000，O(n2) 的算法（约 9times108 次操作）会远超常规的时间限制（约 108 次操作），导致“超时”。

##### 深入分析 - 如果`nums[i,k]`符合条件，那么它的子数组也都符合条件

我们需要一个更高效的算法。

这类涉及“连续子数组”且需要满足某个条件的问题，通常可以考虑 **滑动窗口**。滑动窗口算法之所以可行，是因为问题具有某种 **单调性**：

- 如果一个较长的子数组 `[i, j]` 的乘积小于 `k`，那么它的任何一个子数组（如 `[i, j-1]` 或 `[i+1, j]`）的乘积必然也小于 `k`。
- 反之，如果一个较短的子数组 `[i, j]` 的乘积已经大于等于 `k`，那么任何包含它的更长的子数组（如 `[i-1, j]` 或 `[i, j+1]`）的乘积也必然大于等于 `k`。

这种性质使得我们可以用双指针（`left`, `right`）来维护一个“窗口”，而不需要重复计算，从而将时间复杂度降至**线性级别**。

#### 考察点

这道题主要考察以下几个方面的能力：

1. **算法识别能力**: 能否识别出这是一个典型的“滑动窗口”问题模型。
2. **算法设计能力**: 如何正确地设计滑动窗口的移动策略（何时扩大窗口，何时缩小窗口）。
3. **核心逻辑处理**: 如何在窗口滑动的过程中，不重复、不遗漏地统计所有满足条件的子数组。这是本题的精髓。
4. **边界条件处理**: 能否处理好 `k <= 1` 等特殊情况。
5. **编码细节**: 注意到乘积可能会非常大，需要使用 `long` 类型来防止整数溢出。

#### 核心思想和套路 - 滑动窗口 + 怎样计算连续子数组数量？

##### 定义窗口

使用两个指针，`left` 和 `right`，定义一个左闭右闭的窗口 `[left, right]`。

- `right` 指针负责向右探索，扩大窗口；
- `left` 指针负责在必要时向右移动，缩小窗口。

##### 扩大窗口

`right` 指针不断向右移动（`for` 循环驱动），将新元素 `nums[right]` 纳入窗口，并更新窗口内的乘积 `product`。

##### 缩小窗口

 当 `product >= k` 时，说明当前窗口不满足“乘积小于 `k`”的条件。此时，需要不断地缩小窗口的左边界。

即 `left` 指针向右移动，并从 `product` 中除去 `nums[left]` 的值，直到窗口重新满足 `product < k` 的条件为止。

这个过程通过一个** `while` 循环**实现。

##### 计数 - 最关键的一步 - 计算区间内包含`nums[right]`的连续子数组的数量

在 `right` 指针每向右移动一步，并确保窗口 `[left, right]` 有效（即乘积小于 `k`）之后，我们需要计算 **新增** 的有效子数组数量（~~不是窗口内所有的子数组~~）

此时，所有以 `nums[right]` 为右端点，且左端点在 `[left, right]` 区间内的子数组，都是满足条件的。

总结起来，新增的子数组就是**区间内包含nums[right]的子数组**

- 这些子数组是: `[nums[right]]`, `[nums[right-1], nums[right]]`, ..., `[nums[left], ..., nums[right]]`。
- 它们的数量正好是当前窗口的长度，即 `right - left + 1`。
- 将这个数量累加到`count`中

通过这个机制，我们每次移动 `right` 指针时，都能高效地一次性统计所有以 `nums[right]` 结尾的合格子数组，避免了重复计算。

#### 难点分析和应对

##### 如何高效计数？

很多初学者在使用滑动窗口时，能想到窗口的伸缩，但不知道如何与“计数”结合。可能会错误地在 `right` 移动后，再用一个循环从 `left` 到 `right` 去找子数组，这样复杂度又会退化。

牢记核心技巧——**当窗口 `[left, right]` 满足条件时，新增的、以 `right` 结尾的有效子数组数量就是 `right - left + 1`**。这是整个算法的灵魂，必须深刻理解。

##### 如何防止整数溢出？

题目中 `nums[i]` 和 `k` 的值都很大，子数组的乘积很容易超过 Java `int` 类型的最大值（约 2times109）。

在声明窗口乘积变量 `product` 时，使用 `long` 类型。`long` 的最大值约为 9times1018，足以容纳本题中的乘积计算。

##### 边界条件 （k <= 1）

**分析**: 题目规定 `nums[i] >= 1`。如果 `k` 是 0 或 1，任何正整数的乘积都不可能“严格小于”`k`。

**应对**: 在代码开头进行特判。如果 `k <= 1`，直接返回 0，可以简化后续逻辑并避免潜在错误。

#### 实现代码

```java
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;

        int left = 0;
        long product = 1;
        int count = 0;
        for (int right = 0; right < nums.length; right++){
            product *= nums[right];

            while (product >= k) {
                product /= nums[left];
                left++;
            }

            count += right -left + 1;

        }

        return count;
    }
```

#### 注意事项

**严格小于**: 题目要求是 "strictly less than k"，所以在 `while` 循环中的判断条件是 `product >= k`。

**数据类型**: 务必使用 `long` 来存储乘积 `product`。

**窗口定义**: 理解 `left` 和 `right` 指针的含义，它们是数组的索引，构成 `[left, right]` 的闭区间。

**循环不变量**: 在 `for` 循环的每次迭代结束时（执行 `count += ...` 之前），窗口 `[left, right]` 始终是满足 `product < k` 的最长窗口。



#### 经验总结

**识别模式**: “连续子数组/子串” + “满足特定条件” + “求数量/最长/最短” = **高度警惕滑动窗口**。

**掌握核心**: 滑动窗口的精髓在于其 **双指针的移动策略** 和在移动过程中 **高效地更新结果**。对于计数问题，关键是找到每次窗口调整后，如何计算“增量”。

**举一反三**: 这个思想可以应用于众多问题，例如：

- [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) (和 >= target)
- [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) (窗口内无重复字符)
- [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) (窗口内字符计数与目标一致)