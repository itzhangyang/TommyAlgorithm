## 合并或者查找多个有序集合的交集-多路指针

### 场景和目标

**场景 (Scenario)** 给定两个或多个**已排序**的数组或区间列表。

**目标 (Goal)** 将它们合并成一个大的有序数组，或者找出它们共有的元素或重叠的区间。

### 核心思想和套路 - 多路指针遍历 (Multi-way Pointers)。

为每个数组/列表维护一个独立的指针。在每一步，比较所有指针指向的元素，根据比较结果决定采纳哪个元素，并移动相应的指针。这个过程类似于归并排序的合并步骤。

### 实现原理和步骤 - 两个有序数组的交集

1. 对两个数组进行排序（如果题目未保证）。

2. 初始化两个指针 `i = 0` (for `arr1`), `j = 0` (for `arr2`)。

3. 当 `i` 和 `j` 都在数组范围内时，循环：

   a.  如果 `arr1[i] == arr2[j]`，则找到一个交集元素，记录下来，然后 `i++`, `j++`。 

   b.  如果 `arr1[i] < arr2[j]`，说明 `arr1[i]` 较小，它不可能是交集，故 `i++`。 

   c.  如果 `arr1[i] > arr2[j]`，同理，`j++`。

### 代码套路模板

```java
public int[] intersect(int[] nums1, int[] nums2) {
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    List<Integer> list = new ArrayList<>();
    int i = 0, j = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] < nums2[j]) {
            i++;
        } else if (nums1[i] > nums2[j]) {
            j++;
        } else {
            list.add(nums1[i]);
            i++;
            j++;
        }
    }
    // 将列表转换为数组
    int[] res = new int[list.size()];
    for (int k = 0; k < list.size(); k++) res[k] = list.get(k);
    return res;
}
```

### 注意事项

- 务必先确认输入集合是否已经排序。
- 对于区间交集问题，比较的是区间的端点，逻辑稍有不同，但思想一致。

### 经验总结

处理多个**有序**集合的交互问题时，多路指针是一种非常自然且高效的思路。它将多个集合的比较问题，转化为在每一步只比较 k 个元素（k 为集合数量）的简单问题。

