# 找出符合条件的元素配对或者组合 - 哈希表+滑动窗口

## Leetcode 220 Contains Duplicate III

题目要求我们判断在一个整数数组中，是否存在两个不同的索引`i`和`j`，使得`|nums[i] - nums[j]| <= t`且`|i - j| <= k`，其中`t`和`k`是给定的整数。需要判断是否存在符合这些条件的两个元素。

### 核心思想和套路 - 滑动窗口 + 哈希表

#### 滑动窗口

- 滑动窗口： 通过维持一个大小为`k`的滑动窗口，保证两个元素的索引差`|i-j| <= k`, 这个滑动窗口会随着遍历数组而逐步滑动

#### 哈希表 + 有序桶

为了快速查询窗口内元素的差是否满足`|nums[i] - nums[j]| <= t`，我们使用哈希表或有序桶结构存储当前窗口内的元素。由于`|nums[i] - nums[j]| <= t`这个条件涉及数值范围的比较，采用桶排序思想来优化查询和插入操作。

### 难点分析

#### 如何快速判断数值差？

直接比较数值差`|nums[i] - nums[j]| <= t`的效率较低，可以通过**有序桶**来避免对每一对数值进行穷举式比较。

具体来说，我们把数组元素分成不同的桶，每个桶的大小为`t+1`(最大差值 t+1 - 1)，这样每个桶内的数值之间最大差异就不会超过`t`。

窗口内的每个元素按照 `%t+1`的方式寻找自己的桶

#### 怎样维护滑动窗口？

滑动窗口的大小为`k`，即当前窗口内至多包含`k`个元素。我们需要在遍历过程中维护这个窗口，并确保元素的插入、删除符合条件。

#### 桶排序思想

我们使用桶大小为`t+1`来分配元素，桶的索引为`nums[i] / (t + 1)`。这样同一桶内的元素差异不会大于`t`。

但是需要特别注意桶的边界情况，桶索引相邻的元素之间可能会满足差值要求，因此需要检查邻居桶。

### 实现原理和步骤

#### 桶的设计

每个桶的大小为`t+1`。元素`num`的桶索引为`num / (t + 1)`。

- 注意桶的索引的计算方式是基于**nums[i]中有多少t+1**
- 如果`nums[i]/(t+1) == 1`那么桶的索引就是1 

因此**如果两个元素在同一个桶内，则它们的差值小于`t`，因此不需要进一步检查**。

#### 窗口的维护

随着遍历的进行，我们将元素逐一加入窗口，并且在窗口的左边删除已经超出`k`范围的元素。

#### 桶边界的检查

除了检查元素所在的桶外，还需要检查相邻的桶，因为邻近的桶之间的差值可能满足`t`的条件。

#### 哈希表的使用

我们使用一个哈希表（`map`）来存储每个桶的元素。键是桶的索引，值是桶中存储的元素。

##### 如何检查窗口内是否有符合条件的元素？

对于每一个元素`nums[i]`，

- 通过`bucket = nums[i]/(t+1)`找到对应的桶。
- 如果桶内有元素，说明窗口内存在符合条件的另外一个元素，则可直接返回true，否则：
- 查询其左（`bucket - 1`）右(`bucket + 1`)桶内的元素，如果存在和当前元素`nums[i]`差值绝对值小于`k`的元素，则也直接返回true

##### 如何维护桶？

######添加桶或者桶元素

如果上述检查中没有发现符合条件的元素，那么将当前元素添加到对应的桶中。

如果不存在对应索引的桶，则创建一个新的桶。

最后将元素添加至桶中即可

###### 如何删除桶中元素？

如果说当前窗口的大小超过K了(right - left + 1 > k)，则需要将窗口进行右移，窗口左边过期元素需要被移除。

找到左指针对应的元素的桶索引。

`int oldBucket = nums[left]/(t+1)`

从元素桶中移除对应的元素

`bucket.get(oldBucket).remove(nums[left])`

如果说移除元素之后的桶为空，则直接删除桶：

`bucketMap.remove(oldBucket);`



####实现代码

```java
    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {
        //如果说两个索引差<=0，无法排出i != j的情况
        //valueDiff为绝对值，也不可能小于0
        if (indexDiff <= 0 || valueDiff < 0){
            return false;
        }

        //使用Map模拟桶，Key为桶的ID，Value为桶中存放的元素
        //每个桶里最多只需要一个元素
        //使用long类型是为了防止整数溢出，因为 nums[i] 可能是 Integer.MAX_VALUE 或 MIN_VALUE
        Map<Long, Long> buckets = new HashMap<>();
        //桶的大小。加 1 是为了确保同一个桶内的元素差值绝对值最大为 t
        long bucketSize = valueDiff + 1;

        for (int i = 0; i < nums.length; i++){
            long num = (long) nums[i];

            //获取桶的ID
            long bucketId = getBucketId(num, bucketSize);

            if(buckets.containsKey(bucketId)){
                return true;
            }

            long prevBucketId = bucketId - 1;
            if (buckets.containsKey(prevBucketId) && Math.abs(num-buckets.get(prevBucketId)) <= valueDiff){
                return true;
            }

            long nextBucketId = bucketId + 1;
            if(buckets.containsKey(nextBucketId) && Math.abs(num - buckets.get(nextBucketId)) <= valueDiff){
                return true;
            }

            buckets.putIfAbsent(bucketId, num);

            if (i >= indexDiff){
                long oldNum = (long) nums[i-indexDiff];
                long oldBucketId = getBucketId(oldNum, bucketSize);
                // 确保我们移除的是正确的元素，因为可能这个桶已经被新的元素覆盖了
                // （虽然在这个逻辑下不太可能，但这样写更严谨）
                if (buckets.containsKey(oldBucketId) && buckets.get(oldBucketId) == oldNum) {
                    buckets.remove(oldBucketId);
                }
            }

        }
        return false;
    }

    private long getBucketId(long num, long bucketSize){
        if (num >= 0){
            return num / bucketSize;
        }else{
            //如果是负数的情况
            //这保证了数轴上连续的数会落入逻辑上连续的桶
            //基于Java向下取整的问题
            return (num + 1) / bucketSize - 1;
        }
    }
```

## 怎样计算一个字符串的所有子串？

## Leetcode 30: [串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

### 问题要点 - 找出所有的单词排列的起始位置

**输入**: 一个主字符串 `s` 和一个单词数组 `words`。

**输出**: 一个整数列表，包含所有满足条件的子串在 `s` 中的**起始索引**。

**条件**:

- 这个子串是由 `words` 数组中的**所有**单词串联而成的。
- `words` 中的每个单词都必须被**恰好使用一次**（如果 `words` 中有重复单词，那么它们也必须在子串中出现相应次数）。
- 单词之间的顺序是**任意的**。
- 子串中**不能有任何其他字符**插入在单词之间。

**约束**: `words` 数组中所有单词的**长度都相同**。

这是一个非常关键的隐藏信息。

**示例**: `s = "barfoothefoobarman"`, `words = ["foo", "bar"]`

- 子串总长度 = 2 * 3 = 6。
- 在索引 0 处，子串是 "barfoo"，它由 "bar" 和 "foo" 组成。满足条件，所以 `0` 是一个答案。
- 在索引 9 处，子串是 "foobar"，它由 "foo" 和 "bar" 组成。满足条件，所以 `9` 是一个答案。
- 最终输出: `[0, 9]`

### 问题的本质和分析

#### 利用回溯进行全排列行不行？

初看此题，很多人会想到 "全排列"，即生成 `words` 的所有排列组合，然后去 `s` 中查找。

但这个思路很快就会遇到性能瓶颈。

如果 `words` 有 `n` 个单词，其排列数是 `n!` (n的阶乘)。

当 `n=10` 时，`10! = 3,628,800`，这会导致大规模的计算，必定超时。

#### 转换思维： 构成而不是顺序

因此，我们需要转换思路。

问题的本质不是**“顺序”**，而是**“构成”**。

我们不关心单词以何种顺序出现，只关心在一个**固定长度的窗口**内，是否包含了 `words` 数组中要求的所有单词及相应的数量。

这引导我们走向一个经典的数据结构和算法模型：**使用哈希表来统计词频，并用滑动窗口来检查子串**。

- **问题本质**：在一个长字符串中，寻找所有长度固定的、且内容物（单词集合及数量）符合要求的子串。
- **分析**：由于 `words` 中所有单词长度相同，这给了我们一个巨大的便利。任何满足条件的子串，其长度必然是 `word_count * word_len`。我们可以设定一个这样大小的窗口，在 `s` 上滑动，然后高效地判断窗口内的字符串是否满足条件。

### 背景知识

**哈希表 (HashMap/Dictionary)**: 这是解决本题的核心数据结构。

它的主要作用是进行频率统计。

哈希表可以提供平均 `O(1)` 时间复杂度的插入、删除和查找操作，非常适合用来快速记录和查询一个单词出现了多少次。

**滑动窗口 (Sliding Window)**: 这是一种重要的算法思想，常用于解决数组或字符串中的子区间问题。

它通过维护一个可变的窗口（通常由左右两个指针定义），并根据特定条件移动指针来减少不必要的重复计算。

**时间复杂度分析**: 理解为什么 `O(n!)` 是不可接受的，而 `O(N*M)` (其中N是`s`的长度，M是`words`的长度) 是一个优秀的解决方案。这是衡量算法好坏的关键。

### 模式匹配

#### 固定大小的窗口

当题目要求在序列（字符串/数组）中寻找一个**固定长度**的、满足某种性质的子序列时，就应该立刻想到固定大小的滑动窗口。

窗口向右滑动一格，就意味着左边移出一个元素，右边进入一个新元素。

#### 使用哈希处理无序集合

当题目要求一个集合（子串/子数组）包含某些元素，但**不关心其顺序**时，哈希表是首选。

通过将目标元素存入哈希表进行词频统计，可以快速验证当前集合是否满足要求。

#### 相关题目

- LeetCode 438: 找到字符串中所有字母异位词 (几乎是本题的单字符版本)
- LeetCode 76: 最小覆盖子串 (滑动窗口大小可变，是本题的进阶版)
- LeetCode 567: 字符串的排列 (判断一个串是否包含另一个串的排列)

### 核心思想与套路

#### 核心思想 - 一个需求清单和一个记录清单

用一个“需求清单”（`wordFreqMap`）记录需要哪些单词以及各多少个；

再用一个“当前持有清单”(`windowMap`)记录当前窗口内有哪些单词以及各多少个。

窗口在 `s` 上滑动，每滑动一步就更新“当前持有清单”，并与“需求清单”对比，若完全一致，则找到一个解。

#### 具体的套路

##### 预处理 - 创建需求清单

检查边界条件（输入为空等）。

创建一个哈希表 `wordFreqMap`，遍历 `words` 数组，统计每个单词的目标频率。

##### 滑动窗口框架 

确定单词长度 `wordLen`，单词数量 `wordCount`，窗口总长 `totalLen`。

**关键优化**: 我们不需要从 `s` 的每一个位置 `i` 开始检查。

由于单词长度固定，我们可以将所有起始点按 `i % wordLen` 分组。

例如，如果 `wordLen=3`，那么从 `0, 3, 6, ...` 开始的检查是一类，从 `1, 4, 7, ...` 开始的是另一类。

所以，我们只需要一个外层循环 `for (int i = 0; i < wordLen; i++)` 来覆盖所有可能的起始情况。

在每个外层循环内，初始化窗口的左右边界 `left` 和 `right`，以及一个空的窗口哈希表 `windowMap`。

##### 窗口滑动和判断

在一个 `while` 循环中，将右边界 `right` 每次移动 `wordLen`，相当于把一个新单词滑入窗口。

######判断滑入的单词 - 扩张或者重置窗口

- 如果这个词不在 `wordFreqMap` 中，说明当前窗口不可能构成答案。

  此时需要重置 `windowMap`，并将左边界 `left` 直接移动到当前 `right` 的位置，开始新的窗口探测。

- 如果这个词在 `wordFreqMap` 中，则更新 `windowMap` 中该词的计数。

###### 处理单词冗余 - 收缩窗口

当 `windowMap` 中某个单词的数量超过了 `wordFreqMap` 中要求的数量时，需要从左侧收缩窗口（`left` 指针不断右移 `wordLen`），直到这个单词的数量恢复正常。

###### 判断成功 - 记录窗口起点

当窗口内的单词总数等于 `wordCount` 时（即 `(right - left) / wordLen == wordCount`），说明找到了一个有效的匹配，将 `left` 添加到结果列表中。

此时，为了继续寻找下一个可能的匹配，将窗口左侧的单词移出，`left` 右移 `wordLen`。

### 实现原理和步骤

#### 初始化 - 创建需求清单Map

- 创建结果列表 `res`。

- 处理 `s` 或 `words` 为空的边界情况，直接返回 `res`。

- 获取 `wordLen`, `wordCount`, `totalLen`。

- 创建 `wordFreqMap` 并用 `words` 数组填充它。

#### 外层循环

`for (int i = 0; i < wordLen; i++)`: 对每一种偏移量进行一次完整的滑动窗口扫描。

#### 内层循环 - 定义固定长度的滑动窗口

- 滑动窗口的left指针指向第一个字符，**right指向最后一个字符+1**。即滑动窗口的范围是`[left,right)`，或者准确一段是`[left,right-1]`

- 在 `for` 循环内部，初始化 `left = i`, `right = i`, `windowMap = new HashMap<>()`。

- `while (right + wordLen <= s.length())`: 保证窗口右侧不会越界。

  - **获取滑动窗口的滑入单词：**从 `s` 中截取右侧的新单词 `w_in` 。

    ```Java
    String w_in = s.substring(right, right+wordLen);
    ```

  - **扩展滑动窗口：**`right += wordLen`，扩大窗口。

  - **如果 `w_in` 是需要的单词 (在 `wordFreqMap` 中)**:

    - 将其加入 `windowMap`，更新计数。

    - **循环收缩窗口**: `while (windowMap.get(w_in) > wordFreqMap.get(w_in))`，说明 `w_in` 太多了，必须从左边移出单词，直到 `w_in` 的数量达标。在循环中，更新 `windowMap` 和 `left` 指针。

    - **检查是否成功**: 如果当前窗口大小 `(right - left)` 等于 `totalLen`，说明找到了一个匹配，将 `left` 存入 `res`。

  - **如果 `w_in` 是不需要的单词**:

    - 这表明从上一个 `left` 到当前 `right` 的所有努力都白费了。
    - 清空 `windowMap`。
    - 将 `left` 直接设置为当前的 `right`，准备开始一个全新的窗口。

**返回**: 返回 `res` 列表。

### 实现代码

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        // 1. 边界条件处理
        if (s == null || s.length() == 0 || words == null || words.length == 0) {
            return res;
        }

        // 2. 初始化变量和“需求清单”哈希表
        int wordLen = words[0].length();
        int wordCount = words.length;
        int totalLen = wordLen * wordCount;
        Map<String, Integer> wordFreqMap = new HashMap<>();
        for (String word : words) {
            wordFreqMap.put(word, wordFreqMap.getOrDefault(word, 0) + 1);
        }

        // 3. 外层循环：遍历所有可能的起始点偏移量
        for (int i = 0; i < wordLen; i++) {
            // 每次偏移量变化，都重置窗口和“持有清单”
            int left = i;
            int right = i;
            Map<String, Integer> windowMap = new HashMap<>();
            
            // 4. 内层循环：滑动窗口
            while (right + wordLen <= s.length()) {
                // a. 右侧单词滑入窗口
                String w_in = s.substring(right, right + wordLen);
                right += wordLen;

                // b. 如果滑入的单词是无关词，则重置窗口
                if (!wordFreqMap.containsKey(w_in)) {
                    windowMap.clear();
                    left = right;
                    continue;
                }
                
                // c. 更新窗口内的单词计数
                windowMap.put(w_in, windowMap.getOrDefault(w_in, 0) + 1);
                
                // d. 如果某个单词数量超了，从左侧收缩窗口
                while (windowMap.get(w_in) > wordFreqMap.get(w_in)) {
                    String w_out = s.substring(left, left + wordLen);
                    windowMap.put(w_out, windowMap.get(w_out) - 1);
                    left += wordLen;
                }

                // e. 如果窗口大小正合适，说明找到了一个解
                if (right - left == totalLen) {
                    res.add(left);
                }
            }
        }
        return res;
    }
}
```

### 注意事项

- **字符串截取**: `s.substring()` 操作在某些语言（包括旧版Java）中可能比较耗时。但在现代Java中，它会创建一个新的字符串对象，性能对于本题来说是可以接受的。
- **哈希表的比较**: 不要频繁地使用 `map1.equals(map2)` 来比较两个哈希表，这个操作耗时较高。通过维护窗口内单词数量或者更精细的计数变量来判断是否匹配，会更高效。上面的代码通过巧妙的收缩和尺寸判断来避免了直接比较。
- **变量重置**: 注意在每次外层循环开始时，以及遇到无关词时，`windowMap` 和 `left` 指针需要被正确重置。

### 经验总结

**从暴力到优化**: 解决此题的过程是从“排列组合”的暴力思维，转向“词频统计”的优化思维的典型范例。学会这种思维转换是成为优秀程序员的关键一步。

**识别模式**: 它是“固定长度滑动窗口”和“哈希表计数”模式的结合体。一旦识别出这个模式，解题思路就会非常清晰。

**细节是魔鬼**: 滑动窗口的实现，特别是窗口的收缩逻辑，是本题的难点和重点。如何处理单词过多、如何处理无关单词，都需要清晰的逻辑。

**举一反三**: 彻底理解本题的解法，可以让你轻松应对一系列相关的子串/子数组问题。这是一个回报率非常高的题目。