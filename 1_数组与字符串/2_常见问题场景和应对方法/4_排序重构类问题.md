##排序重构类 - 排序 + 贪心

### 场景

给定一个数组，包含**不同种类的元素**（例如，0和非0，奇数和偶数，或0、1、2三种颜色）。

在**不使用额外空间（原地）**的情况下，将数组元素按照类别进行分区或重排：

- 字符串重排，最小差值、最小插入次数
- 数组元素之间需要形成特定顺序

###目标

- 最小化或者最大化差值
- 重构后的最有结果

###问题本质

通过排序把混乱的顺序改变成可控的顺序，在用**贪心策略**求最优。

### 应对套路 - 排序 + 贪心

- 先排序
- 在按照题目要求贪心地构造结构
- 特别注意间距、插入位置等处理逻辑

###[难点]原地划分或者重排数组元素 - 分区指针

####场景和目标

**场景 (Scenario)** 给定一个数组，包含不同种类的元素（例如，0和非0，奇数和偶数，或0、1、2三种颜色）。

**目标 (Goal)** 在**不使用额外空间（原地）**的情况下，将数组元素按照类别进行分区或重排。

####核心思想和套路 - 双指针分区

使用一个或多个指针来维护不同区域的边界。

一个指针用于遍历数组，根据当前元素的值，将其与边界上的元素进行交换，从而实现分区。

####实现原理和步骤 - 荷兰国旗问题

#####设置三个指针

- `low` 指向`0`区的**下一个位置**

- `mid` 作为**当前遍历指针**
- `high`指向2区的**前一个位置**

#####循环逻辑

当`mid <= high`时，循环：

a.  如果 `nums[mid] == 0`，与 `nums[low]` 交换，然后 `low++`, `mid++`。

 b.  如果 `nums[mid] == 1`，不做任何事，直接 `mid++`。 

c.  如果 `nums[mid] == 2`，与 `nums[high]` 交换，然后 `high--`（`mid` 不动，因为交换过来的元素需要重新检查）。

####代码套路模板 - 颜色分类（LC75）

```java
public void sortColors(int[] nums){
  int low = 0;
  int mid = 0;
  int high = nums.length -1;
  
  while(mid <= high){
    if (nums[mid] == 0){
      swap(mid,low);
      mid++;
      low++;
    }else if(nums[mid] == 1){
      mid++;
    }else{
      swap(mid,high);
      high--;
    }
  }
}
```

###模板代码 - 分发糖果 - 排序 + 两次遍历

有 `n` 个孩子站成一排，每个孩子有一个评分 `ratings[i]`。你需要按照以下要求给孩子们分发糖果：

1. 每个孩子至少分配到 1 个糖果。
2. 相邻的两个孩子中，评分高的孩子必须获得更多的糖果。

问：你最少需要准备多少个糖果？



```java
public int minCandies(int[] ratings){
  int n = ratings.length;
  // 每个孩子的糖果数数组
  int[] candies = new int[n];
  //每个孩子至少发一颗糖果
  Arrays.fill(candies,1);
  
  //两次贪心算法
  //从前往后，第一次贪心算法，如果当前孩子比前一个孩子分数高，则其糖果数 = 前一个孩子的糖果数 + 1
  for (int i = 1; i< n; i++){
    if (ratings[i] > ratings[i-1]) candies[i] = candies[i-1]+1;
  }
  
  //从后往前， 第二次贪心算法，如果当前孩子比后一个孩子分数高，则其分数 = max(自己糖果数，后一个孩子糖果数 + 1)
  for (int j = n-2; j >= 0; j--){
    if (rating[j] > rating[i+1]) candies[j] = Max(candies[j], candies[j+1] + 1);
  }
  // 累计糖果数
  int sum = 0;
  for(int c : candies) sum += c;
  return sum;
}
```

## [二维数组]Leetcode 406: 重构队列

给定一组由 **(h, k)** 表示的人，其中：

- **h** 是某个人的身高；
- **k** 表示在此人前面（即站在队列中更靠前位置）**身高大于或等于 h** 的人数。

请重新排列这些人，使得每个人的 k 值得到满足，返回重建后的队列，其中队列用二维数组（或列表）表示，上述每个元素用一对整数 `[h, k]` 表示。

换句话说：确保重建以后的数组中的元素满足如下条件：

假设`a[i] = [h,k]`那么`a[0...i-1]`中就必须有`k`个元素满足`a[m][1] >= h`， 其中`m = [0...i-1]`

**输入**

```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
```

**输出**

```
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

- 第一个人 [5,0] 表示身高 5，前面没有身高 ≥5 的人；

- 第二个人 [7,0] 表示身高 7，前面没有身高 ≥7 的人；

- 第三个人 [5,2] 表示身高 5，前面正好有 2 个身高 ≥5 的人（分别是 [5,0] 和 [7,0]）；

以此类推，每个人的 k 值都满足题意。

### 本质剖析

#### 对二维数组的约束

本题给出的约束：

- 每个人的身高`h`
- 他前面的身高 `>= h`的人的数量

假设最终队列已经构建，我们对于任意一个人`[h,k]`: 这个人的前面的所有的人的身高中，至少要有`k`个人的身高 >= h，并且数量正好等于k

#### 重建顺序和原始顺序无关

题目给出的录入顺序并不代表队列的最终顺序，仅仅作为输入，我们需要根据`[h,k]`对所有人进行**重新排序**。

#### 贪心算法的可行性

为了满足每个人的K的需求，如果能把信息约束更强，

- 影响范围更大的高个子放到合适位置，再逐步插入相对矮的人
- 则已经放入的高个子不会受到后面矮个子插入的影响，也就是说**身高高的人对后续插入的影响小**

上述的情况暗示了贪心策略：先处理身高高的，再处理身高矮的

### 核心思想和套路： 多重排序

##### 核心思想 - 身高降序 + K值升序

身高高的人优先处理，且同样身高的人中，K值小的人优先处理，保证插入时的位置更靠前，对后续插入的约束更小

##### 将排序后的人依次插入到结果队列中

- 对于当前要插入的`[hi,ki]`，`k_i`表示他前面必须恰好有`ki`个人身高 >= `hi`
- 由于此前被处理的人身高都`>=`当前高度，所以只需要将该元素插入到结果列表中下标为`ki`的位置上即可

#### 详细套路

##### 排序规则：身高降序 + K值升序

- 按照身高降序排列
- 如果两个身高相同，则按照K升序排列
- 身高高的插入时无需考虑已有更高或等高的人会被后续插入的矮个子“破坏”，因为矮个插入不会影响已有更高者的 k 值约束。
- 而同高度时，k 值小的人先插入可以让“Heights are equal”情况下插入在合理的位置，后续 k 值大的人数插入时，前面已经有相应数量的相同身高存在。

##### 插入操作

- 使用一个动态数组（如 `ArrayList` 或 `LinkedList`），初始为空。
- 按照上面排完序的列表，遍历每个 `[h_i, k_i]`，并把该数对插入到动态数组的下标 `k_i` 处：

```
result.add(k_i, [h_i, k_i]);
```

这样，在插入时就能保证前面已有的所有元素身高 ≥ `h_i`，且当插入到第 `k_i` 个位置时，前方有且只有 `k_i` 个被处理的人。

##### 最终返回

插入完成后，动态数组中的顺序即为满足题目要求的重建队列，将其转换为二维数组或 List<List<Integer>> 返回即可。

### 难点分析与应对方法

#### 为什么先排身高降序，再插入操作就正确？

- 直觉上要证明：当处理到当前 `[h, k]` 时，动态数组中已有的所有元素要么身高 > h，要么身高 = h 且 k 比当前更小。所以在它插入到下标 k 时，前面确实有 k 个符合条件（身高 ≥ h）的元素。
- 若先插入身高较低的人，则插入时无法准确知道已有的比它高的人数（因为后续更高者的插入顺序会改变低者的 k 统计）。这也是身高降序策略的核心原因。

#### 同身高的情况的处理

- 对于身高相同的两个人 `[h, k1]` 和 `[h, k2]`，若 k1 < k2，当先插入 `[h, k1]`，此时在队列中已有 k1 个身高 ≥ h，插入到下标 k1 后，其前方正好是 k1 个身高 ≥ h（包括与其相同）。接着插入 `[h, k2]` 时，此时已有的人中必然包含至少 k2 个身高 ≥ h——因为前者身高相同且占据了一个位置，程序会将它插入到下标 k2，前面正好有 k2 个元素身高 ≥ h。
- 若反过来先插入 k2，再插入 k1，则会插入到下标 k2，导致 k1 的前面很可能只有 k1 - 1 个人，违反了 k1 的要求。故同身高按 k 升序必须保证正确性。

#### 性能瓶颈及优化

- 接使用 `ArrayList.add(index, element)` 插入时，如果列表很长且插入在中间，底层需移动大量元素，导致每次插入的平均时间复杂度 O(n)，总共 n 次插入，整体 O(n^2)。

- 但对 LeetCode 406 的数据规模（n 最多 2000 左右）来说，O(n^2) 通常可以接受。如果需应对更大规模，可考虑基于**平衡树**或**Fenwick 树/线段树**来做更快的“第 k 个空位插入”操作，将复杂度降到 O(n log n)。这种思路比直接插 ArrayList 要复杂得多，常见于更高难度的「队列重建」类题目。一般在面试或常规刷题环境下，排序 + ArrayList 插入已经足够。

#### 边界情况

- 输入数组为空，返回空即可。
- 输入中某些人的 k 值可能为 0，表示该人前面必须没有身高 ≥ h 的人，此时它会被插入到列表开头（索引 0）。
- k 值最大可能为 n-1，即所有身高 ≥ h 的人都出现在该人前面。排序之后插入时若 k = 当前列表长度，也会被插入到末尾，依旧合法。

### 实现代码

```java
   public int[][] reconstructQueue(int[][] people) {
        List<int[]> queue = new ArrayList<>();
        Arrays.sort(people, (a,b)->{
            if (a[0] != b[0]) {
                return b[0] - a[0];
            }else{
                return a[1] - b[1];
            }
        });

        for(int[] p : people){
            queue.add(p[1],p);
        }
        return queue.toArray(new int[queue.size()][]);
    }
```

### 注意事项

1. **排序时的细节**
   - 千万注意：先对身高 **降序**，再对 k **升序**。若写反、或者将两个条件搞混，就会导致插入后 k 无法得到保障。
   - 比如，如果把身高写成升序，先插入矮个，再插入高个，插入高个时，矮个的存在不会影响“身高 ≥ h 高个前面需要 k 个”这个约束，但后续如果再插入相同高度的对象，就容易出现前面已有元素位置不对的问题。
2. **List 结构的选择**
   - `ArrayList` 实现的 insert 操作需要移动后续元素，时间复杂度 O(n)。对于 n 较大时会造成性能瓶颈。
   - `LinkedList` 也可以实现在指定位置插入，但找到第 k 个节点需要从头遍历 O(n)。同样是 O(n)。
   - 因此对于纯粹算法思路而言，两者在最坏情况下都是 O(n) 插入，总体 O(n^2)。若要进一步优化，可使用“平衡树”、“Order-Statistic Tree” 或者“树状数组 + 二分” 之类更复杂的数据结构，来支持在 O(log n) 之内完成 “按序号插入” 操作。但那属于更高阶的实现，不是本题常见解法。
3. **内存复用 vs 新建对象**
   - 直接在原数组上排序、并将原数组的指针插入到 List 中，无需新建两维数组，这样可以节省空间。
   - 如果面试官要求“不要修改输入”，则可先拷贝一份再进行排序。
4. **输入合法性检查**
   - 题目通常保证输入合法，即 k 值范围在 `[0, n-1]`，且总有解。但在实际开发中，可额外判断：如果 k > 当前队列长度，则说明无效输入，应抛异常或返回空。
5. **稳定排序与否**
   - Java 的 `Arrays.sort` 对基本类型和引用类型二位数组均采用 **Timsort**，对等于 `compare` 返回 0 的元素会保持原始相对顺序（稳定性）。这一点在本题中并不是关键（因为在相同身高、相同 k 的情况下谁先谁后，结果队列是等价的）。但在一些变种题中若需要更严格的稳定性，就要注意这一点。

### 经验总结

1. **典型的“先高后矮再插入” 贪心套路**
   - 这是队列重建、区间插入类题目的常见模式。类似思路也出现在 “根据年龄/权重/大小等维度重建索引顺序” 之类题目中。核心都在于：对 “约束更严格或影响面更广的元素”（一般是“值更大”或“K 更小”的）先处理，再依次插入，后续插入不会破坏已有约束。
2. **理解“k 值”的含义**
   - 一开始看到“k 表示前面有 k 个身高 ≥ h 的人”时，可能会误以为要反复地“计数”或“扫描”。但其实通过“先排序 + 插入到下标 k” 的操作，就已经隐式地维护了“前面 ≥ h” 的计数需求，无需二次扫描。理解这层映射是解题关键。
3. **代码思路简单，但排序和插入顺序千万不能弄错**
   - 如果排序规则写错，比如先按 k 升序再按身高降序，就会出现 “插入到 k 后，有些插入对象前面其实并没有足够高度的人” 的情况。面试时写代码一定要小心，把排序规则想清楚再写。
4. **性能要点：n 较大时考虑更高效的数据结构**
   - LeetCode 官方题目规模允许 O(n^2)，但实际工程中如果 n 可达 10^5 甚至更多，就需要考虑使用平衡树（如 Java 中的 TreeMap + 存储各节点的子节点数量）、或线段树、或二分索引的 Fenwick 树，来在线性对数时间内完成“插入到第 k 个空位”的操作。这里的思路是：先用一个“容量为 n 的空位数组” 或者位段树表示哪些位置已经被占用，依 k 在空位中二分寻找第 k+1 个空位，然后更新状态。该方法复杂度 O(n log n)，但是实现难度较大。
5. **通用思考方式**
   - 先把“最不受后续干扰”的部分先固定下来。这里“身高高的人受矮人插入位置的干扰几乎为零”，所以先排身高。
   - 然后根据“插入序号”来定位。通常此类“重建”问题都遵循相似思路：先排序，再插入。可以类比“插入区间”、“插入列表”的其他题目，比如 LeetCode 56（合并区间）虽然不是同一类型，但都需要先排序再进行线性处理。

 ## [多类别排序]荷兰国旗问题 - 三路划分

### 场景

- 数据结构： `int[] nums`其中元素只包含(0,1,2)
- 目标： 原地将将所有0排到前面，1排在中间，2排在后面

### 套路： 双指针/三路划分

- `p0 = 0, cur = 0, p2 = n-1`
- `while(cur <= p2)`:
  - 如果`nums[cur] == 0`，交换`nums[cur]`和`nums[p0]`， `p0++, cur++`
  - 如果`nums[cur] == 2`，交换`nums[cur]`和`nums[p2]`，`p2--`(`cur`不变)
  - 如果`nums[cur] == 1`， `cur++`

### 基本思路

- 左指针收集0
- 右指针收集2
- `cur`用于扫描元素并放到对应区间，整体一次扫描完成

### 实现难点和应对

#### 交换后是否移动`cur`

- `nums[cur] ==2`交换到后面的时候，`cur`不移动，因为**交换过来的元素需要重新判断**

#### 循环边界

必须写作`while(cur <= p2)`，否则会**最后几个元素的处理**

### 套路模板

```java
    public void sortColors(int[] nums) {
        int left = 0;
        int cur = 0;
        int right = nums.length - 1;
        while(cur <= right){
            if (nums[cur] == 0){
                //swap nums[left] and nums[cur]
                int temp = nums[left];
                nums[left] = nums[cur];
                nums[cur] = temp;

                left++;
                cur++;
            }else if (nums[cur] == 2){
                int temp = nums[cur];
                nums[cur] = nums[right];
                nums[right] = temp;
                right--;
            }else{
                cur++;
            }
        }
    }
```

### 注意事项与经验总结

1. “交换 2 后是否移动 `cur`” 是易错点，一定演示几组数据。

2. 如果类别数 > 3，可先统计所有类别的频次，然后按“前缀和”区间重写原数组，也能在 O(n) 内完成。

3. 经验：该算法的核心是**维护左右边界+一个扫描指针**，适用于任何“多类别划分”场景。

## 频率驱动重排

### 场景

```
给定一个序列（如字符串 s）—每种元素出现多次，
目标：按某种距离/相邻约束重排，使得冲突最小（如相邻不同 或 相同元素间隔 ≥ k）。
```

### 核心套路 - 哈希计数 + 最大堆 

- 统计各种元素的频率，构造最大堆
- 相邻不同：
  - 每次弹出频率最高的两个元素，追加到尾部
  - 将元素的频率`-1`，如果剩余频率仍然高于0， 重新入队
  - 如果只剩下一个元素了，需要检查元素频率是否为`1`
- **K间距：** 
  - 每次弹出一个元素并且追加到尾部，
  - 并将其放入**等待队列**，记录**下次可用时刻**`step + k -1`，
  - 当时刻到了的时候，重新入堆

### 基本思路

让频率最高的元素尽量分散，通过**优先使用**和**延迟复用**保证冲突最少或者满足距离

### 实现难点与应对

#### 等待队列管理（K距离）

需要记录**可重用**时刻并在每步检查队列头

#### 剩下最后一个检查

若相邻不同场景下，最后剩下的元素如果`freq > 1`就需要判定失败。

### Leetcode 767: 字符串重排

 给定一个字符串 `s`，重新排列其中的字符，使得任意两个相邻字符都不相同。如果存在多种答案，返回其中任意一种；如果无法做到，则返回空字符串。

####问题本质与分析

本题的核心在于 **避免“高频”字符在结果中聚集**，从而导致相邻重复。**若某个字符出现次数过多，超过了字符串长度的一半（向上取整），就一定无法分散开**，问题无解。

如果字符串长度是n， 字符c的最高频次为`maxCnt`,若

`maxCnt > (n+1)/2`，则必然存在相同字符相邻的情况。

#### 核心思想： 贪心 + 堆

##### 贪心 - 每次优先使用剩余频率最高的字符

每次优先使用剩余频率最高的字符，尽可能将高频字符分散开

##### 数据结构 ： 最大堆

使用最大堆来维护剩余频次最高的字符

##### 过程

- 将所有字符按照频次入堆
- 每次取出堆顶的两个字符（频率最高的两个），交替加入结果，并且将他们的剩余频-1后重新入堆（如果>0）
- 最后堆中残留一个字符，则直接拼接

#### 难点分析与应对方法

##### 判断无解场景

扫描一遍字符计数，如果出现计数 > `(n+1)/2`的情况，立即返回空串

##### 如何分散高频

用最大堆保证每次取到的是当前剩余最多的字符串，能最大程度避免聚集

##### 堆操作细节

取出**两个元素** 后要小心更新频次并重新入堆，当堆中只剩一个元素时处理当度逻辑

##### 实现原理和步骤

**统计频次**

- 用长度为 26 的整型数组 `count[26]` 记录 `'a'–'z'` 的出现次数。

**检查可行性**

- 扫描 `count` 数组，若存在 `count[i] > (n+1)/2`，则返回 `""`。

**构建最大堆**

- 优先队列按剩余次数从大到小排序，队列元素可用 `Pair(char c, int cnt)` 来表示。

**贪心拼接**

```java
while (pq.size() >= 2) {
  Pair p1 = pq.poll();
  Pair p2 = pq.poll();
  // 将这两个字符依次加入结果
  sb.append(p1.c).append(p2.c);
  // 更新剩余次数，若>0则重新入堆
  if (--p1.cnt > 0) pq.offer(p1);
  if (--p2.cnt > 0) pq.offer(p2);
}
// 若剩一个字符，直接拼接
if (!pq.isEmpty()) sb.append(pq.poll().c);

```

**返回结果**

- `sb.toString()` 即为满足条件的重组字符串。

#### 实现代码

```java
 public String reorganizeString(String s) {
        Map<Character, Integer> freqMap = new HashMap<>();
        for (char c : s.toCharArray()){
            int freq = freqMap.getOrDefault(c, 0);
            // 这一点十分重要
            if (freq + 1 > (s.length() + 1)/2) return "";
            freqMap.put(c, freq + 1);
        }
        PriorityQueue<Character> pq = new PriorityQueue<>((a,b)-> freqMap.get(b) - freqMap.get(a));
        for (Character ch : freqMap.keySet()){
            pq.offer(ch);
        }

        StringBuilder res = new StringBuilder();
   			//注意这里需要判断堆中是否还有两个以上的元素
        while (pq.size() >=2 ) {
            char c1 = pq.poll();
            char c2 = pq.poll();
            res.append(c1);
            res.append(c2);
            int freq1 = freqMap.get(c1);
            int freq2 = freqMap.get(c2);
             freqMap.put(c1, freq1 - 1);
             freqMap.put(c2, freq2 - 1);

            if (freq1 - 1 > 0){
               pq.offer(c1);
            }

            if (freq2 - 1 > 0){
                pq.offer(c2);
            }
        }
       //如果堆中只剩一个元素，也要追加上
       if (!pq.isEmpty()){
        res.append(pq.poll());
       }

       return res.toString();
    }
```

#### 注意实现

**堆中元素更新**：**务必在减少 `cnt` 后再判断是否重新入堆**，避免将 `cnt=0` 的元素插入。

**单字符剩余**：当堆中只剩一个字符时，直接拼接；此时保证不会与前一个字符相同。

**边界输入**：空串或长度为 1 的字符串需直接返回原串。

**字符范围**：若字符串包含更广字符集（如 Unicode），需用更通用的数据结构（如 `Map<Character, Integer>`）。

#### 经验总结

1. **“贪心+堆”模式**：处理“邻近不相同”或“分散高频”类问题的常见套路。
2. **先判无解，再构造**：任何需要判断可行性的问题，先扫描检查边界条件，避免后续无谓运算。
3. **替代方案**：若字符种类有限，可考虑用“桶排序”方式（按频次分桶，然后交替填充），实现时间复杂度 O(n)。
4. **通用思路迁移**：此题与“重排正负数”“重新安排任务”等问题本质相似，都可用“贪心取最多+交替安排”解决。
5. **代码健壮性**：记得处理各种特殊输入和边界情况，使解法更完备。

### Leetcode 358 K距离间隔重排字符串

给你一个非空的字符串 `s` 和一个整数 `k` ，你要将这个字符串 `s` 中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离 **至少** 为 `k` 。如果无法做到，请返回一个空字符串 `""`。

#### 问题分析 - 带冷却时间的任务调度

**本质：**这是一个带冷却时间的任务调度问题，每一个字符可以视作一个任务，任务执行一次以后，需要冷却K个位置才能再次执行

**输入：** 字符串s和整数k

**输出：** 一个新的字符串，满足任意两个相同的字符在结果中的下标差 >= k， 若无解，返回空串

#### 核心思想和套路

##### 贪心 + 优先队列

- 贪心的每次选择当前剩余出现次数最多的字符放在结果字符串中，以最大化**后续放置同字符串的可能性**
- 用**最大堆**维护剩余字符及其次数

##### 冷却队列

- 为了让字符在取出后等待至少K步，再次被选中，需要一个辅助的等待队列（大小可以理解为滑动窗口）

- 每次从堆里取出字符，放入结果串后频次减一，并连同更新后的频次一起放入一个FIFO的队列

  队列里存储的是**刚用过但是尚未达到可再使用位置**的字符

- 当队列长队唱过K时，队列头的字符就完成了冷却，可以重新入堆

#### 难点分析与应对

##### 如何保证相同字符间距超过K

引入**冷却队列**，队头元素完成K步冷却后再入堆

##### 堆中无可用字符但是结果未完成拼接

说明剩余字符全都在冷却中，不足以填充接下来的K个位置，直接无解返回“”

##### 边界情况 K <= 1

不需要任何重排，直接返回原串

#### 实现原理和步骤

1. 统计频次
2. 构建最大堆： 将所有出现次数超过0的元素入堆，按照`freq`降序
3. 初始化结果容器:`StringBuilder`
4. 初始化冷却队列：`Queue`
5. 循环调度：
   1. 当前堆非空，取出堆顶元素`c`，追加到结果尾部
   2. `c`的频次`-1`，如果频次依然大于`0`，将`c`放入冷却队列队尾
   3. 如果冷却队列`wait.size == ()`，则弹出冷却队列队头，并加入最大堆
   4. 如果堆为空，并且等待队列小于K，但是`sb.length < s.length`， 说明无解
6. 返回： 若构造长度等于原来的串长度，则返回`sb.toString()`，否则返回""

#### 实现代码

```java
   public String rearrangeString(String s, int k) {
        if (k <= 1) return s;
        Map<Character,Integer> freqMap = new HashMap<>();
        for (char c : s.toCharArray()){
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }

        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> freqMap.get(b) - freqMap.get(a));
        for (char c : freqMap.keySet()){
            pq.offer(c);
        }

        Queue<Character> wait = new LinkedList<>();

        StringBuilder res = new StringBuilder();

        while (!pq.isEmpty()) {
            char current = pq.poll();
            res.append(current);
            
            int freq = freqMap.get(current);
            freq -= 1;
            freqMap.put(current, freq);

            wait.offer(current);

            if (wait.size() == k){
                char ch = wait.poll();
                if (freqMap.get(ch) > 0){
                    pq.offer(ch);
                }
            }
        }
        return res.length() == s.length() ? res.toString() : "";
    }
```

#### 注意事项

- **字符集假设**：上述代码假设 `s` 仅包含小写字母；若字符集更大，可改用 `Map<Character,Integer>`。

- **k ≤ 1**：此时无需任何重排，直接返回原串，避免错误进入冷却逻辑。

- **时间复杂度**：O(N log C)，N = `s.length()`，C = 字符种类数（最多 26）。空间复杂度 O(N + C)。

- **无解判断**：当堆为空且 `sb.length() < s.length()` 时退出循环并返回 `""`。

#### 经验总结

- **背后模型**：将「重排字符」抽象为「任务调度，带冷却时间」问题，在多种类似题型（如 CPU 任务调度）中通用。
- **贪心＋队列**：优先调度当前最“紧急”（频率最高）的任务，但用队列强制其冷却，是此类题的标准套路。
- **边界处理**：小 k 和大 k 的边界，以及字符集扩展，都要在实现前理清，否则容易出错。
- **可拓展性**：若题目要求返回任意一种合法解，上述贪心策略即可；若要求「字典序最小」或「原序尽可能保留」，需在优先级定义上做调整。

## 优势配对类 - 重排A让A[i] > B[i]的i数量最大

### 场景描述

```
给定两个等长数组 A, B，
目标：重排 A 生成 ans，使得 ans[i] > B[i] 的 i 数量最大。
```

###核心套路 - 双指针 + 贪心

#### 排序

##### 对数组A进行升序排序

1. 对 A升序排列，

##### 构建数组B的BP数组

1. 构建`bp = [(B[i],j)]`，并且按照值降序排列
   - `bp[x][0]`表示数组B中某元素的值
   - `bp[x][1]`表示该元素在数组B中的索引

```java
int[][] Bp = new int[n][2];
for (int i = 0; i < n; i++) {
    Bp[i][0] = B[i];    // 这里就是 bval
    Bp[i][1] = i;       // 原来的索引
}
Arrays.sort(Bp, (x,y) -> y[0] - x[0]);  // 按 B 值升序
```

`Bp` 数组的核心目的，就是**在不破坏原始索引信息的前提下，把 B 数组按照值从大到小排序**，以便我们能按“小到大”依次对比并贪心分配 A 中的元素。

#### 双指针 + 贪心思想 - 能赢就用最强，不能就牺牲最弱

##### 在A数组上建立双指针

1. 在数组A上建立左右指针：`l = 0, r = n-1`

#####贪心 - 每次选择比最小的B[i] 小的最大的A数组中的元素A[r] 比较

**类似于打牌的规则，如果有把握赢就出该出的牌，如果输的话，就出个最小的牌。**

遍历 `Bp` 时，每次看当前最小的 `bval = Bp[k][0]`，并拿 `A[r]`（A 中最大）去尝试打它：

- 如果能赢（`A[r] > bval`），就把 `A[r]` 放到它原来的位置 `ans[Bp[k][1]]` 上；
- 否则就用最小的 `A[l]` 去“牺牲”，同样放到 `ans[Bp[k][1]]`。

**从小到大**遍历数组`bp`:

- 如果`A[r] > bp[i][0]`: `answer[idx] = A[r]; r--`
- 如果`A[r] <= bp[i][0]`:`answer[idx] = A[l];l++`

### 难点分析与应对

- **维护原始下标**：Bp 存 (value, origIdx)，最后写回 ans。
- **双指针边界**：确认 l, r 的移动时机和条件。

### 代码套路模板

```java
    public int[] advantageCount(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        int n = nums1.length;

        int[][] bp = new int[n][2];
        for (int i = 0; i < n; i++){
            bp[i][0] = nums2[i];
            bp[i][1] = i;
        }
        Arrays.sort(bp,(a,b) -> b[0]-a[0]);

        int[] answer = new int[n];

        int left = 0;
        int right = n - 1;
        for (int i = 0; i < n; i ++){
            int bval = bp[i][0];
            int bidx = bp[i][1];
            if (nums1[right] > bval){
                //能用就用最厉害的牌
                answer[bidx] = nums1[right];
                right--;
            }else{
                //不能赢就用最弱的牌
                answer[bidx] = nums1[left];
                left++;
            }
        }

        return answer;
    }
```

### 注意事项和经验

- 牺牲最小值保留“大牌”去赢后续，贪心策略正确性可用反证法说明。
- 演示 Bp 排序后配对流程，确认索引写回无误。

## 相对排序 - 数组A按照给定数组B元素顺序排序

给定两个数组 arr1, arr2，arr2 中元素互不重复，且均出现在 arr1 中，
目标：让 arr1 中与 arr2 同元素按 arr2 顺序排列，其余元素升序追加

### 核心套路： 哈希构建 + 自定义排序

1. 构建每一个元素在arr2中的索引，不在arr2中的元素映射到一个大值m
2. 对arr1进行排序：
   - 比较器先比较x在arr2中的索引位置
   - 如果相同，再比较x本身

### 基本思想

- 利用映射把“参照顺序”转为“排序键”，剩余元素自然归为最后一组，再按自身升序。

### 难点分析和应对

映射默认值用 `m = arr2.length`；比较器里要双层判断。

### 代码实现

```java
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i< arr2.length; i++){
            map.put(arr2[i], i);
        }
         Integer[] copy=Arrays.stream(arr1).boxed().toArray(Integer[]::new);
        Arrays.sort(copy, (a,b) -> {
            if (map.containsKey(a) && map.containsKey(b)){
                return map.get(a) - map.get(b);
            }else if (map.containsKey(a) && !map.containsKey(b)){
                return -1;
            }else if (map.containsKey(b) && !map.containsKey(a)){
                return 1;
            }else{
                return a - b;
            }
        });

         for(int i=0;i<copy.length;i++) arr1[i]=copy[i];
         return arr1;
    }
```

### 注意事项和经验

- 当剩余元素需特殊顺序（如降序）时，只要调整第二比较键即可。
- 经验：遇到“让 A 按 B 给定顺序排序”就用“值→索引 映射 + 自定义比较器”。