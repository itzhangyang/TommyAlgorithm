# 区间合并类

| 题型名称        | 高频题         | 适用套路         | 难点                | 模板关键点               |
| --------------- | -------------- | ---------------- | ------------------- | ------------------------ |
| 合并区间        | 56, 57         | 排序 + 线性扫描  | 合并条件边界        | 维护当前合并区间         |
| 区间交集        | 986            | 双指针 + 比较    | 判断交集 + 移动策略 | max(start), min(end)判断 |
| 区间最大重叠数  | 253, 1288, 435 | 排序 + 堆        | 同时事件排序        |                          |
| 插入/不重叠区间 | 57, 1288       | 排序 + 插入/合并 | 插入后多区间合并    | 与 merge 类似处理逻辑    |

## [排序 + 线形扫描]合并区间

给定一组无序的区间，合并所有重叠的区间，返回合并后的列表。

### 问题分析和本质

将重叠区间归并，避免重复或者冲突，典型的区间合并模型

### 难点分析

- 如何判断两个区间是否有交集
- 正确维护合并区间的边界

### 核心思想 - 排序 + 线性扫描

- 按照**起点升序** 排序
- 用**当前合并区间**和下一个区间比较，决定是否合并或者开始新合并

### 实现步骤

1. 按区间起点升序排序。

2. 初始化结果列表，将第一个区间加入。

3. 遍历后续区间，与当前最后一个合并区间比较：

   - 若重叠，更新区间右边界；

   - 若不重叠，加入新区间。

### Leetcode题目

####**56. Merge Intervals**: 区间合并问题

具体过程详细见上述介绍

```Java
//区间合并

class Interval{
    int start;
    int end;
    public Interval(int start, int end){
        this.start = start;
        this.end = end;
    }
}
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b) -> a[0] - b[0]);
        List<Interval> result = new ArrayList<>();
        Interval prev = new Interval(intervals[0][0], intervals[0][1]);
        result.add(prev);
        
        for(int i = 1; i < intervals.length; i++){
            Interval curr = new Interval(intervals[i][0], intervals[i][1]);
            if(curr.start <= prev.end){
                prev.end = Math.max(prev.end, curr.end);
            }else{
                result.add(curr);
                prev = curr;
            }
        }

        int[][] ans = new int[result.size()][2];
        for(int i = 0; i < result.size(); i++){
            ans[i] = new int[]{result.get(i).start, result.get(i).end};
        }
        return ans;

    }
}
```

####**57. Insert Interval**

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` *after the insertion*.

**Note** that you don't need to modify `intervals` in-place. You can make a new array and return it.

##### 核心思路：插入 - 排序 - 合并

- 构造一个新的长度为`n+1`的区间数组`intervals2`
- `intervals2 = intervals + newInterval`
- 将新区间数组按照起点排序
- 采用Leetcode 56的方法对区间进行合并操作

### 模板代码

```java
public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    List<int[]> res = new ArrayList<>();
    for (int[] interval : intervals) {
        if (res.isEmpty() || res.get(res.size() - 1)[1] < interval[0]) {
            res.add(interval);
        } else {
            res.get(res.size() - 1)[1] = Math.max(res.get(res.size() - 1)[1], interval[1]);
        }
    }
    return res.toArray(new int[res.size()][]);
}

```

### 注意事项

- 注意边界条件，如单个区间、无重叠区间。
- 插入区间时不要忘记也要排序。

### 经验总结

- 一旦涉及到合并/重叠区间，**排序是必不可少的第一步**。

- 合并逻辑应聚焦于“重叠区间右端点的更新”。

## [双指针]找出两个区间列表的交集

两个区间数组已排序，找出它们所有重叠（交集）区间。

### 问题本质与分析

双指针问题，需要判断两个有序区间序列之间的交集。

### 难点分析

- 理解如何判断交集及其取值。

- 正确推进两个指针。

### 核心思想与套路

**双指针 + 取最大起点，最小终点**

遍历两个数组，对每对区间：

- 若有交集（**最大起点 <= 最小终点**），则**记录**；
- 谁的终点小，谁的指针向后移动。

### 实现步骤

1. 初始化两个指针`i`,`j`
2. 每次比较`intervalsA[i]`和`intervalsB[j]`
   - 计算交集起点
   - 判断是否有效交集
   - 移动**较小** 终点指针

### 代码套路模板

```java
public int[][] intervalIntersections(int[][] A, int[][] B){
  List<int[]> res = new ArrayList<>();
  int i = 0; j < 0;
  int m = A.length;
  int n = B.length;
  
  while(i < m && j < n){
    int start = Math.max(A[i][0], B[j][0]);
    int end = Math.min(A[i][1], B[j][1]);
    if (start <= end){
      res.add(new ArrayList<>(new int[]{start,end}));
    }
    if (A[i][1] < B[i][1]){
      i++;
    }else{
      j++;
    }
  }
  
  return res.toArray(new int[res.size()][]);
}
```

### 注意事项

- 确保只在存在交集时才加入。
- 双指针不要越界。

### 经验总结

- 判断交集：`start = max(start1, start2)`，`end = min(end1, end2)`。

- 移动指针策略决定效率与正确性。

##[排序 + 堆 + 贪心算法]最大同时重叠区间数

找出某个时刻最多有多少个区间重叠（或某一点被覆盖的次数）。

### 问题本质分析

归约为“扫描线”问题。

### 难点分析

- 如何快速知道某个新的区间是否与已有区间重叠？
- 如何移除已经结束的区间？
- 如何动态维护“当前重叠的区间数量”？

### 核心思想套路 - 排序 + 小顶堆

####  排序 - 按照区间起点升序

1. **按起始时间对所有区间排序**；

#### 小顶堆 - 按照结束时间

1. 使用一个 **小顶堆（按结束时间排序）**，实时维护当前所有“正在进行中的区间”；
2. 每到一个新区间：
   - 移除堆中所有已结束的区间；
   - 将该区间加入堆；
   - 更新当前最大堆大小（即最大重叠数）。

### 实现原理和步骤

1. **按 start 升序** 排序所有区间；
2. 初始化 `PriorityQueue` 按 end 升序排列；
3. 遍历每个区间：
   - 清除所有 `end <= 当前区间start` 的区间（它们已结束）；
   - 把当前区间的 end 入堆；
   - 更新最大堆大小（记录最大同时进行的区间数量）。

### 实现代码

```java
public int minMeetingRooms(int[][] intervals) {
    if (intervals.length == 0) return 0;

    // Step 1: 按 start 升序排序
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

    // Step 2: 创建一个小顶堆，按 end 升序排列
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();

    // Step 3: 遍历所有区间
    int maxRooms = 0;
    for (int[] interval : intervals) {
        int start = interval[0], end = interval[1];

        // 移除所有结束时间 <= 当前 start 的区间
        while (!minHeap.isEmpty() && minHeap.peek() <= start) {
            minHeap.poll();
        }

        // 将当前区间的 end 加入堆
        minHeap.offer(end);

        // 更新最大堆大小（即最大并发数）
        maxRooms = Math.max(maxRooms, minHeap.size());
    }

    return maxRooms;
}

```

### Leetcode 相关题目

| 题号                                                         | 题目名                  |
| ------------------------------------------------------------ | ----------------------- |
| [253](https://leetcode.com/problems/meeting-rooms-ii/)       | Meeting Rooms II        |
| [759](https://leetcode.com/problems/employee-free-time/)     | Employee Free Time      |
| [732](https://leetcode.com/problems/my-calendar-iii/)        | My Calendar III         |
| [2958](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/) | 最多K次重复的最长子数组 |

### 注意事项

- **堆只保存“正在进行”的区间的结束时间**，不要保存整个区间；

- 每次入堆之前，要先弹出所有已经结束的区间；

- 注意排序是必须的前置步骤，尤其是按起点升序；

- 若问“需要的最少会议室数”或“最大重叠数”，答案即为堆的最大 size。

### 经验总结

- 遇到区间重叠/并发场景，优先考虑 **排序 + 小顶堆** 方式，高效维护当前活动集合；

- 与“扫描线”方式相比，堆适合在线实时处理场景；

- 堆中始终是“进行中的会议”，“堆的大小”就是当前需要的资源数（如会议室数量）

### Leetcode 732 我的日程安排表III

 设计一个类 `MyCalendarThree`，它能在你添加日程时，返回当前系统中最多有多少个日程同时发生。

- `MyCalendarThree.book(int start, int end)`：在区间 `[start, end)` 中添加一个日程，返回添加后系统中任意时刻的最大重叠数。

#### 问题本质与分析

本题的核心是**动态维护一系列区间**，实时查询所有区间的重叠峰值

- 与**统计所有区间的最大重叠数**不同，这里需要在线的插入新区间并且更新答案
- 关键操作
  - 插入一个区间
  - 查询当前所有区间在任何时刻的最大重叠数

#### 核心思想与套路 ： 差分数组 + 有序映射

直接维护一个区间列表，每次插入新区间后，暴力检查它与所有已有区间的重叠情况并更新全局计数。

时间复杂度最坏 $O(n^2)$，当调用次数 $n$ 达到数百，仍可通过但已有更优解。

### 差分标记

每一次新增一个预约`[start,end]`，在

##### Option 1：差分数组 + 有序映射

- 定义一个差分数组实现，使用`TreeMap`保存每一个元素的差分;
- 差分数组初始状态为空，因为没有元素加入

```java
class Difference {
        private TreeMap<Integer,Integer>  diff = new TreeMap<>();

        //处理数组区间，给指定区间的数字都+val
        public void increment(int l, int r, int val){
            diff.put(l, diff.getOrDefault(l, 0)+val);

            diff.put(r + 1, diff.getOrDefault(r + 1, 0) - val);
        }

        //计算最大重叠数的方法
        public int getMax(){
            int ongoing = 0;
            int maxOverlap = 0;
            for (int delta : diff.values()){
                ongoing += delta;
                maxOverlap = Math.max(maxOverlap, ongoing);
            }
            return maxOverlap;
        }
    }
```

### 调用差分数组实现区间的实时插入

```java
    private final Difference diff;
    public MyCalendarThree() {
         diff = new Difference();
    }
    
    public int book(int startTime, int endTime) {
         // 半开区间转换为闭区间 [start, end-1]
        diff.increment(startTime, endTime - 1, 1);
        // 返回更新后的最大重叠值
        return diff.getMax();
    }
```



## [排序 + 扫描]区间覆盖判断/插入不重叠区间

在已有区间中，插入一个新的区间，使得最终依然不重叠或覆盖。

### 问题本质分析 - 插入 + 合并

变形的“插入 + 合并”问题，考查对边界处理能力。

### 难点分析

- 插入后可能触发多个合并
- 合并逻辑不能遗漏边界

### 核心思想与套路

排序 + 扫描判断是否合并或者保留。

### Leetcode相关题目

- **57. Insert Interval**
- **1288. Remove Covered Intervals**

### Leetcode 1288 . 删除被覆盖区间

- **输入**：一组闭区间 `intervals[i] = [li, ri]`。
- **输出**：移除被其它区间完全覆盖（即存在区间 [a,b] 使得 `a ≤ li` 且 `ri ≤ b`）后的剩余区间数量。

换言之，就是在一堆区间中，把那些“被包裹”在别人的内部的区间统统剔除，只保留“外层”或“同级”区间，最终返回剩下多少。

#### 核心思想和套路 - 贪心 + 排序

##### 堆所有区间按照起点排序

先对所有区间按照 **左端点升序** 排；

对于左端点相同的区间，按 **右端点降序** 排。

原因：

- 保证任何可能覆盖后续区间的“候选者”都已经出现在遍历之前；
- 对于相同左端点的多个区间，较长（右端点大的）放在前面，不会误把自己短的区间当作覆盖者。

##### 一次遍历计数

- 维护一个变量 `maxR` 记录当前遍历过的区间中最大的右端点。
- 遍历排序后列表，对每个区间 `[l, r]`：
  - 若 `r ≤ maxR`，说明当前区间被之前某个区间覆盖 → **跳过**；
  - 否则，更新 `maxR = r`，并将“剩余区间”计数加 1。

此方法时间复杂度 O(n log n)（排序）+ O(n)（遍历），空间复杂度 O(log n)（排序栈）或 O(1)。

#### 难点分析与应对方法

| 难点               | 解决思路                                                     |
| ------------------ | ------------------------------------------------------------ |
| 排序准则选取       | **左端点升序，右端点降序**。否则对相同左点的短区间会被误判覆盖。 |
| 区间端点相等的处理 | 当左右端点都相同时，二维数组排序需稳定：右端点大的先比较好。 |
| 边界条件           | 区间闭合，需用 `≤` 判断；若用 `<` 反而漏删。                 |

#### 实现原理和步骤

##### 输入检查

##### 区间数组排序

```java
Arrays.sort(intervals, (a,b) a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);
```

##### 遍历维护

- 初始化`int res = 0; maxR = 0`
- 对每个区间`for(int[] in: intervals)`:
  - 如果当前区间终点大于`maxR`：
    - `res++`
    - `maxR = in[1]` 
  - 否则，说明已经被覆盖，不计数

##### 返回结果即可

#### 实现代码

```java
    public int removeCoveredIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a,b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);

        int res = 0;
        int maxR = 0;

        for (int[] in : intervals){
            if (in[1] > maxR){
                res++;
                maxR = in[1];
            }
        }
        return res;
    }
```

#### 注意事项

1. **排序关键**：务必使用 `右端点降序` 处理左端点相同时，否则短区间会错误地当作覆盖了长区间。
2. **端点比较**：因题目为闭区间，判断覆盖条件是 `r_i ≤ r_curr`，而不是 `<`。
3. **数据范围**：LeetCode 上 `li, ri` 最大约 10⁵，int 足够；若更大请考虑 long。
4. **特殊情况**：若所有区间都相同，应保留其中一个。上述排序让最长的（其实都一样）先出现，计数一次即可。

#### 经验总结

- **排序 + 贪心** 是区间问题的高效“万能钥匙”。类似题目还有“合并区间”、“非重叠区间最大数目”等，都可借助相同套路。
- **关键在排**，排序顺序决定后续扫描的正确性；往往需要对“同左不同右”或“同右不同左”做专门的 tie‐break。
- **边界清晰**：对题目给出的“覆盖”或“重合”定义务必精确转换为代码中的 `≤` 或 `<`。
- 通过该题，可体会到：一次排序、一次线性扫描，就可处理“全局覆盖”关系，无需 O(n²) 暴力。掌握后能大幅提升区间类题目的解题效率。