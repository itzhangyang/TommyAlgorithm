| 策略               | 核心思想                                       | 基本原理                                            | 注意事项                                     | 适用题型                                     |
| ------------------ | ---------------------------------------------- | --------------------------------------------------- | -------------------------------------------- | -------------------------------------------- |
| 对撞指针           | 从两端向中间移动指针，通过比较和条件收敛       | 两指针不断移动缩小问题规模，直到相遇或满足条件      | 注意终止条件和指针重合情况                   | 排序数组中的求和问题（如两数之和、三数之和） |
| 快慢指针           | 一个指针快走，一个指针慢走，找规律或环         | 快指针探索、慢指针记录或检测，适合找循环或长度关系  | 防止快指针越界；理解何时更新慢指针           | 链表中的环检测、数组中找重复元素             |
| 滑动窗口           | 维护一个子区间，动态扩展区间                   | 通过右指针扩展窗口，适合求满足条件的最长/最短子数组 | 窗口如何初始化，什么时候扩展或停止           | 最长无重复子串，最小覆盖子串                 |
| 收缩窗口           | 动态扩展+缩小窗口以满足特定条件                | 在滑动窗口基础上增加左指针收缩，不断逼近最优解      | 收缩时需要维护窗口内状态是否合法             | 最小子数组长度，大于等于某个值的最小窗口     |
| 双指针分区类       | 使用两个指针根据情况分隔元素到不同区域         | 双指针在一维数组上根据规则移动，实现原地分类        | 边界处理，分类标准明确                       | 荷兰国旗问题，颜色分类问题                   |
| 双指针遍历两个数组 | 分别在两个数组上移动指针，按顺序处理匹配问题   | 两个数组分别排序后，用两个指针遍历比较              | 确保两个数组有序；处理指针越界问题           | 寻找两个数组交集、归并两个有序数组           |
| 前缀和             | 提前计算累积信息，快速查询某一段的和或其他属性 | 利用累积数组快速计算区间属性，减少重复运算          | 初始化正确；避免溢出；边界区间问题           | 连续子数组和，区间计数问题                   |
| 哈希表             | 使用键值对快速存取、统计或判定元素存在性       | 用字典或集合实现 O(1) 查询、去重、计数等            | 哈希冲突问题；合理选择键和值；注意空间复杂度 | 两数之和，字符统计，元素去重                 |



## 题型与算法策略速查手册

| 题型                                      | 主要策略           | 核心思想                                | 注意事项                               |
| ----------------------------------------- | ------------------ | --------------------------------------- | -------------------------------------- |
| 排序数组求两数之和 / 三数之和             | 对撞指针           | 两端向中间收缩，找到符合条件的组合      | 指针相遇终止，注意边界；排序是前提     |
| 链表检测环 / 查找重复元素                 | 快慢指针           | 一个快一个慢探测规律或环                | 快指针越界检查，慢指针更新条件要正确   |
| 最长无重复子串                            | 滑动窗口           | 维护动态区间，扩展右边界，缩左边界      | 区间状态维护正确，防止漏扩展/漏收缩    |
| 最小覆盖子串 / 子数组长度最小问题         | 收缩窗口           | 扩展+收缩，动态维护满足条件的最优子区间 | 维护窗口内部状态合法性；不要遗漏收缩   |
| 荷兰国旗问题 / 分类排序                   | 双指针分类         | 左右指针分类元素，实现原地分区          | 分类标准清晰，指针不会交错             |
| 两个数组交集 / 合并有序数组               | 双指针遍历两个数组 | 分别遍历两个有序数组，双指针同步移动    | 数组必须有序；注意处理越界情况         |
| 连续子数组求和 / 子数组和为k问题          | 前缀和             | 预处理累积和，快速计算区间属性          | 初始化累积数组；注意溢出问题           |
| 字符串/数组中找特定元素出现次数、是否存在 | 哈希表             | O(1)时间内进行元素频次统计和查找        | 避免哈希冲突；合理处理不存在的元素情况 |

## 双指针类问题

### 滑动窗口

#### 滑动固定窗口

##### Leetcode 643 - 子数组最大平均数

```java
class Solution {
    //找出长度为K平均数最大的子数组，并返回平均值
    public double findMaxAverage(int[] nums, int k) {
        int n = nums.length;
        int[] prefixSum = new int[n];
        prefixSum[0] = nums[0];
        for(int i = 1; i < n; i++){
            prefixSum[i] = prefixSum[i-1] + nums[i];
        }
        int maxSum = Integer.MIN_VALUE;
        int left = 0;
        int right = left + k - 1;
        while (right < n) {
            System.out.println("Right: "+right+",Left: "+ left);
            int sum = prefixSum[right] - prefixSum[left] + nums[left];
            System.out.println("Sum: "+ sum+",K: "+k);
            maxSum = Math.max(sum, maxSum);
            right++;
            left++;
        }
       return (double)maxSum/k;
    }
}
```



#### 滑动伸缩窗口

两个指针维护一个窗口，一边移动右指针扩大窗口，一边移动左指针缩小窗口。

##### **常见场景**

- 最长/最短子串满足某个条件
- 子数组中包含所有目标字符

##### 代码套路模板

```java
int left=0;right=0;
while(right<s.length()){
  //扩展窗口
  char r = s.charAt(right);
  right++;
  
  //判断是否要收缩窗口
  while(/*满足收缩条件*/){
    char l = s.charAt(left);
    left++;
  }
  
  //更新结果
}
```

#### Leetcode 3. 求最长的没有重复字符的子串

注意这个题目中，如果在`map`中发现了当前字符的索引，需要首先**检查索引是否大于或者等于`left`指针**。

因为我们**并没有在left指针移动的时候，删除已经无效的entries**。

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, right = 0, maxLength = 0;

    while (right < s.length()) {
        char r = s.charAt(right);
      // 判断是否出现重复
        if (map.containsKey(r) && map.get(r) >= left) {
          //缩小窗口
            left = map.get(r) + 1;
        }
      // 存储到map中
        map.put(r, right);
      //更新max length
        maxLength = Math.max(maxLength, right - left + 1);
      // 放大窗口
        right++;
    }

    return maxLength;
}
```

注意滑动窗口的一个关键点是考虑：

- 在什么情况下放大或者缩小窗口？
- 如何放大或者缩小窗口？
- 怎样计算窗口的大小 `length=right-left+1`

#### Leetcode 76. 找出包含所有指定字符的最小子串

给你两个字符串 `s` 和 `t`，要求你在 `s` 中找出 **包含 `t` 所有字符的最小子串**。如果有多个，返回第一个找到的那个。如果不存在，返回空字符串 `""`。

**注意**：

- `t` 中的字符可以有重复，比如 `t = "AABC"`，那么你在 `s` 中找到的子串里，必须至少有 2 个 `A`，1 个 `B`，1 个 `C`。
- 子串里的字符顺序无所谓，只要都包含就行。

**例子：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

##### 解题思路总结

这是一个典型的**滑动窗口**的问题

我们需要解决两个问题：

- 确保当前窗口内包含了`t`中所有的字符（满足）条件
- 在满足条件的窗口中，找到最短的一个

所以我们需要做的事情是：

| 步骤                                        | 目的                             |
| :------------------------------------------ | :------------------------------- |
| 用两个指针`left`和`right`来表示一个滑动窗口 | 动态地扩展和收缩窗口             |
| 不断向右移动`right`扩展窗口                 | 直到包含了`T`中所有字符          |
| 然后移动`left`收缩窗口                      | 尽可能地缩小窗口同时保持满足条件 |
| 在满足条件时记录当前最小的子串              | 保证最后拿到最小的               |

##### 实现原理-滑动窗口的两个指针都是从左向右滑动的！

1. 需要统计`t`中每个字符出现的次数
   - 通过一个`needMap` 记录，比如 `t=AABC`, 那么 `map = {'A':2,'B':1,'C':1}`
2. 记录当前窗口中每个字符串出现的次数（`windowMap`）
   - 通过比较`needMap`和`windowMap`,看当前的`windowMap`是否已经满足所有需求
3. 引入一个变量`valid`, 表示有多少种字符满足了要求
   - 当一个字符在`windowMap`种的数量和在`needMap` 中一样多，`valid++`;
   - 当`valid== needWindow.keys.size()`,说明当前窗口满足了要求

##### 通过`for`循环和`right`指针扩展滑动窗口

滑动窗口通过如下`for` 循环中扩展：

```java
for(int right=0;right<s.length();right++){
  /*扩展窗口逻辑开始*/
  //处理新扩展的字符
  char ch = s.charAt(right);
  
  //当当前字符在字符串t中的时候，更新windowMap中当前字符出现的次数
  if (needMap.containsKey(ch)){
    windowMap.put(ch, windowMap.getOrDefault(ch,0)+1);
    if (windowMap.get(ch).intValue == needMap.get(ch).intValue){
      //当前字符出现次数满足条件时，valid++
      valid++;
    }
  }
  /*扩展窗口逻辑结束*/
}
```

#####通过`while`循环和`left`指针收缩窗口

```java
for(....){
  //...扩展窗口逻辑
  /*收缩窗口逻辑开始*/
  
  
  while(valid == needMap.size()){
    //计算更新最小长度子串信息
    int length = right - left + 1;
    if (minLength > length){
      start = left;
      minLength = length;
    }
    
    //减少左指针字符出现次数
    char ch = s.charAt(left);
    if (needMap.containsKey(ch)){
      //如果剩余的字符出现次数已经和字符串t中的出现次数相同，则说明再减一次会导致该字符出现次数不满足条件
      // 注意这里用 equals，避免Integer缓存问题
      if (needMap.get(ch).intValue() == windowMap.get(ch).intValue()){
        valid--;
      }
      //减少左指针字符出现次数
      windowMap.put(ch, windowMap.get(ch)-1);
    }
    
    //移动左指针
    left++;
  }
  /*收缩窗口逻辑结束*/
}
```

##### 返回结果

如果说`minLength` 还是 `Integer.MAX_VALUE`, 则说明没有符合条件的字符串，返回`""`, 否则按照`minLength`和`start`位置返回字符串

```java
return minLength == Integer.MAX_VALUE ? "" : s.substring(start,start+minLength);
```



####  Leetcode 485:最大连续1的个数- 典型的滑动窗口求复合条件的最大/最小子数组/子串

给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。

##### 题目分析-典型的滑动窗口求复合条件的最大/最小子数组/子串

###### 滑动窗口的双指针起始点都是0

###### 遍历方式使用`while` 而不是使用`for 循环`

遍历数组的方式使用while，左右指针在while循环体内根据`if` 条件进行移动

###### 左指针什么时候移动？- **不符合**条件时

当`candidates[right]` **不符合**条件时，做指针移动至`candidates[right+1]`

```java
if (candates[right] 不符合条件){
  int length = right-left;//因为candidates[right]不符合条件，所以符合条件的元素为candidates[left, right-1];
  maxLen = Math.max(length,maxLen); //更新最大子数组长度
  left = right+1;
  right=left;
}
```



###### 右指针什么时候移动？- 符合条件时

- **扩展窗口时：** 当`candidates[right]` **符合条件** 时，右指针持续向右移动一步；

  ```java
  if (candidates[right]符合条件){
    //如果right指针已经到了最右侧的元素，则计算当前窗口的长度, 并更新比较最大长度值
    if (right == candidates.length-1){
      //计算和更新最大长度
      //...
    }
    //向前移动右指针;
  }
  ```

  

- **窗口结束时**：当`candidates[right]` **不符合条件**时，需要同时更新左右指针，如同上面提到的情况：

  ```java
  if (candates[right] 不符合条件){
    int length = right-left;//因为candidates[right]不符合条件，所以符合条件的元素为candidates[left, right-1];
    maxLen = Math.max(length,maxLen); //更新最大子数组长度
    left = right+1;
    right=left;
  }
  ```

###### 左指针是跳跃式前进

一般来说滑动窗口的左指针有两个移动方式：

- **收缩窗口**，采用`渐进`收缩方式，不符合条件的情况下，左指针前移收缩(`left++`)
- **跳跃窗口**，一旦当前窗口不符合条件，放弃当前窗口，进入下一个窗口(`left=right+1`)

##### Edge Case : Right是最后一个元素但是符合条件

这种情况下也需要更新记录信息。

本题目中左指针采取的是`跳跃窗口`的方式

##### 代码实现

```java
public int findMaxConsecutiveOnes(int[] nums){
  int left = 0;
  int maxLen = 0;
  for (int right=0;right>nums.length;right++){
    if (nums[right]==1){
      if (right == nums.length-1){
        length = right -left+1;
        maxLen = Math.max(maxLen,length);
      }
      right++;
    }else{
      int length = right-left;
      maxLen = Math.max(length,maxLen);
      left = right+1;
      right = left;
    }
  }
  
  return maxLen;
}
```

#### Leetcode 438. 找出所有的异位词

```java
```



### 快慢指针

#### 基本原理

一个快指针每次移动两步，一个慢指针每次一步，用于`检测链表中是否有环`的问题

#### 常见场景

- 检测链表中是否有环
- 找链表中点
- 删除链表倒数第n个节点

####代码套路模板

##### 检测链表中是否有环

```java
ListNode slow = head, fast = head;
//注意这里的条件问题
while (fast !=null && fast.next !=null){
  slow = slow.next;
  fast = fast.next.next;
  if (fast == slow) return true;
}
return false;
```

#### 寻找链表的中点

```java
ListNode slow = head, fast = head;
while (fast != null && fast.next != null){
  slow = slow.next;
  fast = fast.next.next;
}
return slow;
```

####Leetcode 141. 检测链表中是否存在环

#### Leetcode 876. 找出链表的中间节点

```java
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
```



#### Leetcode 19. 删除链表的倒数第N个节点

##### 基于快慢指针的方法 - 存在一定难度

要删除一个节点，我们必须找到它的**前一个节点**。

######快慢指针的思路：

1. 我们设置两个指针，一个 `fast`（快指针）和一个 `slow`（慢指针），都从链表的起点开始。
2. 我们先让 `fast` 指针向前移动 `n` 步。这样，`fast` 和 `slow` 之间就形成了一个 `n` 个节点的“窗口”。
3. 然后，我们同时移动 `fast` 和 `slow` 指针，一步一步向前，直到 `fast` 指针到达链表的末尾（即 `fast.next == null`）。
4. 由于 `fast` 和 `slow` 之间始终保持着 `n` 个节点的距离，当 `fast` 到达链表末尾时，`slow` 指针所在的位置正好是**待删除节点的前一个节点**。
5. 此时，我们只需要执行 `slow.next = slow.next.next` 就可以删除目标节点了。

###### 边缘情况：删除头节点

如果我们要删除的是头节点（例如，链表长度为 5，删除倒数第 5 个），那么 `slow` 指针最终应该指向头节点之前的位置。

但头节点没有前驱节点，这会使代码变得复杂。

为了优雅地处理这种情况，我们可以使用一个**哨兵节点 (Dummy Node)**。

- 创建一个 `dummy` 节点，让它的 `next` 指向原始链表的 `head`。
- 让 `slow` 和 `fast` 指针都从 `dummy` 节点开始。
- 这样，即使是删除头节点，`slow` 最终也会停在 `dummy` 节点上，我们可以安全地执行 `dummy.next = dummy.next.next`，从而返回新的头节点。

###### 快慢指针的实现代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;

        ListNode slow = dummy;
        ListNode fast = dummy;

        for(int i = 0; i < n; i++){
            fast = fast.next;
        }

        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



#####基于HashMap的解决方法 - 性能低但是较容易实现

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        Map<Integer, ListNode> indexMap = new HashMap<>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        indexMap.put(0, dummy);
        ListNode p = head;
        int i = 1;
        while (p != null) {
            indexMap.put(i, p);
            p = p.next;
            i++;
        }
        int len = i - 1;
        // 1,2,3,4,5
        int index = len - n + 1;
        ListNode prev = indexMap.get(index - 1);
        ListNode next = indexMap.get(index + 1);
        prev.next = next;
        return dummy.next;
    }
}
```



#### Leetcode 160 找出相交链表的交点

给你两个单链表 `headA` 和 `headB`，找出它们相交的起始节点。如果两个链表没有交点，返回 `null`。

**注意**：

- 相交是指**节点地址**相同，不是节点值相同。
- 要求时间复杂度是 O(n)，空间复杂度是 O(1)。

```
A:       a1 → a2
                  ↘
                   c1 → c2 → c3
                  ↗            
B: b1 → b2 → b3
```

返回节点 `c1`。

如果 A、B 没有交点，就返回 `null`。

##### 解题思路

最核心的一点是：

**链表的后半部分如果相交了，那么交点之后是完全一致的**

##### 解决方案一：基于推导归纳方法

###### 核心思想 - 推导归纳

两个人在一条直线跑道上，在不同的起点出发，来回跑，则他们是一定会相遇的。

`PA`跑的路线就成了 `ac->a2-C1->c2->c3->b1->b2->b3->c1->c2->c3`

`PB`跑的路线就成了 `b1->b2->b3->c1->c2-c3->a1->a2->c1-c2->c3`

从上面的过程来看，他们最终会相遇到一个点上

设置两个指针`pA`, `pB`,分别从`hdeadA`、`headB`出发

- If `pA` arrives the tail of linked list `A`, then jump to `headB`
- If `pB` arrives the tail of linked list `B`, then jump to `headA`
- Then the length of the path should be the same: `Length of A + Length of B`
- If there is an `Intersection`, the two points should meet on the `intersection `
- If there is no `intersection`, the points will finally arrive to `null`

###### The code implementation 



```java
public ListNode getIntersection(ListNode headA, ListNode headB){
  if (headA == null || headB == null) return null;
  
  ListNode pA = headA;
  ListNode pB = headB;
  
  while (pA != pB){
    pA = pA==null ? headB : pA.next;
    pB = pB == null ? headA : pB.next;
  }
  
  return pA;
}
```

##### 解决方案二： 快慢指针方法

###### 核心思想

- 分别求出A,B的长度`lenA`和`lenB`
- 让长链表先走`|lenA-lenB|`步
- 然后A， B同时向后走，一定在交点相遇

###### 实现代码

```java
    //快慢指针
    //长度差法，走完交换链表头
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        int lenA = length(headA);
        int lenB = length(headB);
        ListNode pA = headA;
        ListNode pB = headB;
        //如果A表表更长，则A指针先走diff步
        if (lenA > lenB){
            int diff = lenA-lenB;
            while (diff>0) {
                pA = pA.next;
                diff--;
            }
        //如果B链表更长，则B指针先走diff步
        } else if (lenA <lenB) {
            int diff = lenB-lenA;
            while (diff >0) {
                pB = pB.next;
                diff--;
            }
        }
				//同时移动A指针和B指针
        while (pA != pB) {
            pA = pA.next;
            pB = pB.next;
        }
				//如果A指针和B指针指向相同节点，则返回结果
        if (pB == pA) return pA;
      	//否则返回null
        return null;
        
    }

    private int length(ListNode head){
        int length=0;
        ListNode p = head;
        while (p!=null){
            length +=1;
            p=p.next;
        }
        return length;
    }
```

#### Leetcode 142 环形链表II-找到链表上环的入口

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 

为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。

如果 `pos` 是 `-1`，则在该链表中没有环。

**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

##### 详细讲解

这个题目可以分为两步理解：

- 判断链表是否有环
- 如果有环，找到环的起点

这两个步骤可以使用**快慢指针** 完成

###### 判断是否有环

设置两个指针：

- **慢指针：** 每次走一步
- **快指针：** 每次走两步

如果有环，快慢指针一定会为某个时刻相遇

如果没有环，快指针会先达到`null`,终止循环

###### 找到环的入口

假设：

- 链表上起点到环的入口的距离是`a`
- 环的入口节点到相遇节点的距离是`b`
- 从相遇点再绕回入口的距离是`c`, 那么整个环的周长是$b+c$

因为在相遇的时候：

- 慢指针走过的路程是$a + b$ (起点到入口的距离 + 入口到相遇点的距离)
- 快指针走过的路程是$a+b+n\times(b+c)$

因为快指针走的步数是慢指针的两倍，因此有

$2(a+b)=a+b+n\times(b+c)$

整理一下之后得出：

`a+b=n(b+c)`

$a+b = n\times(b+c)$

进一步推到得

$a=(n-1)(b+c)+c$

**重要结论**

- 从链表头节点出发(走`a`步) 和
- 从相遇点出发(走`c`步) 

他们会在环的起点相遇

##### 解题步骤总结

1. 用快慢指针，判断表中是否有环
2. 如果有环，让一个指针从**链表头**开始走，另外一个指针从**相遇点**走，每次走一步
3. 他们相遇的地方就是环的起点

##### 代码实现

```java
public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;

        // 第一步：判断是否有环
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // 快慢指针相遇，说明有环
            if (slow == fast) {
                // 第二步：寻找环的入口
                ListNode p1 = head;
                ListNode p2 = slow;

                while (p1 != p2) {
                    p1 = p1.next;
                    p2 = p2.next;
                }

                return p1; // 返回环的入口
            }
        }
        // 无环
        return null;
    }
```



###双指针遍历两个数组

#### 基本原理

两个指针分别遍历两个有序数组，用于合并、查找交集等

#### 常见场景

- 合并两个有序数组
- 查找两个有序数组的交集
- 两个数组中的最小差值对

####代码实现

```java
int i=0, j=0;
while (i< arr1.length && j< arr2.length){
  if (arr1[i] < arr2[j]){
    //选择 arr1[i]
    i++;
  }else{
    //选择 arr2[j]
    j++;
  }
}
```

#### Leetcode 88. 原地合并两个有序数组

##### 问题要点 - 原地合并两个有序数组

问题的本质是**合并两个已排序的序列**。这是归并排序（Merge Sort）算法中的核心“合并”步骤。

然而，本题增加了一个关键限制：**原地合并**，并且 `nums1` 数组的末尾有足够的空间。

这个限制是解题的关键。

###### 从前到后的归并 - 性能问题

如果我们采用常规的合并思路，从前往后处理：

1. 设置两个指针，分别指向 `nums1` 的开头 (`i=0`) 和 `nums2` 的开头 (`j=0`)。
2. 比较 `nums1[i]` 和 `nums2[j]` 的大小。
3. 将较小的元素放到 `nums1` 的正确位置。

这里会遇到一个致命问题：如果 `nums2[j]` 比 `nums1[i]` 小，我们需要将 `nums2[j]` 插入到 `nums1[i]` 的位置。

但这会**覆盖**掉 `nums1[i]` 原本的值。为了不丢失数据，我们必须将 `nums1` 中从 `i` 开始的所有 `m` 个元素都**向后移动一位**，为 `nums2[j]` 腾出空间。

这个移动操作的时间复杂度是 $O(m)$，如果在最坏情况下（`nums2` 的所有元素都比 `nums1` 的小），每次插入都需要移动，总时间复杂度会达到 $O(m\times{n})$，效率非常低。

###### 从后向前的归并过程

既然从前往后合并会产生覆盖问题，我们应该如何利用 `nums1` 末尾的空闲空间呢？

 答案是：**从后往前合并**。

我们可以把 `nums1` 的末尾 `(m+n-1)` 的位置看作是最终合并后数组的最大元素应该存放的地方。

我们可以比较 `nums1` 和 `nums2` 中的**最大**元素，将其中较大者放到这个最终位置。

这样一来，我们填充的是 `nums1` 末尾的 `0`，不会覆盖任何还未比较的有效数据。

##### 背景知识

###### 双指针

这是一种非常常见且高效的算法技巧，通常用于处理数组或链表问题。

通过使用两个（或多个）指针在数据结构中移动，可以在线性时间内完成很多需要嵌套循环才能解决的问题。

在本题中，我们实际上会用到**三个指针**：一个指向 `nums1` 有效元素的末尾，一个指向 `nums2` 的末尾，还有一个指向 `nums1` 整个数组的末尾（用于写入）。

###### 原地算法

指在不使用额外数据结构（或只使用常数级别的额外空间，即 O(1) 空间复杂度）的情况下，直接在原始数据结构上进行修改来完成计算的算法。这是衡量算法空间效率的一个重要指标。

###### 归并排序

本问题是归并排序算法核心步骤的简化版。

理解归并排序的思想有助于更好地理解这个问题的重要性。

在标准的归并排序中，合并步骤通常需要一个**辅助数组**来避免原地合并的复杂性。

##### 核心思想和套路

###### 设置三个指针

- `p1`: 指向 `nums1` 的有效元素末尾，初始值为 `m - 1`。
- `p2`: 指向 `nums2` 的末尾，初始值为 `n - 1`。
- `p`: 指向 `nums1` 数组的最末端（即写入位置），初始值为 `m + n - 1`。

###### 从后向前的遍历和填充

当 `p1` 和 `p2` 都有效时（即都 `>= 0`），比较 `nums1[p1]` 和 `nums2[p2]`。

将两者中较大的值复制到 `nums1[p]` 的位置。

将被选中的那个元素的指针向前移动一位（`p1--` 或 `p2--`）。

写入指针 `p` 也向前移动一位（`p--`）。

###### 处理剩余元素

- 循环结束后，`p1` 和 `p2` 中可能有一个还没有遍历完（另一个已经变为 `-1`）。
- **如果 `p1` 没遍历完**：**不需要任何操作**。因为 `nums1` 的前半部分本来就是有序的，且这些剩余元素比所有已放入的元素都小，它们已经处在正确的位置。
- **如果 `p2` 没遍历完**：说明 `nums2` 中还有一些更小的元素。需要将这些剩余元素依次复制到 `nums1` 的前部（从 `p` 指针当前位置开始）。

这个“只需处理 `nums2` 剩余部分”的结论是本算法的一个优雅之处。

##### 实现原理和步骤

**初始化指针**:

- `p1 = m - 1`
- `p2 = n - 1`
- `p = m + n - 1`

**主循环**:

- `while (p1 >= 0 && p2 >= 0)`:
  - `if (nums1[p1] > nums2[p2])`:
    - `nums1[p] = nums1[p1]`
    - `p1--`
  - `else`:
    - `nums1[p] = nums2[p2]`
    - `p2--`
  - `p--`

**收尾循环**:

- `while (p2 >= 0)`: (处理 `nums2` 的剩余部分)
  - `nums1[p] = nums2[p2]`
  - `p2--`
  - `p--`

**结束**: 函数执行完毕，`nums1` 已被修改为合并后的排序数组。

##### 实现代码

```Java
class Solution {
    //合并两个有序数组nums1和nums2
    //本质上不允许说用中间变量，而是将num2合并进nums1
    //函数是void的
    //使用双指针方案，先合并，然后分区交换
    //应当避免每一次操作都移动大量的元素，如何避免呢？
    //也就是说应当保持两个数组中的元素的相对位置不变
    // 1 3 5 7 9
    // 2 4 6 8 10
    // 正向遍历的时候会发生元素被覆盖的问题
    // 反过来遍历
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        //反过来遍历nums1和nums2
        while(i >= 0 && j >= 0){
            if(nums1[i] > nums2[j]){
                nums1[k] = nums1[i];
                i--;
            }else{
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        //如果nums1没有遍历完成,不需要做任何事情，因为已经在位置上了
        //如果nums2没有遍历完成，继续将剩余的nums2元素放入nums1的前面
        while(j >= 0){
            nums1[k] = nums2[j];
            k--;
            j--;
        }
        
    }
}
```

##### 注意事项

1. **指针初始化**: 指针必须指向有效的**索引**，所以是 `length - 1`，即 `m-1`, `n-1`, `m+n-1`。这是一个常见的 `off-by-one` 错误点。
2. **循环条件**: 主循环的条件是 `p1 >= 0 && p2 >= 0`，确保两个数组都还有元素可供比较。
3. **处理剩余元素**: 深刻理解为什么只需要检查 `p2` 的剩余部分，而不需要检查 `p1`。这是因为如果 `nums1` 有剩余，它们本身就在 `nums1` 里，并且位置是正确的。
4. **边缘情况**:
   - `m = 0`: 此时 `p1` 初始为 `-1`，主循环不执行。后续的收尾循环会将 `nums2` 的所有元素复制到 `nums1`，正确。
   - `n = 0`: 此时 `p2` 初始为 `-1`，两个循环都不执行，`nums1` 保持不变，正确。

##### 经验总结

- **逆向思维是解决原地修改问题的利器**。当正向操作会导致数据覆盖和大量移动时，检查是否可以从后向前操作。

- **双指针（或多指针）是数组问题的瑞士军刀**。通过精确地控制指针的初始位置、移动逻辑和终止条件，可以用简洁高效的方式解决复杂问题。

- **画图模拟**: 对于指针操作类的题目，在纸上画出数组和指针，手动模拟一遍算法流程，是理解算法和查错的最佳方式。模拟一下普通情况和 `m=0` 或 `n=0` 等边缘情况，可以加深理解。

- 此题是面试中的“热身”或“筛选”题，要求能够快速、准确地写出无误的代码。**将其作为模板记在心里**，可以为后续更难的题目赢得时间。



####Leetcode 350. 求两个数组的交集 II

题目 **350. 两个数组的交集 II（Intersection of Two Arrays II）** 要求找出两个数组中**所有相同的元素**，**每个元素出现的次数**应与其在两个数组中出现次数的**最小值一致**。

这个问题可以有两种解法，一种是基于`HashMap`计算，一种是基于双指针。

##### 基于双指针的解决方案

对两个数组都排序。

使用两个指针分别从两个数组头部开始遍历，遇到相同的元素就加入结果，并都向前移动；

如果一个小就移动那个数组的指针。

###### 基本思路：排序+双指针 - 更高效

1. 对两个数组都进行排序
2. 使用两个指针分别从两个数组的头部开始遍历，
   1. 遇到相同的元素就加入到结果，两个数组的指针同时向前移动
   2. 如果元素不同，则向前移动较小元素所在数组的指针

###### 为什么 排序+数组的方式可以做到`每个元素出现的次数为出现次数较小的值`？

因为排序让相同元素**排在一起**，而双指针的移动方式保证了：

- 每当找到相等的元素时，**两个指针都前进**，**记录一次匹配**；
- 一旦某个元素在某数组中用完了，另一个数组中剩下的就不会再匹配到这个元素。

换句话说：**每次匹配只能发生一次，两个指针一起动，自动限制了匹配次数最多为两者中较小的那个。**

###### 代码实现

```java
public int[] intersect(int[] nums1, int[] nums2){
  Arrays.sort(nums1);
  Arrays.sort(nums2);
  
  List<Integer> list = new ArrayList<>();
  int i=0,j=0;
  while (i<nums1.length && j< nums2.length){
    if (nums1[i] == nums2[j]){
      list.add(nums1[i]);
      i++;
      j++;
    }else if (nums1[i]<nums2[j]){
      i++;
    }else{
      j++;
    }
  }
  
  int[] res = new int[list.size()];
  for (int k=0;k<list.size();k++){
    res[k]=list.get(k);
  }
  return res;
}
```

##### 基于哈希表的实现方案

###### 实现代码

```java
class Solution {
    //给定两个数组nums1和nums2,求交集
    //结果中的每一个元素应当和他们在两个数组中同时出现的次数一样
    //你可以以任何顺序返回结果

    //本质和分析
    //题目并未说明数组是否排序
    //尝试采用双指针的方式？ 还是哈希表的方式？
    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> counter1 = new HashMap<>();
        for(int num : nums1){
            counter1.putIfAbsent(num,0);
            counter1.put(num, counter1.get(num) + 1);
        }

        Map<Integer, Integer> counter2 = new HashMap<>();
        for(int num : nums2){
            counter2.putIfAbsent(num,0);
            counter2.put(num, counter2.get(num) + 1);
        }
        List<Integer> res = new ArrayList<>();
        for(Map.Entry<Integer, Integer> e : counter1.entrySet()){
            int num = e.getKey();
            if(counter2.containsKey(num)){
                int times = Math.min(e.getValue(), counter2.get(num));
                for(int i = 0; i < times; i++){
                    res.add(num);
                }
            }
        }

        int[] ans = new int[res.size()];
        for(int i = 0; i < res.size();i++){
            ans[i] = res.get(i);
        }
        return ans;
    }
}
```



#### Leetcode 986. 求两个有序区间列表的交集

给定两个由一些 **闭区间** 组成的列表，`firstList` 和 `secondList` ，其中 `firstList[i] = [starti, endi]` 而 `secondList[j] = [startj, endj]` 。每个区间列表都是成对 **不相交** 的，并且 **已经排序** 。

返回这 **两个区间列表的交集** 。

形式上，**闭区间** `[a, b]`（其中 `a <= b`）表示实数 `x` 的集合，而 `a <= x <= b` 。

两个闭区间的 **交集** 是一组实数，要么为空集，要么为闭区间。例如，`[1, 3]` 和 `[2, 4]` 的交集为 `[2, 3]` 。

###### 基本原理-双指针数组

定义两个指针，指针`i`用在第一个区间，指针`j`用在第二个区间

- 如果说`firsList[i]`区间小于`secondList[j]`,向前移动指针`i`
- 如果`firstList[i]`区间大于`secondList[j]`,向前移动指针`j`
- 如果两个区间出现交集，需要生成一个`intersection`
  - `intersection`的起点选择两个区间起点中的较大者
  - `intersection`的终点选择两个区间中的较小者

###### 注意：怎么处理一个区间和多个区间可能交集的情况？

我们需要考虑来自A区间列表的某个区间跟来自区间列表B中的`多个区间`存在交集的情况.

这种情况下，我们需要判断哪一个区间是先结束的，则移动哪一个对应的指针。

- `firstList[i]`的区间终点小于`secondList[j]`的终点，则向前移动指针`i`
- `secondList[j]`的区间终点小于`firstList[i]`的终点，则向前移动指针`j`

###### 代码实现

```java
class Intersection{
  int start;
  int end;
  public Intersection(int start, int end){
    this.start=start;
    this.end=end;
  }
}

public int[][] intervalIntersection(int[][] firstList, int[][] secondList){
  List<Intersection> intersections = new ArrayList<>();
  int i=0,j=0;
  
  while(i<firstList.length && j< secondList.length){
    int[] first = firstList[i];
    int[] second = secondList[j];
    
    if (first[1] < second[0]){
      i++;
    }else if(first[0]>second[1]){
      j++;
    }else{
      int start = Math.max(first[0],second[0]);
      int end = Math.min(fist[1],second[1]);
      intersections.add(new Intersection(start,end));
      //怎么处理一个区间和多个区间可能交集的情况？
      if (first[1]< second[1]){
        i++;
      }else{
        j++;
      }
    }
  }
}
```

#### Leetcode 844: 比较含退格的字符

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

##### 基本思路

对于每一个字符串，`从后往前`遍历，跳过被删掉的字符，直接比较有效字符

##### 具体实现

1. 设定两个指针`i`和`j`,分别从`s`和`t`的**最后一位**开始
2. 对于每个字符串
   - 如果遇到`#` ,就增加一个`skip` 计数器，表示需要跳过几个字符
   - 如果 `skip>0`,跳过当前字符, `skip--`
   - 直接找到一个有效字符
3. 比较当前指向的两个有效字符是否相同
   - 如果不同，返回`false`
   - 如果相同，则继续
4. 如果都遍历完成，返回`true`;

##### 代码实现

这个题目属于非典型的双指针在两个数组上遍历的例子，两个指针指向的数组的比较方式本质上跟**套路模板**是一样的

###### 套路模板复习

```
int i=0, j=0;
while (i< arr1.length && j< arr2.length){
  if (arr1[i] < arr2[j]){
    //选择 arr1[i]
    i++;
  }else{
    //选择 arr2[j]
    j++;
  }
}
```



```java
    public boolean backspaceCompare(String s, String t) {
        int i = s.length() - 1, j = t.length() - 1;
        int skipS = 0, skipT = 0;
        
        while (i >= 0 || j >= 0) {
            // 处理字符串s
            while (i >= 0) {
                if (s.charAt(i) == '#') {
                    skipS++;
                    i--;
                } else if (skipS > 0) {
                    skipS--;
                    i--;
                } else {
                    break;
                }
            }
            
            // 处理字符串t
            while (j >= 0) {
                if (t.charAt(j) == '#') {
                    skipT++;
                    j--;
                } else if (skipT > 0) {
                    skipT--;
                    j--;
                } else {
                    break;
                }
            }
            
            // 比较有效字符
            if (i >= 0 && j >= 0) {
                if (s.charAt(i) != t.charAt(j)) {
                    return false;
                }
            } else {
                // 其中一个字符串遍历完了，另一个没有，说明不等
                if (i >= 0 || j >= 0) {
                    return false;
                }
            }
            i--;
            j--;
        }
        
        return true;
    }
```

#### Leetcode 1213. 三个有序数组的交集-多指针遍历多数组

给出三个均为 **严格递增排列** 的整数数组 `arr1`，`arr2` 和 `arr3`。返回一个由 **仅** 在这三个数组中 **同时出现** 的整数所构成的有序数组。

##### 解题思路

这道题的关键是：**三个数组都是升序的递增排列**

所以我们可以使用 **三个指针**的方法来解：

- `i`,`j`,`k`分别指向 `arr1`,`arr2`,`arr3`的当前位置
- 比较`arr1[i]`、`arr2[j]`、`arr3[k]`：
  - 如果相等，说明找到了一个公共元素，加入结果集，然后三个指针同时后移一位
  - 如果不想等，则谁最小，谁往前移动，因为小的元素不可能再跟大的匹配了，得跳到更大的元素

因为数组是**升序**的，小的值即使后移，后面可能还会遇到相同的值。但当前小的值绝对不会再跟大的值匹配成功了，所以直接移动小的值指针是正确的。

##### 代码实现

```java
    //三个数组三指针同步前进
    public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {
        int i=0,j=0,k=0;
        List<Integer> list = new ArrayList<>();
        while (i< arr1.length && j< arr2.length && k < arr3.length) {
            int a = arr1[i]; int b = arr2[j]; int c = arr3[k];

            if (a==b && b==c){
                list.add(a);
                i++;
                j++;
                k++;
            }else{
                int min = Math.min(a, Math.min(b, c));
                if (min == a){
                    i++;
                } else if (min ==b){
                    j++;
                }else{
                    k++;
                }
            }
        }
        return list;
    }
```



###窗口收缩类

#### 基本思路-先扩展再缩小

窗口先扩展到符合条件，再逐步缩小以找到最优解

#### 常见场景

- 最小子数组长度
- 移除无效字符

#### 代码套路模板

```java
int left=0,sum=0,minLen=Integer.MAX_VALUE;
for (int right=0;right < nums.length;right++){
  sum +=nums[right];
  while (sum >=target){
    minLen = Math.min(minLen, right-left+1);
    sum -=nums[left];
    left++;
  }
  
  return minLen == Integer.MAX_VALUE? 0:minLen;
}
```

#### Leetcode 11: 盛最多水的容器

```java
  //对撞指针，左右向中间收缩，每次计算当前面积
    public int maxArea(int[] height) {
        int left=0,right=height.length-1;
        int maxArea=Integer.MIN_VALUE;
        while (left<right) {
            int area = calculateArea(left, right,height[left],height[right]);
            if (area>maxArea){
                maxArea=area;
            }
            if (height[left]<height[right]){
                left++;
            }else{
                right--;
            }
        }
        return maxArea;
    }
```

####Leetcode 209. 求和大于某值的最小子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

##### 复习窗口收缩的套路模板

```java
int left=0,sum=0,minLen = Integer.MAX_VALUE;
for (int right=0;right<nums.length;right++){
  sum += nums[right];
  
  while (sum >= target){
    minLen = Math.min(minLen, right-left+1);
    sum -= nums[left];
    left++;
  }
  
  return minLin == Integer.MAX_VALUE ? 0 : minLen;
}
```

##### 实现代码

```Java
class Solution {
    //和大于target的最小子数组
    //滑动收缩窗口 + 前缀数组 套路
    //
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int[] prefixSum = new int[n];
        prefixSum[0] = nums[0];
        for(int i = 1; i < n; i++){
            prefixSum[i] = prefixSum[i-1] + nums[i];
        }

        int left = 0;
        int minLen = Integer.MAX_VALUE;
        for(int right = 0; right < n; right++){
            int sum = prefixSum[right] - prefixSum[left] + nums[left];
            //当sum >= target的时候，尝试继续收缩Left指针，一直到不满足条件为止
            while (sum >= target && left <= right){
                int len = right - left + 1;
                minLen = Math.min(minLen, len);
                left += 1;
                if(left < n){
                    sum = prefixSum[right] - prefixSum[left] + nums[left];
                }
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

##### 经验总结 - 窗口收缩逻辑的逻辑总结

###### 通过left指针前移实现窗口收缩逻辑

###### 计算符合条件的最优值的时候

先记录符合条件的记录，再移动left指针

###### 列举符合条件的值的时候

先收缩指针，再保存符合条件的值

#### Leetcode 239. 滑动窗口最大值 - 单调队列

但是本题最适合的是**单调队列**。

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

```java
class Solution {
    //滑动窗口最大值，应该是单调队列？
    //单调队列是基于双端队列实现的
    //我们设置一个单调递减
    //每次新元素入队的时候，删除队尾比其小的元素，然后入队
    //配合滑动窗口
    //滑入一个元素的时候，将元素按照上述入队逻辑入队
    //滑出一个元素的时候，将元素索引和队首值比较，如相等，则出队
    //求窗口最大值，peek队首元素即可
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> decreaseQueue = new LinkedList<>();
        int left = 0;
        List<Integer> list = new ArrayList<>();
        for(int right = 0; right < n; right++){
            //删除队尾比当前元素小的元素
            while(!decreaseQueue.isEmpty() && nums[decreaseQueue.peekLast()] < nums[right]){
                decreaseQueue.pollLast();
            }
            //将当前元素入队
            decreaseQueue.offer(right);

            //检查窗口大小是否超过k
            //超过k则滑出左侧元素
            int len = right -left + 1;
            while(len > k){
                if(decreaseQueue.peekFirst() == left){
                    decreaseQueue.pollFirst();
                }
                left++;
                len = right -left + 1;
            }
            if(len == k){
                list.add(nums[decreaseQueue.peekFirst()]);
            }
        }
       int[] ans = new int[list.size()];
       for(int i = 0; i < list.size(); i++){
        ans[i] = list.get(i);
       }
       return ans;
    }
}
```



##### 经验总结

###### 单调队列中存储的是索引而不是元素值本身！



#### Leetcode 697.数组的度-收缩窗口+哈希计数

给定一个非空且只包含非负数的整数数组 `nums`，数组的 **度** 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 `nums` 中找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。

###### 解题思路

1. 先扫描整个数组，得到原来数组的度；
2. 使用滑动窗口[left,right]在数组上滑动
   1. 使用一个map统计窗口内元素的频率
   2. 每次窗口内某个元素频率达到原来数组的度的时候，判断当前窗口是否满足要求；
   3. 如果满足（窗口内的最大频率==原来数组的度），记录最短长度

######  窗口扩展和收缩的逻辑

1. 每次扩展窗口道右边（增加一个元素后）
   - 更新窗口频率
   - 检查此时是否有元素频率为原数组的度
2. 如果满足条件（窗口中某个元素的频率==原数组的度）
   - 尝试收缩左边界`left`, 希望能够变短窗口长度但是仍然满足条件。
3. 收缩时怎么判断可以继续？
   - 每次收缩，就把`windowFreqMap[nums[left]]--`
   - 然后再次判断窗口中的最大频率是不是还是==原来数组的度

###### 实现代码

```java
public int findShortestSubArray(int[] nums){
  //计算当前数组的度
  Map<Integer,Integer> frequencyMap = new HashMap<>();
  int degree=0;
  for (int num:nums){
    frequencyMap.putIfAbsent(num,0);
    int frequency = frequencyMap.get(num)+1;
    degree = Math.max(degree,frequency);
    frequencyMap.put(num,freqquency);
  }
  
  int left=0;
  //初始化最小长度的值为数组的长度
  int minLen = nums.length;
  //定义窗口的frequency map
  Map<Integer,Integer> windowFreqMap = new HashMap<>();
  for (int right=0;right<nums.length;right++){
    //扩展窗口
    windownFreqMap.putIfAbsent(num,0);
    int windowFreq = windowFreqMap.get(num)+1;
    windowFreqMap.put(num,windowFreq);
    //如果windownFreq和degree相同，尝试收缩窗口
    if (while windowFreqMap.get(num) == degree){
      //1. 计算当前窗口的度
      int windowDegree=0;
      for (int freq:windowFreqMap.values()){
        maxFreq = Math.max(windowDegree,freq);
      }
      //2. 如果当前窗口的度和数组的度相同，则更新最小长度
      if (windowDegree == degree){
        minLen = Max.min(maxLen, right-left+1);
      }
      //3. 收缩窗口
      int leftNum = nums[left];
      //3.1 减少左元素的窗口频率
      windowFreqMap.put(leftNum,windowFreqMap.get(leftNum)-1);
      //3.2 左指针前移
      left++;
    }
    
  }
}
```

#### Leetcode 1004 统计最大连续1个数III

给定一个二进制数组 `nums` 和一个整数 `k`，假设最多可以翻转 `k` 个 `0` ，则返回执行操作后 *数组中连续 `1` 的最大个数* 。

##### 基本思路-窗口收缩

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int n = nums.length;
        int left = 0;   // 窗口左边界
        int zeros = 0;  // 窗口内 0 的数量
        int ans = 0;    // 最大长度

        // right 指针作为窗口的右边界，不断向右扩张
        for (int right = 0; right < n; right++) {
            // 将新元素纳入窗口
            if (nums[right] == 0) {
                zeros++;
            }

            // 当窗口不满足条件时（0的数量 > k），收缩左边界
            // 使用 while 是因为可能需要不止一次收缩
            while (zeros > k) {
                // 将左边界元素移出窗口
                if (nums[left] == 0) {
                    zeros--;
                }
                // 左边界向右移动
                left++;
            }

            // 经过上面的循环，当前 [left, right] 窗口一定是满足条件的
            // 计算当前窗口的长度，并更新最大值
            ans = Math.max(ans, right - left + 1);
        }

        return ans;
    }
}
```

##### 算法策略总结：可变长度滑动窗口（Variable-length Sliding Window）

###### 标准套路

```java
while(right<nums.length){
  if (nums[right]影响是否合法){
    调整可控变量，比如k--;
  }
  
  while(窗口不合法，比如k<0){
    if(nums[left]有关控制变量){
      恢复控制变量，比如k++;
    }
    left++;
  }
  
  //更新答案
  maxLen =Math.max(maxLen,right-left+1);
  
  right++;
}
```

###### 核心思想

- `right`负责扩展窗口
- 如果窗口失去合法性(比如反转的次数用光了），就用`left`收缩窗口，直到重新合法
- 每次移动完`right`后，都可以安全的更新最大区间

###### 适合的场景

| 类型                                          | 说明                                            |
| --------------------------------------------- | ----------------------------------------------- |
| 有一段连续区间，需要满足某种**最大/最小条件** | 比如：最长子数组、最短子串                      |
| 区间内元素满足**限制条件**                    | 比如：最多k次操作、最多k个不同字符、最多k次替换 |
| 允许**部分不满足**但数量有限                  | 比如：允许k个错误、允许k个替换、允许k次删除     |

###### 典型例子

| 题目                                                         | 场景描述                        |
| ------------------------------------------------------------ | ------------------------------- |
| 1004. Max Consecutive Ones III                               | 翻转k个0，找最长连续1           |
| 424. Longest Repeating Character Replacement                 | 替换k个字符，找最长重复字符子串 |
| 995. Minimum Number of K Consecutive Bit Flips               | 最少翻转次数使数组全为1         |
| 3. Longest Substring Without Repeating Characters（稍有变化） | 不重复字符的最长子串，k相当于0  |

### At-Most滑动窗口

#### At-Most滑动窗口的核心思想 - $恰好为K = AtMost(K) - AtMost(K-1)$ 

将一个复杂的 “恰好为 k” 的问题，转化为两个相对简单的 “至多为 k” 的问题来求解。

其背后的数学逻辑非常简单：

```
恰好为 k 的数量 (exactly k) = 至多为 k 的数量 (at most k) - 至多为 k-1 的数量 (at most k-1)
count(exactly k) = count(at most k) - count(at most k-1)
```

举个例子，假设我们要在一个数组中寻找满足“恰好有3个不同整数”的子数组数量。

直接计算会非常麻烦，因为当窗口内不同整数数量超过3时，你需要收缩窗口，但收缩到什么程度才能恰好变回3，这个边界很难判断。

而 “至多为 k” 的问题则简单得多。

我们通常可以使用滑动窗口来解决：当窗口内的状态满足 “至多为 k” 的条件时，就一直扩张右边界；

当不满足时，就收缩左边界，直到再次满足为止。

这个过程中的每一步扩张，都能轻易地计算出以新右边界为结尾的、满足条件的子数组数量。

因此，我们不再直接攻克复杂的 “exactly k” 问题，而是分别计算出 `at most k` 和 `at most k-1` 的情况，然后相减得出最终答案。

#### At-Most滑动窗口的实现原理和步骤

“AtMost” 策略通常与 **滑动窗口 (Sliding Window)** 算法结合使用。下面是解决一个典型问题（例如：给定一个数组，求恰好包含 k 个不同整数的子数组个数）的实现步骤：

##### 定义atMost(k)函数

**初始化变量**：

- `left`, `right`：滑动窗口的左右指针，初始都为 0。
- `count`：最终结果，满足条件的子数组总数，初始为 0。
- `distinct_count`：当前窗口内不同元素的数量，初始为 0。
- `freq`：一个哈希表 (或数组)，用来记录窗口内每个元素出现的频率。

**扩张窗口**：

- `right` 指针向右移动，遍历整个数组。
- 将 `nums[right]` 元素加入窗口，更新 `freq`。
- 如果 `nums[right]` 是一个新元素 (即 `freq[nums[right]]` 从 0 变为 1)，则 `distinct_count` 加 1。

**收缩窗口**：

- **当窗口状态不再满足 `at most k` 时** (即 `distinct_count > k`)，需要从左边收缩窗口。
- 移动 `left` 指针，将 `nums[left]` 元素移出窗口，更新 `freq`。
- 如果 `nums[left]` 在窗口内的频率变为 0 (即 `freq[nums[left]]` 减到 0)，说明窗口内少了一个不同的元素，则 `distinct_count` 减 1。
- 循环这个收缩过程，直到 `distinct_count <= k` 再次成立。

**计算结果**：

- 在每一次扩张 `right` 指针并调整好 `left` 指针之后，**窗口 `[left, right]` 内的子数组都是满足 `at most k` 条件的**。
- 更重要的是，**以 `right` 指针为右端点的所有子数组，只要它们的左端点在 `[left, right]` 区间内，就都满足条件**。
- 这些子数组包括：`[right]`, `[right-1, right]`, ..., `[left, right]`。
- 其数量为 `right - left + 1`。
- 将这个数量累加到 `count` 中：`count += right - left + 1`。

**返回结果**：

- 当 `right` 遍历完整个数组后，返回 `count`。

##### 主函数调用

```python
def main_function(nums, k):
  # 处理特殊情况，例如 k <= 0
  if k <= 0:
    return 0
  
  result = atMost(nums, k) - atMost(nums, k - 1)
  return result

def atMost(nums, k):
  # ... 实现上述第一步的逻辑 ...
  pass
```

#### At-Most套路的核心总结

**识别问题**：看到 “恰好/正好 k 个” (exactly k) 的字眼，特别是与子数组/子字符串和某种性质（如不同元素、奇数个数等）相关时，就要想到 “AtMost” 策略。

**转化问题**：将 `exactly(k)` 转化为 `atMost(k) - atMost(k-1)`。

**实现`atMost(k)`**：利用滑动窗口实现计算 “至多 k 个” 的通用函数。

- 用哈希表记录窗口内元素状态。
- 扩张右边界，更新状态。
- 当状态不满足 `at most k` 时，收缩左边界，直到满足为止。
- **关键一步**：每次扩张后，将窗口长度 `right - left + 1` 累加到结果中。

#### At-Most套路适用于哪些场景？

“AtMost” 策略非常适用于那些 “至多 k” 比 “恰好 k” 容易计算得多的场景。以下是一些经典的 LeetCode 题目和场景：

#####**子数组中不同整数的个数**

- **LeetCode 992. K 个不同整数的子数组 (Subarrays with K Different Integers)**：这是 “AtMost” 策略最经典的应用，问题直接要求计算恰好有 K 个不同整数的子数组数量。

#####**子字符串中不同字符的个数**

- 与上一场景类似，只是把数组换成了字符串。例如，计算一个字符串中恰好包含 k 个不同字符的子串数量。

#####**子数组中奇数/偶数的个数**

- **LeetCode 1248. 统计「优美子数组」 (Count Number of Nice Subarrays)**：问题定义 “优美子数组” 为含有 k 个奇数的子数组。这也可以用 `atMost(k) - atMost(k-1)` 的思想解决，这里的 `k` 指的是奇数的个数。

#####**二进制子数组中 1 的个数**

- **LeetCode 930. 和相同的二元子数组 (Binary Subarrays With Sum)**：问题要求和为 S 的子数组个数。因为数组元素是 0 或 1，所以 “和为 S” 就等价于 “包含 S 个 1”。这道题虽然可以用前缀和更优地解决，但同样也适用于 “AtMost” 策略。

#### 为什么在这些场景下 “AtMost” 更简单？

因为在滑动窗口模型中，“至多” 这个条件具有 **单调性**。

- 当你扩张窗口（增加一个元素）时，不同元素的数量 **只会增加或不变**。
- 当你收缩窗口（减少一个元素）时，不同元素的数量 **只会减少或不变**。

这种单调性使得我们可以放心地移动 `left` 和 `right` 指针。如果当前窗口满足 `at most k`，那么它的所有子数组也一定满足。而对于 `exactly k`，当你扩张窗口从 k 个变成 k+1 个时，再收缩窗口，可能会跳过很多仍然满足 `exactly k` 的状态，导致逻辑处理非常复杂。

总之，“AtMost” 策略是一个化繁为简的绝佳工具，当你遇到 “恰好 k” 的计数问题时，不妨思考一下是否能将其转化为两个 “至多” 问题的差。

#### Leetcode 1248:统计优美子数组

###### 方法一： 基于哈希表

```java
//滑动窗口 + 前缀和
    //固定奇数个数的窗口
    //问题转化为有多少个子数组的“奇数个数”刚好为 k。
    public int numberOfSubarrays(int[] nums, int k) {
       //先尝试使用HashMap的方式
       int count=0,oddCount=0;

      //包含key个奇数的子数组有value个
      //Map<oddCount, subArrayCount>
       Map<Integer,Integer> map = new HashMap<>();
       //包含0个奇数的子数组有1个
       map.put(0, 1);

       for(int num:nums){
        //如果当前值为奇数
        if (num%2 !=0){
            oddCount++;
        }
        // 假设遍历到某个位置i, oddCount = oddCount1
        // 现在遍历到某个位置j,oddCount = oddCount2
        // 若oddCount2-oddCount1=k,则说明子数组nums[i...j]恰好包含k个元素
        count +=map.getOrDefault(oddCount-k, 0);
        //无论当前num是奇数还是偶数，都会更新包含oddCount个奇数的子数组的数量
        //为什么不在只是奇数时才更新，所以map中存放的究竟是什么含义？
        //map存放的是前缀中出现某个奇数个数（oddCount）的次数
        //nums=[0,0,1,0,1]
        // 基于这个原理，当前的nums[i]为奇数的时候，如果此时奇数数量为oddCount,这个是只有一个子数组含有oddCount个奇数，那就是[0....i]
        // 如果下一个nums[i+1]不为奇数的时候，那么就会有两个子数组含有oddCount个奇数，[0...i],[i...i+1]
        // 如果下一个nums[i+2]依然不是奇数，那么就会有三个子数组含有oddCount个奇数[0..i],[0...i+1],[0...i+2]
        //....
        //1. nums[0]=0, oddCount=0,Map=[(0,2)]
        //2. nums[1]=0, oddCount=0,map=[(0,3)]
        //3. nums[2]=1, oddCount=1,map=[(0,3),(1,1)]
        //4. nums[3]=0, oddCount=1,map=[(0,3),(1,2)]
        //5. nums[4]=1, oddCount=2,map=[(0,3),(1,2),(2,1)]
        map.put(oddCount, map.getOrDefault(oddCount, 0)+1);
       }
       return count;
    }
```

###### 方法二： 基于at-most滑动窗口

基本思路：先计算`最多含有k个奇数`的连续子数组的数量，再减去`最多有k-1个奇数`的连续子数组的数量，即可得到`恰好k个奇数的`数量

**计算`最多`含有K个奇数的子数组**

窗口的定义`[left...right ]`  为每一个包含不超过`k` 个奇数的子数组

- 从`left`开始向右移动`right`指针
  - 如果发现`[left...right]`中超过了k个元素，则从左边开始**收缩**窗口，直到窗口中具有`k`个元素
  - 将`[left...right]`添加至含有不超过`k`个元素的子数组集和中（只计数）
- 继续向右移动`right` 指针，并重复上述过程，直到`right`指针指向`nums[nums.length-1]`

**计算`最多`含有k-1个奇数的子数组**

重复利用上述过程，计算最多含有`k-1`个奇数的子数组集合

**计算恰好含有K个奇数的子数组**

```
恰好含有K个奇数的子数组 = `最多`含有K个奇数的子数组-最多含有k-1个奇数的子数组
```



```java
public int numberOfSubarrays(int[] nums, int k) {
    return atMost(nums, k) - atMost(nums, k - 1);
}

//求最多含有k个奇数的连续子数组的数量
prvate int atMost(int[] nums,int k){
  int left=0,count=0;
  for (int right=0;right<nums.length;right++){
    //扩展窗口,当前数字为奇数时，k -= 1;
    if (nums[right%2 ==1]){
      k--;
    }
		//当k<0的时候，说明当前窗口中的奇数的数量已经超过了k，需要缩小窗口(left++)
    while(k<0){
      if (nums[left]%2==1){
        k++;
      }
      left++;
    }
  }
  //累加每一个含有不超过k个奇数的数组数量
  count +=right-left+1;
  return count;
}
```



###多指针分区类

####基本思路：定义不变量和边界指针

我们在数组中设定一个或者多个**边界指针**。

在遍历过程中始终维持一个约定：边界的一侧是已经处理好的、满足特定属性的元素，另一侧则是待处理的或者不满足该属性的区域。

指针移动并交换元素，进行数组重排或者快速排序的分区操作

#### 实现原理

##### 两路分区

将数组划分为两个区域。

通常使用一个指针`k`来标记**目标区域的右边界**。

另外一个指针`i`作为**遍历指针**。

###### 指针一： 指向目标区域的下一个待填充位置

指向**目標區域的下一個待填充位置**。`[0, k-1]` 區間內的元素都滿足目標屬性。

###### 指针二： 遍历整个数组

`i`: 遍歷整個數組，從 `0` 到 `n-1`，負責尋找滿足目標屬性的元素。

###### 实现流程

1. 初始化邊界指針 `k = 0`。
2. 用遍歷指針 `i` 從頭掃描數組。
3. 如果 `nums[i]` **滿足目標屬性** (例如 `nums[i] != 0`，或 `nums[i] < pivot`):
   - 說明 `nums[i]` 應該被放入目標區域。
   - 將 `nums[i]` 與 `nums[k]` 交換。
   - 將目標區域的邊界右移一位，即 `k++`。
4. 如果 `nums[i]` **不滿足**目標屬性，則它暫時留在原地，`k` 不動，只有 `i` 繼續前進。

###### 典型应用

- **移動零:** 目標屬性是“非零”。遍歷時，只要發現非零數，就把它換到 `k` 的位置。
- **快速排序 (Lomuto 分區方案):** 目標屬性是“小於 pivot”。遍歷時，只要發現小於 pivot 的數，就把它換到 `k` 的位置。

##### 三路分区

将数组划分为三个区域。

通常用于处理右三种状态的元素，或者在快速排序中优化和pivot元素相等的元素。

###### 三个指针的职责分别是什么？

- `p0`: **0 區**的右邊界。`[0, p0-1]` 都是 0。
- `p2`: **2 區**的左邊界。`[p2+1, n-1]` 都是 2。
- `curr`: 當前遍歷指針，`[p0, curr-1]` 是 **1 區**，`[curr, p2]` 是**未知區**。

###### 实现详细流程

- 初始化 `p0 = 0`, `curr = 0`, `p2 = n - 1`。

- 當 `curr <= p2` 時，循環處理「未知區」。

- 如果 `nums[curr]` 屬於第一類 (值為 0):
  - 與 `nums[p0]` 交換，然後 `p0++`, `curr++`。

- 如果 `nums[curr]` 屬於第三類 (值為 2):
  - 與 `nums[p2]` 交換，然後 `p2--` (**`curr` 不動**，因為交換過來的元素需要重新判斷)。

- 如果 `nums[curr]` 屬於第二類 (值為 1):
  - `curr++`。

###### 典型应用

- 快速排序
- 移动零
- 荷兰国旗问题

##### 快速排序

相见排序部分章节。

#### 三指针分区：Leetcode 75 荷兰国旗问题 

##### 问题要点

**输入 (Input):** 一个整数数组 `nums`。

**元素 (Elements):** 数组中的每个整数只可能是 0、1 或 2。

**输出 (Output):** 对原数组进行 **原地排序 (in-place sorting)**，使得所有 0 排在前面，所有 1 位于中间，所有 2 排在最后。

**限制 (Constraints):**

- 不能使用库函数中的排序方法，例如 `Arrays.sort()`。
- 通常要求一个**单次遍历 (one-pass)** 的解决方案。

**比喻 (Analogy):** 这个问题通常用红、白、蓝三种颜色来比喻 0、1、2，这也是为什么它被称为 "Sort Colors"。

##### 问题的本质和分析 - 三路分区

这个问题的本质不是一个通用的排序问题，而是一个**三路分区 (Three-Way Partitioning)** 问题。

通用排序算法（如快速排序、归并排序）需要处理任意范围和数量的元素。

但在这里，我们已知元素的种类和值是固定的（只有 0, 1, 2）。

这个关键信息使得我们可以设计出比通用排序算法**更高效、更具针对性**的解决方案。

###### 简单的暴力方法 - 两次遍历

- **两次遍历 (Two-pass):** 第一次遍历，统计数组中 0、1、2 的数量。

- 第二次遍历，根据统计的数量，重写整个数组。先写入所有 0，然后是 1，最后是 2。

这个方法虽然可行，但不符合 "单次遍历" 和 "原地操作" 的最佳要求（虽然它也是原地修改，但不是通过交换元素，而是通过覆写）。

面试官通常会追问是否能用一次遍历解决。

因此，问题的核心挑战在于如何**仅遍历数组一次**就完成三路分区。

##### 背景知识 - 荷兰国旗问题

这个问题的经典解法是**荷兰国旗问题 (Dutch National Flag Problem)**，由计算机科学家 **Edsger W. Dijkstra** 提出。

该问题的名字来源于荷兰国旗的颜色（红、白、蓝）。想象一堆红色、白色和蓝色的鹅卵石，目标是将它们按照国旗的颜色顺序排列。算法的核心思想就是将数组分为三个区域：

- 红色区域 (对应数字 0)
- 白色区域 (对应数字 1)
- 蓝色区域 (对应数字 2)

我们通过移动指针来扩展这些区域，直到整个数组被正确分区。

##### 考察点

面试官通过这道题主要考察以下几点：

- **数组操作能力:** 能否熟练地在数组上进行元素交换和移动。
- **原地算法思想:** 是否理解 O(1) 空间复杂度的重要性，并能设计出不需要额外存储空间的算法。
- **指针的灵活运用:** 这是本题的核心。考察你是否能通过设置和移动多个指针来维护不同区间的状态。
- **逻辑严谨性:** 在处理指针移动和边界条件时，逻辑是否清晰、无误。例如，在什么情况下指针应该移动，什么情况下不应该。
- **经典算法知识:** 是否了解或能够推导出像“荷兰国旗问题”这样的经典分区算法。

##### 模式匹配 - 多指针分区

这个问题属于一个非常重要的算法模式：**多指针分区 (Multi-Pointer Partitioning)**。

- **双指针模式的扩展:** 很多问题（如“两数之和”、“反转数组”）使用双指针从两端向中间移动或同向移动。本题是这一模式的升级版，使用了三个指针来划分三个区域。
- **三路快排的核心:** 这个思想是三路快速排序 (3-way Quicksort) 的核心分区逻辑。在处理含有大量重复元素的数组时，三路快排比传统快排效率更高，因为它能将等于 pivot 的元素聚集在中间，从而减少递归的规模。

一旦你识别出这是一个三路分区问题，就可以立即联想到荷兰国旗算法。

##### 核心思想和套路 - 三指针分区

核心思想是使用三个指针来维护四个区域的状态。

###### 三个指针如何定义？

- `p0`: 指向**0区域的右边界**。在 `p0` 左边的所有元素（不含 `p0`）都保证是 0，**向右移动扩展左区域**。
- `curr`: 当前遍历到的元素指针。`curr` 在数组中**从左向右移动扩展中间区域**。
- `p2`: 指向**2区域的左边界**。在 `p2` 右边的所有元素（不含 `p2`）都保证是 2，**向左移动扩展右区域**。

###### 区域划分和不变量(Invariants)

在`curr`指针的遍历过程中，我们始终维护以下四个区域：

- `[0, p0 - 1]`: 全部是 0。

- `[p0, curr - 1]`: 全部是 1。

- `[curr, p2]`: 未处理的未知区域。

- `[p2 + 1, n - 1]`: 全部是 2。

###### 算法套路过程

我们的目标是不断缩小“未知区域” `[curr, p2]`，直到它消失 (`curr > p2`)。

 循环条件是 `while (curr <= p2)`。

在循环中，检查 `nums[curr]` 的值：

1. **如果 `nums[curr] == 0`:**

   - 当前元素应该在 0 区域。

   - 将 `nums[curr]` 与 `nums[p0]` 交换。

   - `p0` 右移一位，因为 0 区域扩大了 - Lomuto思想。

   - `curr` 右移一位，因为当前位置的元素已经处理完毕。（**交换过来的元素必然是 1，因为 `p0` 左边是 0，`curr` 左边是 1**）。

     **`[0...p0],[p0...curr]`是已知区域**

2. 如果 `nums[curr] == 1`:

   当前元素位置正确，它就在 1 区域。

   只需将 `curr` 右移一位，继续探寻下一个未知元素。

3. 如果 `nums[curr] == 2`:

   - 当前元素应该在 2 区域。

   - 将 `nums[curr]` 与 `nums[p2]` 交换。

   - `p2` 左移一位，因为 2 区域扩大了。

   **注意：** `curr` 指针**不移动**。因为从 `p2` 交换过来的新 `nums[curr]` 是一个未经检查的元素（因为`[curr...p2]`是**位置区域**），它可能是 0, 1 或 2，需要在下一次循环中重新判断。

##### 实现原理和步骤

**初始化:**

- `p0 = 0`
- `curr = 0`
- `p2 = nums.length - 1`

**循环:**

- 当 `curr <= p2` 时，持续循环。

**条件判断:**

- 使用 `if-else if-else` 或 `switch` 结构判断 `nums[curr]` 的值。
- **Case 0:**
  - 调用 `swap(nums, curr, p0)`。
  - `p0++`。
  - `curr++`。
- **Case 1:**
  - `curr++`。
- **Case 2:**
  - 调用 `swap(nums, curr, p2)`。
  - `p2--`。

**循环结束:**

- 当 `curr` 越过 `p2` 时，所有元素都已被归类，排序完成。

```java
int low=0;mid=0;high=nums.length-1;
while(mid <=high){
  if (nums[mid]==0){
    swap(nums,low++,right++);
  } else if (nums[mid]==1){
    mid++;
  }else{
    swap(nums,mid,high--);
  }
}
```

#### 双指针分区： Leetcode 283: 将数组中的0移动到末尾

给你一个数组，其中包含一些“重要的物品”（非零元素）和一些“空位置”（零元素）。要求你把所有“空位置”都移到末尾，同时保持“重要物品”的原有顺序不变。

##### 核心思想 - 插槽书架上的书和空位置 - 和快速排序的思想类似

想象你在排队发糖果：那些拿到糖果的小朋友（非零元素）都得站到队伍前面，而空着手的小朋友（零元素）都往队尾挪，但不能打乱拿到糖果的小朋友之间的相对先后顺序。最直接的办法就是用“左右两根手指”——右手指往前挨个看谁拿到糖果，若看见了，就和左手指指向的空位交换，然后左手指往右移一格，继续找下一个。

###### 注意逆向思维

我们利用类似于快速排序中的Lomuto方法进行分区。

- 设置一个指针left，用来表示**合格区域的右边界**
- 设置一个指针right,用来从左到右遍历所有的元素

怎样定义**合格元素呢**？

原来问题的要求是将0放在后面，在**Lomuto**方法中，**合格元素最终是排在前面的**。

我们在需要将非0元素定义为**合格元素**。

##### 基本套路 - 双指针 - 本质上是压缩过程

###### 双指针遍历

- `right`: 指针负责扫描全队（从头到尾）**寻找非0元素**
- `left`: 指针始终指向下一个该存放非0元素的位置（**第一个0**的索引位置）

###### 遇到非0则交换

如果 `nums[right] != 0`，就把它和数组`nums[left]`交换，然后`left++`

这样一次遍历结束后，所有非零元素都被依次推到数组前面，空洞自然而然地留在后面。

##### 难点分析

**自交换冗余写入**

- 当 `left == right` 时，交换操作会把元素和自己换来换去，浪费时间。
- **应对**：在交换前判断 `if (left != right)`，只有确实不同才调用 `swap`。

**保持顺序**

- 直接“遇零就扔到后面”容易打乱后面非零元素相对顺序。
- **应对**：只对非零元素做“拉前”操作，零元素从不主动参与交换。

##### 实现原理

1. 初始化两个指针

```java
int left = 0;             // 下一个非零元素应该放的位置
for (int right = 0; right < nums.length; right++) {
    // 下面扫描并交换
}
```

2. 遍历整个数组

- 如果`nums[right]`非0:
  - 如果`left != right`， 则交换`nums[left]`和`nums[right]`
  - `left++`，为下一个非零元素腾出位置
- 否则，继续`right++`扫描

3. 遍历结束以后，`left`右侧自然全是0， 不需要填充

##### 实现代码

```java
    public void moveZeroes(int[] nums) {
        int left = 0;
        for (int right = 0; right < nums.length; right++){
            if (nums[right] != 0){
                if (left != right){
                    swap(nums, left, right);
                }
                left++;
            }
        }
        
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

##### 注意事项

- **原地操作**：无额外数组，空间复杂度 O(1)。
- **边界处理**：
  - 全零数组：`left` 永远不动，`right` 走完，数组保持不变。
  - 全非零数组：`left` 始终追着 `right`，但因 `left==right` 始终跳过交换，也不会改动任何元素。
  - 空数组或 `null`：立刻返回。
- **性能优化**：跳过自交换能略微减少写操作，尤其在大数组时更明显。

##### 经验总结

- 许多“移动”类型问题都能归结为“过滤 + 原地重写”套路：先把想保留的元素按原顺序“拉拢”到前面，再让不想保留的空出来。

- 双指针的“扫描指针 + 写入指针”方案非常通用，既能保证顺序，又能做到 O(n) 时间、O(1) 空间。

- 在实际编码时，记得去掉冗余操作（比如自交换），能让常数时间开销更小，也更符合“写少做少”的编程哲学。

#### 双指针分区： Leetcode 905: [按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)

Given an integer array `nums`, move all the even integers at the beginning of the array followed by all the odd integers.

Return ***any array** that satisfies this condition*.

```java
public int[] sortArrayByParity(int[] nums) {
        int left=0;
        for (int right=0;right<nums.length;right++){
            if (nums[right]%2 ==0){
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right]=temp;
                left++;
            }
        }
        return nums;
    }
```

### Leetcode题目集合

我已经为你整理并排序出**高频双指针题目 Top 100**，按“考察频率”从高到低排序，优先练习最常见、最容易考到的题。每题都标注了：

- ✅ 题目编号与名称
- 📈 难度
- 🔍 策略类型（滑动窗口、对撞指针、快慢指针等）
- ⚠️ 注意事项（包括边界处理、双指针移动逻辑、细节陷阱等）
- 📊 考察频率（根据常见程度人工模拟）

如果你需要我：

- 制作一个「刷题计划表」或「每周训练任务」
- 导出 Markdown、Excel、PDF 文件
- 为每种策略生成「模板+变形题训练包」

| **LeetCode****编号** | **题目名称**                                   | **难度** | **策略类型**           | **注意事项**                                       | 错误 备注                                                    |
| -------------------- | ---------------------------------------------- | -------- | ---------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **11**               | Container With Most Water                      | Medium   | 对撞指针               | 左右向中间收缩，每次计算当前面积                   |                                                              |
| **27**               | Remove Element                                 | Easy     | 双指针覆盖式           | 覆盖所有非目标值元素                               |                                                              |
| **485**              | Max Consecutive Ones                           | Easy     | 滑动窗口               | 连续1的最大长度                                    | 注意当最后一段连续几个都是1的情况                            |
| **977**              | Squares of a Sorted Array                      | Easy     | 对撞指针               | 左右比较平方值从大到小填入新数组                   | 注意需要考虑数组元素数量为基数的情况，所以需要使用`while(left<=right){...}`, 不需要验证或者计算中间元素的情况，则不需要，比如验证回文串 |
| **680**              | Valid Palindrome II                            | Easy     | 对撞指针               | 最多允许删除一个字符，递归或辅助函数判断子串       | 你跳过一次后继续用原来的指针逻辑（继续比较 s[left] 和 s[right]），但是一旦跳过之后，剩下的部分其实要重新验证是不是回文了，不应该继续之前的 while 流程。 |
| **350**              | Intersection of Two Arrays II                  | Easy     | 双指针遍历两个数组     | 先排序两个数组，同时移动指针找交集                 |                                                              |
| **876**              | Middle of the Linked List                      | Easy     | 快慢指针               | 快指针到达末尾时，慢指针在中间                     |                                                              |
| **141**              | Linked List Cycle                              | Easy     | 快慢指针               | 快指针每次走两步，慢指针走一步                     |                                                              |
| **26**               | Remove Duplicates from Sorted Array            | Easy     | 快慢指针               | 慢指针记录唯一值位置                               |                                                              |
| **143**              | Reorder List                                   | Medium   | 快慢指针 + 链表反转    | 先找中点再反转后一半合并                           |                                                              |
| **19**               | Remove Nth Node From End of List               | Medium   | 快慢指针               | 快指针先走 n 步，注意 dummy 节点                   |                                                              |
| **88**               | Merge Sorted Array                             | Easy     | 双指针遍历两个数组     | 从后往前填充可避免覆盖，注意数组大小               |                                                              |
| **26**               | Remove Duplicates from Sorted Array            | Easy     | 快慢指针               | 原地去重，保留一个                                 |                                                              |
| **3**                | Longest Substring Without Repeating Characters | Medium   | 滑动窗口               | 使用 HashSet 或 Map 判断重复字符                   |                                                              |
| **2095**             | Delete the Middle Node of a Linked List        | Medium   | 快慢指针               | 找到中点并删除                                     |                                                              |
| **30**               | Substring with Concatenation of All Words      | Hard     | 滑动窗口 + 字典        | 分块 + 哈希映射计数                                |                                                              |
| **485**              | Max Consecutive Ones                           | Easy     | 滑动窗口               | 计数最长连续1                                      |                                                              |
| **1679**             | Max Number of K-Sum Pairs                      | Medium   | 双指针 + 哈希表        | 也可排序+双指针                                    |                                                              |
| **76**               | Minimum Window Substring                       | Hard     | 滑动窗口               | 注意需要收缩窗口并维护计数，更新最小长度           |                                                              |
| **80**               | Remove Duplicates from Sorted Array II         | Medium   | 双指针                 | 保留每个元素最多两次                               |                                                              |
| **697**              | Degree of an Array                             | Easy     | 滑动窗口/计数          | 记录频率 + 左右边界位置                            |                                                              |
| **1248**             | Count Number of Nice Subarrays                 | Medium   | 滑动窗口 + 前缀和      | 固定奇数个数的窗口                                 |                                                              |
| **4**                | Median of Two Sorted Arrays                    | Hard     | 双指针/二分            | 二分找第k小元素                                    |                                                              |
| **930**              | Binary Subarrays With Sum                      | Medium   | 滑动窗口 + 前缀和      | 固定目标和的子数组计数                             |                                                              |
| **283**              | Move Zeroes                                    | Easy     | 分区类双指针           | left 记录非0位置，right 遍历所有元素，避免重复交换 |                                                              |
| **125**              | Valid Palindrome                               | Easy     | 对撞指针               | 跳过非字母数字字符，注意大小写转换                 |                                                              |
| **1099**             | Two Sum Less Than K                            | Easy     | 对撞指针               | 有序数组中找和 < K 的最大值                        |                                                              |
| **605**              | Can Place Flowers                              | Easy     | 线性扫描               | 不是典型双指针但涉及区间判断                       |                                                              |
| **1004**             | Max Consecutive Ones III                       | Medium   | 滑动窗口/容错K次       | 允许翻转最多K个0                                   |                                                              |
| **1005**             | Maximize Sum After K Negations                 | Easy     | 排序+双指针            | 尽量反转负数变正数                                 |                                                              |
| **905**              | Sort Array By Parity                           | Easy     | 分区类双指针           | 左找偶数，右找奇数，交换                           |                                                              |
| **80**               | Remove Duplicates from Sorted Array II         | Medium   | 快慢指针               | 保留最多两个                                       |                                                              |
| **844**              | Backspace String Compare                       | Easy     | 对撞指针 + 栈思想      | 可用双指针从后往前模拟删除                         |                                                              |
| **160**              | Intersection of Two Linked Lists               | Easy     | 快慢指针               | 长度差法，走完交换链表头                           |                                                              |
| **42**               | Trapping Rain Water                            | Hard     | 对撞指针 + 动态高度    | 维护左右最大高度，边遍历边计算水量                 |                                                              |
| **986**              | Interval List Intersections                    | Medium   | 双指针遍历两个区间列表 | 找重叠区间，移动结束较早的那个指针                 |                                                              |
| **1213**             | Intersection of Three Sorted Arrays            | Easy     | 多指针                 | 三个数组三指针同步前进                             |                                                              |
| **239**              | Sliding Window Maximum                         | Hard     | 窗口收缩 + 单调队列    | 使用双端队列维护最大值                             |                                                              |
| **438**              | Find All Anagrams in a String                  | Medium   | 滑动窗口               | 需要频次统计，窗口大小固定                         |                                                              |
| **986**              | Interval List Intersections                    | Medium   | 双指针遍历两个区间列表 | 找重叠区间                                         |                                                              |
| **142**              | Linked List Cycle II                           | Medium   | 快慢指针               | 找到相遇点后慢指针从头出发再次相遇即为环入口       |                                                              |
| **392**              | Is Subsequence                                 | Easy     | 双指针                 | 一指针扫子串，另一扫母串                           |                                                              |
| **283**              | Move Zeroes                                    | Easy     | 分区类双指针           | 左记录非0位置，右遍历所有元素                      |                                                              |
| **167**              | Two Sum II - Input array is sorted             | Medium   | 对撞指针               | 数组已排序，从两端逼近目标值                       |                                                              |
| **523**              | Continuous Subarray Sum                        | Medium   | 前缀和 + HashMap       | 判断和能否被k整除                                  |                                                              |
| **209**              | Minimum Size Subarray Sum                      | Medium   | 窗口收缩               | 右边界先扩张，满足条件后收缩左边界                 |                                                              |
| **1413**             | Minimum Value to Get Positive Step by Step Sum | Easy     | 前缀和                 | 维护最小前缀和                                     |                                                              |
| **75**               | Sort Colors                                    | Medium   | 荷兰国旗问题           | low, mid, high 三指针，三路分区                    |                                                              |
| **567**              | Permutation in String                          | Medium   | 滑动窗口               | 固定窗口大小，频次匹配                             |                                                              |

##### Leetcode 1679: [K 和数对的最大数目](https://leetcode.cn/problems/max-number-of-k-sum-pairs/)

给你一个整数数组 `nums` 和一个整数 `k` 。

每一步操作中，你需要从数组中选出和为 `k` 的两个整数，并将它们移出数组。

返回你可以对数组执行的最大操作数。

###### 题目分析

- 题目求的是`最大操作数`， 也就是求所有的`num1+num2=k`的`pair`数量
- 我们并不需要实际上对数组进行操作，只需要求出`pairs`数量

###### 方法一：哈希表记录每一个元素的频率

**第一次遍历数组`nums`**

定义一个`HashMap<num,frequency>`，首先遍历并记录每一个元素出现的频率。

**第二次遍历数组`nums`**`

对于每一个元素`num`，定义：`target=k-num`:

1. 从`map`中获取其**剩余**频率，如果剩余频率为`0`,则说明`所有`该元素已经被删除，检查下一个元素（`continue`）;
2. 检查元素的另外一半(`target=k-num`),如果`map`中不存在`target`元素，则说明不存在另外一半，检查下一个元素(`continue`)；
3. 如果`target=num`, 则说明`k=num*2`, 检查`num`的频率`freq`:
   1. 删除的数量 `count += freq/2`
   2. 如果freq为奇数，将map中的freq修改为1:`map.put(num,1)`;
   3. 如果freq为偶数，将map中的freq修改为0:`map.put(num,0)`
4. 如果`target !=null ` , 则需要同时处理`num`和`target`的频率：
   1. 查找`num`和`target`的频率，并且取其中较小者为操作数（`pairs`）, `count += pairs`
   2. 修改num的频率`map.put(num,map.get(num)-pairs)`
   3. 修改target的频率： `map.put(target,map.get(target)-pairs)`
5. 返回累加之后的操作次数`count`

###### 代码实现

```java
//双指针+哈希表
    public int maxOperations(int[] nums, int k) {
      Map<Integer, Integer> map = new HashMap<>();
      for (int i=0;i<nums.length;i++){
        int num = nums[i];
        map.putIfAbsent(num, 0);
        map.put(num, map.get(num)+1);
      }
      int count = 0;
      for (int num:nums){
        if (!map.containsKey(num) || map.get(num)==0) continue;

        int target=k-num;
        if (!map.containsKey(target)) continue;

        if (num == target){
            int freq = map.get(num);
            if (freq%2 !=0){
                map.put(num, 1);
            }else{
                map.remove(num);
            }
            count+=freq/2;
        }else{
            int pairs = Math.min(map.get(num), map.get(target));
            count += pairs;
            map.put(num,map.get(num)-pairs);
            map.put(target, map.get(target)-pairs);
        }
      }
      return count;
    }
```

##### 方案二：排序+双指针

###### 基本思路

- 先对数组进行排序
- 设置两个指针：
  - `left=0`
  - `right=nums.length-1`
- 不断判断`nums[left]+nums[right]`:
  - 如果小于`k`, 则`left++`
  - 如果大于`k`，则`right--`
  - 如果等于`k`, 说明找到一组配对则
    - `count++`
    - 同时移动两个指针：`left++;right--`
- 每一个元素就只能使用一次，使用完成之后就不会再次使用了

###### 实现代码

```java
public int maxOperations(int[] nums, int k) {
        Arrays.sort(nums); // 第一步：排序
        int left = 0;
        int right = nums.length - 1;
        int count = 0;

        // 第二步：双指针遍历
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == k) {
                count++;
                left++;
                right--;
            } else if (sum < k) {
                left++; // 总和太小，左边需要大一点
            } else {
                right--; // 总和太大，右边需要小一点
            }
        }

        return count;
    }
```

## 哈希表策略

### 适用场景

- 查找是否存在某元素组合
- 统计频率
- 检测重复元素
- 子数组前缀和和技巧配合哈希查表
- 找补数、差值等(Two Sum/Subarray Sum)

### 核心思路

#### 构建Map/Set

- 用Set做集合判重、存在性判断
- 用Map做频率统计、元素索引记录等

#### 边遍历边查找

- 边遍历数组边更新哈希表，实现常数级别的查找

#### 利用Key的语义设计

设计Key的方式非常关键，下列是会使用到的key含义

- 前缀和做为key
- 数组中的补数做为key
- 排序后的字符串做为key

### 典型题型+原理解析+代码套路模板

#### Two Sum问题

找出数组中两个数之和为target的一组数

- 原理，查找补数是否出现
- 时间复杂度 `O(n)`

```java
int[] twoSum(int[] nums, int target){
  // 数组中每一个数字作为key
  Map<Integer, Integer> map = new HashMap<>();
  for (int i=0;i<nums.length;i++){
    int complement =target-nums[i];
    if (map.contains(complement)){
      return new int[]{map.get(complement),i};
    }
    map.put(nums[i],i);
  }
  return new int[0];
}
```

#### Subarray Sum Equals K

求和为K的子数组个数

##### 什么是子数组？

我们说 **“某个数组的子数组”** 时，指的是原数组中 **若干个**（可以是 1 个，也可以是全部）**连续的元素** 所构成的新数组。

##### 什么是`前缀和`？

**前缀和（Prefix Sum）** 是一种用于快速计算数组某一段区间和的技巧，常用于优化涉及频繁区间求和的问题。

###### 概念

给定一个数组`nums`, 它的`前缀和(prefix)`定义为：

```
prefix[0]=0;
prefix[i]=nums[0]+nums[1]+nums[2]+...nums[i-1];
```

这样，对于任意区间`[l,r]` 的和，可以使用前缀和数组快速求出：

```
区间和 = prefix[r+1] - prefix[l]
```

###### 代码套路模板

```java
//构建前缀和数组
int nums[] = {2,4,5,7,1}
int[] prefix = new int[nums.length+1];
for (int i=1;i<=nums.length;i++){
  prefix[i]=prefix[i-1]+nums[i-1];
}
// 查询区间[1,3]的和，即nums[1]+nums[2]+nums[3].
int sum = prefix[4]-prefix[1];
```

###### 用途场景

- 多次查询数组某段区间和
- 二维前缀和（处理矩阵中的某块区域的和）
- 子数组和的问题

###### 衍生技巧

- 差分数组（前缀和的逆操作）
- 结合哈希表优化子数组个数统计
- 二维前缀和构建和查询方式稍微不同

##### 以`前缀和`为Key定义哈希表

哈希表的每一个`entry`代表了前缀和为`key`的子数组的个数`value`

- `key` = 前缀和
- `value` = 字数组个数

**精髓：** `sum[j]-sum[i]=k` -> 维护`sum[i]`的出现次数

```java
Map<Integer, Integer> map = new HashMap<>();
int count =0;// 和为k的子数组的数量
for (int right=0;right<nums.length;right++){
  sum += nums[right];
  // prefix[i]=sum
  // prefix[j]=sum-target
  // 假设遍历到某个位置i, 前缀和prefix[i]=sum1
  // 现在遍历到某个位置j, 前缀和prefix[j]=sum2
  // 若sum2-sum1=target, 则说明从[i...j]之间的数组和是target
  // 找到前缀和为sum1的子数组的数量，就相当于找到了前缀和为k的子数组的数量
  count += map.getOrDefault(sum-target,0);
  
  // 更新前缀和map
  map.put(sum,map.getOrDefault(sum,0)+1);
}
```

#### 判断数组中是否出现重复元素

```java
boolean containsDuplicate(int[] nums) {
    Set<Integer> seen = new HashSet<>();
    for (int num : nums) {
        if (!seen.add(num)) return true;
    }
    return false;
}
```



####  最长的连续子序列的长度

找出数组中最长连续序列的长度。

用 `Set` 记录所有数，从起点向右扩展连续段

```java
int longestConsecutive(int[] nums){
  Set<Integer> set = new HashSet<>();
  for (int num:nums) set.add(num);
  
  for (int num:set){
    if (!set.contains(num-1)){
      int current = num;
      int lenght=1;
      while(set.contains(current+1)){
        current++;
        length++;
      }
      longest = Math.max(longtest,length);
    }
  }
  return longest;
}
```

#### 频率统计类问题（哈希计数）

```java
int majorityElement(int[] nums) {
    Map<Integer, Integer> freq = new HashMap<>();
    int n = nums.length;
    for (int num : nums) {
        freq.put(num, freq.getOrDefault(num, 0) + 1);
        if (freq.get(num) > n / 2) return num;
    }
    return -1;
}
```

#### Leetcode 336 回文对

##### 问题要点

这是一个综合题目。

给定一个字符串数组 `words`，找出所有索引对 `(i, j)`，使得 `words[i] + words[j]` 是一个回文字符串。

其中 `i` 和 `j`不能相等。

**示例:**

- **输入:** `words = ["abcd", "dcba", "lls", "s", "sssll"]`
- **输出:** `[[0, 1], [1, 0], [3, 2], [2, 4]]`
- **解释:**
  - `words[0] + words[1]` = "abcd" + "dcba" = "abcddcba" (回文) -> `[0, 1]`
  - `words[1] + words[0]` = "dcba" + "abcd" = "dcbaabcd" (回文) -> `[1, 0]`
  - `words[3] + words[2]` = "s" + "lls" = "slls" (回文) -> `[3, 2]`
  - `words[2] + words[4]` = "lls" + "sssll" = "llssssll" (回文) -> `[2, 4]`

##### 问题本质和分析 - 如何高效的寻找字符串拼接后的回文特性

###### 朴素的暴力方法 - 遍历所有的Pair

一个朴素的暴力想法是遍历所有的索引对`[i,j]`,然后拼接字符串`words[i] + words[j]`，再判断拼接后的字符串是否是回文。

假设有`n`个单词，单词的拼接长度是`k`，那么：

- 一共有$n \times(n-1)$个有序对
- 每次拼接需要$O(K)$的时间
- 每次判断是否回文需要$O(K)$的时间

综合以上，暴力法的时间复杂度是$O(n^2)\cdot K$

对于 LeetCode 的数据规模来说，这个复杂度通常会超时。因此，我们需要找到一种更高效的匹配方法，避免不必要的遍历和拼接。

问题的核心在于，如何**拆解**回文串的构成，从而将“寻找两个字符串的组合”转化为“为一个字符串寻找它的有效‘另一半’”的问题。

##### 背景知识

###### 什么是回文串？ - 正读反读都一样

**回文字符串 (Palindrome):** 一个正读和反读都一样的字符串。例如 "level", "racecar"。

判断一个字符串是否是回文是本题的基础操作。

###### 哈希表 - 用于快速查找

用于快速查找。在本题中，我们可以将字符串与其在数组中的索引存储起来，实现 O(k) 时间复杂度的查找（k为字符串长度）。

###### 如何快速反转一个字符串？

快速得到一个字符串的逆序串。

###### # 什么是前缀树？- Trie树

- （可选，但为最优解之一）一种高效的字符串检索数据结构。将所有字符串的**翻转形式**存入 Trie，可以在查找一个词的“另一半”时，极大地优化匹配过程。

##### 模式匹配

此题属于**字符串匹配**和**查找优化**类问题。

当遇到涉及大量字符串查找和匹配，且暴力解法复杂度过高时，通常可以考虑以下两种优化模式：

###### 使用哈希表进行预处理

将一部分数据存入哈希表，然后遍历另一部分数据，在哈希表中进行快速查询。

这是一种空间换时间的策略。

###### 前缀树/后缀树优化

当问题涉及到大量字符串的前缀或者后缀匹配时，Trie树是首选的优先数据结构。

##### 核心思想和套路 - 对每一个单词进行全切扫描

###### 如果两个字符串长度相等

这种情况下，只需要判断`reverse(words[i])`是否和`words[j]`相同即可。

######如果两个字符串长度不同

我们假设`word[i]`的长度大于`words[j]`。

假设我们将`words[i]`拆分两个部分`prefix`和`suffix`:

如果 `prefix + suffix + words[j]` 是回文，需要满足：

a. `suffix` 本身是一个回文串。

b. `words[j]` 恰好是 `prefix` 的翻转。

所以，我们可以遍历 `words[i]` 的所有可能前缀 `prefix`，如果其对应的 `suffix` 是回文，我们就去哈希表中查找 `reverse(prefix)` 是否存在。

如果存在且不是 `words[i]` 本身，就找到了一个配对。

同样的，我们使用上述逻辑检查前缀为回文串的情况下，查找是否存在后缀的反转字符串。

###### 哈希表还是字典树方案？

哈希表方案可读性好；

Trie 方案更工程化（常数略大，代码更复杂）。

###### 步骤一： 预先构建哈希表 

预建哈希表：`word -> index`（若可能重复：`word -> indices`）。

###### 步骤二：遍历每一个单词并且扫描所有的切点

遍历每个词 `w`，扫描所有切点 `cut ∈ [0..len]`：

- **左回文**：`isPal(w, 0, cut-1)` 为真 → 找 `reverse(w[cut..])` 的索引 `j`，若 `j != i` 加入 `[j, i]`。
- **右回文**：`isPal(w, cut, len-1)` 为真且 `cut != len` → 找 `reverse(w[0..cut-1])` 的索引 `j`，若 `j != i` 加入 `[i, j]`。
   （`cut != len` 常用于避免与左回文在空后缀的重复检查导致的冗余。）

- 校验 `j != i` 后加入答案。

返回结果即可。

##### 实现原理和步骤 - 基于哈希表

- **建表**：`indexOf.put(words[i], i)`。

- **主循环**：对每个单词 `w` 和每个切点 `cut`：

  - 调用 `isPal` 判定一侧是否为回文。

  - 用 `StringBuilder(...).reverse().toString()` 生成另一侧残差的逆串并在表中查找。

  - 校验 `j != i` 后加入答案。

- **返回**结果。

##### 实现代码

```java
class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        Map<String, Integer> indexMap = new HashMap<>();
        for(int i = 0; i < words.length;i++){
            String word = words[i];
            indexMap.put(word, i);
        }
        List<List<Integer>> res = new ArrayList<>();

        for(int i = 0; i < words.length; i++){
            String word = words[i];
            int n = word.length();
            //这里需要注意遍历到n，因为需要处理空字符串的情况
            for(int k = 0; k <= n; k++){
                String prefix = word.substring(0, k);
                String suffix = word.substring(k, n);
                //处理前缀是回文串的情况
                if(isPal(prefix)){
                    String reversedSuffix = new StringBuffer(suffix).reverse().toString();
                    Integer j = indexMap.get(reversedSuffix);
                    if(j != null && !j.equals(i)){
                        res.add(Arrays.asList(j,i));
                    }
                }
                //如果后缀为回文串，处理前缀
                //排除后缀是空串的情况(k != n)
                if(k != n && isPal(suffix)){
                    String reversedPrefix = new StringBuilder(prefix).reverse().toString();
                    Integer j = indexMap.get(reversedPrefix);
                    if(j != null && !j.equals(i)){
                        res.add(Arrays.asList(i,j));
                    }
                }
            }
        }
        return res;
    }

    private boolean isPal(String s){
        int start = 0;
        int end = s.length() - 1;
        while(start < end){
            if(s.charAt(start) != s.charAt(end)){
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
}
```

##### 注意事项

###### 一定要考虑空字符串的情况

- 判断前缀的时候，已经考虑了前缀为空串的情况，因为切点是从0开始的

###### 后缀判断的时候需要排除空串情况

- 当 **k = n** 时：

  - `suffix = ""` （空串），
  - `prefix = 整个单词`。

  此时你再判断 `isPal(suffix)`，一定为真（空串是回文）。
  然后按照逻辑会去找 `reverse(prefix)`，也就是找 **整个单词的逆串**。

  问题是：

  1. **重复**：这一情况其实在前一个逻辑（判断 `prefix` 是否回文时）已经覆盖过了，不需要再算一次，否则**可能会重复加入结果**。
  2. **无效结果**：如果没有特别小心，就可能得到 `[i, i]`（自己和自己拼接）这样的无效结果。

  所以加 `k != n`，就是为了：

  - 避免在最后一个切点（空后缀）再次触发“后缀回文”的逻辑；
  - 保证结果不重复、不产生 `[i, i]`。

##### 经验总结

**先暴力，再优化:** 面对一个问题，首先思考最直接的暴力解法。分析其时间复杂度瓶颈，然后针对性地进行优化。本题的瓶颈在于两两组合，优化的方向就是如何避免这种组合。

**化“组合”为“查找”:** 将“`A` 和 `B` 组合满足某条件”的问题，转化为“对于 `A`，什么样的 `B` 能满足条件？我们如何快速找到这个 `B`？”。这通常是使用哈希表或 Trie 树的信号。

**拆解问题:** 将一个复杂的回文条件 `word1 + word2` is palindrome，拆解成更小的、可操作的子问题：`word1` 的某部分是回文，而另一部分的翻转等于 `word2`。

**注意边界和重复:** 在设计算法时，要时刻考虑空字符串、单词本身就是回文、以及算法逻辑是否会导致结果重复等边界情况。在代码中加入相应的判断来保证正确性。

**Trie 树解法:** 虽然哈希表解法已经足够高效并通过本题，但使用 Trie 树是另一个重要的优化思路。将所有单词的**翻转**插入 Trie。然后遍历每个单词 `w`，在 Trie 中搜索它。在搜索过程中，每经过一个节点，就相当于匹配了 `w` 的一个前缀。如果这个节点自身代表一个单词的结束，并且 `w` 剩余的后缀是回文，就找到了一个配对。反之，如果在 Trie 中走完了整个 `w`，那么从当前节点开始，所有子树中是回文的路径都代表一个有效的配对。Trie 的解法逻辑更复杂，但对于理解字符串算法非常有帮助。



## 前缀和类问题

### 前缀和的核心思想

通过预处理累计信息，让区间查询或者区间统计的时间复杂度从`O(0)`降低到`O(1)`

### 前缀和的基本原理

设数组为`nums`,长度为`n`.

定义前缀和`prefixSum`,规则如下：

- `prefixSum[0]=0`(通常为0，表示空区间)
- `prefixSum[i]=nums[0]+nums[1]+...nums[i-1]`

那么任意区间的`[i,j]`的和就可以表示为：

```
sum(nums[i...j]) = prefixSum(j+1) - prefixSum[i];
```

从`i`开始，到`j`结束的累积量=`前缀和到j+1`减去`前缀和到i`

这样以来：

- 原本要`O（j-1+1）`的累加操作
- 变成了简单的`O(1)`两个数相减

### 前缀和的代码套路模板

#### 基础模板-预处理和查询

```java
int n=nums.length;
int[] prefixSum = new int[n+1];
for (int i=0;i<n;i++){
  prefixSum[i+1]=prefixSum[i]+nums[i];
}

int sum = prefixSum[i+1]-prefixSum[i];
```

#### 经典应用套路

##### 求任意区间和

直接套用上述模板

##### 子数组求和为目标值（比如两数之间的扩展）

用一个`HashMap` 记录`前缀和`出现的位置，快速找出满足条件的区间

```java
Map<Integer, Integer> map = new HashMap<>();
map.put(0,1);//注意这里放0对应1次
int prefix =0; count=0;
for(int num:nums){
  prefix += num;
  //我们找到前缀和为 prefix[]
  count += map.getOrDefault(prefix-target,0);
  map.put(prefix,map.getOrDefault(prefix,0)+1);
}
```

#### 前缀和的常见应用场景小结

| 场景                          | 描述                  | 备注                            |      |
| :---------------------------- | :-------------------- | :------------------------------ | ---- |
| 子数组求和                    | 固定或任意子数组的和  | 固定区间 O(1)，任意区间配合哈希 |      |
| 满足某种关系的子数组个数      | 如和为 k 的子数组数量 | 常见在子数组统计                |      |
| 最多/最少满足条件的子数组长度 | 二分 + 前缀和         | 典型如最短子数组                |      |
| 二维矩阵区域查询              | 矩阵子区域累加和      | 二维前缀和技巧                  |      |
| 差分（前缀和逆运用）          | 快速处理区间加减修改  | 差分数组是前缀和的**反操作**    |      |
| 位运算版本                    | 前缀异或数组          | 适用于异或和相关问题            |      |

#### 注意事项总结

- `prefixSum`数组要开`n+1`位，`prefixSum[0]=0`
- 查询时`sum=prefixSum[j+1]-prefixSum[i]`,不是直接`prefixSum[j]-prefixSum[i]`
- 注意是否包含边界、是否从0开始的细节
- 前缀和不一定是[0....i-1]的总和，可能是某个`特定逻辑`计算出来的值

###Leetcode 523: 连续的子数组求和

给你一个整数数组 `nums` 和一个整数 `k` ，如果 `nums` 有一个 **好的子数组** 返回 `true` ，否则返回 `false`：

一个 **好的子数组** 是：

- 长度 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

**注意**：

- **子数组** 是数组中 **连续** 的部分。
- 如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` **始终** 视为 `k` 的一个倍数。

##### 分析：求子数组的和是否满足某个条件

属于前缀和的应用场景之一。

##### 从前缀和求子数组和模板开

###### 复习前缀和模板

```java
//返回和为k的子数组的数量
public int count(int[] nums, int k){
  // Key：前缀和
  // Value:前缀和为key的子数组的数量
  Map<Integer, Integer> map = new HashMap<>();
  // 前缀和为0的子数组，空数组先初始化
  map.put(0,1);
  // 和为k的子数组的数量
  int count =0;
  // 前缀和
  int prefixSum =0;
  //从数组起点开始遍历
  for (int i=0;i<nums.length;i++){
    //累加前缀和
    prefixSum += nums[i];
    // 求当前前缀和与k之间的差值（target）
    int target = prifixSum -k;
    // 如果map中含有前缀和为target的前缀数组，说明这些前缀数组和当前前缀数组之间的差值为k
    // 也就是对于每一个前缀和为target的前缀数组[0....m] 以及当前前缀数组[0....i], [m+1...i]的和为k
    if (map.contains(target)){
      count += map.get(target);
    }
    // 更新当前的map中mod所对应的前缀数组数量
    map.put(mod, map.getOrDefault(mod,0)+1);
  }
  // 返回和为k的子数组的数量
  return count;
}
```



###### 怎么定义前缀和`HashMap`?

- `Key =  prefixSum % k`
- `Value` = `prefixSum % k 第一次出现的索引位置`

###### 怎么定义count?

符合要求的子数组（`sum % k == 0` ）的数量，但是不是准确的数字，只是用来判断是否存在。

###### 怎么计算之前的前缀和数组？

```java
int mod = sum % k;
//只存放第一个索引
if (!map.containsKey(mode)){
  map.put(mode, i);
}
```

###### 怎么找出符合条件的前缀数组？

- 计算当前的`前缀和 mod`: `mod = sum %k`
- 在`map` 中查询`前缀和mod`的第一索引: `firstIndex = map.get(mod)`
- 如果 `mod`的`第一索引` 与当前索引不是同一个索引：
  - 那说明子数组`nums[firstIndex+1,i]`的和为`n*k`
  - 增加符合条件的子数组的数量： `count +=1`
- 如果`map` 中不存在`前缀和mod`的**第一索引**，将当前索引设置为当前**前缀和mod**的**第一索引**。

```java
Map<Integer, Integer> map = new HashMap<>(); //map 保存的是 前缀和 %k = 某个数字的前缀数组的数量
// 哈希表，记录每个 (前缀和 % k) 第一次出现的下标
        Map<Integer, Integer> modFirstIndexMap = new HashMap<>();
        // 为什么初始化 (0, -1)：
        // 方便处理从数组开头就满足条件的情况
				//例如[6,6] k=6的情况
        modFirstIndexMap.put(0, -1);
				int count =0;//符合条件的子数组的个数
        int prefixSum = 0; // 初始化前缀和为0

        for (int i = 0; i < nums.length; i++) {
            prefixSum += nums[i]; // 不断累加到当前元素

            // 如果k不是0，就取模，防止后续判断错误
            int mod = k==0 ? prefixSum : prefixSum % k;

            // 检查当前前缀和模k的结果是否出现过
            if (modFirstIndexMap.containsKey(mod)) {
              	// 找到第一次出现mod的索引位置（prevIndex）
                int previousIndex = modFirstIndexMap.get(mod);

                // 子数组是 previousIndex+1 到 i
                // 因为要求子数组长度至少2，所以 i - previousIndex >= 2
                if (i - previousIndex >= 2) {
                    count++; // 找到了符合要求的子数组
                }
                // 如果长度不够，不急，继续遍历后面的元素
            } else {
                // 如果是第一次出现这个模k的结果，记录下当前下标
                modFirstIndexMap.put(mod, i);
            }
        }

        // 遍历完没有找到，返回false
        return count >= 1;
    }
}
}
```

### Leetcode 304: 二维矩阵求子区域元素和

#### 问题要点

给定一个二维矩阵 `matrix`，你需要实现一个类 `NumMatrix`，它包含两个功能：

1. **`NumMatrix(int[][] matrix)`:** 用给定的矩阵初始化对象。
2. **`int sumRegion(int row1, int col1, int row2, int col2)`:** 返回矩阵中由左上角 `(row1, col1)` 和右下角 `(row2, col2)` 定义的矩形区域内所有元素的总和。

**核心要求:** `sumRegion` 方法会被**频繁调用**。这意味着初始化的时间复杂度可以高一些，但每次查询 `sumRegion` 的时间复杂度必须尽可能低。

**示例:**

- **输入:**
  - `NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);`
  - `numMatrix.sumRegion(2, 1, 4, 3);` // 查询
  - `numMatrix.sumRegion(1, 1, 2, 2);` // 查询
- **输出:**
  - `8`
  - `11`

#### 问题本质和分析 

这道题的本质是**在不可变数据上进行高效的重复性范围查询**。

##### 朴素的暴力方法

一个朴素（暴力）的想法是，每次调用 `sumRegion` 时，都遍历 `(row1, col1)` 到 `(row2, col2)` 之间的所有元素，并将它们累加起来。

时间复杂度分析：

- 构造函数 `NumMatrix`: O(1)，因为只保存了矩阵的引用。
- 查询 `sumRegion`: $O(m\times{n})$，其中 `m` 是查询区域的行数，`n` 是列数。在最坏情况下，查询整个矩阵，复杂度为 $O(R\times{C})$，`R` 和 `C` 是原矩阵的行数和列数。

由于题目强调了 `sumRegion` 会被**频繁调用**，每次查询都进行一次完整的遍历是无法接受的，必然会导致超时。因此，问题的核心就变成了：**如何通过预计算和空间换时间，来将查询操作的复杂度优化到 O(1)**。

#### 背景知识 - 前缀和

- 这是一项基础且强大的技巧。对于一维数组 `a`，它的前缀和数组 `p` 定义为$ p[i]=a[0]+a[1]+...+a[i]$。

- 有了前缀和数组，我们就可以在 O(1) 的时间内计算出任意区间 `[i, j]` 的和：`sum(i, j) = p[j] - p[i-1]`。

本题需要将这个思想从一维扩展到二维。

#### 考察点

- **算法优化意识:** 能否识别出暴力解法的性能瓶颈，并主动寻求优化。

- **预计算思想 (Pre-computation):** 能否想到通过在初始化时进行计算，来加速后续的查询操作，这是典型的空间换时间策略。

- **一维到二维的思维推广:** 能否将一维前缀和的核心思想正确地应用到二维矩阵上。

- **数学/几何推导能力:** 正确推导出二维区域和与二维前缀和矩阵之间的关系（一个包含-排除的几何思想）。

- **代码实现细节:** 数组索引的处理，特别是为了避免边界判断而引入的“哨兵”（即让前缀和矩阵比原矩阵大一圈）。

#### 核心思想和套路 - 二维前缀和矩阵

核心思想就是构建一个**二维前缀和矩阵**，我们称之为 `preSum`。

`preSum[i][j]` 的定义是：**从原点 `(0, 0)` 到 `(i-1, j-1)` 这个矩形区域内所有元素的和**。

注意，为了方便计算和避免处理边界情况，我们通常让 `preSum` 矩阵的维度比原 `matrix` 大1，即 `(R+1) x (C+1)`。这样 `preSum[i][j]` 对应的是原矩阵中以 `(i-1, j-1)` 为右下角的区域。

##### 如何计算前缀和矩阵？

`preSum[i][j]` 的值可以通过它周围的值和原矩阵 `matrix[i-1][j-1]` 计算得出。

阴影区域 `preSum[i][j]` 的面积等于：

- 上方矩形 `preSum[i-1][j]` 的面积
- **加上** 左方矩形 `preSum[i][j-1]` 的面积
- **减去** 左上方被重复计算的矩形 `preSum[i-1][j-1]` 的面积
- **最后加上** 当前点 `matrix[i-1][j-1]` 的值。

递推公式就是：

$preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + matrix[i-1][j-1]$

##### 如何使用前缀和矩阵进行查询？- 容斥原理

我们想要求 `(row1, col1)` 到 `(row2, col2)` 的区域和。同样利用几何关系（容斥原理）：

以 `(row2, col2)` 为右下角的整个大矩形 (`D`) 的和

- **减去** 上方多余的矩形 (`B`) 的和
- **减去** 左方多余的矩形 (`C`) 的和
- **再加上** 左上方被重复减去的矩形 (`A`) 的和

对应到 `preSum` 矩阵的索引：

- **右下角整个大矩形的和**：`D` 的和: `preSum[row2 + 1][col2 + 1]`
- **上方多余矩阵的和：**`B` 的和: `preSum[row1][col2 + 1]`
- **左方多余矩阵的和：**`C` 的和: `preSum[row2 + 1][col1]`
- **左上角矩阵的和：**`A` 的和: `preSum[row1][col1]`

$sumRegion(row1,col1,row2,col2)=preSum[row2+1][col2+1]−preSum[row1][col2+1]−preSum[row2+1][col1]+preSum[row1][col1]$

通过这两步，我们把高频操作 `sumRegion` 的复杂度降到了 O(1)。

#### 实现原理和步骤

#####**类成员变量:**

- 定义一个二维整型数组 `preSum` 作为类的成员变量，用于存储前缀和。

#####**构造函数 `NumMatrix(int[][] matrix)`:**

- 检查输入矩阵 `matrix` 是否为空或行/列为0。如果是，则提前返回。
- 获取原矩阵的行数 `R` 和列数 `C`。
- 初始化 `preSum` 矩阵，大小为 `(R+1) x (C+1)`。
- 使用双层循环遍历原矩阵 `matrix` (从 `i=1` 到 `R`，`j=1` 到 `C`)。
- 在循环中，根据递推公式 `preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + matrix[i-1][j-1]` 来填充 `preSum` 矩阵。

#####**查询方法 `sumRegion(int row1, int col1, int row2, int col2)`:**

- 直接应用查询公式：`return preSum[row2+1][col2+1] - preSum[row1][col2+1] - preSum[row2+1][col1] + preSum[row1][col1]`。
- 返回计算结果。

#### 实现代码

```Java
class NumMatrix {
    int[][] matrix;
    int m;
    int n;
    //prxSum[i][j] = 以[i-1,j-1]结尾的前缀和
    int[][] preSum;

    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        this.m = matrix.length;
        this.n = matrix[0].length;

        preSum = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <=n; j++){
                //上方的区域 + 左边的区域 - 左上方的区域 + 当前matrix值
                preSum[i][j] = preSum[i-1][j] 
                + preSum[i][j-1] 
                - preSum[i-1][j-1] 
                + matrix[i-1][j-1];
            }
        }
    }
    // 右下角大矩阵 - 上方矩阵 - 左边矩阵 + 左上方矩阵
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return preSum[row2+1][col2+1] 
        //
        - preSum[row1][col2+1] 
        - preSum[row2+1][col1] 
        + preSum[row1][col1];
    }
}
```

#### 注意事项

##### **索引对应关系:** 

这是最容易出错的地方。`preSum[i][j]` 对应的是 `matrix` 中以 `(i-1, j-1)` 为右下角的区域。理解这个 `+1` 的偏移量是关键。

##### **构造函数中的空值检查:**

 如果输入的 `matrix` 是空的，直接初始化一个空的 `preSum` 矩阵或进行标记，避免在 `sumRegion` 中出现空指针异常。

##### **公式的理解:** 

不要死记硬背公式，而是通过画图理解其背后的几何含义（容斥原理），这样才能记得牢固且不易出错。

##### **空间复杂度:**

 `preSum` 矩阵需要 $O(R\times{C})$ 的额外空间。

这是典型的空间换时间。

#### 经验总结 (Experience Summary)

**识别模式是关键:** 遇到“不可变数据 + 多次范围查询”，立刻想到“前缀和”。这个反应速度是需要通过练习培养的。

**升维思考:** 能够将一维前缀和的 `sum(i, j) = p[j] - p[i-1]` 思想，通过画图和逻辑推导，平滑地扩展到二维，是解决问题的核心能力。

**善用“哨兵”:** 将 `preSum` 矩阵的尺寸设置为 `(R+1) x (C+1)` 是一种编程技巧（有时称为“哨兵”或“虚拟节点”），它可以极大简化边界条件的判断，让代码更简洁、优雅，减少出错的可能性。

**理解时间/空间权衡:** 本题完美地诠释了时间与空间的权衡。我们接受了 $O(R\times{C})$ 的初始化时间和空间，换来了无数次 O(1) 的查询效率。在实际应用中，这种权衡无处不在。

**前缀和的扩展:** 前缀和思想不仅可以用于求和，还可以用于求前缀积、前缀异或和等。只要运算满足结合律，并且可以求逆运算（对于和是减法，对于积是除法，对于异或是其本身），就可以应用前缀和技巧。

## 位图-使用32bit数组表示某些元素是否存在

**位图（Bitmap）** 是一种使用**位（bit）数组**来表示某些元素是否存在的数据结构。每一个位仅能表示两个状态：`0`（不存在）或 `1`（存在）。

### 核心思想和原理

位图的本质是**用一个二进制位（bit）来映射一个元素**。

想象一个从0开始的整数集合，我们可以用一个很长的二进制串来表示这个集合中的所有元素。

如果数字 `i` 存在于集合中，那么这个二进制串的第 `i` 位就为1；

反之，如果数字 `i` 不存在，则第 `i` 位为0。

例如，要表示集合 `{1, 2, 5}`，我们可以使用一个8位的二进制串 `01100100`。

其中，从右到左（或从左到右，取决于具体实现）的第1、2、5位（从0开始计数）为1，其余位为0。

这种设计的巧妙之处在于，它将元素的**存在性问题**转化为了对二进制位的**直接寻址和操作**，极大地压缩了存储空间，并能以极高的效率进行插入、删除和查询操作。

| 项目         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| **核心思想** | 使用一个大的二进制位数组，通过**位的开/关状态**表示某个值是否存在、被访问、被标记 |
| **实现原理** | 利用整数的每一位（bit）表示某个数是否出现，比如第 `i` 个位置上的 bit 代表数字 `i` 是否存在 |

### 背景知识： 二进制运算的威力

位图的强大能力深度依赖于计算机底层的二进制位运算。理解以下几种基本的位运算符是掌握位图的关键：

| 运算符 | 名称                   | 描述                                                 | 示例 (a=5, b=3)                  |
| ------ | ---------------------- | ---------------------------------------------------- | -------------------------------- |
| `&`    | **按位与 (AND)**       | 两位都为1时，结果才为1。                             | `a & b` (0101 & 0011) = 0001 (1) |
| `      | `                      | **按位或 (OR)**                                      | 只要有一位为1，结果就为1。       |
| `^`    | **按位异或 (XOR)**     | 两位相同时为0，不同时为1。                           | `a ^ b` (0101 ^ 0011) = 0110 (6) |
| `~`    | **按位非 (NOT)**       | 0变为1，1变为0。                                     | `~a` (~0101) = 1010 (-6)         |
| `<<`   | **左移 (Left Shift)**  | 各二进制位全部左移若干位，高位丢弃，低位补0。        | `a << 1` (0101 << 1) = 1010 (10) |
| `>>`   | **右移 (Right Shift)** | 各二进制位全部右移若干位，正数高位补0，负数高位补1。 | `a >> 1` (0101 >> 1) = 0010 (2)  |

在位图操作中，这些运算符被巧妙地用来定位和修改特定位：

- **`|` (按位或):** 用于将某一位设置为1（添加元素）。
- **`&` (按位与) 和 `~` (按位非):** 结合使用，用于将某一位清零（删除元素）。
- **`&` (按位与):** 用于检查某一位是0还是1（查询元素是否存在）。

### 位图的常见应用场景

| 应用场景                       | 目标                             | 详细说明                                                     |
| ------------------------------ | -------------------------------- | ------------------------------------------------------------ |
| **海量数据去重与排序**         | 节省内存，快速排序               | 对于一个包含大量无重复正整数的文件，如果内存有限，无法直接加载所有数据进行排序。可以使用位图，将每个整数映射到一位。遍历一遍所有数据，在位图中将对应位设为1，然后遍历位图，输出所有位为1的索引，即可得到排序后的去重结果。 |
| **用户行为分析**               | 高效统计与查询                   | 网站或APP需要统计用户的日活跃、月活跃、留存等指标。可以将每个用户ID映射到位图的一位。例如，一个32位的整数可以表示一个用户连续32天的登录情况。通过对不同日期的位图进行位运算（如`AND`求交集），可以快速计算出连续登录用户、留存用户等。 |
| **数据库索引优化**             | 加速复杂查询                     | 在数据库中，对于基数（不同值的数量）较低的列（如性别、地区），可以创建位图索引。每个可能的值都对应一个位图，位图的每一位对应表中的一行。查询时，可以通过对多个条件的位图进行`AND`、`OR`等操作，快速定位到符合条件的行，极大地提升了多条件组合查询的性能。 |
| **布隆过滤器（Bloom Filter）** | 快速判断元素是否存在（允许误判） | 布隆过滤器是一种概率型数据结构，用于判断一个元素是否在一个集合中。其核心就是多个位图和多个哈希函数的组合。它能以极高的空间效率判断一个元素“一定不存在”或“可能存在”，常用于缓存穿透、垃圾邮件过滤等场景。 |
| **操作系统资源管理**           | 标记资源使用状态                 | 操作系统需要管理磁盘块、内存页等资源。可以使用位图来标记每个资源块是否被占用。例如，磁盘的每个扇区对应一位，1表示已分配，0表示空闲。分配资源时，只需查找位为0的位置；释放时，将对应位清零即可。 |

###实现原理和步骤

位图通常是基于**数组**来实现的，数组的每个元素可以看作是一个**桶**，每个桶里装着多个二进制位。

例如，可以使用一个整型（`int`）数组，在32位系统中，每个`int`可以存储32个位的状态。

#### 确定数组的大小

首先，需要知道待处理数据的最大值 `maxValue`。

数组的大小 `size` 可以通过 `maxValue / (每个数组元素能存储的位数) + 1` 来计算。

例如，如果使用 `int` 数组（32位），则 `size = maxValue / 32 + 1`。

#### 定位元素位置

对于任意一个数字 `n`，需要确定它在哪个数组元素（桶）的哪个位上。

#####怎样确定元素在哪一个桶（数组元素）中？

- **数组索引 (Index):** `index = n / 32` (或 `n >> 5`)，这决定了数字 `n` 应该存储在数组的第几个元素中。

##### 怎样确定元素在桶里的位置？

- **位偏移 (Position):** `pos = n % 32` (或 `n & 31`)，这决定了在 `array[index]` 这个整数中，`n` 对应的是第几位（从0开始）。

#### 怎样操作特定位置？

##### 怎样添加一个元素

假设我们要将数字 `n` 添加到位图中，现在我们我们已经确定要将该元素放到：`array[index]`的pos位置上。

那么现在我们需要将 `array[index]` 的第 `pos` 位设置为1。

这可以通过按位或操作实现：

```Java
	int index = x >> 5; // x/32
  int position = x & 31; // x % 32
  // int temp = 1 << position , 将数字1左移pos个位置，左移之后，第pos个位置是1
  //这里 `1 << pos` 会生成一个只有第 `pos` 位是1，其余位都是0的掩码（mask）。
  // bits[index] = bits[index]|temp, 使用或操作，只有有一个1，那么这个位置就是1，通过这种方式将pos位修改为1
  bits[index] |= ( 1 << position); //将某个位置设置为1
```

##### 怎样删除一个元素？

要删除数字 `n`，需要将 `array[index]` 的第 `pos` 位设置为0。这可以通过按位与和一个取反的掩码实现：

```Java
 public void remove (int x){
    int index = x >>5;
    int position = x & 31;
   //1. 同样将1左移pos个位置，获得一个只有pos位置是1，其余位置是0的数字
   // int temp = 1 << pos
   // 2.将上述数字取反，只有pos是0，其余位置位1
   // int reversedTemp = ~temp;
   // 3.使用按位与操作 (只有两个数字都是1时候才结果才是1)
   // 这样可以： 1. 确保pos位置一定会被置0， 2 其余位置可以保持原来的值不变
   // bits[index] = bits[index] & reversedTemp;
    bits[index] &= ~(1 << position);
  }
```

##### 查询一个元素是否存在

```Java
  public boolean contains(x){
    int index = x >> 5;
    int position = x & 31;
    //同样取temp = 1 << pos
    //采用按位与操作，判断pos位置是否是1
    return (bits[index] & (1 << position)) != 0;
  }
```

### 优缺点总结

#### 优点

- 节省空间：1 bit表示一个数，相比哈希集合大大节省内存
- 操作高效： `O(1)`的插入、查找时间复杂度
- 适用于大范围整数操作

#### 缺点

- 只能表示**整数**，且需要提前知道**最大范围**
- 不能存储具体数据内容（只能表示“是否存在”）
- 不适用于负数（需要做偏移）

### 适用场景

| 场景                 | 描述                              |
| -------------------- | --------------------------------- |
| 大规模整数去重       | 使用 Bitmap 标记出现过的数        |
| 黑名单判定           | 比如判断手机号、IP 是否在黑名单中 |
| 分布式系统布隆过滤器 | 位图是布隆过滤器的基础结构之一    |
| 排序整数数据         | 对大范围稀疏整数进行位图排序      |
| 唯一访问计数         | 例如UV去重统计                    |

### 代码套路模板

#### 位图定义

```java
class BitMap{
  private int[] bits;
  
  public BitMap(int max){
    bits = new int[(max >> 5) + 1]; //等价于max/32
  }
  
  public void add(int x){
    int index = x >> 5; // x/32
    int position = x & 31; // x % 32
    bits[index] |= ( 1 << position); 
  }
  
  public boolean contains(x){
    int index = x >> 5;
    int position = x & 31;
    return (bits[index] & (1 << position)) != 0;
  }
  
  //删除数字
  public void remove (int x){
    int index = x >>5;
    int position = x & 31;
    bits[index] &= ~(1 << position);
  }
}
```



## 差分法 - 将区间问题转化为点问题

### 什么是差分数组？

差分数组是一种巧妙并且基础的技巧，用于高效处理对数组**某个区间内的所有元素**进行**相同增减**操作的场景。

差分法是一种**将区间操作转化为点操作， 并通过前缀和恢复原来序列的技巧**。

其核心是在更新区间时，只是在差分数组的**两个端点**做**加减标记**，最后**一次性通过累加恢复最终结果**，从而将每次区间更新的复杂度从O(N)降低到O(1).

### 差分数组的定义

给定一个初始数组`A[0...n-1]`，定义差分数组D为
$$
D[0]=A[0],D[i]=A[i]−A[i−1] (i≥1)
$$
那么：
$$
A[i]= 
\sum_{j=0}^{i}
 D[j]
$$
`A[i] =D[0]+D[1]+D[2]+...+D[i]`

### 应用场景和解决的问题

#### 常见的场景类型

- **区间内的元素批量加/减操作**：多次对数组某些区间 $[l,r]$ 加上相同值 $v$；
- **矩阵区间更新**（二维差分）：对子矩阵加/减操作；
- **区间贡献统计**：例如统计某些事件在区间内的覆盖次数；
- **离线处理**：当更新操作多、最后才需要输出结果时；
- **DP 优化**：将某些 DP 状态转移的区间加权优化为常数时间；

#### 经典的问题场景

| 场景                       | 目标                                                         | 差分数组的应用                                               |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **公交车/航班订票**        | 有一系列的上下车/订票记录（例如，从第`l`站到第`r`站，增加了`v`名乘客），计算每一站或某个时间点公交车/飞机上的总人数。 | 将站点/时间轴看作数组。每个订票记录 `[l, r, v]` 对应一次区间 `[l, r-1]` 的增加操作（因为乘客在第`r`站下车，所以影响的站点是`l`到`r-1`）。对差分数组进行 `D[l] += v, D[r] -= v`。最后通过前缀和还原出每个站点的总人数。 |
| **游戏中的范围伤害/治疗**  | 游戏角色对一个矩形区域内的所有单位造成`v`点伤害。            | 这是一维差分数组的扩展（二维差分）。对二维差分矩阵的四个角点进行修改，即可实现对一个子矩阵的范围增减。 |
| **对数组进行多次区间增减** | 给定一个初始数组和多次区间修改操作，求最终的数组状态。       | 先根据初始数组构建差分数组，然后对每一次区间修改，都只修改差分数组的两个端点。所有修改完成后，再通过一次前缀和计算，从差分数组还原出最终结果数组。 |



### 核心思想 - 如何批量增减某个连续区间上的所有元素？

想象一下，我们有一个数组 `A`，现在需要频繁地对某个连续的区间 `[l, r]` 上的所有元素加上一个值 `v`。

#### 朴素的暴力方法 - 遍历区间内的所有元素

直接遍历从`l`到`r`的所有元素，将它们都加上`v`。

如果这样的操作有`m`次，每次操作的区间长度为`k`，那么总的时间复杂度为$O(m \cdot {k})$。

当`m`和`k`很大的时候，效率会非常低下。

#### 基于差分数组的方法

创建一个新的数组 `D`（差分数组），`D[i]` 记录了原数组 `A[i]` 与前一个元素 `A[i-1]` 的差值。

通过这种方式，**对原数组一个区间的修改，会神奇地转化为对差分数组两个端点的修改**。

##### 差分数组的定义

- `D[0] = A[0]`
- `D[i] = A[i] - A[i-1]`（当 `i` > 0）

##### 差分数组的关键性质 

###### A[i]是差分数组的前缀和

差分数组和前缀和数组是**互逆**的关系。

`A[i] = D[0] + D[1] + ... + D[i]`

这个性质是差分数组所有魔法的来源。当我们修改了差分数组 `D`，就相当于间接地修改了它的前缀和，也就是修改了原数组 `A`。

###### 区间修改的影响 - 差分数组修改边界值等价于修改整个数组的区间元素值

思考一下，当我们将 `A[l...r]` 区间内的所有数都加上 `v` 时，这个操作对它们与前一个元素的“差值”会产生什么影响？

- 对于 `A[l]`：它的值增加了 `v`，而 `A[l-1]` 没变，所以 `A[l] - A[l-1]` 这个差值，**即 `D[l]`，增加了 `v`**。
- 对于区间中间的任何元素 `A[i]` (`l < i <= r`)：`A[i]` 和 `A[i-1]` 都同时增加了 `v`，所以它们的差值 `A[i] - A[i-1]`，即 `D[i]`，**保持不变**。
- 对于 `A[r+1]`：它的值没变，而 `A[r]` 增加了 `v`，所以差值 `A[r+1] - A[r]`，**即 `D[r+1]`，减少了 `v`**。

所以**对原数组的区间`[l,r]`加上`v`，等价于对差分数组D进行两处修改：**

- `D[l]`加上`v`
- `D[r+1]`减去`v`

这样，一次 O(k) 的区间操作就变成了两次 O(1) 的单点操作，效率得到了质的飞跃。

### 实现原理

假设所有的区间都是在某一个数组A

#### 初始化A的差分差分数组

- 输入：原始数组 `A`，长度为 `n`。

- 创建一个长度相同的差分数组 `D`。

- `D[0] = A[0]`。

- 遍历 `i` 从 `1` 到 `n-1`，计算 `D[i] = A[i] - A[i-1]`。

这个过程的时间复杂度是 O(n)。

```java
D[0] = A[0];
for i = 1..n-1: D[i] = A[i] - A[i-1];
```

#### 对数组区间`[l,r]`内的元素加上`v`

- 输入：起始索引 `l`，结束索引 `r`，增量 `v`。

- 对差分数组 `D[l]` 加上 `v`：`D[l] += v`。

- 如果 `r+1` 没有越界（即 `r+1 < n`），则对 `D[r+1]` 减去 `v`：`D[r+1] -= v`。

这个过程的时间复杂度是 O(1)。

```
D[l] += v;
if (r + 1 < n) D[r+1] -= v;
```

#### 复原原数组 - 本质上原数组就是差分数组的前缀和数组

当所有更新操作都完成后，需要将最终的差分数组 `D` 还原成结果数组 `A'`。

- `A'[0] = D[0]`。
- 遍历 `i` 从 `1` 到 `n-1`，计算 `A'[i] = A'[i-1] + D[i]`。
- 这个过程本质上是在求 `D` 的**前缀和**，时间复杂度是 O(n)。

```
A[0] = D[0];
for i = 1..n-1:
    D[i] += D[i-1];
// 此时 D 就是更新完毕后的 A
```

### 代码套路模板

```java
public class Difference {
    private long[] diff;   // 使用 long 防止溢出
    private int n;

    // 构造差分数组，传入原数组 A
    public Difference(long[] A) {
        n = A.length;
        diff = new long[n];
        diff[0] = A[0];
        for (int i = 1; i < n; i++) {
            diff[i] = A[i] - A[i - 1];
        }
    }

    // 区间 [l, r] 增加 val
  	// 意思是给数组A[l...r]中的每一个元素都加val
    public void increment(int l, int r, long val) {
        if (l < 0 || r >= n || l > r) {
            throw new IllegalArgumentException("Invalid range");
        }
        diff[l] += val;
        if (r + 1 < n) {
            diff[r + 1] -= val;
        }
    }

    // 返回更新后的数组
    public long[] result() {
        long[] res = new long[n];
        res[0] = diff[0];
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }

    // 示例用法
    public static void main(String[] args) {
        long[] A = {1, 2, 3, 4, 5};
        Difference df = new Difference(A);
        df.increment(1, 3, 10);   // 对 A[1..3] 加 10
        df.increment(2, 4, -2);   // 对 A[2..4] 减 2
        long[] updated = df.result();
        System.out.println(Arrays.toString(updated));
        // 输出: [1, 12, 11, 12, 3]
    }
}

```

### 注意事项

**越界检查**：`l`、`r` 的合法性必须保证，避免访问 `diff[r+1]` 时越界；

**数据类型**：如果多次更新值较大，或数组元素本身较大，推荐使用 `long`；

**初始构造**：若初始数组全为 0，可直接 `diff = new long[n]`，无需从 `A` 构造；

**多维差分**：二维差分需要在 $(x1,y1)$ 加，在 $(x2+1,y1)$、$(x1,y2+1)$ 减，在 $(x2+1,y2+1)$ 加；

**应用场景**：仅适合“离线”场景——在所有更新结束后才需要整体结果，不适合实时查询每次更新后的单点查询（除非结合树状/线段树）。

### 经验总结

- **先画图、推公式**：画出一维/二维数组，标记边界增减，理解“边界差分”原理；
- **模板复用**：将差分封装成类，提高复用性，并在需要时扩展到高维；
- **结合其他技巧**：差分常与前缀和、扫描线、离散化、树状/线段树等结合，解决更复杂的区间或区间交集问题；
- **调试时多打印**：尤其是差分数组的中间状态，确认增减操作是否生效；
- **关注边界**：含头含尾、半开半闭区间的选择要与题目一致，避免 off-by-one；
- **实践题目**：LeetCode 1109、HDU “差分” 专题、各大竞赛区间操作题，都是巩固差分思维的好机会。

### Leetcode 1109 ： 航班预订问题

#### 问题要点

**输入**: 一个整数 `n` 代表航班总数（从 1 到 n），以及一个预订列表 `bookings`。

每个预订 `bookings[i] = [first, last, seats]` 表示一个预订记录，**即从第 `first` 个航班到第 `last` 个航班（包含两端），都预订了 `seats` 个座位**。

**输出**: 返回一个长度为 `n` 的数组 `answer`，其中 `answer[i]` 是第 `i+1` 个航班上总共被预订的座位数。

**举例**:

- 预订1: 航班1, 2 各增加 10 个座位。`[10, 10, 0, 0, 0]`

- 预订2: 航班2, 3 各增加 20 个座位。`[10, 10+20, 20, 0, 0]` -> `[10, 30, 20, 0, 0]`

- 预订3: 航班2, 3, 4, 5 各增加 25 个座位。`[10, 30+25, 20+25, 25, 25]` -> `[10, 55, 45, 25, 25]`

#### 问题本质和分析 (Problem Essence and Analysis)

这道题的本质是对一个数组进行多次 **区间更新** (Range Update) 操作。

##### 朴素的暴力方法

最直观的想法是，创建一个长度为 `n` 的结果数组 `result`，全部初始化为 0。

然后遍历每一个预订 `[first, last, seats]`，再用一个循环从 `first-1` 到 `last-1` 遍历对应的数组区间，给每个元素都加上 `seats`。

###### 暴力方法的时间复杂度

假设有 `k` 个预订。对于每个预订，最坏情况下需要遍历 `n` 个元素。所以总时间复杂度是 $O(k\cdot{n})$。

###### 可行性分析

 根据题目给定的数据范围 (`n` 和 `bookings.length` 可达 20000)，$20000\times20000=4\times{10^8}$，这个计算量太大了，一定会超时 (Time Limit Exceeded)。

$D[i] = \begin{cases} {A[i], i = 0}\\A[i]-A[i-1], i\ge 1\end{cases}  $

#### 模式匹配

##### 问题的特征和匹配

当你遇到以下特征的问题时，应该立刻想到差分数组：

1. 操作对象是一个线性结构（如数组）。
2. 需要进行大量的 **区间增加/减少** 操作。
3. 问题 **不要求** 在每次更新后立即得到结果，而是要求在 **所有更新操作完成后** 给出最终的数组状态（这被称为“离线操作”）。

##### 类似问题

- **LeetCode 1094. Car Pooling**: 非常相似，也是在时间轴（类似数组）上进行区间增减（乘客上下车），最后判断每个点的负载是否超标。

- 任何需要在数组上频繁对某个范围进行统一修改的问题。

#### 核心思想和套路

本题的套路就是使用差分数组：

1. **转化视角**: 不要直接去维护最终的座位数数组。而是去维护一个“变化量”数组，这个数组就是差分数组。
2. **构建差分**: 创建一个长度为 `n` 的差分数组 `diff`，初始全为 0。
3. **处理操作**:
   - 对于每个预订 `[first, last, seats]`：
   - 这意味着从 `first` 航班开始，座位数增加了 `seats`。我们记录这个“事件”：`diff[first-1] += seats`。
   - 这个增加效应会一直持续下去。为了让它在 `last` 航班之后失效，我们需要在 `last+1` 航班处记录一个反向的“事件”：`diff[last] -= seats` (注意边界检查)。
4. **最终求和**: 当所有预订都处理完毕后，差分数组 `diff` 就记录了所有座位的“变化点”。我们通过计算它的前缀和，就能一举得到每个航班最终的座位总数。

#### 实现原理和步骤

**创建差分数组**: `int[] diff = new int[n];`

**遍历预订列表**:

- `for (int[] booking : bookings)`
- 获取 `first`, `last`, `seats`。
- 转换为 0-based 索引：`l = first - 1`, `r = last - 1`。
- 在起始位置增加座位数：`diff[l] += seats;`
- 在结束位置的后一个位置减去座位数（如果该位置存在）：`if (r + 1 < n) { diff[r + 1] -= seats; }`

**还原结果数组**:

- 遍历差分数组，从第二个元素开始，将它与前一个元素的值相加，实现前缀和计算。
- `for (int i = 1; i < n; i++) { diff[i] += diff[i-1]; }`
- 此时，`diff` 数组本身已经变成了我们想要的最终结果。

**返回结果**: `return diff;`

#### 实现代码

```Java
class Solution {
    //返回每个航班预订的座位数量
    //bookings表示航班flights[i...j]的**每个航班**预订了seat_i
    //如何转化为差分数组问题？
    class Difference {
        int[] diff;
        int n;
        public Difference(int[] arr){
            this.n = arr.length;
            this.diff = new int[n];
            diff[0] = arr[0];
            for(int i = 1; i < n; i++){
                diff[i] = arr[i] - arr[i-1];
            }
        }

        public void add(int l, int r, int val){
            diff[l] += val;
            if(r+1 < n) diff[r+1] -= val;
        }

        public int[] getArr(){
            int[] res = new int[n];
            res[0] = diff[0];
            for(int i = 1; i < n; i++){
                res[i] = res[i-1] + diff[i];
            }
            return res;
        }
    }

    public int[] corpFlightBookings(int[][] bookings, int n) {
        Difference difference = new Difference( new int[n+1]);
        for(int[] b : bookings){
            int l = b[0];
            int r = b[1];
            int seats = b[2];
            difference.add(l, r, seats);
        }
        return Arrays.copyOfRange(difference.getArr(), 1, n+1);
    }
    
}
```

#### 注意事项

1. **下标转换**: 题目中的航班号是 1-based (`1` to `n`)，而 Java 数组是 0-based (`0` to `n-1`)。在实现时一定要小心转换，`航班 i` 对应 `数组索引 i-1`。
2. **边界处理**: 在处理预订 `[first, last, seats]` 时，减少 `seats` 的位置是 `last` 航班之后，即对应数组索引 `last`。如果 `last` 已经是 `n` 了，那么 `last+1` 就超出了范围，我们不需要做任何减少操作，因为这个预订的影响会一直持续到最后一个航班，无需被“取消”。代码中的 `if (last < n)` 正是处理这个边界情况。
3. **空间优化**: 我们可以直接在差分数组上进行前缀和计算，从而将它原地转换为结果数组，避免了额外创建一个结果数组的开销。

#### 经验总结

**识别模式是关键**: "多次区间修改，一次最终查询" 是使用差分数组的强烈信号。

**化繁为简**: 差分思想的精髓在于将复杂的区间操作转化为简单的端点操作，大大降低了算法的时间复杂度。

**举一反三**: 掌握了差分数组，不仅能解决这道题，还能解决一系列类似的区间问题。它是解决算法问题的一个重要工具。与它相对应的是 **前缀和**，前缀和用于解决 **“一次初始化，多次区间查询”** 的问题。它们是一对互补的技巧。

## 前缀/后缀最值数组 - 求前i个元素的最值

在算法和数据结构领域，前缀/后缀最值数组是一种强大而高效的预计算技术。

它通过提前计算数组中每个位置之前或之后元素的极值（最大值或最小值），来优化问题的求解过程，显著降低时间复杂度。

### 核心思想 - 预算计算前缀/后缀最值

前缀/后缀最值数组的核心思想是 **“空间换时间”**。

对于一个给定的数组，我们可以创建新的辅助数组，用于存储原始数组从头到当前位置（前缀）或从尾到当前位置（后缀）的所有元素中的最大值或最小值。

#### 前缀最值数组

`prefix_max[i]` 存储了原始数组 `arr[0...i]` 区间内的最大值，而 `prefix_min[i]` 存储了该区间内的最小值。

#### 后缀最值数组

`suffix_max[i]` 存储了原始数组 `arr[i...n-1]` 区间内的最大值，而 `suffix_min[i]` 存储了该区间内的最小值。

通过这样的预处理，当我们需要查询任意一个前缀或后缀的最值时，可以直接以 O(1) 的时间复杂度获取，避免了在需要时才进行遍历计算的 O(n) 复杂度。

### 背景知识 - DP的一种简单应用

前缀/后缀最值数组是 **动态规划 (Dynamic Programming)** 思想的一种简单应用。其状态转移方程非常直观：

- **前缀最大值**：`prefix_max[i] = max(prefix_max[i-1], arr[i])`
- **前缀最小值**：`prefix_min[i] = min(prefix_min[i-1], arr[i])`
- **后缀最大值**：`suffix_max[i] = max(suffix_max[i+1], arr[i])`
- **后缀最小值**：`suffix_min[i] = min(suffix_min[i+1], arr[i])`

这种思想与**前缀和 (Prefix Sum)** 数组一脉相承。

前缀和数组预计算了数组的前缀总和，从而可以 O(1) 地查询任意区间的和。

前缀/后缀最值数组则将这种预计算的思想应用到了求解最大值和最小值的问题上。

### 常见的应用场景

前缀/后缀最值数组在解决那些需要依赖于某个元素左侧或右侧所有元素信息的数组问题时，表现得尤为出色。

#### 场景一：左右侧极值问题

对于数组中的每一个元素，需要知道其左边所有元素的最大/最小值，以及右边所有元素的最大/最小值，然后进行综合计算。

##### 经典案例：接雨水 - 求左右两侧最高的柱子的高度

**问题描述：** 给定一个非负整数数组，代表一个直方图，计算这个直方图能接多少雨水。

**应用解析：** 对于数组中的任意一个位置 `i`，它能接的雨水量取决于其左右两侧最高的柱子中较矮的那个。

具体来说，`i` 位置能接的雨水量为 `min(左侧最高柱子的高度, 右侧最高柱子的高度) - height[i]`。

- 我们可以通过一个**前缀最大值数组 `left_max`** 来存储每个位置左侧（包括自身）的最高柱子高度。
- 通过一个**后缀最大值数组 `right_max`** 来存储每个位置右侧（包括自身）的最高柱子高度。
- 最后，遍历一次数组，对每个位置 `i`，其能接的雨水量就是 `min(left_max[i], right_max[i]) - height[i]` (如果结果为负则取0)。

#### 场景二： 单次交易的最大收益问题

**目标：** 在一次买入和一次卖出的约束下，找到最大化收益的策略。

##### 经典案例： 买卖股票的最佳时间

**问题描述：** 给定一个数组 `prices`，其中 `prices[i]` 是某只股票在第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

**应用解析：** 为了在第 `i` 天卖出时获得最大利润，我们需要在 `i` 天之前（即 `0` 到 `i-1` 天）以最低的价格买入。

- 我们可以使用一个**前缀最小值数组 `prefix_min`** 来存储到第 `i` 天为止的最低股价。`prefix_min[i]` 表示 `prices[0...i]` 中的最低价格。
- 然后遍历 `prices` 数组，对于第 `i` 天，计算在当天卖出的最大利润 `prices[i] - prefix_min[i]`。
- 在所有天数中，取这个利润的最大值即可。

#### 场景三： 数组分割和划分问题

**目标：** 将数组分割成两部分（或多部分），并比较这两部分之间的某些属性（如最值、和等）。

经典案例：将数组分离为两个子数组使得一个子数组的最大值小于另一个子数组的最大值

- **问题描述：** 给定一个数组，找到所有可能的分割点，使得该点左侧（前缀）所有元素的最大值小于右侧（后缀）所有元素的最大值。
- 应用解析：
  - 创建一个**前缀最大值数组 `prefix_max`**，`prefix_max[i]` 存储 `arr[0...i]` 的最大值。
  - 创建一个**后缀最大值数组 `suffix_max`**，`suffix_max[i]` 存储 `arr[i...n-1]` 的最大值。
  - 遍历所有可能的分割点 `i` (从 `0` 到 `n-2`)，如果 `prefix_max[i] < suffix_max[i+1]`，则 `i` 是一个有效的分割点。

### 实现原理和步骤

#### 前缀最值数组的实现

**`prefix_max` 数组：**

1. 初始化 `prefix_max` 数组，其大小与原数组 `arr` 相同。
2. `prefix_max[0]` 的值等于 `arr[0]`。
3. 从 `i = 1` 开始遍历到数组末尾：
   - `prefix_max[i] = max(prefix_max[i-1], arr[i])`

**`prefix_min` 数组：**

1. 初始化 `prefix_min` 数组，其大小与原数组 `arr` 相同。
2. `prefix_min[0]` 的值等于 `arr[0]`。
3. 从 `i = 1` 开始遍历到数组末尾：
   - `prefix_min[i] = min(prefix_min[i-1], arr[i])`

#### 后缀最值数组的实现

- **`suffix_max` 数组：**
  1. 初始化 `suffix_max` 数组，其大小与原数组 `arr` 相同。
  2. 设数组长度为 `n`，`suffix_max[n-1]` 的值等于 `arr[n-1]`。
  3. 从 `i = n-2` 开始向前遍历到数组开头：
     - `suffix_max[i] = max(suffix_max[i+1], arr[i])`
- **`suffix_min` 数组：**
  1. 初始化 `suffix_min` 数组，其大小与原数组 `arr` 相同。
  2. 设数组长度为 `n`，`suffix_min[n-1]` 的值等于 `arr[n-1]`。
  3. 从 `i = n-2` 开始向前遍历到数组开头：
     - `suffix_min[i] = min(suffix_min[i+1], arr[i])`

### Leetcode 42: 接雨水

详细见Airbnb专题问题列表。

## 字符串匹配算法

### 明确字符串搜索匹配的目标 - 查找某个子串

在深入算法之前，我们先明确问题本身。

字符串搜索匹配的目标是：**在一个较长的文本字符串（Text）中，查找一个较短的模式字符串（Pattern）是否存在，如果存在，则返回其所有出现的位置。**

例如，在文本 `T = "ABCABAABCABAC"` 中查找模式 `P = "ABCAB"`。

在字符串搜索中，最常用的算法有KMP（Knuth-Morris-Pratt）算法和Rabin-Karp算法，它们分别解决了暴力搜索中可能出现的低效问题。

### KMP算法 - **避免在匹配过程中进行不必要的回溯**

KMP 算法由 Donald Knuth、Vaughan Pratt 和 James H. Morris 在 1977 年联合发表，其核心思想是**避免在匹配过程中进行不必要的回溯**。

#### 核心思想和背景知识

##### 朴素的暴力方法

最容易想到的朴素解法是**双循环**：

1. 将文本字符串`T`的第一个字符和模式串`P`的第一个字符对齐，逐个比较。
2. 如果遇到不匹配的字符，将模式串`P`整体向右移动一位，再从`P`的第一个字符开始和`T`的新位置比较。
3. 重复这个过程，知道找到匹配或者遍历完成整个文本。

缺陷在于：发生不匹配的时候，朴素算法简单的将模式串右移一位，完全**忽略了已经匹配过的那部分信息**，导致了大量冗余的比较。

例如： `T = "ABCABAABCABAC"` `P = "ABCABD"`

当我们在 `T` 的索引 0 处开始匹配，直到 `P` 的最后一个字符 `D` 与 `T` 的 `A` 不匹配时：

```
T: A B C A B A A B C A B A C
P: A B C A B D
             ↑
             不匹配
```

朴素算法会把 `P` 右移一位，从头开始比较：

```
T: A B C A B A A B C A B A C
 P:  A B C A B D
     ↑
     重新开始比较
```

但我们通过肉眼观察可以发现，`T` 的 `B` 根本不可能和 `P` 的 `A` 匹配。

**KMP 算法就是为了利用已经匹配过的信息，智能地决定模式串应该“滑动”多远。**

##### KMP的核心思想：最长公共前后缀

KMP 算法的核心在于，当发生不匹配时，我们不希望将模式串 `P` 完全回溯到头部，而是希望利用**已经匹配过的前缀信息**，找到一个**最佳的位置**继续匹配。

这个“最佳位置”取决于模式串 `P` 自身的结构。

具体来说，是**已匹配前缀的“最长公共前后缀”（Longest Proper Prefix which is also Suffix, LPS）**。

###### 前缀

指**除了字符串本身外**的所有**头部子串**。

例如 `"ABCAB"` 的前缀有 `A`, `AB`, `ABC`, `ABCA`。

###### 后缀

指除了**字符串本身外**的所有**尾部子串**。

例如 `"ABCAB"` 的后缀有 `B`, `AB`, `CAB`, `BCAB`。



在上面的例子中，已匹配的部分是 `P` 的前缀 `"ABCAB"`。它的最长公共前后缀是 `"AB"`。

```
P: A B C A B
前缀: A, AB, ABC, ABCA
后缀: B, AB, CAB, BCAB
公共部分: AB
长度为 2
```

这个长度2告诉我们： 当不匹配发生的时候，我们可以将模式串`P`向右滑动，使得`P`中长度为2的前缀`AB`对齐到刚刚匹配上的`T`中的那段`AB`的位置。

```
T: A B C A B A A B C A B A C
P: A B C A B D          (不匹配前)
       A B C A B D      (滑动后)
         ↑
         从这里继续比较
```

