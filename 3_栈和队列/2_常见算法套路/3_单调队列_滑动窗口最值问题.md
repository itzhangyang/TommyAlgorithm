### 单调队列-滑动窗口最值问题

#### 什么是单调队列？

单调队列是一种维护队列中元素单调性的数据结构，常常用来在**滑动窗口**或者**区间问题**中快速获取**最值**。

单调队列**从头到尾**保持单调👍。

- 单调递减队列：队列中的元素从头到尾是递减的，因此队头元素是**最大值**
- 单调递增队列：队列中的元素从头到尾是递增的，因此队头元素是**最小值**

单调队列中一般**存储元素的索引而不是元素的值**，无论递增还是递减，单调队列中的索引值是**递增**的。

**存储索引**：在绝大多数应用中，单调队列确实存储的是元素的**索引（index）** 而不是元素值本身。这样做的好处是可以通过索引随时访问到原始值，并且能轻易判断一个元素是否已经“滑出”了当前窗口。

**索引递增**：因为我们总是按从左到右的顺序遍历原始数组（例如 `for i in 0..n-1`），新入队的元素的索引 `i` 必然大于队列中已存在的所有元素的索引。因此，**无论队列中存储的值是单调递增还是递减，其对应的索引一定是严格单调递增的**。

通过在入队时移除无用元素（会被新元素`淘汰`的元素），从而保证队列头部始终是当前区间内的最小值或者最大值。

#### 单调队列的实现原理

首先单调队列的实现是基于**双向链表或者队列**实现的。

以单调递减队列为例（维护区间的最大值）：

##### 单调队列的入队过程

- 它会从**队尾**开始，与队列中已有的元素进行比较
- 所有“不如”新元素 `x` 的队尾元素都会被**永久剔除**。
  - 在单调递减队列（求最大值）中，“不如”指的是小于 `x` 的元素：
    - **单调递减队列队头比队尾大**，不能够出现相邻元素**后者比前者大**的情况。
    - 因为 `x` 更“新”也更“大”，那些比它小的旧元素未来**绝不可能成为窗口内的最大值**，因此可以直接丢弃

  - 在单调递增队列（求最小值）中，“不如”指的是大于 `x` 的元素。

- 完成剔除后，新元素 `x` 才从队尾入队。

##### 维护“窗口”范围的出队机制 (Window-based Dequeue)

单调队列通常用于解决**固定大小滑动窗口**相关的问题。因此，它的出队操作与普通队列不同，是基于**窗口**的。

- 队列中存储的不仅仅是元素值，通常还需存储该元素在原序列中的**索引**，以便判断其是否“过期”。
- 在窗口滑动的每一步，我们都需要检查**队头**元素的索引是否已经超出了当前窗口的左边界。

- 如果超出，说明队头元素已经“过期”，需要从队头将其弹出。

##### 单调队列的特性

###### 单调递减队列的特性

- 从头到尾递减
- 队首的元素为**最大值**

###### 单调递增队列的特性

- 从头到尾递增
- 队首的元素为**最小值**

##### 单调队列是如何保证单调性的？

在插入新元素时，**将所有不满足单调性的尾部元素弹出**，就是从双端队列的尾部取出，从而确保队列内元素始终满足特定的单调性（递增或递减）。

##### 如何使用单调队列解决滑动窗口最大值/最小值问题？

###### 求最大值时，使用单调递减队列

###### 求最小值时，使用单调递增队列



#### 代码套路模板-滑动窗口最大值

##### 变量初始化

- 结果集合
- 双端队列 - `Deque`

#####遍历数组中的所有元素

###### 移除不在滑动窗口的队首元素

- **队列中的元素索引也是递增的**， 所以**队首元素的索引也是滑动窗口中最小的**。
- 队列中存储的是元素的index, 永远是**index小的排在前面**
- 需要注意下列规则：
  - **队首元素的值能够保证是窗口最大值**
  - **队首元素的索引在队列中是最小的**
  - **队首元素的索引不一定是滑动窗口的start 索引**
- 因此每次滑动窗口向前移动一步，就检查队首元素是否**已经过期**（也有可能还没有过期），如果已经过期则需要删除

###### 检查并删除队列中较小元素

从队列的队尾开始，删除所有**比当前元素小的元素**，确保队列的单调性

###### 将当前元素加入到队列中

###### 如果已经凑齐了窗口（`i>=k-1`），则记录最大值

当 `i` >= `k-1` 的时候，就说明已经进入至少第一个滑动窗口，则需要记录当前的最大值。

当前的最大值就是队首的元素。

```java
public int[] maxSlidingWindow(int[] nums, int k){
  Deque<Integer> deque = new LinkedList<>();
  List<Integer> list = new ArrayList<>();
  
  for (int i=0;i<n;i++){
    // 滑动窗口的范围[i-k....i]
    //如果队列的头即将或者已经离开滑动窗口，移除滑动窗口的索引
    if (!deque.isEmpty() && deque.peekFirst() <= i-k){
      deque.pollFirst();
    }
    
    //从队列的尾开始，删除比当前元素小的元素
    //所以本质上来说队列中并不会一只包含窗口中的所有的元素
    while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]){
      deque.pollLast();
    }
    
    //将当前索引加入队尾，删除了比当前元素小的之后，当前元素就是最小的元素，所以加入队尾即可
    deque.offerLast(i);
    
    if(i >= k-1){
      result.add(nums[deque.peekFirst()]);
    }
  }
  //将结果转换成数组返回
  return result.stream().mapToInt(Integer::intValue).toArray();
}
```

注意：队列中存的是索引，方便判断是否过期以及取对应值。

#### 适用场景 - 单调队列需要配合滑动窗口使用

| 场景类型                  | 特征                                             |
| ------------------------- | ------------------------------------------------ |
| **滑动窗口最大值/最小值** | 要求固定窗口内快速获取最值                       |
| **维护动态区间最值**      | 数组中动态滑动窗口、区间内最值问题               |
| **单调栈思想的拓展**      | 用于优化暴力 $O(n\cdot k)$ 的区间最值计算为 O(n) |

#### LeetCode 相关题目推荐

| 题号                                                         | 题目名称                                               | 类型                      |
| ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------- |
| [239](https://leetcode.com/problems/sliding-window-maximum/) | Sliding Window Maximum                                 | ⭐⭐⭐⭐ 核心题               |
| [1438](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) | Longest Continuous Subarray with Absolute Diff ≤ Limit | ⭐⭐⭐⭐ 双队列维护最值       |
| [862](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) | Shortest Subarray with Sum at Least K                  | ⭐⭐⭐⭐⭐ 单调队列优化前缀和  |
| [1696](https://leetcode.com/problems/jump-game-vi/)          | Jump Game VI                                           | ⭐⭐⭐⭐⭐ 动态规划 + 单调队列 |
| [1006](https://leetcode.com/problems/clumsy-factorial/)      | Clumsy Factorial                                       | ⭐⭐ 逻辑处理，了解即可     |
| [1100](https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/) | Find K-Length Substrings Without Repeated Characters   | ⭐⭐ 变种滑动窗口           |

#### 常见变形和注意点

**递增队列维护最小值**（如求最小值）：

- 只需反过来处理入队逻辑，将比新元素大的都踢出队尾。

**队列中存索引而非值**：

- 可以更方便地判断元素是否过期、访问实际值。

**可以配合 DP、二分查找等高级技巧**：

- 如 Jump Game VI、Shortest Subarray with Sum at Least K 等题目中是 DP 优化的关键。

#### 模版题目：Leetcode 239：求每个固定滑动窗口的最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

##### 实现代码

```Java
//单调递减队列 + 滑动收缩窗口
//利用滑动窗口维护单调递减队列
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        List<Integer> list = new ArrayList<>();
        Deque<Integer> queue = new LinkedList<>();
        int left = 0;
        for(int right = 0; right < nums.length; right++){
            int rNum = nums[right];
            //删除队尾比当前元素小的元素
            while(!queue.isEmpty() && nums[queue.peekLast()] < rNum){
                queue.pollLast();
            }
            queue.offer(right);

            while(right - left + 1 > k ){
                if(queue.peekFirst() == left){
                    queue.pollFirst();
                }
                left++;
            }

            if(right - left + 1 == k){
                list.add(queue.peekFirst());
            }
        }
        int[] ans = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            ans[i] = nums[list.get(i)];
        }
        return ans;
    }
}
```



#### Leetcode 1438 求任意两个元素差值绝对值小于目标值的最大连续子数组

给你一个整数数组 `nums` 和一个整数 `limit`，求最长的**连续子数组**，使得这个子数组中最大值和最小值的差不超过 `limit`。

- 输入：`nums = [8,2,4,7], limit = 4`
- 输出：`2`，最长的子数组是 `[2,4]`，最大值 `4`，最小值 `2`，差为 `2 ≤ 4`

连续数据分析，比如监控系统收集温度数据时，计算“变化幅度受限的最长稳定区间”

找到一个最长的连续子数组，其最大值与最小值的差小于等于 limit。

##### 涉及到的知识点 ： 滑动窗口 + 单调队列 + 双端队列

- 滑动窗口： 用于寻找连续区间的通用技巧
  - 滑动窗口的套路： 扩展 ->满足/不满足条件收缩 ->统计窗口数据
- 单调队列：用于在滑动窗口中高效维护最大值或者最小值，**需要牢记它们的维护逻辑**
  - **最大队列**的维护：删除队列尾部**比当前数字小**的部分，确保队列头部的元素比尾部的元素大
  - **最小队列**的维护：删除队列尾部比**当前数字大**的比分，确保对头部分的元素比尾部的元素小
- 双端队列： 支持在`O(1)`时间内在队首和队尾插入和删除

##### 核心思想和应对套路 - 两个单调队列同时维护窗口最大值和最小值

我们需要在一组连续的数字中，找出最长的一段区间，使这段区间中最大值和最小值之间的差不超过给定的值。

**思路就像观察一个温度计读数的变化：**
 我们一直往右看新的数字，同时保留一个从“左到右”连续的一段。

如果这段的波动太大（最大值 - 最小值 > limit），就从左边去掉一些旧的数，直到这段区间又合法了。

##### 实现原理和步骤

###### 步骤一：维护窗口中的最大值和最小值

- 用一个 **单调递减队列** `maxQueue`：队首永远是当前窗口中的最大值
- 用一个 **单调递增队列** `minQueue`：队首永远是当前窗口中的最小值

###### 步骤二：滑动窗口逻辑

- 用两个指针 `left` 和 `right` 表示当前窗口
- 每次移动 `right` 扩展窗口
- 如果窗口中的最大值 - 最小值 > limit，说明窗口非法 → 向右移动 `left` 来缩小窗口
- 每次更新合法窗口的长度，记录最大值

##### 实现代码

```java
    public int longestSubarray(int[] nums, int limit) {
        Deque<Integer> minQueue = new LinkedList<>();
        Deque<Integer> maxQueue = new LinkedList<>();

        int n = nums.length;

        int left = 0;

        int maxLen = 0;
        for (int right = 0; right < n; right++){
            int num  = nums[right];
            //更新最大队列
            //删除队列尾部比当前数字小的部分，确保队列头部的元素比尾部的元素大
            while( !maxQueue.isEmpty() && maxQueue.peekLast() < num ){
                maxQueue.pollLast();
            }
            maxQueue.addLast(num);

            //更新最小队列，重点：怎样维护单调队列
            //删除队列尾部比当前数字大的部分，确保队列头部的元素比尾部的元素小
            while( !minQueue.isEmpty() && minQueue.peekLast() > num){
                minQueue.pollLast();
            }

            minQueue.addLast(num);
            // 如果不符合要求，尝试收缩窗口
            while (maxQueue.peekFirst() - minQueue.peekFirst() > limit){//尝试收缩窗口
                if(maxQueue.peekFirst() == nums[left]){
                    maxQueue.pollFirst();
                }
                if(minQueue.peekFirst() == nums[left]){
                    minQueue.pollFirst();
                }
                left++;
            }

            maxLen = Math.max(maxLen, right -left + 1);
            
        }

        return maxLen;
    }
```

##### 注意事项

| 注意点                            | 说明                                             |
| --------------------------------- | ------------------------------------------------ |
| **不能排序**                      | 排序会破坏“连续子数组”的结构                     |
| **不能错误使用 `pollFirst()`**    | 用 `peekFirst()` 判断，再调用 `pollFirst()` 删除 |
| **使用 Deque 而非 PriorityQueue** | 优化性能，避免每次查找最大/最小都重新排序        |
| **最大值与最小值必须实时维护**    | 否则无法准确判断窗口是否合法                     |

##### 经验总结

| 难点                                           | 应对方法                                           |
| ---------------------------------------------- | -------------------------------------------------- |
| 如何在 O(1) 时间内获取窗口中的最大值和最小值？ | 使用两个单调队列分别维护最大值和最小值             |
| 为什么需要两个队列？                           | 一个队列无法同时维护最大和最小值，会有信息丢失     |
| 如何保证窗口合法时长度最大？                   | 每次合法就记录一次窗口长度，尝试扩展右边，收缩左边 |

#### Leetcode 862: 和不小于K的最小子数组

#####问题要点 - 数组中可能包含负数！

- **目标 (Goal):** 找到一个 **连续非空子数组**，其元素之和 **至少** 为 `k`，并且这个子数组的 **长度最短**。
- **输入 (Input):** 一个整数数组 `nums` 和一个整数 `k`。
- **输出 (Output):** 最短子数组的长度。如果不存在这样的子数组，则返回 `-1`。
- **核心约束 (Key Constraint):** `nums` 数组中可以包含 **正数、负数和零**。这是本题最关键的特点，也是导致常规解法失效的原因。

##### 问题本质和分析

###### 常规想法： 滑动收缩窗口 + 前缀和， 为啥不行？

**滑动收缩窗口**是很多人首先想到方法，包括我也掉坑里了。

但是它在这里是错误的。

常规滑动窗口依赖一个重要特性： 单调性。

**当窗口扩张时，窗口内的某种属性（例如“和”）会单调增加或减少；当窗口收缩时，该属性也会朝相反方向单调变化**。

但因为本题存在负数，当你把一个负数移出窗口时，窗口的和反而会 **增加**。

这破坏了算法的单调性，导致我们可能会错过最优解。



对于一个只包含 **正数** 的数组，这个前提是成立的：

- 扩大窗口（`right++`），和必然增加。
- 收缩窗口（`left++`），和必然减少。

因此，当 `sum(left, right) >= k` 时，我们收缩窗口 (`left++`)，得到的和会变小。

如果新窗口的和仍然 `>= k`，那它肯定是一个更优（更短）的解。这个逻辑没有问题。



然而，本题的 `nums` 数组中可能包含负数和零。

负数的存在彻底破坏了上述前提。

当你收缩窗口，即 `left++` 时，如果 `nums[left]` 是一个负数，那么新窗口 `[left+1, right]` 的和反而会 **增加**！



##### 模式匹配

我们将问题转化为利用**前缀和**解决子数组和问题。

假设`int[n+1] P`为数组`nums`的**前缀和数组**， 注意其中`P[i]`为`sum(nums[0]....nums[i-1])`。

那么对于子数组`nums[i...j-1]`而言，其和就是`P[j] - P[i]`。



现在我们就单纯将问题转化成为如下的问题：找到最短的`[i...j]`并且符合`P[j] - P[i] >= k`。

对于数组中的每一个元素 `P[j]`，我们需要在它之前的元素中，找到一个 `P[i]`，它:

- 既要满足一个关于值的条件 (`P[i] <= P[j] - k`)，
- 又要满足一个关于位置的条件 (使 `j - i` 最小，**即 `i` 尽可能大**)。

现在我们针对前缀和数组建立一个**单调递增队列**：

任何时刻单调队列中只保存了**当前窗口内符合单调性的元素（或者其索引）**。

对于任何一个当前前缀和`P[j]`，因为队首元素是最小的，因此我们只要看看队首元素是否符合条件`p[j] - p[deque.peekFirst()] >= k`。

如果队首元素不符合条件，那么后面的元素更加不符合条件了。

同时上述条件也是**窗口收缩的条件**，即**出队的条件**。

因此单调递增队列是和窗口一起维护的，我们需要考虑滑动窗口的两个关键操作：

- **什么时候收缩窗口？**

  我们需要在窗口满足`P[j] - P[i] >=k`的时候收缩窗口，这个时候队首的元素就是**左侧最小的元素**，因此滑动窗口收缩的条件应该是：

  ```Java
  while(!deque.isEmpty() && p[j] - p[deque.peekFirst()] >= k){
    //....
  }
  ```

- **入队之前删除队尾比当前元素大的元素**

  ```Java
  while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {
       deque.pollLast();
  }
  ```

注意单调队列的两个属性：

- 值是按照单调行存储的
- 值对应的索引也是单调存储的，即`nums[i+1]`在`nums[i]`后面, **违反单调性原则的元素会被删除**

因此任何时刻单调队列中只保存了**当前窗口内符合单调性的元素（或者其索引）**。



#####核心思想和套路： 单调队列 + 前缀和

我们将使用一个 **双端队列 (Deque)** 来存储前缀和数组的 **索引**，并维护队列中索引对应的 **前缀和值是单调递增的**。

我们遍历前缀和数组 `P`，对于当前的索引 `j` 和值 `P[j]`，我们执行两个核心操作：

###### 核心操作一：检查队首，寻找答案

前面说过了，**单调递增队列**的队首就是**最小值**。

因此在这一步我们检查递增队列的队首元素是否符合`p[j] - p [deque.peekFirst()] >= k`的条件，如果是的话，我们应当**收缩窗口**。

对于这种通过遍历寻找最优值的问题，我们需要**先记录当前值再进行下一轮循环**。

收缩窗口的操作本质上就是**单调队列的出队操作**：

- 记录当前窗口的长度
- 从单调队列中删除队首元素

###### 核心操作二： 更新单调队列

现在我们就要按照标准流程将当前元素加入单调队列：

- 从队尾删除所有比**当前元素大**的元素
- 将当前元素加入单调队列

##### 实现原理和步骤

1. **初始化:**
   - 创建一个 `long` 类型的数组 `prefixSum`，长度为 `N+1`，避免整数溢出。`prefixSum[0] = 0`。
   - 初始化 `minLength = N + 1` (一个不可能达到的值)。
   - 创建一个 `Deque<Integer>` 来存储索引。
2. **计算前缀和:** 遍历 `nums` 数组，填充 `prefixSum` 数组。
   - `prefixSum[i+1] = prefixSum[i] + nums[i]`。
3. **主循环:** 遍历前缀和数组，`j` 从 `0` 到 `N`。 a.  **[操作1]** `while` 循环：当队列不为空，且 `prefixSum[j] - prefixSum[deque.peekFirst()] >= k` 时： * `minLength = Math.min(minLength, j - deque.pollFirst())`。 b.  **[操作2]** `while` 循环：当队列不为空，且 `prefixSum[j] <= prefixSum[deque.peekLast()]` 时： * `deque.pollLast()`。 c.  将当前索引 `j` 加入队尾：`deque.addLast(j)`。
4. **返回结果:**
   - 循环结束后，如果 `minLength` 仍然是 `N + 1`，说明没有找到任何有效的子数组，返回 `-1`。
   - 否则，返回 `minLength`。

##### 实现代码

```Java
//前缀和 + 单调递增队列
class Solution {
    public int shortestSubarray(int[] nums, int k) {
        //创建n+1大小的前缀和数组，prefixSum[i] = sum(nums[0]...nums[i-1])
        int n = nums.length;
        long[] prefixSum = new long[n+1];
        prefixSum[0] = 0;
        for(int i = 0; i < n; i++ ){
            prefixSum[i+1] = nums[i] + prefixSum[i];
        }

        Deque<Integer> deque = new LinkedList<>();
        int minLen = Integer.MAX_VALUE;
        
        for(int i = 0; i <= n; i++){
            //出队过程
            //检查队首元素是否符合prefix[i] - nums[deque.peekFirst()] >= k
            //如果如何，保存记录
            //弹出队首
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
                //本质上是nums[i-1...peeked -1]
                int len = i - deque.pollFirst();
                minLen = Math.min(len, minLen);
            }

            //入队过程
            //删除队尾比当前元素大的元素
            //入队当前元素
            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {
                deque.pollLast();
            }

            deque.addLast(i);
        }

        return minLen == Integer.MAX_VALUE ? -1 : minLen;
    }
}
```

######为什么使用 `<=` 而不是 `<`？

1. **保持队列的递增顺序**：

   - 队列的目标是 **维护单调递增顺序**，即队列中的元素从前到后是递增的。
   - 由于我们需要保证队列中每个元素都小于或等于 **当前的元素**，我们在删除队尾元素时必须确保所有大于 **当前元素** 的元素都被删除。
   - 如果使用 `<=`，我们确保 **所有大于等于当前元素的元素** 都会被移除，从而保证队列中的所有元素都 **小于或等于当前元素**。

2. **避免有重复元素时的遗漏**：

   - 如果使用 `<`，在 **有重复元素** 时，可能会导致 **相等的元素** 被保留在队列中，而我们希望队列保持的是 **“最小的元素”**，以便每次取队头元素时能够获取最小的前缀和。
   - 例如，如果队列的队尾是 `prefixSum[j] = 5`，当前元素 `prefixSum[i] = 5`，使用 `<` 可能会让我们错过删除 `prefixSum[j] = 5`，从而导致队列中有两个相同的元素（5），这会影响我们后续的计算。

3. **确保当前元素能与前面较小的元素相比**：

   - 通过使用 `<=`，即使队尾元素和当前元素相等，队尾元素也会被删除。这样可以确保当前元素作为新的候选元素入队时，队列中的所有前缀和都是 **严格递增** 或 **相等但不重复的**。
   - 使用 **`<=`** 而不是 **`<`** 是为了 **删除所有不符合递增条件的元素**，包括与当前元素相等的元素。这样可以确保队列中存储的是符合条件的、且最小的前缀和，从而保证算法的正确性。

   - 如果使用 **`<`**，当遇到相等的元素时，它们会被保留下来，这可能导致队列不再符合递增顺序，从而影响求解最短子数组或最值的准确性。

##### 注意事项

######**队列的单调性**

- **单调队列** 是 **维护一个递增或递减顺序** 的队列，在本题中我们通常使用 **单调递增队列**。
- 使用单调队列的好处是可以在 **O(1)** 时间内快速获取当前窗口中的最小（或最大）元素，从而有效计算满足条件的最短子数组。

######**入队时的队尾删除条件**

- 在 **入队** 时，**需要先检查队尾元素**，删除那些不符合 **单调递增** 顺序的元素，即比当前元素大的元素。
- 使用 **`<=`** 条件而非 `<` 条件的原因：
  - 保证 **所有比当前元素大的元素** 都被删除，保持队列中的前缀和是 **递增的**。
  - 通过删除队尾的元素，确保队列中每个元素都小于或等于当前元素，这样可以快速获取当前窗口内的最小值。
  - **避免重复元素**：使用 `<=` 确保队列中没有重复的元素，以便后续的操作更加高效。

######**出队时的条件**

- **出队** 时，当队头元素已经不在当前窗口范围内（即它的索引小于当前窗口的左边界），应该 **出队**，从而缩小窗口。
- 这样可以 **动态调整窗口**，以确保我们始终在当前窗口范围内进行计算。

######**队头作为最小值**

- 在 **单调递增队列** 中，队头始终是当前窗口的 **最小值**，因为队列是递增的，队头元素是当前窗口内的最小前缀和。
- 通过维护队列的单调性，我们可以在 **O(1)** 时间内获取最小的前缀和，从而更新最短子数组长度。

######**窗口满足条件时更新最短子数组长度**

- 当找到一个满足条件的子数组（即 `prefixSum[i] - prefixSum[deque.peekFirst()] >= K`），立即计算子数组的长度，并更新最短子数组长度。
- **窗口满足条件时**，可以通过 **队头元素** 来计算当前子数组的长度：`i - deque.peekFirst()`，并记录最短长度。

######**队列的大小**

- 单调队列的 **大小是动态变化的**，在 **每次入队或出队** 时都会根据当前窗口的需求进行调整。
- 队列的操作是 **O(1)**，因此整体算法的时间复杂度是 **O(n)**，其中 `n` 是数组的长度。

######**特例和边界条件**

- **没有满足条件的子数组**：如果遍历完数组后，最短子数组的长度依然是初始化的最大值，说明不存在满足条件的子数组，应该返回 `-1`。
- **空数组或不满足条件的情况**：需要在代码中妥善处理边界情况，如空数组或者无法找到符合条件的子数组。

#####经验总结

######**保持队列单调性**：

- 在处理滑动窗口问题时，特别是在涉及到最值（最大值或最小值）查询的场景中，**单调队列** 是一个非常有效的数据结构。
- 在入队时 **维护递增顺序**，即删除比当前元素大的队尾元素，保证队列中的元素按递增顺序排列。

######**快速获取最小值**：

- 由于队列是递增的，队头始终是最小值，这使得我们可以 **在 O(1) 时间内获取当前窗口中的最小前缀和**，并用于后续的计算。

######**动态调整窗口大小**：

- 使用队列的 **出队** 操作可以帮助我们 **动态缩小窗口**，并确保窗口内的元素始终满足问题的条件。

######**删除不必要的元素**：

- 使用 `<=` 删除不符合条件的元素是为了 **避免重复的元素** 和 **保持队列的单调性**。避免在队列中出现不必要的元素，这样可以提高效率。

######**避免超时**：

- 通过使用单调队列来优化最值查询，可以显著降低算法的时间复杂度，从 **O(n²)** 降低到 **O(n)**，大大避免了超时问题。

######**理解滑动窗口和单调队列的结合**：

- **滑动窗口** 问题通常需要动态调整窗口的大小，通过 **单调队列** 来维护窗口内的最值，能有效减少不必要的计算。
- 使用 **单调队列** 可以快速找到满足条件的最短子数组，尤其是在前缀和问题中尤为高效。

#### Leetcode 1696 : 跳跃游戏VI - 动态规划 + 单调队列

##### 问题要点

题目要求你从数组 `nums` 的第一个元素出发，通过跳跃到后面的元素，最大化每一步的得分。每次跳跃的步数最大为 `k`。目标是找出到达最后一个元素的最大得分。

给定数组 `nums` 和整数 `k`，我们从第一个位置开始，跳跃 `k` 步以内，计算从起始位置到当前位置的最大得分。最终，返回到达数组最后一个位置的最大得分。

**输入:**

- `nums`: 一个长度为 `n` 的数组，表示每个位置的得分。
- `k`: 每次跳跃的最大步数。

**输出:**

- 返回一个整数，表示从第一个位置到达最后一个位置的最大得分。

#####问题本质和分析

**目标:** 通过每次从当前位置跳到下一个位置，选择一个合理的步数（最多 `k` 步），使得最终到达最后一位时，获得的最大得分最大。

**限制条件:** 从当前位置跳跃最多 `k` 步，无法跳到负数位置或超出数组范围。

**状态转移:** 从位置 `i` 到位置 `i + j`（`j` 是步数，`1 <= j <= k`），我们可以通过最大化从 `i` 到 `i + j` 的得分来推动状态转移。

##### 模式套路匹配

###### 使用动态规划计算每一轮最大分数

这是一个典型的**动态规划**问题，通过状态转移方程解决。

考虑到每次跳跃可以在 `k` 步内选择，我们需要维护一个动态窗口，帮助我们计算每次跳跃后的最大得分。

###### 使用滑动窗口+单调队列维护[i-k...i-1]的最大得分

对于每个位置 `i`，我们需要计算从 `i` 跳跃 `1` 到 `k` 步后的最大得分。可以使用 **滑动窗口** 或 **优先队列** 来优化这一过程。

##### 核心思想和套路 - 动态规划 + 滑动窗口

###### 动态规划状态数组的定义

`dp[i]` 表示到达位置 `i` 的最大得分。

状态转移方程：`dp[i] = nums[i] + max(dp[i-1], dp[i-2], ..., dp[i-k])`，即从 `i-k` 到 `i-1` 之间选择一个最大值加上当前位置的得分。

######使用滑动窗口+单调队列维护dp[i-k...i-1]最值

使用一个滑动窗口 `window` 来维护 `dp[i-1]` 到 `dp[i-k]` 的最大值。每次只需要常数时间来更新最大值。

使用 **队列** 或 **双端队列**（deque）来保持窗口中的最大值。

##### 实现原理和步骤

1. 初始化一个数组 `dp`，大小为 `n`，并设置 `dp[0] = nums[0]`（从第一个位置开始）。
2. 用一个双端队列（deque）来存储可能的最大值的索引。
3. 对于每个位置 `i`，计算 `dp[i]`，并将其加入队列中，同时保持队列中的最大值始终是 `dp[i-k]` 到 `dp[i-1]` 之间的最大值。
4. 最终 `dp[n-1]` 即为我们要求的答案。

##### 实现代码

```Java
//数组中的跳跃游戏
//每一跳可以最多跳k步
//假设当前你的位置是i，下一步你可以选择的目标范围是[i+1...min(n-1,i+k)]
//每跳跃到一个格子上，你就会得到那个格子中的分数
//假设最终目的是nums[n-1]，求你能够获得的最大分属
//考虑动态规划 + 滑动窗口[单调队列]
class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        

        //递减队列
        Deque<Integer> deque = new LinkedList<>();
        deque.addLast(0);
        for(int i = 1; i < n; i++){
            //不懂脑筋做推理是一个很坏的习惯
            //先出队
            if (deque.peekFirst() < i - k) {
                deque.pollFirst();
            }
            
            // 当前 dp[i] 的值为 nums[i] + 队列中最大 dp 值
            dp[i] = nums[i] + dp[deque.peekFirst()];
            
            // 将当前 dp[i] 对应的索引加入队列中
            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);
        }
        return dp[n-1];
    }
}
```

##### 注意事项

**滑动窗口的使用:** 由于每次只能跳 `k` 步，所以我们使用双端队列（deque）来维护 `dp[i]` 的最大值，这样可以在常数时间内更新当前的最大值。

**队列的维护:** 需要确保队列中的元素是**递减的**，即队列头部的元素是当前窗口中的最大值。

**数组大小:** 若数组长度为 1，直接返回 `nums[0]`。

##### 经验总结

- **动态规划 + 滑动窗口**的结合非常适合这类问题，因为我们需要从一个位置向后推移并选择最优路径，而滑动窗口能够有效地更新状态。
- 使用**双端队列**而不是单纯的遍历来寻找最大值，大大提高了效率，将时间复杂度优化为 O(n)。
- 需要特别注意队列中的边界条件：当队列中的元素超出了跳跃的范围时，及时将其移除。
