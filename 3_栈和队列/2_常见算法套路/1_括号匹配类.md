###括号匹配类（栈）

**场景**：给定一个只包含**各种括号**的字符串。

**目标：** 

1. 判断字符串中的括号是否完全匹配？
2. 计算最少需要添加多少括号才能使其匹配？

#### 核心思想

利用栈的`先进后出`特性匹配左括号和右括号。

#### 基本原理

遇到左括号入栈，遇到右括号时判断是否与栈顶左括号匹配。

##### 定义一个 **栈** 来保存匹配过程中的右括号

`Deque` 是双端队列，但这里作为栈用（只在一端进出）。`ArrayDeque` 是栈的一种高效实现。

##### 遍历字符串中所有的字符

###### 如果遇到左括号，就**把对应的右括号压入栈中**

我们**直接压入期望匹配的右括号**，这样在遇到右括号时只需判断是否和栈顶一致。

- `(` → 压入 `)`
- `[` → 压入 `]`
- `{` → 压入 `}`

###### 遇到的是右括号或者是非括号的情况

- 如果栈为空，不管遇到的是右括号还是非括号，字符串都是非法的
- 如果栈不为空，弹出栈顶元素-**之前压入的右括号**，并且与当前字符进行比较
  - 如果当前字符不匹配，则说明括号不匹配，返回`false`

##### 检查栈中是否还有剩余元素

如果栈中还有剩余元素，则说明字符串是非法的，返回`false`.

#### 代码套路模板

```java
public boolean isValid(String s){
  Deque<Character> stack = new ArrayDequeue<>();
  for (char c : s.toCharArray()){
    //如果遇到括号，将对应的另外一半括号入栈
    if (c == '(') stack.push(')');
    else if (c == '[') stack.push (']');
    else if (c == '{') stack.push('}');
    //如果不是括号，																																								
    else if (stack.isEmpty() || stack.pop() != c) return false;
  }
  
  return stack.isEmpty();
}
```

#### 如何判断一个字符串中的括号是否合法匹配？

也可以使用栈的方式实现，这个方式更简洁一些。

```Java
//查看是否合法
private boolean isValid(String s){
        int count = 0;
        for(char c : s.toCharArray()){
          //遇到左括号++
            if(c == '('){
                count++;
              //遇到右括号--
            }else if(c == ')'){
                count--;
            }
          //如果中间出现count < 0的情况，则返回false;
            if(count < 0){
                return false;
            }
        }
  //如果最终结果count为0，返回true
        return count == 0;
    }
```



#### Leetcode 20 验证一个字符串中的括号是否合法匹配

见上述解析过程

#### Leetcode 921- 计算最少需要添加的括号的数量才能合法匹配

##### 题目简化

给定一个只包含 `'('` 和 `')'` 的字符串 `s`，请你返回 **最少需要添加的括号数目**，以使字符串变为 **有效括号字符串**。

##### 核心思想

###### 遍历字符串

1. 遇到左括号直接**入栈**
2. 如果遇到右括号：
   - 如果栈顶元素是左括号，则说明可以匹配，弹出栈顶元素
   - 如果栈顶为空或者栈顶元素不是左括号，说明**右括号是多余的右括号**，**入栈**

###### 遍历后统计未匹配的括号的数量

- 栈中剩下的括号都是**未匹配**的
- 栈中的左括号数量=**需要补充**的右括号的数量
- 栈中的右括号数量=**需要补充**的左括号的数量

因此，栈的大小就是**需要补充**的括号的数量

##### 代码模板套路

```java
public int minAddToMakeValid(String s){
  Stack<Character> stack = new Stack<>();
  for (char c: s.toCharArray()){
    if (c == '('){
      stack.push(c);
    }else if (c == ')'){
      if (!stack.isEmpty() && stack.peek == '('){
        stack.pop();
      }else{
        stack.push(c);
      }
    }
  }
  return stack.size();
}
```



#### Leetcode 301 最少需要删除的括号的数量才能合法匹配

##### 问题要点

给定一个包含小括号 `(` 和 `)` 以及小写字母的字符串 `s`。

你的任务是移除最少数目的无效括号，使得剩下的字符串是一个有效的括号字符串，并返回所有可能的结果。

###### 核心要求 - 最少移除并且所有有效的结果

- **最少移除 (Minimum Removals):** 必须找到移除括号数量最少的方案。不能多移除。

- **结果有效 (Valid Result):** 移除括号后得到的字符串必须是有效的。一个有效的括号字符串满足以下两个条件：

  - 任意前缀中，左括号 `(` 的数量大于或等于右括号 `)` 的数量。

  - 整个字符串中，左括号 `(` 的数量等于右括号 `)` 的数量。

- **所有可能 (All Possibilities):** 可能有多种移除方式都能满足“最少移除”和“结果有效”，需要返回所有这些结果。

**示例:**

- 输入: `s = "()())()"`
- 输出: `["(())()", "()()()"]`
- 输入: `s = "(a)())()"`
- 输出: `["(a())()", "(a)()()"]`
- 输入: `s = ")("`
- 输出: `[""]`

##### 问题的本质和分析 - 图的状态搜索问题

从表面上看，这是一个字符串操作问题。但深入分析，我们会发现它的本质是一个**状态搜索问题**。

###### 怎样将问题转化为图模型？

- **状态（State）**: 每个通过移除原字符串中若干括号得到的字符串，都可以看作一个状态。
- **初始状态（Initial State）**: 原始字符串 `s`。
- **目标状态（Goal State）**: 所有有效的括号字符串。
- **状态转移（Transition）**: 从一个状态（字符串）移除一个括号，就转移到了一个新的状态。

###### 怎样做到最少移除？

问题的核心是“最少移除”，这提示我们寻找从“初始状态”到“目标状态”的**最短路径**。

想象一个图，每个节点是一个字符串。

如果字符串 A 可以通过移除一个括号得到字符串 B，那么 A 和 B 之间就有一条边。

我们的任务就是从代表原始字符串 `s` 的节点出发，找到距离它最近的（边最少的）、代表有效字符串的节点。

###### 广度优先搜索

这种在图中寻找最短路径的问题，最经典的算法就是**广度优先搜索（BFS, Breadth-First Search）**。

BFS 的特性是逐层遍历，它首先访问所有距离为 1 的节点，然后是距离为 2 的节点，以此类推。

因此，BFS 第一次找到的有效字符串，必然是通过最少次数的移除得到的。

##### 模式套路匹配 - 图的最短路径问题

1. **图的最短路径 (Shortest Path in a Graph):** 特别是在一个所有边的权重都为 1 的无权图中寻找最短路径。
2. **状态空间搜索 (State-Space Search):** 在一个巨大的、隐式的状态空间中寻找满足特定条件的解。
3. **广度优先搜索 (BFS):** 当问题要求“最少步数”、“最短时间”、“最少操作”等时，BFS 是首选的模板。

##### 核心思想和套路 - 基于广度优先搜索

FS 的核心思想是**逐层扩展**。

1. **第 0 层**: 原始字符串 `s`。
2. **第 1 层**: 从 `s` 移除任意一个括号得到的所有字符串。
3. **第 2 层**: 从第 1 层的每个字符串中，再移除任意一个括号得到的所有字符串。
4. ...以此类推。

我们在每一层遍历时，检查当前层的所有字符串是否有效。

- 一旦在当前层（比如第 `k` 层）找到了**第一个**有效的字符串，我们就知道“最少移除次数”是 `k`。
- 此时，我们不再需要生成下一层（第 `k+1` 层）的字符串了。
- 我们只需要把当前层所有剩余的字符串都检查一遍，将其中所有有效的字符串都加入结果集即可。
- 为了避免重复计算和无限循环（例如，从一个字符串生成了重复的子串），我们需要一个 `Set` 来记录已经访问过的字符串。

##### 实现原理和步骤

这里我们以更直观的 BFS 为例，详细拆解步骤。

###### **初始化队列和visisted**:

- `List<String> result`: 用于存放最终结果。
- `Queue<String> queue`: BFS 核心数据结构，存放待处理的字符串。
- `Set<String> visited`: 存放已经处理过的字符串，用于去重和避免死循环。
- 将初始字符串 `s` 加入 `queue` 和 `visited`。

```Java
Queue<String> queue = new LinkedList<>();
Set<String> visited = new HashSet<>();
queue.offer(s);
visited.add(s);
```



######**循环与分层逻辑的实现**:

- 设置一个布尔变量 `found = false`，用于标记是否已在当前层找到解。
- `while (!queue.isEmpty())`: 只要队列不空，就继续搜索。
- 在 `while` 循环内部，获取当前层的节点数 `level_size = queue.size()`。
- `for (int i = 0; i < level_size; i++)`: 遍历当前层的所有字符串。

```Java
boolean found = false;
while(!queue.isEmpty()){
  int size = queue.size();
  for(int i = 0; i < size; i++){
    //....
  }
}
```



######**从队列中取出并处理节点**:

- 从队列中取出一个字符串 `current = queue.poll()`。
- **检查有效性**: 使用一个辅助函数 `isValid(current)` 判断其是否为有效的括号字符串。
- **如果有效**:
  - 将 `current` 加入 `result` 列表。
  - 设置 `found = true`。这表明我们已经找到了最短路径的长度，当前层就是最浅的解层。
- **如果 `found` 为 `true`**:
  - `continue`。我们只需要完成当前层的检查，不再为当前字符串生成下一层的状态，因为那会增加移除次数，不符合“最少移除”的要求。

````Java
String curr = queue.poll();
if(isValid(curr)){
  res.add(curr);
  found = true;
}

if(found){
  //继续从本层中取出其他节点并且验证是否有效
  continue;
}
````



######**生成下一层状态**:

- 如果 `found` 仍然为 `false`（即当前层还没找到解），则为 `current` 生成所有可能的下一层状态。
- 遍历 `current` 字符串的每一个字符：
  - 如果字符是 `(` 或 `)`，则创建一个移除了该字符的新字符串 `next_str`。
  - 如果 `visited` 集合中不包含 `next_str`：
    - 将其加入 `queue` 以便下一层处理。
    - 将其加入 `visited` 防止重复。

```Java
//否则，继续将下一层节点加入队列
for (int j = 0; j < curr.length(); j++) {
                    char c = curr.charAt(j);
                    if (c == '(' || c == ')') {//注意排除到current[j]不是括号的情况
                        String next = curr.substring(0, j) + curr.substring(j + 1);
                        if (!visited.contains(next)) {
                            queue.offer(next);
                            visited.add(next);
                        }
                    }
                }
```

######**结束**:

- 当 `found` 变为 `true` 后，外层 `while` 循环在处理完当前层后，因为 `result` 不再为空，可以提前结束。或者让它自然结束。
- 最终返回 `result` 列表。

###### 辅助函数 -  判断字符串是否合法

用计数器，从左往右遍历

- `(`, 计数器++；
- `)`,计数器--；
- 最终必须为0，才能合法

##### 代码实现

```java

class Solution {
    public List<String> removeInvalidParentheses(String s) {
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        queue.offer(s);
        visited.add(s);

        boolean found = false;
        List<String> res = new ArrayList<>();

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                String curr = queue.poll();
                if(isValid(curr)){
                    res.add(curr);
                    found = true;
                }
                
                if(found){
                    continue;
                }

                for(int j = 0; j < curr.length(); j++){
                    char c = curr.charAt(j);
                    if(c == '(' || c == ')'){
                    String next = curr.substring(0,j) + curr.substring(j+1);
                    if(!visited.contains(next)){
                        queue.offer(next);
                        visited.add(next);
                    }
                    }
                }
            }
        }
        return res;
    }

    private boolean isValid(String s){
        int count = 0;
        for(char c : s.toCharArray()){
            if(c == '('){
                count++;
            }else if(c == ')'){
                count--;
            }
            if(count < 0){
                return false;
            }
        }
        return count == 0;
    }
}

   
```



##### 要点总结

| 项目       | 说明                                                 |
| ---------- | ---------------------------------------------------- |
| 搜索策略   | BFS 最合适，保证找的是最少删除次数                   |
| 判重       | 用 `Set` 记录访问过的字符串                          |
| 判断合法性 | 遍历时维护一个计数器，不能出现负值，最后也必须为0    |
| 剪枝       | 一旦找到一层的合法解，停止搜索更深层                 |
| 时间复杂度 | 最坏为 O(2^n)，但因为有 `Set` 去重和剪枝，效率可接受 |

##### 注意事项

- **去重**: 无论 BFS 还是 DFS，都必须处理重复情况。BFS 中使用 `visited` 集合防止重复访问状态。DFS 中，不同的移除顺序可能产生相同的结果字符串，因此最后需要用 `Set` 来存储结果去重。
- **BFS 的 `found` 标志**: 这个标志是 BFS 算法的核心。没有它，BFS 就会继续向更深的层次搜索，从而违反了“最少移除”的原则。
- **DFS 的剪枝条件**: `rightCount < leftCount` 是保证在构建过程中字符串始终有效（或部分有效）的关键剪枝，极大地减少了搜索空间。
- **字符串操作**: 在 Java 中，频繁地创建和拼接字符串（如 `substring`）开销较大。DFS 实现中使用 `StringBuilder` 进行路径构建和回溯，效率更高。

##### 经验总结

1. **识别问题模式**: "最少操作/步数" -> **BFS**。这是解决这类问题的首要直觉。
2. **状态表示与转移**: 清晰地定义什么是“状态”以及状态之间如何“转移”，是解决所有搜索问题的基础。在这里，状态是字符串，转移是移除一个括号。
3. **考虑性能**: 对于状态空间可能爆炸的问题，BFS 的空间复杂度可能是个瓶颈。此时，可以思考是否能通过**预计算**和**剪枝**来优化 DFS，使其在时间和空间上都表现得更好。
4. **两种思路的权衡**:
   - **BFS**: 思路直观，代码易于理解，直接对应“最短路”模型，能天然保证“最少移除”。
   - **DFS + 剪枝**: 通常性能更优，空间占用更小，但需要更精巧的剪枝设计和状态管理。