# 表达式求值

栈（Stack）是一种先进后出（LIFO）的数据结构，特别适合处理具有**后进先出**特性的算法问题。

利用栈来计算表达式的核心思想是**利用栈“后进先出”（LIFO）的特性来处理运算的优先级**。

我们知道，在常规的数学表达式（中缀表达式）中，存在运算符的优先级（如 `*` / `/` 高于 `+` / `-`）以及括号。

**直接从左到右计算是行不通的**。

##核心思想：栈暂存数字和处理优先级

栈的应用主要依赖于以下几点：

###暂存数字

当我们遇到一个数字时，可以先将其放入栈中。

###处理运算的优先级 - 遇到不同的运算符的时候

当我们遇到一个**运算符**时，可以根据它与栈顶运算符的优先级关系，来决定是

- 先进行**栈顶**的运算，或者，
- 将**当前运算符入栈**等待**更高优先级的运算完成**。

###处理括号：左括号和右括号的不同意义

括号提供了明确的运算边界。

- 左括号可以被视为一个**提升后续运算符优先级的信号**
- 而右括号则意味着括号内的表达式需要**立即被计算出结果**。

通过将表达式的元素（数字和运算符）按照特定规则进行入栈和出栈操作，我们可以将复杂的、带有优先级的运算顺序，转化为一系列简单的、线性的出入栈操作。

##常见的表达式类型

###中缀表达式 - 运算符位于操作数中间：容易理解单技术上难度高

最常见的表达式形式，运算符位于操作数之间。例如：`(1 + 2) * 3 - 4 / 5`

###后缀表达式 - 运算符位于操作数之后：不容易理解但是技术上难度低

运算符位于操作数之后。例如：`1 2 + 3 * 4 5 / -`

使用栈可以很容易计算后缀表达式。

###前缀表达式 - 运算符位于操作符之前（波兰表达式）

运算符位于操作数之前。例如：`- * + 1 2 3 / 4 5`

其中，后缀和前缀表达式的特点是**不需要括号**， 仅仅通过运算符和操作数的相对位置就能确定**唯一的计算顺序**。



##两种常见的主流方法： 单栈和双栈

###双栈法： 数字栈 + 符号栈

这是最直观、最符合人类思考逻辑的方法。

一个栈用来存放数字（操作数），另一个栈用来存放运算符。

###单栈法 - 先将中缀表达式转化为后缀表达式

单栈发最适合解决后缀表达式。

比如表达式``1 2 + 3 * 4 5 / -``

如果使用栈的话：

- 遇到数字就压入栈

- 遇到运算符就弹出两个操作数，将计算结果压回栈顶

  

这是一种更高效、更优雅的方法。

它首先将我们习惯的**中缀表达式**转换为**后缀表达式**，然后仅用一个栈即可完成计算。

很多 LeetCode 题目中的解法都直接或间接地运用了后缀表达式的思想。

##各种表达式的求解方法

###中缀表达式 - 双栈法

这是最复杂但也是最常见的情况，因为题目通常会直接给出这种形式。

例如 LeetCode 的 **224. 基本计算器**, **227. 基本计算器 II**, **772. 基本计算器 III**。

####操作数栈： 存储表达式中的数字

**数字栈**：存储表达式中的数字。

####符号栈： 存储运算符和左括号

存储运算符（`+`, `-`, `*`, `/`）和左括号 `(`。

#### 双栈法的计算逻辑过程

##### 遇到数字解析并压入操作数栈 - 注意数字可能不止一位！

解析出完整的数字（可能不止一位），并将其压入**数字栈**。

对于 "123"，解析出整数 `123` 后 `push` 到数字栈。

##### 遇到左括号直接入栈

无条件压入**符号栈**。

**左括号的优先级最低，它会等待匹配的右括号**。

##### 遇到右括号 - 触发一次计算

触发一次计算。

######计算过程 - 不断的从栈中弹出运算符直到左括号

不断地从**符号栈**弹出一个运算符，从**数字栈**弹出两个数字，进行计算，并将结果再压回**数字栈**。

这个过程持续进行，**直到符号栈顶是左括号 `(` 为止**。

最后，将这个匹配的左括号 `(` 从符号栈中弹出。

##### 遇到运算符 - 比较当前运算符和栈顶运算符的优先级

###### 符号栈顶为空或者左括号 - 直接入栈

**如果符号栈为空，或栈顶是左括号 `(`**：直接将当前运算符压入**符号栈**。

###### 当前优先级大于符号栈顶优先级 - 直接入栈

**如果当前运算符的优先级 > 符号栈顶运算符的优先级**：也直接将当前运算符压入**符号栈**。（例如，当前是 `*`，栈顶是 `+`）。

###### 当前运算符的优先级小于栈顶的优先级 - 先执行栈顶的运算

说明栈顶的运算可以先执行了。

从符号栈弹出一个运算符，从数字栈弹出两个数字，计算结果，并将结果压回数字栈。

然后**重复**这个比较过程，直到当前运算符可以被压入符号栈（即满足前两种情况）。

注意优先级的定义通常是通常 `*`, `/` 的优先级高于 `+`, `-`。

##### 遍历结束后计算剩余运算符

**逻辑**：此时符号栈中可能还剩下一些运算符。依次弹出符号栈的运算符和数字栈的数字进行计算，直到符号栈为空。

**最终结果**：数字栈中剩下的**唯一一个数字**就是整个表达式的最终结果。

#### 双栈法的限制 - 操作数只能是非负整数

直接的说，双栈法只适合Leetcode 772:

- 表达式字符串只包含非负整数
- 算符 `+`、`-`、`*`、`/` ，左括号 `(` 和右括号 `)` 。

### 后缀表达式的求解方法 - 单栈法

后缀表达式的计算是栈最经典的应用之一。

例如 LeetCode 的 **150. 逆波兰表达式求值**。

后缀表达式将操作符放在两个操作数之后：例如

- 中缀 `3+4*2` -> 后缀`3 4 2 * +`

- **直接按照操作顺序排列**，无需`括号`

#### 后缀表达式求值只需要一个操作数栈

后缀表达式只需要一个操作数栈即可，不需要操作符栈。

#### 后缀表达式的求解过程

##### 遇到操作数直接入栈

**逻辑**：直接将该数字压入栈中。

需要注意判断当前字符串是否是数字的逻辑：

- 整数，即该数字的第一位就是数字
- 负数：该数字的第一位是`-`并且长度 >= 2

##### 遇到操作符 - 弹出数字并计算回栈

**逻辑**：从栈中**连续弹出两个**数字（注意弹出的顺序，先弹出的是右操作数，后弹出的是左操作数）。

**执行计算**：使用当前运算符对这两个数字进行计算。

**结果入栈**：将计算得到的结果再压回栈中。

##### 遍历结束后计算结果

**逻辑**：整个表达式遍历完毕后，栈中只会留下一个数字。

**最终结果**：这个唯一的数字就是表达式的最终结果。

##### 代码套路-后缀表达式

```java
Deque<Integer> stack = new ArrayDeque();

for (String token: tokens){
  if (("+-*/").contains(token)){
    int b = stack.pop();
    int a = stack.pop();
    stack.push(eval(a,b,token));
  }else{
    stack.push(Integer.parseInt(token));
  }
  return stack.pop();
}
```

##### 适用场景

- 四则运算字符运算求值
- 中缀转后缀表达式
- 嵌套括号计算

### 中缀表达式计算 - 单栈法

#### 单栈法的核心思想 - 将所有运算延迟并转化为一个简单的求和问题

单栈法的核心思想是**将所有运算“延迟”并最终转化为一个简单的求和问题**。

双栈法的核心是**遇到高优先级运算符就先算**，而单栈法的法则有所不同。

##### 乘除法具有高优先级，先算

当我们遇到乘法或除法时，它连接的是当前数字和**前一个**数字。

这个小团体优先级最高，所以我们立刻从栈顶取出前一个数，和当前数做乘除，然后把结果放回栈中。

##### 将加减法转化为带符号的数字

**加减法 (`+`, `-`) 具有低优先级，不做计算，而是“转换”**：

我们**不着急做加减法**。

而是把表达式看作一系列“带符号的数字”的集合。

例如 `3 - 2 * 5 + 4` 可以看作是 `[+3, -10, +4]` 这三个数字的求和。

- 遇到 `+` 号，就把后面的数字（比如 `+num`）直接存入栈。
- 遇到 `-` 号，就把后面的数字的**相反数**（比如 `-num`）存入栈。

最终，当整个表达式遍历完毕，**栈里存放的就是一系列可以直接相加的“求和项”**。

我们只需要将栈中所有的数字全部加起来，就得到了最终结果。

#### 单栈法的实现原理

##### 单栈法中的关键成员

###### 操作数栈(Stack): 仅仅保存数字

只用来存储数字。

###### 当前的操作数（currentNum）：当前正在解析的操作数

用来解析当前正在读取的、可能的多位数。

###### 上一个符号（sign）：最后一次解析出来的运算符

用来保存**上一个**遇到的运算符。

这个变量至关重要，因为它决定了我们该如何处理 `currentNum`。

我们将它初始化为 `+`。

##### 单栈法的操作流程

###### 操作数解析完毕（当前字符是运算符或者末尾）：

算法的流程是遍历字符串，当我们遇到一个运算符或者遍历到字符串末尾时，就意味着一个完整的数字 `currentNum` 已经解析完毕。

此时，我们根据**上一个运算符 `preOp`** 的值，来决定如何处理 `currentNum`：

###### 上一个运算符是加号或者减号的情况：带符号入栈

- 如果 `preOp` 是 `+`：说明 `currentNum` 是一个独立的求和项，直接将其压入栈中。

- 如果 `preOp` 是 `-`：说明 `currentNum` 是一个带负号的求和项，将其相反数 `-currentNum` 压入栈中。

###### 上一个运算符是乘号或者除号的情况：计算并入栈

- 如果 `preOp` 是 `*`：说明 `currentNum` 需要和**前一个**求和项（即栈顶元素）相乘。我们从栈顶 `pop` 出前一个数，与 `currentNum` 相乘，再将结果 `push` 回栈中。

- 如果 `preOp` 是 `/`：同理，从栈顶 `pop` 出前一个数，与 `currentNum` 相除，再将结果 `push` 回栈中。

处理完 `currentNum` 后，我们将**当前**的运算符赋值给 `preOp`，并重置 `currentNum` 为 0，准备解析下一个数字。

##### 遍历完成后：累加栈内操作数

遍历完成之后，所有的结果便以带符号的数的形式存储在栈中。

我们依次遍历栈，取出数字并累加之后就是最终的结果。

#### 单栈法的套路总结（不含括号）

**初始化**：

- `Stack<Integer> stack = new Stack<>();`
- `int currentNum = 0;`
- `char preOp = '+';`

**遍历字符串**：使用一个 `for` 循环遍历 `s` 的每个字符 `c`。

**解析数字**：

- 如果 `c` 是数字，更新 `currentNum = currentNum * 10 + (c - '0')`。

**触发计算**：

- 如果 `c` **不是数字**且**不是空格**，或者**已经到达字符串末尾** (`i == s.length() - 1`)，则触发计算。
- 根据 `preOp` 的值对 `currentNum` 进行操作：
  - `if (preOp == '+') stack.push(currentNum);`
  - `if (preOp == '-') stack.push(-currentNum);`
  - `if (preOp == '*') stack.push(stack.pop() * currentNum);`
  - `if (preOp == '/') stack.push(stack.pop() / currentNum);`
- **更新状态**：`preOp = c;`，`currentNum = 0;`

**计算最终结果**：

- 遍历结束后，创建一个变量 `result = 0`。
- 不断从 `stack` 中 `pop` 元素累加到 `result` 上，直到栈为空。
- 返回 `result`。

####单栈法的套路总结（扩展到带括号的情况）- 基于递归

当引入括号时，意味着括号内的表达式需要被当作一个整体、优先计算出结果。单栈法处理括号最主流的方式是**递归**。

#####**核心思想**：将括号内的表达式看作一个**子问题**。

#####**实现原理**

1. 设计一个递归函数，比如 `calculate(String s, int[] index)`，它负责计算从 `index` 开始的一段表达式。
2. 当主流程遇到 `(` 时，**递归调用** `calculate` 函数，并将当前索引 `i` 传进去。
3. 子问题（递归函数）会计算括号内的所有内容，当它遇到匹配的 `)` 时，就计算完当前层级的结果并返回。
4. 主流程拿到递归返回的结果，就把它当作一个普通的 `currentNum`，继续主流程的逻辑。

这种“递归下降”的思路是处理嵌套结构（如括号、JSON解析等）的通用且强大的方法。

如果不使用递归，本质上就是一种**双栈法的实现**。

##Leetcode 224: 基本计算器（包含加减法和括号）

###问题要点

实现一个基本计算器，输入为一个**只包含数字、加减号、括号和空格的字符串**，返回表达式的计算结果。

- 运算符仅有：`+`, `-`
- 运算顺序支持括号嵌套
- 无乘除法，无负数输入（负数通过减号表达）

### 单栈法1 - 基于递归的方法

#### 核心思想和套路 - 栈用来暂存操作数

##### 栈的功能

栈只用来存储待相加的操作数。如果是减法，我们就把负数压入栈中（例如 `3 - 2`，我们会把 `3` 和 `-2` 压入栈）。

##### 符号sign的作用

符号变量 `sign` 不再是作用于一个全局的 `result`，而是决定了**下一个**数字应该以正数还是负数的形式入栈。

##### 括号的处理

括号包裹的表达式可以被看作一个**单一的、完整的操作数**。

因此，遇到左括号 `(` 时，我们通过递归调用来计算出这个“大号操作数”的值。

#### 实现原理和步骤

##### 初始化操作数栈和符号

初始化一个栈 `stack`，当前数字 `num = 0`，以及上一个符号 `sign = '+'`。

##### 遍历处理的逻辑 - 逐个字符遍历

###### 遇到数字： 继续解析

因为数字后面可能还会有数字，所以需要等下一位不是数字的时候才结束数字的解析。

######遇到左括号： 递归调用

递归调用计算函数，将返回的整个括号表达式的结果**赋值**给 `num`。

 ```Java
 num = doCalculate(s);
 ```



###### 遇到操作符 - 入栈$符号\times 操作数$

- 这时说明一个完整的数字 (`num`) 已经解析完毕。

- 根据**上一个**符号 `sign` 的值，决定如何处理 `num`：

  - 如果 `sign` 是 `+`，将 `num` 直接压入栈。
  - 如果 `sign` 是 `-`，将 `-num` 压入栈。

  处理完毕后，更新 `sign` 为当前遇到的操作符，并重置 `num = 0`。

###### 遇到右括号：跳过循环(break)

```Java
if(c == ')'){
  break;
}
```



说明当前递归层级的计算结束，跳出循环。

循环结束后，栈里存放的就是当前层级所有被正确处理了符号的数。

将它们全部求和，就是当前层级的结果，将其返回。

##### 处理栈内剩余数字

遍历完成之后，将站内的数字累加，就是最后的结果。

```Java
int result = 0;
for(int num : stack){
  result += num;
}
return result;
```



#### 实现代码

```Java
class Solution {
  	//定义全局的Index变量
    private int index = 0;
    public int calculate(String s) {
        return calculateHelper(s);
    }

    private int calculateHelper(String s){
        Stack<Integer> stack = new Stack<>();
        int num = 0;
        int sign = 1;
        
        while(index < s.length()){
            char c = s.charAt(index);
            index++;
            //遇到数字继续解析数字
            if(Character.isDigit(c)){
                num = num * 10 + (c - '0');
            }
            //遇到左括号递归调用
            if(c == '('){
                num = calculate(s);
            }
            //如果遇到非数字非空格的字符
            //或者是遇到字符串结尾
            //将数字 * 符号 入栈
            //重置符号和数字
            if (!Character.isDigit(c) && c != ' ' || index == s.length()) {
                stack.push(num * sign);
                
                // 更新符号为当前符号，并重置 num，为下一个数字做准备
                sign = c == '+' ? 1 : -1;
                num = 0;
            }
            //遇到右括号跳出循环
            if(c == ')'){
                break;
            }
        }
        
        //累加栈中的操作数作为结果
        int result = 0;
        while(!stack.isEmpty()){
            result += stack.pop();
        }
        return result;
    }
}
```



###单栈法2 - 栈用来暂存括号外上下文

我们得意识到，这个方法虽然直观，但是却不在我们上述的方法当中 - 即**不算双栈法也不算单栈法**。

即不算单栈法的套路，也不算双栈法的套路。

但是这个方法比较简单容易理解，面试的时候遇到本题的时候应该属于首选。

其次的选择应该双栈法。

####核心思想-用栈暂存括号之前的结果和符号

和上面的单栈或者双栈的思路不同，这里的栈**并不是用来保存操作数的**。

栈在这里的作用是**暂存括号之前的结果和符号**。

换言之，栈不保存普通的操作数。

当前结果是在遍历表达式的过程中就计算的。

模拟表达式计算过程，借助**栈**处理括号作用域（这个过程同样可以使用**递归**实现）。

- 每次遇到`(`:
  - 将**当前结果**和**当前符号**一起入栈，开启一个**新的作用域**
- 每次遇到`)`:
  - 将当前括号内的`res`与**栈中保存**的`sign`，`res`合并，**恢复`上一个作用域`**

####实现原理-将加减符号转化为正负符号（sign）

- 记录当前正在读取的数字`num`
- 用`sign`表示当前数字前的符号(1为`+`,-1为`-`)
- 用`res`表示**当前作用域**内的累计值
- 遇到括号时，用栈保存**括号外的状态**(`res`和`sign`)

####实现步骤

#####初始化变量

- **当前的计算结果：**`res=0`
- **当前正在解析的数字：**`num=0`
- **当前的符号：**`sign=1`
- **栈（用于暂存结果和符号）：**`stack`:用于保存**括号外**的`res`和`sign`

#####遍历字符串中的每个字符

###### 遇到数字： 继续解析

- **数字：** `num = num*10+digit`

##### 遇到运算符号： 更新当前的结果

- **运算符号：** 将前一个`num*sign`加入到`res`中，更新`sign`
- **括号：**
  - **左括号`(`:** 将当前`res`和`sign`**入栈**, 重置`res=0`和`sign=1`
  - **右括号`)`:** 将当前`num*sign`加入`sign`，然后将`res`与栈顶的`sign`与`res`合并
- **空格：**跳过

#####处理最后一个数字

处理最后一个数字（因为表达式可能**不以符号结束**）

#### 实现代码

```java
public int calculate(String s){
  Stack<Integer> stack = new Stack<>();
  int res = 0;
  int num = 0;
  int sign = 1;
  
  for (int i=0;i<s.length();i++){
    char ch = s.charAt(i);
    // 注意这里使用到的两个技巧，Character.isDigit()判断字符是否为数字，ch-'0'将字符转化为数字
    if (Character.isDigit(ch)){
      num = num*10+(ch-'0');
    }else if (ch == '+'){
      //如果遇到运算符号
      //将num * sign 加入到res中
      res +=sign*num;
      //重置num
      num=0;
      sign=1;
    }else if (ch == '-'){
      res +=sign*num;
      //重置num
      num=0;
      sign=-1;
    }else if (ch == '('){
      //保留括号外现场，将括号之前的res和sign入栈保存
      stack.push(res);
      stack.push(sign);
      
      res=0;
      sign=1;
    }else if (ch == ')'){
      //注意不要漏掉这个步骤，因为后括号和操作符一样，出现就说明当前数字已经解析完成，但是还没有计算
      res += num*sign;
      
      num=0;
      res *= stack.pop();
      res += stack.pop();
      
    }
  }
  //不要漏掉最后一个数字
  res += sign*num;
  
  return res;
}
```

#### 注意事项

1. **处理多位数**: 不能只读取一个字符就当作数字，需要循环读取所有连续的数字字符来构成一个完整的数。
2. **表达式结尾**: 循环结束后，最后一个 `num` 可能还没有被加到 `result` 中，需要额外处理。
3. **空格处理**: 代码实现中通过 `if/else if` 忽略了空格，这是一种简洁的处理方式。
4. **符号与数字**: 符号 (`+` 或 `-`) 的作用对象是它 *后面* 的那个数。因此，在遇到符号时，应该先处理它 *前面* 的那个数。
5. **括号的符号**: 括号前的符号至关重要。例如 `1 - (2 + 3)`，括号内的结果 `5` 需要乘以 `-1`。栈的解法通过将 `sign` 入栈优雅地解决了这个问题。

#### 经验总结

- **栈是处理嵌套结构的神器**: 对于括号匹配、表达式求值、迷宫路径等问题，栈提供了一种非常直观和强大的方式来管理“待办事项”或“上下文状态”。
- **递归是另一种视角**: 递归将问题分解为更小的、结构相同的子问题。对于本题，括号内的表达式就是一个完美的子问题。递归的代码通常更简洁，但可能难以调试，且需要注意栈溢出的风险。
- **状态管理是关键**: 无论是哪种方法，成功的关键在于清晰地定义和管理当前的状态，包括：当前累积的结果 `result`、当前正在解析的数字 `num`、以及下一个数字应该使用的符号 `sign`。
- **从简单到复杂**: 解决这类问题时，可以先思考没有括号的简单情况如何处理，然后再考虑加入了括号后，需要保存和恢复哪些状态，这样就能自然而然地想到使用栈或递归了。LeetCode 227 (Basic Calculator II) 是一个很好的进阶练习，它引入了乘除法，需要更复杂的优先级处理。

##Leetcode 227: 基本计算器II - 只包含加减乘除不包含括号

实现一个基本的计算器来计算一个简单的字符串表达式的值。表达式中仅包含非负整数、`+`、`-`、`*`、`/` 运算符和空格。整数除法只保留整数部分（即向下取整）。

```
输入: "3+2*2"
输出: 7
```

###问题本质

实现一个支持**优先级**的表达式求值，涉及：

- 操作数的提取
- 操作数的处理
- 运算符顺序的控制：`*`和`/`的优先级高于`+`和`-`

###核心思想-单栈法

本题属于标准的**单栈法**不带递归解决的问题。

#### 单栈法的基本思路

在单栈法中，栈用来处理运算符的不同优先级：

##### 数字解析完毕以后检查上一个运算符

在数字解析完毕以后（遇到运算符或者遍历结束），我们需要检查**上一个运算符**

###### 上一个运算符为加号或者减号的情况

- 加号则将`num`压入栈
- 减号则将`-num`压入栈

###### 上一个运算符为乘号或者除号的情况

- 弹出上一个操作数`prevNum`
- 将**上一个操作数**和**当前操作数**进行乘法或者除法运算
- 将运算的结果压入栈

###### 操作完毕一个更新sign并重置当前操作数

- 将`sign`更新为**当前操作符**
- 将操作数`num`重置为0

##### 遍历完成以后累加栈中的数字

在遍历完成以后，栈中的带符号的数字之和就是最终的结果。

####实现原理和详细步骤

1. 利用栈存储数值（处理操作数优先级）
2. 遍历字符，识别数字和符号
3. 在遇到操作符或遍历到最后一个字符时，根据**上一个符号**进行处理
4. 特别处理乘除法：**栈顶元素与当前数字计算后重新入栈**

##### 实现步骤

###### 准备工作1-删除字符串中的空格？

取出字符串中的空格，当然也可以在遍历的时候跳过

###### 准备工作2-初始化关键变量：num和sign

和`Basic Calculator`的实现也需要借助`num`和`sign`

- `int num=0;`用来记录当前数字
- `char sign`：用来记录**上一个**符号
- `Stack<Integer>`:处理优先级

###### 遍历字符串-处理数字和操作符的情况

- **数字：** 构造完成当前数字
- **操作符：**
  - 更新`sign`和`num`来处理栈
  - 更新`sign`为当前字符，重置`num`;

需要注意有如下情况需要处理：

- 当当前字符为操作符的时候，处理上一个数字
  - 上一个操作符为+或者-的时候，将当前数字x1或者x(-1)然后压入栈
  - 上一个操作符为`*/`的时候：
    - 出栈上一个数字（`num1`）
    - 将`num1 * num`或者`num1 / num`结果入栈
- 当已经遍历到最后一个字符的时候`i == n - 1`，需要采用同样的方法结算最后一个数字

###### 累加栈中的数字，得到最终结果

遍历完成之后，将栈中的所有数字相加，得到最终结果

###代码实现

```java
public int calculate(String s){
  int n = s.length;
  int num=0;
  char sign = '+';
  Stack<Integer> stack = new Stack<>();
  
  int i=0;
  while(i<n){
    char ch = s.charAt(i);
    
    if (Character.isDigit(ch)){
      num = num*10+(ch-'0');
    }
    
    if ((!Character.isDigit(ch) && ch != ' ') || i == n-1){
      if (sign == '+'){
        stack.push(num);
      }else if (sign == '-'){
        stack.push(-num);
      }else if (sign == '*'){
        stack.push(stack.pop()*num);
      }else if(sign == '/'){
        stack.push(stack.pop()/num);
      }
      
      sign = ch;
      num = 0;
    }
  }
  
  int result =0;
  for (int x:stack){
    result += x;
  }
  
  return result;
}
```

## Leetcode 772: 基本计算器III - 包含加减乘除和括号 - 双栈法

本题算是计算器系列中的最难的一道题，但是属于双栈法的标准实现。

### 双栈法的核心思想 - 操作数栈与符号栈

#### 操作数栈 - 暂存操作数和中间结果

操作栈用来保存操作数和运算结果

#### 符号栈 - 暂存运算符和括号

#### 符号的优先级：乘除>加减>左括号

左括号需要特殊处理。

#### 双栈法的基本逻辑

##### 采用while循环 - 因为索引是根据逻辑增长的

每次所以如果只是增长固定步数，可以使用**for循环**。

每次索引的前移步数如果是由具体的逻辑决定的则采用**while循环**。

##### 遇到数字解析并压入操作数栈:解析整个数字

遇到数字则解析**整个数字**，然后放入操作数栈

#####遇到左括号将左括号压入操作符栈

遇到左括号则直接加入到操作符栈，**注意左括号不是运算符，所以不需要比较或者计算操作符栈顶的运算**

#####遇到运算符先清理栈顶优先级较高的运算然后入栈

遇到运算符，则：

- 计算所有操作符栈顶优先级比当前运算符优先级更高的计算
- 然后将运算符加入到操作符栈

##### 遇到右括号清理操作符栈中左括号顶上的计算

遇到右括号

- 将操作符栈中的运算一直计算到栈顶为左括号为止
- 将操作符栈顶的左括号弹出

####运算的实现 - 弹出操作数和操作符将计算结果入栈

- 取出操作数栈顶的两个操作数，如果操作数栈中没有两个操作数，直接返回
- 取出操作符栈顶的运算符
- 计算并将结果放入操作数栈

#### 运算符优先级的定义

- 乘法和除法优先级最高
- 加法和减法优先级中间
- 左括号的优先级最低

### 实现代码

```Java
//双栈法
//符号栈： 运算符和左括号
//操作数栈： 操作数和中间结果
//遍历逻辑
//遇到数字，解析整个数字，然后入栈
//遇到操作符，比较当前操作符和栈顶操作符的优先级
//当前运算符优先级更高： 入栈
//栈顶运算符更高：执行栈顶的运算：
//弹出两个操作数，计算之后入栈
//重复上述过程直到栈顶操作符优先级不高于当前操作符，然后将当前操作符入栈
//遇到右括号呢： 计算当前栈顶运算，直到栈顶为左括号，然后弹出左括号
//After the above trverse process
//Finished all the left computations in the op stack.
class Solution {
    public int calculate(String s) {
        Stack<Integer> numStack = new Stack<>();
        Stack<Character> opStack = new Stack<>();
        int index = 0;
        while(index < s.length()){
            char c = s.charAt(index);
            if (Character.isDigit(c)){
                int num = 0;
                while (index < s.length() && Character.isDigit(s.charAt(index))) {
                    num = num * 10 + (s.charAt(index) - '0');
                    index++;
                }
                numStack.push(num);
            //遇到左括号，直接入栈
            }else if (c == '('){
                opStack.push(c);
                index++;
            //遇到右括号
            }else if (c == ')'){
                while (opStack.peek() != '(') {
                    compute(numStack, opStack); 
                }
                opStack.pop();
                index++;
             //遇到运算符， 先比较栈顶运算符和当前运算符的优先级
            //计算掉栈顶所有比当前运算优先级高的运算
            }else{
                while (!opStack.isEmpty() && priority(opStack.peek()) >= priority(c)) {
                    compute(numStack, opStack); 
                }
                opStack.push(c);
                index++;
            }
        }

        while(!opStack.isEmpty()){
            compute(numStack, opStack);
        }
        return numStack.peek();
    }

    private void compute(Stack<Integer> numStack, Stack<Character> opStack){
        if(numStack.size() < 2){
            return;
        }
        int num2 = numStack.pop();
        int num1 = numStack.pop();
        char op = opStack.pop();
        switch (op) {
            case '+':
                numStack.push(num1 + num2);
                break;
            case '-':
                numStack.push(num1 - num2);
                break;
            case '*':
                numStack.push(num1 * num2);
                break;
            default:
                numStack.push(num1 / num2);
                break;
        }
    }

    private int priority(char op){
        if (Arrays.asList('*','/').contains(op)){
            return 2;
        }else if (Arrays.asList('+','-').contains(op)){
            return 1;
        }else{
            return 0;
        }
    }
}
```

见基本介绍部分。

### 基于单栈法的实现

#### 单栈方案的四个重要组件

##### 栈：存储操作数

 只存储“待累加”的数字（操作数）。它不存操作符。

##### 递归：专门处理括号

 专门用于处理 `()`。每当遇到 `(`，就发起一次递归调用，将括号内的计算结果（一个整数）返回。

##### 正在解析的数字：currentNum

`currentNum (int)`：当前正在解析的数字（例如 "123"）。

##### 上一个操作符：lastOp

**上一个**操作符，默认为 `+`。

#### 核心思想： 正在解析的数字在遇到下一个操作符的时候才结算

真正的套路是：**我们从不立即计算**。

当你解析完一个数字（`currentNum`）时，你不知道该拿它怎么办。

你需要等到你看到**下一个**操作符时，才回头看**上一个**操作符 (`lastOp`)，并用它来处理你刚刚解析完的 `currentNum`。

#### 实现原理：遍历每一个字符

| **遇到的字符**        | **它的职责 (Role)** | **处理动作 (Action)**                                        |
| --------------------- | ------------------- | ------------------------------------------------------------ |
| **数字 (Digit)**      | **解析**            | 1. `currentNum = currentNum * 10 + (c - '0')`。 <br> 2. **不**做任何结算，**不**更新 `lastOp`。 |
| **左括号 `(`**        | **委托 (Delegate)** | 1. 立即停止当前解析。<br>  2. **递归调用** `doCalculate(s)`。<br>  3. 将递归返回的结果（一个整数）赋值给 `currentNum`。 |
|                       |                     |                                                              |
| **运算符 `+ - \* /`** | **结算 + 更新**     | 1. 这是一个**结算触发点**。<br>  2. 根据 `lastOp` 的值，对 `currentNum` 执行结算（见下方代码模板）。<br>  3. **更新状态：** `lastOp = c` (c 是当前的 `+ - * /`)。 <br> 4. **重置状态：** `currentNum = 0`。 |
| **右括号 `)`**        | **结算 + 终止**     | 1. 这是一个**结算触发点**。<br>  2. **首先**，根据 `lastOp` 的值，对 `currentNum` 执行结算（同上）。<br>  3. **然后**，`break;` 退出当前循环（结束当前递归层）。 |
| **字符串末尾**        | **最终结算**        | 1. 这是一个**结算触发点**。 <br> 2. 为了在代码中优雅地处理它，我们的 `while` 循环中需要 ` |



```Java
import java.util.Stack;

class Solution {
    // 使用成员变量 index 来跟踪我们在字符串 's' 中的全局位置
    private int index = 0;

    public int calculate(String s) {
        // 调用递归辅助函数
        return doCalculate(s);
    }

    /**
     * 递归函数，计算从 s.index 开始的表达式，
     * 直到遇到 ')' 或字符串末尾。
     */
    private int doCalculate(String s) {
        Stack<Integer> stack = new Stack<>();
        int currentNum = 0;
        char lastOp = '+'; // 存储上一个操作符，默认为 '+'

        while (index < s.length()) {
            char c = s.charAt(index);
            index++; // 立即移动指针

            // --------- 步骤一：解析 currentNum (只处理数字和左括号) ---------
            
            // 跳过空格
            if (c == ' ') {
                continue;
            }

            // [情形1：遇到数字]
            // 持续更新 currentNum
            if (Character.isDigit(c)) {
                currentNum = currentNum * 10 + (c - '0');
            }

            // [情形2：遇到左括号]
            // 递归调用，将括号内的计算结果视为一个 "数字"
            if (c == '(') {
                currentNum = doCalculate(s);
            }


            // --------- 步骤二：检查是否触发“结算” ---------
            
            // 触发点：
            // 1. 遇到非数字、非空格（即 +,-,*,/, ) ）
            // 2. 或者，我们到达了字符串的末尾 (index == s.length())
            
            if ((!Character.isDigit(c) && c != ' ') || index == s.length()) {
                
                // --- 开始结算 ---
                // 根据 *上一个* 操作符 (lastOp) 来处理 *上一个* 数字 (currentNum)
                
                // [情形3：遇到 '+' 或 '-' (由 lastOp 决定)]
                if (lastOp == '+') {
                    stack.push(currentNum);
                } else if (lastOp == '-') {
                    stack.push(-currentNum);
                } 
                
                // [情形4：遇到 '*' 或 '/' (由 lastOp 决定)]
                else if (lastOp == '*') {
                    stack.push(stack.pop() * currentNum);
                } else if (lastOp == '/') {
                    stack.push(stack.pop() / currentNum);
                }

                
                // --- 结算完毕，更新状态 ---
                
                // 1. 重置 currentNum，为解析下一个数字做准备
                currentNum = 0;
                
                // 2. 存储 *当前* 运算符 c，作为下一次结算的 "lastOp"
                lastOp = c;
                
                // [情形5：遇到右括号]
                // ')' 也是一个结算触发点。
                // 在结算完它前面的数字后，立即终止当前递归层。
                if (c == ')') {
                    break;
                }
            }
        } // while 循环结束

        // --------- 步骤三：计算最终结果 ---------
        // 将栈中所有 "待累加" 的数字块求和
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        return result;
    }
}
```



## 使用单栈法解决计算器类问题的总结

| **维度 / 处理方式**  | **LeetCode 224 (基本计算器)**                                | **LeetCode 227 (基本计算器 II)**                             | **LeetCode 772 (基本计算器 III)**                            |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **是否支持 `+ -`**   | **是**                                                       | **是**                                                       | **是**                                                       |
| **是否支持 `\* /`**  | **否**                                                       | **是**                                                       | **是**                                                       |
| **是否支持 `( )`**   | **是**                                                       | **否**                                                       | **是**                                                       |
|                      |                                                              |                                                              |                                                              |
| **遇到 `+` 或 `-`**  | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。<br>  2. 压栈：`stack.push(sign * currentNum)`。 <br> 3. **(更新)** `lastOp = c`。`currentNum = 0`。 | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。 <br> 2. `stack.push(...)` 或 `stack.push(pop...*...)`。  <br>3. **(更新)** `lastOp = c`。`currentNum = 0`。 | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。  <br>2. `stack.push(...)` 或 `stack.push(pop...*...)`。  <br>3. **(更新)** `lastOp = c`。`currentNum = 0`。 |
| **遇到 `\*` 或 `/`** | **不支持 (N/A)**   *(代码中该分支不存在)*                    | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。<br>  2. `stack.push(stack.pop() * currentNum)`。<br>  3. **(更新)** `lastOp = c`。`currentNum = 0`。 | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。 <br> 2. `stack.push(stack.pop() * currentNum)`。<br>  3. **(更新)** `lastOp = c`。`currentNum = 0`。 |
| **遇到 `(`**         | 1. **(递归)** `currentNum = doCalculate(s)`。                | **不支持 (N/A)**   *(代码中该分支不存在)*                    | 1. **(递归)** `currentNum = doCalculate(s)`。                |
| **遇到 `)`**         | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。<br>  2. `break;` (退出递归)。 | **不支持 (N/A)**   *(代码中该分支不存在)*                    | 1. **(结算)** 根据 `lastOp` 结算 `currentNum`。<br>  2. `break;` (退出递归)。 |



##计算器类相关的题目的应对方法总结

| 题型                     | 示例题目                              | 场景与目标               | 限制条件                                                     | 栈的定义与作用                                 | 遇符号时处理                                            | 遇括号时处理                                         | 遍历逻辑                                                     |
| ------------------------ | ------------------------------------- | ------------------------ | ------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| **基本加减**             | 224. Basic Calculator                 | 实现带括号的加减法计算器 | 支持 `+ - ( )` <br>支持空格；<br>无乘除；<br>支持一元负号    | 栈保存括号内外的 `result` 和 `sign`            | 更新当前 `sign`，在遇到数字时执行 `res += sign * num`   | `(` 入栈当前 `result` 和 `sign`，重置； `)` 弹栈恢复 | 单指针遍历，遇空格跳过，数字累加，括号递归计算               |
| **加减乘除**             | 227. Basic Calculator II              | 实现无括号的四则运算     | <br>无括号；<br>有空格；<br>优先级：`*/ > +-`；<br>支持一元负号 | 栈存放中间结果（加减直接压栈，乘除与栈顶计算） | <br>遇 `+`/`-` 压栈当前数，<br>`*`/`/` 出栈并计算再压栈 | 无括号处理                                           | 单指针遍历，遇符号时处理上一个 `sign` 和 `num`，最后累加栈中结果 |
| **加减乘除+括号**        | 拓展题如772. Basic Calculator III     | 实现完整的四则运算解析器 | 支持 `+ - * / ( )` 和空格；<br>有优先级                      | 使用**两个栈**：数字栈+符号栈                  | 根据优先级与符号栈栈顶比较，低优先级时出栈运算          | `(` 直接入符号栈；`)` 触发连续出栈直到 `(`           | 单指针扫描，构造完整数字，处理运算优先级与括号嵌套           |
| **逆波兰表达式（后缀）** | 150. Evaluate Reverse Polish Notation | 解析逆波兰表达式并计算   | <br>输入已按 RPN 排列；<br>无括号；<br>不含空格；<br>仅整数与符号 | 单栈保存操作数；每遇到运算符弹出两个数计算     | 运算符直接触发两个数出栈运算                            | 无括号处理                                           | 遍历每个 token，是数字入栈，是运算符则弹出两个数计算后再入栈 |