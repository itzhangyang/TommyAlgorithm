# 双栈/双队列

##使用两个栈实现一个队列

###核心思想 - 一个只入一个只出

利用两个栈`inStack`以及`outStack`:

#### 入口栈： 每个压入元素都直接进入入口栈

我们定义一个入口栈，每次有新的元素来了之后都先进入入口栈(`inStack`)

#### 出口栈： 只能从出口栈出去

每次执行出栈操作的时候：

- 如果出口栈还有剩余元素，则从出口栈弹出一个剩余元素
- 如果出口栈没有元素了：
  - 将入口栈的所有元素弹出，并压入出口栈
  - 弹出并返回出口栈的栈顶元素即可

###逻辑套路模板

```java
入队操作：push(x)
inStack: [1, 2, 3]   （栈顶是3）

出队操作：pop()
如果 outStack 为空：
   把 inStack 所有元素倒到 outStack
   inStack: []  -> outStack: [3, 2, 1]（栈顶是1）
然后 outStack.pop() 即可
```

###代码实现

```java
public class MyQueue{
  private Stack<Integer> inStack;
  private Stack<Integer> outStack;
  
  public MyQueue(){
    this.inStack = new Stack<>();
    this.outStack = new Stack<>();
  }
  
  public int pop(){
    peek();
    return outStack.pop();
  }
  
  public int peek(){
    if (outStack.isEmpty()){
      while (!inStack.isEmpty()){
        int num = inStack.pop();
        outStack.push(num);
      }
    }
  }
  
  public void push(int num){
    inStack.push(num);
  }
}
```

###适用场景

- 栈为可用结构，需要实现队列功能
- 高频入队，低频出队（可以延迟转移）

##使用两个队列实现一个栈

### 核心思想 - 入口队列和出口队列角色互换

#### 两个队列 - 轮流交换职责岗位

我们并不固定哪一个队列会一直承担固定的责任。

相反，我们定定义每次都会清空一个队列，然后让它承担接收新元素的职责，另外一个队列则承担放出弹出元素的职责。

#### 元素的入栈流程

##### 将新元素加入到空的入口队列

最新的元素始终是放入一个**被清空**之后的队列中。

##### 将出口队列的元素追加到入口队列中

然后将另外一个队列中的元素转移到该队列。

#####角色互换

现在被清空的出口队列变成入口队列，而原来的入口队列则变成出口队列

#### 元素的出栈流程

弹出出口队列的元素即可。

###逻辑套路模板

```java
push(x);
1. queue2.offer(x);
2. 把queue1的所有元素都poll出来，放进queue2;
3. 交换queue1和queue2(保证queue1仍是主队列)
 queue1:[x...old element]->x是栈顶
```

###代码套路模板

```java
class MyStack{
  private Queue<Integer> queue1 = new LinkedList<>();
  private Queue<Integer> queue2 = new LinkedList<>();
  
  public void push(int x){
    queue2.offer(x);
    // 清空队列queue1
    while(!queue1.isEmpty()){
      queue2.offer(queue1.poll());
    }
    
    //交换Queue1和Queue2的引用
    Queue<Integer> temp = queue1;
    queue1 = queue2;
    queue2 = queue1;
  }
  
  //始终从queue1中取得下一个元素？
  public int pop(){
    return queue1.poll();
  }
  
  public int top(){
    return queue1.peek();
  }
  
  public boolean isEmpty(){
    return queue1.isEmpty();
  }
}
```

##总结套路模式

###双栈队列套路

- 一个栈负责**压入**（`inStack`），一个栈负责**弹出**(`outStack`)
- 出栈`outStack`的时候栈为空的时候，一次性将入栈`inStack`的内容搬到`outStack`
- 惰性策略，**避免多次搬移**，提升性能

###双队列栈

- 新元素始终进入**临时队列**（`queue2`），再把**主队列**(`queue2`)的内容全部搬移过去
- 操作最后**清空临时队列**`queue2`,将**临时队列**的内容**全部复制到主队列**（注意是**复制**，不是`poll`）

##Leetcode 1381 :自定义栈 -  基于差分数组和延迟标记 - 较为复杂容易出错

给定一个固定容量 `maxSize` 的栈，实现三个 O(1) 操作：

| 操作                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `push(x)`           | 若栈未满，将 `x` 压入栈顶                                    |
| `pop()`             | 若栈非空，弹出栈顶元素并返回，否则返回 `-1`                  |
| `increment(k, val)` | 将**栈底**开始的 `k` 个元素全部 + `val`（若元素不足 `k` 个则全部加） |

###问题本质和分析 - 差分数组和延迟标记

1. 固定容量栈的基本实现
2. 如何实现**区间增量**降到`O(1)` - **差分数组**
   - 朴素做法`incremental`遍历`k`个元素，最坏需要`O(K)`
   - 题目期望所有操作均摊`O(1)`，考察**延迟标记/差分数组**

####延迟增量的核心逻辑

- 维护一个与stack同步的**差分数组**`diff`
- 每次`increment(k,val)`时，不需要直接加，而是仅仅在`diff[k-1]`层上加val
- `pop`时，将当前层增量下传，当前层清零，并返回值 + 增量

####抽象差分逻辑

- 用 `Difference` 类维护 `diff[]` 和下传逻辑；
- `push` 时无需增量处理；
- `pop` 时由 `Difference` 完成结算和增量转移；
- `increment(k, val)` 只操作 `Difference` 内部逻辑。

####什么是差分数组？

假设有一个数组A，那么A的**差分数组**的定义如下

$D[0] = A[0], D[i] = A[i] - A[i-1]$

####差分数组的用途 - 区间[L...R]批量增减

```java
private void increment(int l, int r, int val){
  if (l < 0 || i >= n){
    throw new IllegalArgumentException("Invalid Range");
  }
  
  diff[i] +=val;
  if(r + 1 < n){
    diff[r+1] -= val;
  }
}
```

####怎样从差分数组中恢复修数组？

```java
private long[] result(){
  int[] res = new long[n];
  
  res[0] = diff[0];
  
  for (int i=1; i < n; i++){
    res[i] = res[i-1] + diff[i];
  }
  
  return res;
}
```

###难点分析和应对

| 难点                       | 对应策略                                    |
| -------------------------- | ------------------------------------------- |
| 差分标记和传递过程繁琐     | 使用 `Difference` 类封装增量数据与传递逻辑  |
| 操作边界处理               | 所有 `top` 的变更都保持和 `Difference` 同步 |
| pop 时增量累加与转移正确性 | 通过封装减少出错范围                        |

###实现原理和步骤 - 利用差分数组记录增量

本题使用一个数组作为存储数据的场所。



####主类：CustomStack

- 管理核心栈数组；
- 委托 `Difference` 管理所有**增量操作**。

####差分类：Difference - 用来计算每个数组元素的增量累计值

- 管理与栈同步的**延迟增量**数组，不是_**数组元素的来的真实值**_ 
- 提供两个方法：
  - `increment(l,r,val)`：在第 `k-1` 层添加延迟增量；
  - `getArray()`：结算栈顶增量，并将增量传给下一层。

#### 初始化过程

##### 初始化相关限制变量

- 最大容量：`capacity = maxSize`

- 数组（存储数据的场所）：`this.arr = new int[maxSize]`

##### 初始化用来保存增量的差分数组

`Difference diff = new Difference[maxSize]`

#### 入栈的过程

##### 检查是否超过了限制容量

如果超过限制容量，什么都不做。

##### 将新元素放入数组的最后位置

`arr[++top] = x`

#### 区间增减的实现过程

这个时候使用**差分数组**实现区间增减过程。

##### 判断K是否超过了栈的大小

如果K超过了栈的大小，则仅仅修改`arr[0..top]`，如果没有超过，则修改`arr[0...k-1]`。

##### 使用差分数组保存增量

```Java
int r = Math.min(top,k-1);
diff.incr(0,r,val);
```

##### pop的实现过程

##### 获得原来数组中的元素

```
int origin = arr[top];
```

##### 获得差分数组中的增量

需要使用**前缀和计算方法**：

```Java
int incr = 0;
for(int i = 0; i <= top;i++){
  incr += diff[i];
}
```

##### 计算最终的返回值

```
int res = origin + incr;
```

##### 重置差分数组中的top位置的增量为0

```Java
diff.incr(top,top, -incr);
```

最后返回最终的值就可以了。

###实现代码

####差分数组保存每一个元素的累积增量

```java
    class Difference {
        int size;
        int[] diff;

        public Difference(int size){
            this.size = size;
            //差分数组的初始值都是0
            this.diff = new int[size];
        }

        public void increment(int l, int r, int val){

            if (l < 0){ l = 0;}

            r = Math.min(r,top);
            diff[l] += val;

            if (r + 1 < size){
                diff[r+1] -= val;
            }
        }

        public int[] getInc(){
            int[] res = new int[size];

            res[0] = diff[0];
            for (int i = 1; i < size; i++){
                res[i] = res[i-1] + diff[i];
            }
            return res;
        }
    }
```

####栈的定义 - 如何保持top的计算和转换

```java
class CustomStack {
    int capacity;
    int top;
    int[] arr;
    // 差分数组，用以保存增量
    Difference diff;

    public CustomStack(int maxSize) {
        this.capacity = maxSize;
        this.top = -1;
        arr = new int[maxSize];
        this.diff = new Difference(maxSize);
    }
    
    public void push(int x) {
        if (top + 1 >= capacity) {
            return;
        }
        arr[++top] = x;
    }
    
    public int pop() {
        if (top == -1) {
            return -1;
        }

        // 核心修正点 1: 计算栈顶元素所累积的增量
        // 通过计算差分数组的前缀和来得到 top 位置的精确增量值
        // 时间复杂度为 O(top)，这是此方法固有的
        int current_increment = 0;
        for (int i = 0; i <= top; i++) {
            current_increment += diff.diff[i];
        }
        
        int result = arr[top] + current_increment;
				//撤销top位置的增量，这一步十分关键
        if(current_increment != 0){
            diff.incr(top, top, -current_increment);
        }
        top--;
        
        return result;
    }
    
    public void increment(int k, int val) {
        if(k <= 0) return;
        if (top == -1) {
            return;
        }
        
        // 核心修正点 3: 修正边界条件
        // 增量操作的范围不能超过当前栈顶
        int range_end = Math.min(k - 1, top);
        
        // 只有在范围有效时才进行操作
        if (range_end >= 0) {
            diff.incr(0, range_end, val);
        }
    }
}
```

###注意事项

1. **top 与 size**：`size = top + 1`。空栈必须保持 `top == -1`，否则边界易错。
2. **increment(k,val)** 如果 `k` 大于当前元素个数，应当只修改现有元素。
3. **多线程**：题干默认单线程；如生产环境需加锁或用 `AtomicIntegerArray`。
4. **内存**：`stack` 和 `inc` 都固定 O(maxSize)`；不使用 `ArrayList` 可避免自动扩容成本。

###经验总结

- **延迟标记思想**在栈/数组设计题中屡见不鲜（如「差分数组」「树状数组」「懒标记线段树」），关键是**把时间复杂度均摊到真正需要的操作上**。
- 写完后**自检边界**：
  - 空栈操作
  - 栈满时 push
  - `increment(k, ...)` 的 *k* = 0、k = size、k > size
- 面试答题顺序可先给朴素 O(k) 做法，再提出优化 O(1) 方案，展示思考过程

###[数组+指针]Leetcode 1381 - 普通解法

设计一个“有最大容量限制”的栈，并实现 3 种操作：

1. `push(x)`：若栈未满，将 `x` 压入栈；
2. `pop()`：若栈非空，弹出栈顶元素；
3. `increment(k, val)`：将栈底前 `k` 个元素全都加上 `val`。

##### 考察点

| 考察点         | 说明                                        |
| -------------- | ------------------------------------------- |
| 栈结构基本实现 | 固定容量，手动维护下标                      |
| 模拟操作题     | `push`/`pop`/`increment` 三者状态转换的实现 |
| 状态边界处理   | 空栈、满栈、`k > size` 等特殊情况的正确判断 |

##### 核心套路 - 数组模拟栈实现 - 跟踪最大index(top)

###### 使用数组模拟栈

- 使用数组模拟栈（`int[] stack`），手动维护 `top` 下标。

- `top = -1` 表示空栈，`top + 1 == maxSize` 表示满栈。

###### 加值操作的实现

- 对于 `increment(k, val)` 操作，**直接遍历栈底前 `k` 个元素，逐个 +val**，没有优化。

- 时间复杂度为 O(k)。

##### 难点分析和应对方法

| 难点               | 解决方法                                                     |
| ------------------ | ------------------------------------------------------------ |
| 栈满/空判断        | 使用 `top` 判断（空栈：`top == -1`，满栈：`top + 1 == maxSize`） |
| increment 边界判断 | 计算 `Math.min(k, top + 1)`                                  |
| increment 性能差   | 此版本暂不优化，强调为“初级思路”                             |
| 易错下标处理       | 所有数组访问均基于 0 下标，避免越界                          |

##### 实现原理和步骤

1. 定义成员变量：
   - `int[] stack`：保存数据；
   - `int top`：表示栈顶；
   - `int maxSize`：最大容量。
2. 实现 `push(x)`：
   - 若 `top + 1 < maxSize`，则 `stack[++top] = x`。
3. 实现 `pop()`：
   - 若空栈（`top == -1`）返回 `-1`；
   - 否则返回 `stack[top--]`。
4. 实现 `increment(k, val)`：
   - 遍历 `i = 0` 到 `min(k, top + 1)`，每个元素加上 `val`。

##### 代码实现

```java
class CustomStack {
    int[] stack;
    int top;
    int maxSize;

    public CustomStack(int maxSize) {
        this.stack = new int[maxSize];
        this.top = -1;
        this.maxSize = maxSize;
        
    }
    
    public void push(int x) {
        if (top + 1 < maxSize){
            top += 1;
            stack[top] = x;
        }
    }
    
    public int pop() {
        if (top == -1){
            return -1;
        }
        int res = stack[top];
        top -= 1;
        return res;
        
    }
    
    public void increment(int k, int val) {
        int r = Math.min(maxSize,k);
        for (int i = 0; i<r; i++){
            stack[i] += val;
        }
    }
}
```

##### 注意事项

1. `top == -1` 表示空栈，不能访问 `stack[top]`。
2. `increment(k, val)` 必须避免对超出栈元素个数的下标访问。
3. 不使用 Java 原生栈类，以便控制容量上限。
4. 此实现不适合大数据量或频繁 `increment` 的场景。

##### 经验总结

| 经验点        | 说明                                         |
| ------------- | -------------------------------------------- |
| 面试答题顺序  | 先写朴素直觉版本，再提出“延迟增量”优化版本   |
| push/pop 模拟 | 推荐用 `top = -1` 起始，简单清晰             |
| 实战建议      | 若面试题目没要求高性能，可优先写这种直接实现 |
| 提升建议      | 熟悉类似懒惰更新思路，掌握空间换时间技巧     |