# 最小栈-辅助栈实现常数实现最小值

##核心思想 - 双栈同时记录数据

用一个**额外栈**同步记录栈中的最小值，实现`O(1)`查询最小功能

### 主栈 - 存储所有数据

用一个主栈`mainStack`保存所有的数据

### 辅助栈 - 栈顶保存当前最小的值

每次来新的数据：

- 将元素压入主栈
- 将元素和辅助栈栈顶元素进行比较，如果当前元素更小，则压入辅助栈

##代码套路

```java
Stack<Integer> stack = new Stack<>();
Stack<Integer> minStack = new Stack<>();

void push(int x){
  stack.push();
  //如果当前主栈栈顶值小于最小栈栈顶值，将值压入最小栈
  if (minStack.isEmpty() || x < minStack.peek()){
    minStack.push(x);
  }
}

void pop(){
  //如果当前主栈栈顶等于最小值，同时弹出主栈和最小栈
  if (stack.pop().equals (minStack.peek())){
    minStack.pop();
  }
}

int getMin(){
  return minStack.peek();
}
```

###适用场景

- 实现栈的扩展功能
- 高频查询栈中的最小值

## Leetcode 155: 设计最小栈

见上述描述

##Leetcode 716: 设计最大栈

### 问题要点

设计一个最大栈数据结构，既支持栈操作，又支持查找栈中最大元素。

实现 `MaxStack` 类：

- `MaxStack()` 初始化栈对象
- `void push(int x)` 将元素 x 压入栈中。
- `int pop()` 移除栈顶元素并返回这个元素。
- `int top()` 返回栈顶元素，无需移除。
- `int peekMax()` 检索并返回栈中最大元素，无需移除。
- `int popMax()` 检索并返回栈中最大元素，并将其移除。如果有多个最大元素，只要移除 **最靠近栈顶** 的那个。

### 问题本质和分析

**这是一个典型的多操作、双目标的数据结构设计题。**

需要同时满足：

- 栈的“后进先出”特点（LIFO）
- 快速找到并删除“最大元素”

因此，不能仅使用一个普通的栈，还需设计额外的数据结构来维护**最大值访问和删除的效率**。



###核心思想-栈+TreeMap+双向链表

####解法一： 双栈-主栈+最大栈 - 无法快速删除最大值

- `push(x)`:两个栈都压入
- `pop()`:两个栈都弹出
- `top()`:主栈栈顶
- `peekMax()`: 最大栈栈顶
- `popMax()`: 难以实现，只能找最大值，但是无法快速删除位于主栈中间的那个最大值

首先我们想到的是**最大栈**的概念，通过最大栈我们可以快速的找到最大值。

问题是如何实现`popMax()`，原题队该操作的描述是：

- 检索并返回栈中最大元素，并将其移除。
- 如果有多个最大元素，只要移除 **最靠近栈顶** 的那个。
- 如何在$O(1)$时间内找到并删除最大值就变成了较大的挑战，

####解法二： 双向链表 + TreeMap(或者堆+HashSet)

##### 什么是TreeMap？

TreeMap 是 Java 集合框架中一种重要的 Map 实现，它以其键（key）的有序性而著称。

与 HashMap 的无序存储不同，TreeMap 能够确保其存储的键值对始终处于排序状态，这使得它在需要有序遍历或基于键范围进行查询的场景中大放异彩。

##### TreeMap的核心特性

###### 有序性

这是 TreeMap 最核心的特性。

它会根据键的自然顺序或者在创建时指定的 `Comparator` 对键进行排序。

这意味着遍历 TreeMap 时，得到的键是按照升序排列的。

###### 高效的性能

TreeMap 的增、删、改、查等主要操作的平均和最坏时间复杂度均为 $O(logn)$，其中 n 是 TreeMap 中键值对的数量。

这种对数级别的时间复杂度得益于其底层高效的**自平衡二叉搜索树**结构。

###### 不允许null键

由于需要对键进行比较排序，TreeMap 不接受 `null` 作为键。尝试存入 `null` 键会抛出 `NullPointerException`。但是，它允许多个 `null` 作为值（value）。

###### 非线程安全

与 `HashMap` 类似，`TreeMap` 的实现不是同步的。

如果在多线程环境下对 TreeMap 进行并发修改，必须由外部程序来保证同步，否则可能会导致数据不一致。

可以通过 `Collections.synchronizedSortedMap` 方法来包装一个线程安全的 TreeMap。

###### 丰富到导航方法

TreeMap 实现了 `NavigableMap` 接口，提供了一系列强大的导航方法，例如 `firstKey()`、`lastKey()`、`ceilingKey()`（返回大于或等于给定键的最小键）、`floorKey()`（返回小于或等于给定键的最大键）以及 `subMap()`（返回指定范围内的子映射）等。

##### TreeMap的实现原理：红黑树

TreeMap 的所有特性都源于其底层的数据结构——**红黑树（Red-Black Tree）**。

红黑树是一种自平衡的二叉搜索树，它通过一系列严格的规则来确保树的高度大致保持在 O(logn)，从而保证了各项操作的高效性。

##### 怎样使用TreeMap来解决本题？

###### 使用双链表模拟栈

- 用双链表模拟栈（需要删除中间节点）

###### 使用TreeMap保存<值，节点列表>的映射

- 用`TreeMap`保存`{值->所有节点}`的映射，并自动排序，便于获得最大值

###### 最大栈每个操作的实现原理

| 操作        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `push(x)`   | 创建一个新链表节点，添加到链表尾部，并记录到 map 的 x -> List 中 |
| `pop()`     | 移除链表尾部，更新 map（将该 val 的 node 从列表中移除）      |
| `top()`     | 读取链表尾部的值                                             |
| `peekMax()` | 获取 `TreeMap` 的最大 key                                    |
| `popMax()`  | 从 `map.get(max)` 中获取最后一个节点（靠近栈顶），将其从链表中移除 |

#### 解法三： 双栈 + 回溯

我们采用**最大栈**的思路来实现。

##### 主栈：存储所有元素

一个普通的栈，用于存储所有元素，维持它们的插入顺序。

##### 辅助栈(maxStack)： 栈顶始终保存最大元素

`maxStack` 的栈顶元素始终是 `stack` 在当前状态下的最大值。

###### Push操作的实现流程

我们将 `x` 压入 `stack`。

同时，我们将 `x` 和 `maxStack` 当前的栈顶元素（如果 `maxStack` 不为空）中的较大者压入 `maxStack`。

###### Pop操作的实现流程

我们同时从 `stack` 和 `maxStack` 中弹出栈顶元素，以保持同步。

##### PopMax过程的实现 - 基于递归思想

`popMax` 的难点在于移除一个可能在**栈中间**的元素。

我们可以利用一个临时的辅助空间来暂存**最大元素之上**的元素。

通常的迭代做法是使用**第三个栈**作为缓冲区， 这里的第三个栈就是**递归函数的调用栈**。

然而，我们可以巧妙地利用**函数调用栈**来充当这个缓冲区，从而实现**递归**。

###### 递归实现的核心思想：递归+回溯

- 找到当前栈中的最大元素：`maxVal = maxStack.peek()`
- 定义一个递归函数：`findAndRemoveMax(maxVal)`
- **递归过程**：在递归函数中，查看当前**主栈** `stack` 的栈顶元素：
  - 如果主栈栈顶元素不是`maxVal`,说明我们还没有找到目标。
    - 弹出主栈栈顶元素，此时被弹出的元素将会被暂时保存在**函数调用栈**（局部变量）
    - 然后进行递归调用
  - 如果栈顶元素是`maxVal`，我们就找到了最**靠近栈顶的那个最大值**
    - 弹出该元素
    - 终止递归
- **回溯过程**：
  - 当递归函数从更深的一层返回时，我们将之前保存在**调用栈帧**中的元素重新push回**主栈**中。
  - 这样我们就恢复了除了最大值以外的其他元素的相对顺序

##### PopMax的实现 - 基于第三个Buffer栈

###### 从辅助最大栈栈顶获取最大值

```Java
int val = maxStack.peek();
```

###### 定义Buffer栈 - 用来缓存Pop出来的非MaxVal值

```
Stack<Integer> buffer = new Stack<Integer>();
```

###### 弹出并检查主栈的栈顶值直到找到最大值

- 弹出当前主栈栈顶元素
- 检查弹出元素是否与最大值相同
- 如果不同，将弹出元素暂存到buffer栈中
- 如果相同，则调用`pop()`方法同时弹出最大栈栈顶和主栈栈顶
- 恢复被弹出的元素，将Buffer中的元素逐个通过`push()`方法放回主栈和最大栈



### 实现原理和步骤 - 基于双栈（或者叫做三栈）

#### Push操作的实现

1. 将 `x` 压入 `stack`。
2. 计算当前的最大值：如果 `maxStack` 为空，最大值就是 `x`；否则，最大值是 `x` 和 `maxStack.peek()` 中的较大者。
3. 将计算出的最大值压入 `maxStack`。

#### Pop操作的实现 - 弹出两个栈的栈顶即可

1. 从 `maxStack` 弹出栈顶。
2. 从 `stack` 弹出栈顶并返回。

#### Top操作的实现

返回 `stack.peek()`。

#### PeekMax的实现

返回 `maxStack.peek()`。

#### PopMax的实现 - 基于Buffer栈实现

1. 获取当前的最大值 `maxVal = peekMax()`。
2. 创建一个临时的缓冲区栈 `buffer`。
3. 循环：当 `stack.peek()` 不等于 `maxVal` 时，将 `stack.pop()` 的结果压入 `buffer`。
4. 此时 `stack.peek()` 就是最靠近栈顶的最大值，调用 `pop()` 将其移除。
5. 循环：当 `buffer` 不为空时，将 `buffer.pop()` 的结果通过 `push()` 方法压回栈中（注意是调用我们自己实现的 `push`，而不是直接操作 `stack`，以保持 `maxStack` 的同步）。
6. 返回 `maxVal`。

#### PopMax的实现 - 基于回溯

1. 获取当前栈顶元素 `top = stack.peek()`。
2. 如果 `top` 等于 `maxVal`:
   - 调用 `pop()` 移除此最大值。
   - 返回。
3. 如果 `top` 不等于 `maxVal`:
   - 调用 `pop()` 移除栈顶元素，并用一个局部变量 `currentVal` 保存它。
   - 递归调用 `popMaxRecursive(maxVal)`。
   - 递归返回后，调用 `push(currentVal)` 将之前弹出的元素压回栈中。

### 实现代码  - 基于双栈（或者叫做三栈）

```Java
import java.util.Stack;

class MaxStack {

    private Stack<Integer> stack;
    private Stack<Integer> maxStack;

    /** initialize your data structure here. */
    public MaxStack() {
        stack = new Stack<>();
        maxStack = new Stack<>();
    }

    public void push(int x) {
        stack.push(x);
        if (maxStack.isEmpty() || x >= maxStack.peek()) {
            maxStack.push(x);
        } else {
            maxStack.push(maxStack.peek());
        }
    }

    public int pop() {
        maxStack.pop();
        return stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int peekMax() {
        return maxStack.peek();
    }

    public int popMax() {
        int maxVal = peekMax();
        Stack<Integer> buffer = new Stack<>();
        // 找到最顶部的最大值，将其余元素暂存
        while (top() != maxVal) {
            buffer.push(pop());
        }
        // 移除最大值
        pop();
        // 将暂存的元素放回
        while (!buffer.isEmpty()) {
            push(buffer.pop());
        }
        return maxVal;
    }
    
    // 以下是递归实现的popMax，可以选择性使用
    /*
    public int popMaxRecursive() {
        int maxVal = peekMax();
        removeTopMax(maxVal);
        return maxVal;
    }

    private void removeTopMax(int maxVal) {
        int currentTop = pop(); // 使用我们自己的pop来保持maxStack同步
        if (currentTop == maxVal) {
            return; // 找到并移除了，终止递归
        }
        // 递归下沉
        removeTopMax(maxVal);
        // 回溯时，将非最大值的元素重新push回去
        push(currentTop);
    }
    */
}

/**
 * Your MaxStack object will be instantiated and called as such:
 * MaxStack obj = new MaxStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.peekMax();
 * int param_5 = obj.popMax();
 */
```

### 实现原理和详细步骤 - 基于TreeMap +双链表

我们采用双链表 + TreeMap的方式来实现。

雙棧解法的主要瓶頸在於 `popMax` 操作的時間複雜度為 O(n)。

當棧內元素非常多時，每次 `popMax` 都可能需要遍歷整個棧，效率較低。

`TreeMap` + 雙向鏈結串列的組合拳旨在解決這個痛點：

- **如何快速找到最大值？** -> `TreeMap` 可以在 O(log n) 時間內告訴我們最大值是什麼。
- **找到後如何快速刪除它？** -> 如果最大值不在棧頂，直接刪除會破壞棧結構。但雙向鏈結串列允許我們在 O(1) 時間內刪除任意節點。

因此，我們將這兩者結合，`TreeMap` 負責「找」，雙向鏈結串列負責「存」和「刪」。

#### 双链表和TreeMap的职责分别是什么？

我們將資料同時存放在兩個結構中：

1. **`DoublyLinkedList dll`**:
   - 鏈結串列的每個節點 `Node` 包含 `val`, `prev`, `next` 指標。
   - 我們將鏈結串列的**尾部（tail）当作栈顶**。`push` 操作是在尾部新增節點，`pop` 和 `top` 操作是在尾部進行。
2. **`TreeMap<Integer, List<Node>> map`**:
   - **Key**: 儲存的元素值 `int`。
   - **Value**: 一個 `List<Node>`。因為棧中可能存在多個值相同的元素（例如 `push(5), push(5)`），所以我們需要一個列表來儲存所有值為 `Key` 的節點的參考。

這兩個結構協同工作，確保資料的一致性。

#### 双链表的作用 - 快速查找和删除元素

##### 双链表节点的定义

```Java
class ListNode{
  int val;
  ListNode prev;
  ListNode next;
  public ListNode(int val){
    this.val = val;
  }
}
```



##### 定义两个辅助节点： 头节点和尾节点

###### 没有辅助节点会怎样？

如果我们的链结串列只用一个 `head` 指標指向第一个实际节点，一个 `tail` 指標指向最后一个实际节点，那么在进行插入和删除操作时，需要处理大量烦人的**边界**情况：

**向空链结串列中插入第一个节点**：

- 你需要同时更新 `head` 和 `tail` 指標，让它们都指向这个新节点。
- 这个新节点的 `prev` 和 `next` 指標都必须是 `null`。
- 这是一个特殊的逻辑分支。

**在链结串列头部插入节点**：

- 你需要更新整个链结串列的 `head` 指標。
- 原先的 `head` 节点的 `prev` 指標需要更新。
- 这是一个特殊的逻辑分支。

**在链结串列尾部插入节点**：

- 你需要更新整个链结串列的 `tail` 指標。
- 原先的 `tail` 节点的 `next` 指標需要更新。
- 这又是一个特殊的逻辑分支。

**删除链结串列中唯一的节点**：

- 删除后，链结串列变为空。
- 你需要把 `head` 和 `tail` 指標都设为 `null`。
- 这是一个特殊的逻辑分支。

**删除头节点或尾节点**：

- 同样需要更新 `head` 或 `tail` 指標。
- 这又是特殊的逻辑分支。

###### 使用辅助节点之后

**链结串列永远不“空”**：

从结构上看，`head` 和 `tail` 永远存在，所以我们不需要进行 `if (list == null)` 的判断。

一个“空”的栈，在链结串列层面只是 `head.next == tail`。

**插入逻辑统一**：

无论是向一个空链结串列插入，还是向一个已有 N 个元素的链结串列尾部插入，逻辑是完全一样的！

我们总是将新节点 `node` 插入到 `tail.prev` 和 `tail` 之间。

请看 `addNode` 方法中的这四行程式码，它处理了所有情况，无需任何 `if` 判断：

```Java
Node last = tail.prev; // 永远能取到前一个节点 (最差也是 head)
last.next = node;
node.prev = last;
node.next = tail;
tail.prev = node;
```

**删除逻辑统一**：

无论是删除第一个、最后一个，还是中间的任意一个节点，逻辑也是完全一样的！

对于要删除的节点 `node`，我们只需要将它的前驱节点 `node.prev` 和后继节点 `node.next` 连接起来即可。

请看 `removeNode` 方法中的这两行程式码，它同样处理了所有情况：

```Java
Node prev = node.prev; // 永远存在 (最差也是 head)
Node next = node.next; // 永远存在 (最差也是 tail)
prev.next = next;
next.prev = prev;
```

###### 辅助头节点和尾节点的定义

```
ListNode head = new ListNode(0);
ListNode tail = new ListNode(0);
head.next = tail;
tail.prev = head;
```

#### TreeMap的作用： 快速找到最大的元素

由于TreeMap的特性是可以按照Key进行排序，并且提供了可以获取最大key值和最小key值的功能。

#####TreeMap的定义`<val,List<Node>>`

- Key是元素的值
- Val是具有该值的节点的列表

因为我们要求如果发现有多个节点同时和最大值相同，则删除**最后一个**，因此我们在获取了最大值相应的节点列表之后，只需要删除最后一个即可。

#### Stack操作的实现

##### Push操作的实现

1. 創建一個新的 `Node` 物件，值為 `x`。
2. 將這個新 `Node` 加入到雙向鏈結串列的尾部。
3. 從 `TreeMap` 中根據 `x` 查找對應的節點列表。如果不存在，就創建一個新的空列表。
4. 將新創建的 `Node` 的參考加入到這個列表中。
5. 將更新後的列表放回 `TreeMap`。

##### Pop的实现

1. 從雙向鏈結串列的尾部移除節點（即棧頂節點）。
2. 獲取該節點的值 `val`。
3. 從 `TreeMap` 中找到 `val` 對應的節點列表。
4. 從該列表中移除**最後一個**元素（因為它對應的是最靠近棧頂的那個節點）。
5. 如果移除後列表變空，則從 `TreeMap` 中移除 `val` 這個 Key。
6. 返回 `val`。

##### Top的实现

1. 直接返回雙向鏈結串列尾部節點的值即可。

##### PeekMax的实现

1. 直接調用 `map.lastKey()`，返回 `TreeMap` 中最大的 Key。

##### PopMax的实现

1. 調用 `peekMax()` 找到最大值 `maxVal`。

2. 從 `TreeMap` 中找到 `maxVal` 對應的節點列表。

3. 從該列表中取出**最後一個**節點 `nodeToRemove`（這確保了我們移除的是最靠近棧頂的那個最大值）。

4. 從雙向鏈結串列中移除 `nodeToRemove`（這是一個 O(1) 的操作）。

5. 從 `TreeMap` 的節點列表中移除 `nodeToRemove` 的參考。

6. 如果移除後列表變空，則從 `TreeMap` 中移除 `maxVal` 這個 Key。

7. 返回 `maxVal`。

####实现代码

```java
class Node {
  int val;
  Node prev, int next;
  public Node (int val, Node prev, Node next){
    this.val = val;
    this.prev = prev;
    this.next = next;
  }
}

private Node head, tail;

private TreeMap<Integer, List<Node>> map;

public MaxStack(){
  head = new Node(0);
  tail = new Node(0);
  tail.prev = head;
  head.next = tail;
  map = new TreeMap<>();
}

private void addNode(Node node){
  Node prev = tail.prev;
  prev.next = node;
  node.prev = prev;
  node.next = tail;
  tail.prev = node;
}

private void removeNode(Node node){
  Node prev = node.prev;
  Node next = node.next;
  prev.next = next;
  next.prev = prev;
}

public void push(x){
  Node node = new Node(x);
  addNode(node);
  map.computeIfAbsent(x,z->new ArrayList()).add(node);
}

public int pop(){
  Node node = tail.prev;
  removeNode(node);
  List<Node> list = met.get(node.val);
  list.remove(list.size()-1);//删除最后一个
  //注意`map`中的列表为空时需要删除键，否则会影响`peekMax()`的正确性
  if(list.isEmpty()) map.remove(node.val);
  return node.val;
}

public int top(){
  return tail.prev.val;
}

public int peekMax(){
  return map.lastKey();
}

public int popMax(){
  int max = map.lastKey();
  List<Node> list = map.get(max);
  Node node = list.remove(list.size()-1);
  //注意`map`中的列表为空时需要删除键，否则会影响`peekMax()`的正确性
  if (list.isEmpty()) map.remove(max);
  removeNode(node);
  return max;
}
```

####注意事项

- `popMax()` 删除的是**最靠近主栈栈顶的最大值元素**，不是栈底最早插入的那个
- `TreeMap<Integer, List<Node>>` 可能有多个相同值的节点，所以要用列表存储
- **双向列表**可以以**O(1)**删除任意节点，避免了栈无法删除中间节点的问题
- **注意`map`中的列表为空时需要删除键，否则会影响`peekMax()`的正确性**
- 不能使用`PriorityQueue`替代`TreeMap`，因为**`PriorityQueue`无法有效移除中间的节点**

###补充知识：Java中的TreeMap

###### TreeMap的基本特性

**有序性**
 `TreeMap` 会自动按照键（key）进行**升序排序**（默认使用键的自然顺序，也可以传入自定义比较器 `Comparator`）。

**底层数据结构**
 使用的是 **红黑树（Red-Black Tree）** 实现，是一种**自平衡的二叉搜索树**。

**时间复杂度**

- `get(key)`：O(logN)
- `put(key, value)`：O(logN)
- `remove(key)`：O(logN)
- `firstKey()` / `lastKey()`：O(logN)
- `ceilingKey(k)` / `floorKey(k)`：O(logN)

**不允许 null 键**（但允许 null 值）
 插入 null key 会抛出 `NullPointerException`（除非你自定义 Comparator 明确支持 null）

**线程不安全**
 多线程访问时需外部加锁或使用 `Collections.synchronizedMap()` 包装。

###### TreeMap的核心实现原理-红黑树

- `TreeMap`维护的是一个**红黑树的根节点**
- 每个节点包含`key`,`value`,`left`,`right`,`parent`,`color(红或者黑)`
- 插入或者删除节点之后，红黑树通过旋转变色保持平衡，确保**最长路径不超过最短路径的两倍**
- 排序操作基于`Comparable`接口或者`Comparator`，以实现自动有序存储

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(3, "C");
map.put(1, "A");
map.put(2, "B");
System.out.println(map); // 输出：{1=A, 2=B, 3=C}，自动按 key 排序
```

###### TreeMap的典型方法

| 方法              | 功能说明                            |
| ----------------- | ----------------------------------- |
| `put(k, v)`       | 插入键值对（如果已存在则覆盖）      |
| `get(k)`          | 获取指定 key 的 value               |
| `remove(k)`       | 移除指定 key 的映射                 |
| `firstKey()`      | 获取最小的 key                      |
| `lastKey()`       | 获取最大的 key                      |
| `floorKey(k)`     | 返回 ≤ k 的最大 key                 |
| `ceilingKey(k)`   | 返回 ≥ k 的最小 key                 |
| `descendingMap()` | 返回 key 逆序视图                   |
| `subMap(k1, k2)`  | 获取 key 介于 k1 和 k2 之间的子映射 |

###### TreeMap的适用场景

- 需要根据Key排序的数据结构（例如区间、最大值、最小值处理）
- 需要快速查找>=,<=某个值的key（天平问题，滑动窗口）
- 实现LRU/时间戳调度策略，需要按照顺序检索或者检查节点