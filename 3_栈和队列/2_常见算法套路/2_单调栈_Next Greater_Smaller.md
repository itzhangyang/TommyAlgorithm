### 单调栈-Next Greater/Smaller问题

#### 核心思想 - 单调栈

维护一个单调递增/递减栈，快速找到某元素左/右边第一个更大的/更小的值

##### 什么是单调栈？- 元素满足单调性

单调栈是指栈中元素（或其映射值）满足**单调性**的栈。

本题中，维护的是一个 **单调递减栈**：栈中下标所指的值依次递减，即：

```
nums[stack[0]] > nums[stack[1]] > nums[stack[2]] ...
```

##### 单调栈的意义 - 查找下一个Greater/Smaller元素

每次遇到一个`新数`时：

###### 什么时候入栈？

- 如果它比栈顶元素小，则**入栈**（因为将来可能遇到**更大的数**）

###### 什么时候出栈？

- 如果它比栈顶元素大，说明找到了**比栈顶元素更大的`下一个元素`**，可以**出栈**并记录结果

##### 单调栈是如何保证单调性的？

###### 单调递减栈 - 入栈之前请清空所有较小元素

通过每次在入栈前，先**出栈所有小于当前元素的栈顶元素**，来确保整个栈是种保持**单调递减**。

###### 单调递增栈 - 入栈之前清空所有较大元素

每次在入栈之前，先出栈所有大于当前元素的元素，确保整个栈保持**单调递增**。

```java
while (!stack.isEmpty()){
  if (nums[stack.peek()]) < num){
    //将栈顶元素的next greater设置为num
    res[stack.poll()] = num;
  }
}
```

保证**单调递减**的原理如下

- **栈里保存的是索引**，但是比较的是这些索引在数组中的值：`nums[stack.peek()]`
- 当当前值 `num = nuts[i%n]` 大于栈顶的元素值
  - 栈顶元素不再具有单调性要求, 因为它后面有更大的值，应当被移除
  - 同时记录结果，栈顶的**下一个更大元素** 就是当前的`num`
- 只要当前值大于栈顶值，就不断出栈，直到恢复**递减状态**
- 之后再将**当前元素入栈**

#### 适用场景 - Prev/Next Greater/Smaller

| 问题类型                                      | 描述                                                 | 单调栈类型            |
| --------------------------------------------- | ---------------------------------------------------- | --------------------- |
| **下一个更大元素 (Next Greater Element)**     | 对于数组中的每个元素，找到其右侧第一个比它大的元素。 | 单调递减栈            |
| **下一个更小元素 (Next Smaller Element)**     | 对于数组中的每个元素，找到其右侧第一个比它小的元素。 | 单调递增栈            |
| **上一个更大元素 (Previous Greater Element)** | 对于数组中的每个元素，找到其左侧第一个比它大的元素。 | 单调递减栈 (反向遍历) |
| **上一个更小元素 (Previous Smaller Element)** | 对于数组中的每个元素，找到其左侧第一个比它小的元素。 | 单调递增栈 (反向遍历) |

#####下一个/上一个更大/更小元素

在一般的题目当中，一般可能会要求如果不存在next/prev greater/smaller的情况下，则将值设置为-1。

然而在部分计算区边界值的过程当中，我们需要使用到具体的边界值。

###### 如何设置不存在的情况下的默认值？

- 有要求的情况下，按照要求设置默认值
- 在计算左右边界的场景中：
  - Next Greater/Smaller的默认值应该是`n`， 即数组的长度
  - Prev Greater/Smaller的默认值应该是`-1`，即第一个元素之前的位置

###### 使用单调递减栈计算 Next Greater问题

###### 使用单调递增栈计算Next Smaller问题

#####柱状图中的最大矩形

#####股票买卖问题

#### Leetcode 496 寻找数组中每个元素的Next Greater

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2`，其中 `nums1` 是 `nums2` 的子集。
 对于 `nums1` 中的每个元素，你需要在 `nums2` 中找到它右边的 **第一个比它大的元素**。如果不存在，则输出 `-1`。

##### 核心思想：单调栈+哈希映射

这属于典型的**下一个更大元素**问题，使用**单调栈**是最优解

###### 单调栈解法的直觉

我们要找到`右边第一个比当前元素大的数`，这属于**下一个更大的元素问题**，适合从右到左构造`单调递减栈`。

##### 实现原理和步骤

1. 用栈维护一个**从栈底到栈顶单调递减**的元素序列
2. 每次遇到一个新元素`num`时，**弹出所有比它小的元素**，说明`num`时这些被弹出元素的`下一个更大的元素`
3. 把这些配对关系存入`map<num,nextGreaterNum>`
4. 遍历完`nums2`后，再用`map`映射`nums1`中的每一个元素

##### 代码实现

###### 使用单调递减栈计算`nums2`中每个元素的`下一个更大值`

```java
private int[] getNextGreaterMap(int[] nums){
  Map<Integer, Integer> nextGreaterMap = new HashMap<>();
  
  Deque<Integer> stack = new ArrayDeque<>();
  for (int num:nums){
    // 如果栈不为空，弹出所有比num小的元素，并且将这些弹出元素的next greater设置为num
    while (!stack.isEmpty() && num > stack.peek()){
      int top = stack.pop();
      nextGreaterMap.put(top,num);
    }
    // 将当前元素压入栈
    stack.push(num);
  }
  //处理没有next greater的元素
  while (!stack.isEmpty()){
    nextGreaterMap.put(stack.pop(),-1);
  }
  
  return nextGreaterMap;
}
```

###### 查询`nums1`中的每一个元素在`nums2`中的**下一个更大值**

```java
Map<Integer,Integer> nextGreaterMap = getNextGreaterMap(nums2);
int[] res = new int[nums1.length];

for (int i=0;i<nums1.length;i++){
  res[i] = nextGreaterMap.get(nums1[i]);
}

return res;
```



#### Leetcode 503 寻找循环数组中每个元素的Next Greater

给定一个**循环数组** `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字`之后`的**第一个比它更大的数**，这意味着你应该**循环地搜索**它的下一个更大的数。

如果不存在，则输出 `-1` 。

##### 不要怕该死的变形之循环数组应对套路

 数组的**最后一个元素之后是第一个元素**，形成一个环。

常用于寻找循环数组中的最大/最小值、下一个更大元素等。

###### 模运算 - 处理循环数组最直接的工具

这是处理循环数组最直接的工具。

通过 `index % length` 可以将任何索引映射到 `[0, length-1]` 的范围内，模拟环形结构。

###### 数组拼接/扩展 - 复制2n长度数组

将原数组复制一份拼接到其后 (`nums + nums`)，形成一个长度为 `2n` 的新数组。

这样，任何原循环数组中的长度为 `n` 的子数组问题，都转化为了新线性数组中的子数组问题，从而避免了复杂的边界判断。

例如，在处理“下一个更大元素II”时，这个技巧非常有效。

##### 为什么需要遍历两次？ - 两次遍历就足以覆盖所有的可能性

在数组是**循环数组**的情况下，如

`nums = [1,2,1]`

- 对于第一个`1`,我们需要看到第二个`1`之后的那个`2`
- **遍历两遍即可覆盖所有的可能性**

#### 基本原理 - 两次遍历数组

遇到破坏单调性的元素时弹栈，并记录当前元素是哪个元素的`next greater`.

##### 从i 到 2n-1遍历两次数组

```Java
for(int i = 0; i < 2*n; i++){
  //....
}
```



######每次取出元素`nums[i % n]`，进行单调栈操作：

```Java
int num = nums[i % n];
while(!stack.isEmpty() && nums[stack.peek()] < num){
  greater[stack.poll()] = num;
}
```

###### 如果当前元素没有入栈过（i < n），则入栈

```Java
if(i < n){
  stack.push(i);
}
```

#### 代码套路模板

找右边第一个更大值

```java
//在循环数组中寻找Next Greater
//经典套路： 将原数组x2,拼接称为一个长度为2n的数组
//然后按照递减栈的套路工作
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] greater = new int[n];
        Arrays.fill(greater, -1);
        Stack<Integer> stack = new Stack<>();
        for(int i = 0; i < 2*n; i++){
            int num = nums[i % n];
            
            while(!stack.isEmpty() && nums[stack.peek()] < num){
                greater[stack.pop()] = num;
            }

            if(i < n){
                stack.push(i);
            }
        }

        return greater;
    }
}
```

#### Leetcode 739: 寻找下一个比温度高的日期

##### 核心思想-单调递减栈应用于Next Greater问题

这个题目本质上就是一个纯粹的Next Greater题目，唯一不同的是题目求的是**下一个更高温度出现在几天后**,而不是具体的某一天。

```Java
class Solution {
    //给定一个temperatures数组， temperatures[i]表示日期i的问题
    //返回一个数组answer[i]表示需要等几天以后会有一个问题更高的日期
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];

        Stack<Integer> stack = new Stack<>();
        for(int i = 0; i < n; i++){
            int t = temperatures[i];
            while(!stack.isEmpty() && temperatures[stack.peek()] < t){
                int top = stack.pop();
                answer[top] = i - top;
            }

            stack.push(i);
        }
        return answer;
    }
}
```



#### Leetcode 84 ： 求直方图中的最大矩形面积

给定一个只包含非负数的数组`heights`，表示直方图中每个柱子的高度，宽度统一为`1`, 求直方图中最大矩形的面积。

##### 问题要点

1. **输入 (Input):** 一个非负整数数组 `heights`，每个整数代表一个柱子的高度。
2. **假设 (Assumption):** 每个柱子的宽度都为 1。
3. **输出 (Output):** 在这个柱状图中，能够勾勒出的最大矩形的面积。

**示例:** 输入 `heights = [2,1,5,6,2,3]` 输出 `10` 解释：最大的矩形是图中由高度为 5 和 6 的两个柱子构成的区域，高度取较小的 5，宽度为 2，面积为 `5 * 2 = 10`。



##### 问题的本质是什么？

###### 朴素的暴力解法 - 枚举所有的矩形

- 枚举矩形的左边界 `i`。

- 枚举矩形的右边界 `j`。

- 在 `[i, j]` 这个区间内，找到最矮的柱子 `min_height`。

- 计算面积 `min_height * (j - i + 1)`。 这个方法的时间复杂度是 O(n3)，显然无法通过。

我们可以优化一下：

- 固定一个柱子 `i` 作为矩形的**最终高度** (即这个矩形中最矮的那个柱子)。
- 然后，从这个柱子 `i` 向左和向右扩展，直到遇到一个比它更矮的柱子或者到达边界。
- 假设向左最远能到达 `left`，向右最远能到达 `right`。
- 那么，以 `heights[i]` 为高的最大矩形宽度就是 `right - left - 1`，面积为 `heights[i] * (right - left - 1)`。
- 我们遍历所有柱子，对每个柱子都执行这个操作，就能找到全局的最大面积。

这个思路的时间复杂度是 $O(n^2)$，因为对于每个柱子，我们都需要向两边扫描。虽然比 $O(n^3)$ 好，但对于 LeetCode 的数据规模通常还是会超时。

对于每个柱子`i`而言，我们可以：

- 以它为**最低柱子**向左右扩展

- 找到**左边第一个小于它的柱子**和**右边第一个小于它的柱子**

- 然后计算面积

  `area = height[i]*(right[i]-left[i]-1)`

  这就是**单调栈**的用武之地：**高效的找出每个元素左/右第一个比它小的位置**。

##### 核心思想和套路： 单调递增栈

###### 复习-利用单调递减栈求下一个较大值

```java
public int[] nextGreater(int[] nums){
  if (nums == null || nums.length == 0) return null;
  int n = nums.length;
  
  int[] result = new int[n];
  Arrays.fill(result, -1);
  
  Stack<Integer> stack = new Stack<>();
  
  for (int i=0; i<n; i++){
    while (!stack.isEmpty() && nums[tack.peek()]<nums[i]) {
      int top = stack.pop();
      result[top] = i; 
    }
    
    stack.push(i);
  }
  
  return result;
}
```

###### 如何利用单调递增栈求左边和右边第一个较小值？

- 维护一个栈：栈内存的是柱子的下标，对应高度是递增的
- 当遇到一个**比栈顶元素低**的柱子时，出发出栈，并计算以出栈元素为高的矩形面积

这种结构可以在`O(n)`时间内完成所有必要的计算。

###### 核心思想

我们将使用一个 **单调递增栈**。

这个栈里存储的是柱子的**索引 (index)**，而不是高度。

并且，这些索引对应的高度在栈中是严格单调递增的。

当我们遍历到柱子 `i` 时，如果 `heights[i]` 比栈顶索引对应的柱子高度要矮，那么对于**栈顶的**那个柱子来说，我们找到了它的**右边界**！

这个右边界就是当前的柱子 `i`。

为什么？

因为我们维护的是一个**单调递增栈**，所以栈顶柱子的左边一定是比它更矮的（或者是栈里的下一个元素），而 `i` 是我们从左到右遍历时，遇到的第一个**比它矮**的柱子。

所以，当 `heights[i]` 小于栈顶元素的高度时，我们就找到了一个可以计算面积的机会。

- **矩形的高度**：就是刚刚从栈顶**弹出的那个柱子**的高度。

- **矩形的右边界**：就是当前遍历到的索引 `i`。

- **矩形的左边界**：就是弹出栈顶元素后，**新的栈顶元素**对应的索引。

  如果弹出后栈为空，说明左边没有比它更矮的了，左边界可以视为 `-1`。

###### 弹出所有比当前元素大的栈内元素并计算每一个的最大矩阵面积

对于遍历过程中的每一个元素`heights[i]`:

**弹出**栈内**所有比`heights[i]`大的元素**，并且在弹出的过程中，每一个**弹出的元素**计算矩形面积 ：

**寻找弹出元素最大矩形的起点和终点：**

- 起点为**左边第一个比弹出元素小**的元素（`left`）- 下一个栈顶元素
  - 栈不为空的时候，这个节点是栈顶元素`stack.peek`
  - 栈为空的时候，**弹出元素就是最小元素**，说明`**heights[0....i]`都比栈顶元素大**

- 终点为**右边第一个比弹出元素小**的元素 (`right`)
  - 对于弹出元素而言，`height[i]`就是**右边第一个更小元素**，因为弹出的每个元素都大于`Height[i]`

**栈为空或者不为空的情况下的起点和终点**

- 栈不为空的情况下：
  - **左边第一个比弹出元素小**的元素`left`为`stack.peek()`
  - 对于弹出元素而言，`height[i]`就是**右边第一个更小元素**
  - 矩形的宽度为`right-left-1`， 意思**宽度不包括`left`和`right`**
- 栈为空的情况下：
  - 如果栈为空， 说明所有[0...i-1]都是比i元素大的.
  - 对于已经弹出的栈顶元素而言，所有的元素除了heights[i]都比它小
  - 矩阵的宽度就是`i`
- 矩阵的高度则为**弹出元素的高度**

###### 为什么在栈为空的情况下，当前最大矩阵的宽度是`i`?

- 如果栈为空， 说明所有[0...i-1]都是比i元素大的.
- 对于已经弹出的栈顶元素而言，所有的元素除了heights[i]都比它小
- 矩阵的宽度就是`i`

##### 代码实现

```java
//返回直方图中最大的矩形的面积
//每一个柱子的宽度是1
//对于每一根柱子，找到左边和右边第一根比它小的柱子
//如果使用递增栈，那么每一个元素入栈的时候，将会先出栈比当前元素大的元素poped
//柱子的感度就是poped的高度
//柱子的右边界是i
//柱子的左边界就是当前栈顶的元素
//如果栈为空，说明元素[0...i-1]比当前元素都大
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int ans = 0;
        //为什么需要从0遍历到n, 而不是n-1? 考虑右边没有元素的情况
        //因为是使用i作为右边界的，需要考虑右边界没有元素的情况
        //左边界没有元素的情况是stack为空
        for(int i = 0; i <= heights.length; i++){
            //
            int height = i== heights.length ? 0 : heights[i];
            
            while(!stack.isEmpty() && heights[stack.peek()] > height){
                //高度就是弹出元素的高度
                int poped = stack.pop();
                int rectangleHeight = heights[poped];
                int right = i;
                if(!stack.isEmpty()){
                    int left = stack.peek();
                    int area = rectangleHeight * (right - left - 1);//不计算left点和right点？
                    ans = Math.max(ans, area);
                }else{
                    int width = i;
                    int area = rectangleHeight * width;
                    ans = Math.max(ans, area);
                }
            }

            stack.push(i);
        }
        return ans;
    }
}
```

##### 注意事项

- **栈中存索引**：这是最关键的一点。存索引才能通过 `i - stack.peek() - 1` 的方式计算宽度。如果存高度，宽度信息就丢失了。

- **哨兵 (Sentinel) 的妙用**：在数组末尾假想一个高度为 0 的柱子（或者直接在循环中处理 `i == n` 的情况），可以极大地简化代码。它保证了即使原数组是单调递增的（如 `[1,2,3,4,5]`），栈中所有元素在最后也能够被正确弹出并计算面积。否则，你需要在循环结束后再写一段几乎重复的代码来清空栈。

- **边界处理**：当弹出元素后栈变为空时，意味着该矩形可以一直向左延伸到数组的起始位置，所以左边界可以看作是 `-1`。

- **栈的单调性**：我们维护的是一个栈底到栈顶，索引对应高度**单调递增**的栈。所以新元素只有在不破坏这个性质时才能直接入栈，否则就要先弹出栈顶元素。

| 注意点           | 说明                                 |
| ---------------- | ------------------------------------ |
| 末尾加一个 `0`   | 为了清空栈，触发最后一批面积计算     |
| 栈中存的是“下标” | 不是值，方便计算宽度                 |
| 不能随意出栈     | 只有当前柱子小于栈顶对应高度时才出栈 |
| 宽度计算公式     | `i - stack.peek() - 1`，注意理解含义 |

##### 经验总结

**识别模式**：LeetCode 84 是学习和掌握单调栈数据结构的“圣经”级题目。一旦理解了它，很多类似问题（如 LeetCode 85: Maximal Rectangle, LeetCode 42: Trapping Rain Water）的解法也会变得清晰。

**核心转化**：将问题从“求最大矩形面积”转化为“为每个柱子找到左右两边第一个比它矮的柱子”。这个思维转化是解题的关键。

**单调栈的本质**：单调栈通过牺牲一定的空间（栈空间），将一个嵌套的、看似需要 O(n2) 搜索的问题，通过一次遍历（每个元素最多进栈一次、出栈一次）优化到了 O(n) 的时间复杂度。它是一种用空间换时间的经典算法思想。

**举一反三**：练习与单调栈相关的其他题目，比如 "Next Greater Element I/II"，"Daily Temperatures" 等，来巩固对这个数据结构的理解。你会发现它们的核心逻辑都非常相似：**在某个元素被弹出时，触发弹出的那个元素就是它的答案（下一个更大/更小元素）**。

##### 总结一句话套路

> 用单调递增栈维护“递增高度柱子的下标”，遇到比栈顶小的元素就出栈计算面积，最终找出最大矩形面积。

#### Leetcode 85: 找到01矩阵中全部为1的最大子矩阵的面积

要求在一个只包含 `0` 和 `1` 的二维矩阵中找到只包含 `1` 的最大矩形面积。

##### 问题本质

本题的本质是**将二维最大矩形问题转化为多个一维柱状图中最大矩形问题**。

###### 核心思路 - 转化为柱状图求最大面积的问题

- 将每一行当作`柱状图`的**底部**
- 每往下一行，统计**当前列向上连续1的个数**作为`柱子的高度`
- 在每一行上，应用**单调栈**求解直方图最大矩形面积

##### 如何转化为Next/Last Greater问题？

在`Leetcode 84`中，我们需要求出每一根柱子的**左边第一个比它小的柱子**的位置和 **右边第一个比它小的柱子**的位置。

从而确定这跟柱子**可以扩展的最大宽度**。

这本质上就是一个**Next/Last Greater**问题，可以通过**单调栈**解决。

##### 核心思想 - 转化为柱状图求最大面积问题

######基本思路

- 将每一行当作`底部`，把它和上面所有行中**这一列的连续1数量**当作`柱高`。
- 对于每一行构造出**柱状图**，用**单调栈**计算**最大矩形面积**

###### 举个例子

```java
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```

###### 怎样构造柱状图数组？

按照上面的矩阵，转化为如下四个**柱状图**。

```java
Row 0: [1, 0, 1, 0, 0]
Row 1: [2, 0, 2, 1, 1]
Row 2: [3, 1, 3, 2, 2]
Row 3: [4, 0, 0, 3, 0]
```

##### 代码实现

###### 复习-求柱状图中的最大矩形面积-递增栈

```java
public int lagestRectangleArea(int[] heights){
  if (heights == null || heights.length =0) return 0;
  
  int n  = heights.length;
  
  int maxArea = Integer.MIN_VALUE;
  Stack<Integer> stack = new Stack<>();
  //为什么是i<=n?
  for (int i=0; i<=n;i++){
    //出栈并计算所有比当前元素heights[i]大的元素
    while (!stack.isEmpty() && heights[stack.peek() > heights[i]]){
      int top = stack.pop();
      int height = heights[top];
      
      int width = stack.isEmpty() ? i : i-stack.peek()-1;
      
      int area = height * width;
      
      maxArea = Math.max(maxArea, area);
    }
    
    stack.push(i);
  }
  
  return maxArea;
}
```

###### 将矩阵转化为柱状图 - **每一行**都转化为**一组柱状图**

- 矩阵中的**每一行**都转化为**一组柱状图**,所以一共生成`rows`组柱状图
- 假设当前正在生成第`row`行第`col`列的柱状图
  - 如果`matrix[row][col]=1`,那么 `heights[row][col]=heights[row-1][col]+1`
  - 如果`matrix[row][col]=0`，那么`heights[row][col]=0`
- 计算所有柱状图中的每一个柱子的**最大矩形面积**，最大值即为所求。

```java
int rows = matrix.length;
int cols = matrix[0].length;

int[] heights = new int[cols];

int maxArea =0;

for (ch[] row: matrix){
  //每一行转化为一组柱状图
  //对于每一个柱子而言
  //如果matrix[i]=1,则heights[i]=heights[i]+1, 该柱子在上一组柱状图中的值+1
  //如果matrix[i]=0,则heights[i]=0
  for (int i=0;i<cols,i++){
    heights[i] = row[i] == '1' ? heights[i]+1:0;
  }
  maxArea = Math.max(lagestRectangleArea(heights),maxArea);
}

return maxArea;
```



####Leetcode 907 子数组最小值的和 (Sum of Subarray Minimums)

##### 问题要点 - 每一个子数组的最小元素之和

**输入 (Input)**: 一个整数数组 `arr`。

**输出 (Output)**: 该数组所有 **连续** 子数组的最小值之和。

**约束 (Constraints)**:

- 数组长度 `1 <= arr.length <= 3 * 10^4`。
- 数组元素 `1 <= arr[i] <= 3 * 10^4`。
- 由于结果可能很大，需要对 `10^9 + 7` 取模。

**例子**: 输入: `arr = [3, 1, 2, 4]` 输出: `17` 解释: 子数组有: `[3]`, `[1]`, `[2]`, `[4]`, `[3,1]`, `[1,2]`, `[2,4]`, `[3,1,2]`, `[1,2,4]`, `[3,1,2,4]` 对应的最小值是: `3`, `1`, `2`, `4`, `1`, `1`, `2`, `1`, `1`, `1` 和是: `3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17`

##### 问题本质和分析

###### 暴力法的思路和性能问题 - 枚举所有子数组

暴力解法是枚举所有的子数组，然后找到每个子数组的最小值并求和。

- 枚举起点 `i`：O(N)
- 枚举终点 `j`：O(N)
- 找到 `[i, j]` 的最小值：O(N) 总时间复杂度为 $O(N^3)$。可以优化到 O(N2)（在枚举 `j` 时维护最小值），但这对于 $N = 3 \times 10^4$ 来说是不可接受的。

问题的核心在于，直接**求和**这个动作，让我们把目光聚焦在了**子数组**上。



###### 一种新的思维：对于每一个元素，有多少子数组是以它为最小值的？

高效的算法通常需要我们转变视角。

我们不去枚举每个**子数组**，而是去计算每个**元素**对最终结果的**贡献 (Contribution)**



**问题的本质**：将“求所有子数组的最小值之和”转化为“**计算每个元素 `arr[i]` 作为最小值时，能为总和贡献多少**”。

一个元素 `arr[i]` 的总贡献值可以这样计算： `贡献值 = arr[i] * (以 arr[i] 为最小值的子数组的个数)`

那么，问题就变成了：**对于每个 `arr[i]`，如何快速计算有多少个子数组是以它为最小值的**？

#####背景知识 - 单调栈

######单调栈的定义 - 栈内元素保持递增或者递减

**定义**: 单调栈是一种特殊的栈，它在任何时候，栈内的元素都保持单调递增或单调递减的顺序。

######单调栈的用途 - 快速找到左边和右边第一个更小/更大的元素

**功能**: 它可以在 O(N) 的时间复杂度内，为数组中的每个元素找到其左边和右边第一个比它更小（或更大）的元素。

######单调栈的工作原理 - 先删掉违反单调性的元素再入栈

我们以**单调递增栈**为例：

1. 遍历数组，对于当前元素 `num`：

2. 查看栈顶元素 `top`。

3. 如果栈不为空且 `top > num`，说明对于 `top` 元素而言，**`num` 就是它右边第一个比它小的元素**。

​	此时可以处理 `top` 的逻辑，然后将 `top` 出栈。

​	重复此过程，直到**栈顶元素不大于 `num` 或者栈为空**。

4. 经过步骤3，栈顶元素（如果存在）就是 `num` **左边第一个比它小的元素**。

5. 将当前元素 `num`（通常是其索引）入栈，维持栈的单调性。

单调栈是解决涉及“范围”、“边界”、“最近的最大/最小值”等问题的利器。

##### 考察点

这道题主要考察以下几点：

1. **问题转化能力**: 能否将暴力求解的思路，转化为更高效的“贡献法”思路。这是解决问题的关键，体现了算法思维的灵活性。
2. **数据结构的应用**: 对栈，特别是单调栈这种高级数据结构的理解和熟练应用。
3. **算法设计**: 设计出线性时间复杂度的解决方案。
4. **边界情况处理**: 如何处理数组边界、栈为空以及数组中存在重复元素等情况。
5. **编码细节**: 注意取模运算的时机，防止中间计算结果溢出。

##### 模式匹配 - 使用单调栈计算元素的贡献范围

此题属于一个非常经典的算法模式：**使用单调栈计算元素的贡献范围**。

当你遇到需要在 O(N) 或 O(NlogN) 时间内解决与子数组/子序列的**范围最值**相关的问题时，就应该立刻联想到单调栈。

**类似题目**

**LeetCode 84. 柱状图中最大的矩形**: 几乎是单调栈的模板题。对于每个柱子 `h[i]`，找到它能向左和向右延伸的最大范围（即找到左右两边第一个比它矮的柱子），然后计算面积。其核心思想与本题完全一致。

**LeetCode 496. 下一个更大元素 I**: 单调栈的直接应用。

**LeetCode 503. 下一个更大元素 II**: 循环数组版本的下一个更大元素，需要一点技巧（例如将数组复制一份）。

##### 核心思想和套路 - 贡献法 ：找到左边和右边的Next Smaller

###### 转换视角 - 贡献法

不要去枚举子数组。

而是遍历每个元素 `arr[i]`，并思考它能对最终答案产生什么影响。

###### 什么是贡献？

`arr[i]` 的贡献是 `arr[i] * count`，其中 `count` 是以 `arr[i]` 为严格最小值的子数组数量。

###### 如何确定某个元素的贡献范围？

要让 `arr[i]` 成为子数组 `[j, k]` 的最小值，这个子数组必须满足：

- `arr[i]` 在 `[j, k]` 范围内。
- `[j, k]` 范围内的所有其他元素都大于等于 `arr[i]`。

###### 寻找边界

为了计算 `count`，我们需要找到 `arr[i]` 作为最小值可以“统治”的范围。这个范围由两个边界决定：

- **左边界 `L`**: `i` 左侧第一个**小于** `arr[i]` 的元素的下标。

- **右边界 `R`**: `i` 右侧第一个**小于等于** `arr[i]` 的元素的下标。

   *注意：为了处理重复元素，我们将一边的边界设为严格小于 `<`，另一边设为小于等于 `<=`。这确保了当有多个相同的最小值时，只有一个元素（通常是最后一个）会被计算在内，避免重复计数。*

###### 计算以arr[i]为最小值的子数组的数量

- `arr[i]` 左边可选的起点个数为 `i - L`。

- `arr[i]` 右边可选的终点个数为 `R - i`。

因此以 `arr[i]` 为最小值的**子数组总数就是 `(i - L) * (R - i)`。**

#####实现原理和步骤

我们将使用一个**单调递增栈**来同时计算左边界和右边界。

栈中存储的是数组的**下标**。

###### 初始化

- 创建两个数组 `left` 和 `right`，`left[i]` 存储 `i` 的左边界 `L`，`right[i]` 存储 `i` 的右边界 `R`。

- 初始化 `left[i] = -1` (代表左边没有更小的)，`right[i] = n` (代表右边没有更小的)。

- 创建一个空栈 `stack`。

- 初始化总和 `ans = 0`，模数 `MOD = 10^9 + 7`。

###### 计算左边界 - prev smaller element

从**左到右**遍历数组 `arr` (从 `i = 0` 到 `n-1`)。

对于当前下标 `i`：

- `while` 栈不为空且 `arr[stack.peek()] >= arr[i]`：
  - 栈顶元素对应的数值比当前的大或相等，不满足要求，出栈。
- `if` 栈不为空：
  - 此时的栈顶 `stack.peek()` 就是 `i` 左边第一个比 `arr[i]` 小的元素下标，所以 `left[i] = stack.peek()`。
- `else` (栈为空):
  - 说明左边没有比 `arr[i]` 更小的元素，左边界为 `-1`。
- 将当前下标 `i` 入栈。

###### 计算右边界 - next smaller element

过程与计算左边界类似，但需要**从右到左**遍历数组 `arr` (从 `i = n-1` 到 `0`)。

对于当前下标 `i`：

- `while` 栈不为空且 `arr[stack.peek()] > arr[i]`：

  - 出栈。 

    *注意*：这里用 `>` 还是 `>=` 取决于左边界的比较符。

    为了避免重复计算，如果左边界用了 `>=`，右边界就用 `>`；

    反之亦然。这里我们让右边界严格小于，所以用 `>`.

- `if` 栈不为空：

  - `right[i] = stack.peek()`。

- `else` (栈为空):

  - 右边界为 `n`。

- 将当前下标 `i` 入栈。

###### 计算总和

再次遍历数组，从 `i = 0` 到 `n-1`。

对于每个 `i`，根据计算出的 `left[i]` 和 `right[i]`：

- 左边可选的元素个数 `left_count = i - left[i]`。
- 右边可选的元素个数 `right_count = right[i] - i`。
- 贡献值 `contribution = arr[i] * left_count * right_count`。
- 将贡献值累加到 `ans` 中，并记得每一步都取模：`ans = (ans + contribution) % MOD`。

###### 返回结果

返回 `ans`

**优化**: 实际上，我们可以在一次遍历中完成所有计算。当一个元素 `i` 因为遇到了比它更小的元素 `j` 而要出栈时，我们其实已经找到了 `i` 的右边界（就是 `j`），而 `i` 的左边界就是它下面的那个栈内元素。

##### 实现代码

```java

class Solution {
    // 子数组中的最小值的和
    // 对于数组arr的任意一个子数组subArr, 求其最小值 
    // 暴力解法？还有什么办法？
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] prevSmallers = getPrevSmallers(arr);
        int[] nextSmallers = getNextSmallers(arr);
        long ans = 0;
        long mod = 1000000007;

        for(int i = 0; i < n; i++){
            int left = prevSmallers[i];
            int right = nextSmallers[i];

            long count = (long)(i - left) * (right - i);
            
            // 修正了贡献计算公式
            long contribution = (count * arr[i]);
            
            ans = (ans + contribution) % mod;
        }

        return (int) ans;
        
    }
    //获取每个元素的上一个更小的元素
    //使用单调递增栈实现
    public int[] getPrevSmallers(int[] arr){
        int n = arr.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        //定义一个单调递增栈
        Stack<Integer> stack = new Stack<Integer>();

        for(int i = 0; i < n; i++){
            int val = arr[i];
            //弹出所有比当前元素大的元素
            while (!stack.isEmpty() && arr[stack.peek()] >= val) {
                stack.pop();
            }
          //栈顶元素就是第一个比当前元素小的prev
            if(!stack.isEmpty()){
                ans[i] = stack.peek();
            }
          //入栈当前元素
            stack.push(i);
        }
        return ans;
    }

    public int[] getNextSmallers(int[] arr){
        int n = arr.length;
        int[] ans = new int[n];
        Arrays.fill(ans, n);

        Stack<Integer> stack = new Stack<>();

        for(int i = n-1; i >=0; i--){
            int val = arr[i];
          //弹出所有比当前元素大的元素
            while (!stack.isEmpty() && arr[stack.peek()] > val ) {
               stack.pop();
            }
          //栈顶元素就是第一个比当前元素小的next
            if(!stack.isEmpty()){
                ans[i] = stack.peek();
            }
          //入栈当前元素
            stack.push(i);
        }
        return ans;
    }
}
```

#####注意事项

1. **处理重复元素**: 这是此题最容易出错的地方。如果 `left` 和 `right` 的边界条件都设为 `<` 或者都设为 `<=`，当遇到 `[2, 2, 2]` 这样的数组时，就会重复计算。例如，对于中间的`2`，如果左右都找小于它的，找不到，范围就是整个数组。这会导致错误。解决方案是让一个边界是严格的 (`<`)，另一个是非严格的 (`<=`)。在上面的优化代码中，通过 `arr[stack.peek()] > currentVal` (严格大于) 来确定右边界，就隐式地处理了这个问题。
2. **取模运算**: 由于 `arr[i] * left_count * right_count` 的结果可能非常大，超过 `long` 的范围，所以需要在计算乘积时就进行取模，或者确保中间变量是 `long` 类型。最安全的方式是每一步加法后都取模。`totalSum = (totalSum + contribution) % MOD;`
3. **边界处理 (哨兵)**: 在优化代码中，循环到 `i <= n` 并且当 `i == n` 时 `currentVal = 0`，这是一个非常巧妙的“哨兵”技巧。它确保了即使数组是单调递增的（如 `[1, 2, 3, 4]`），栈中所有元素最终也都能被弹出并计算贡献，无需在循环外再写一段清理栈的代码。
4. **栈中存索引**: 栈中应该存储元素的**下标**而不是元素值，因为我们需要下标来计算距离（即 `left_count` 和 `right_count`）。

#####  经验总结

**贡献法是处理“子数组/子序列和/积”问题的强大武器**。当直接枚举目标（如子数组）复杂度过高时，尝试转换视角，计算每个独立元素对最终结果的贡献。

**单调栈是寻找“下一个/上一个更大/更小元素”的标准解法**。这个模式可以解决一系列看似无关，但本质都是寻找元素影响范围的问题。记住它 O(N) 的高效性。

**注意细节决定成败**。重复元素、边界条件和取模运算是这类问题的常见陷阱。在思考解法时就要把这些情况考虑周全。

**学会使用“哨兵”简化代码**。在数组末尾添加一个虚拟元素（如本题的 `i=n`），或者在栈底预置一个-1，可以统一处理边界逻辑，让代码更优雅、更不易出错。
